// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:json_annotation/json_annotation.dart' as json;
import 'package:collection/collection.dart';
import 'dart:convert';

import 'package:chopper/chopper.dart';

import 'client_mapping.dart';
import 'dart:async';
import 'package:http/http.dart' as http;
import 'package:http/http.dart' show MultipartFile;
import 'package:chopper/chopper.dart' as chopper;
import 'jellyfin_openapi_stable.enums.swagger.dart' as enums;
export 'jellyfin_openapi_stable.enums.swagger.dart';

part 'jellyfin_openapi_stable.swagger.chopper.dart';
part 'jellyfin_openapi_stable.swagger.g.dart';

// **************************************************************************
// SwaggerChopperGenerator
// **************************************************************************

@ChopperApi()
abstract class JellyfinOpenapiStable extends ChopperService {
  static JellyfinOpenapiStable create({
    ChopperClient? client,
    http.Client? httpClient,
    Authenticator? authenticator,
    ErrorConverter? errorConverter,
    Converter? converter,
    Uri? baseUrl,
    List<Interceptor>? interceptors,
  }) {
    if (client != null) {
      return _$JellyfinOpenapiStable(client);
    }

    final newClient = ChopperClient(
        services: [_$JellyfinOpenapiStable()],
        converter: converter ?? $JsonSerializableConverter(),
        interceptors: interceptors ?? [],
        client: httpClient,
        authenticator: authenticator,
        errorConverter: errorConverter,
        baseUrl: baseUrl ?? Uri.parse('http://'));
    return _$JellyfinOpenapiStable(newClient);
  }

  ///Gets activity log entries.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param minDate Optional. The minimum date. Format = ISO.
  ///@param hasUserId Optional. Filter log entries if it has user id, or not.
  Future<chopper.Response<ActivityLogEntryQueryResult>>
      systemActivityLogEntriesGet({
    int? startIndex,
    int? limit,
    DateTime? minDate,
    bool? hasUserId,
  }) {
    generatedMapping.putIfAbsent(ActivityLogEntryQueryResult,
        () => ActivityLogEntryQueryResult.fromJsonFactory);

    return _systemActivityLogEntriesGet(
        startIndex: startIndex,
        limit: limit,
        minDate: minDate,
        hasUserId: hasUserId);
  }

  ///Gets activity log entries.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param minDate Optional. The minimum date. Format = ISO.
  ///@param hasUserId Optional. Filter log entries if it has user id, or not.
  @Get(path: '/System/ActivityLog/Entries')
  Future<chopper.Response<ActivityLogEntryQueryResult>>
      _systemActivityLogEntriesGet({
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('minDate') DateTime? minDate,
    @Query('hasUserId') bool? hasUserId,
  });

  ///Get all keys.
  Future<chopper.Response<AuthenticationInfoQueryResult>> authKeysGet() {
    generatedMapping.putIfAbsent(AuthenticationInfoQueryResult,
        () => AuthenticationInfoQueryResult.fromJsonFactory);

    return _authKeysGet();
  }

  ///Get all keys.
  @Get(path: '/Auth/Keys')
  Future<chopper.Response<AuthenticationInfoQueryResult>> _authKeysGet();

  ///Create a new api key.
  ///@param app Name of the app using the authentication key.
  Future<chopper.Response> authKeysPost({required String? app}) {
    return _authKeysPost(app: app);
  }

  ///Create a new api key.
  ///@param app Name of the app using the authentication key.
  @Post(
    path: '/Auth/Keys',
    optionalBody: true,
  )
  Future<chopper.Response> _authKeysPost({@Query('app') required String? app});

  ///Remove an api key.
  ///@param key The access token to delete.
  Future<chopper.Response> authKeysKeyDelete({required String? key}) {
    return _authKeysKeyDelete(key: key);
  }

  ///Remove an api key.
  ///@param key The access token to delete.
  @Delete(path: '/Auth/Keys/{key}')
  Future<chopper.Response> _authKeysKeyDelete(
      {@Path('key') required String? key});

  ///Gets all artists from a given item, folder, or the entire library.
  ///@param minCommunityRating Optional filter by minimum community rating.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm Optional. Search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
  ///@param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
  ///@param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
  ///@param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
  ///@param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
  ///@param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param person Optional. If specified, results will be filtered to include only those containing the specified person.
  ///@param personIds Optional. If specified, results will be filtered to include only those containing the specified person ids.
  ///@param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
  ///@param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
  ///@param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Total record count.
  Future<chopper.Response<BaseItemDtoQueryResult>> artistsGet({
    num? minCommunityRating,
    int? startIndex,
    int? limit,
    String? searchTerm,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.BaseItemKind>? includeItemTypes,
    List<enums.ItemFilter>? filters,
    bool? isFavorite,
    List<enums.MediaType>? mediaTypes,
    List<String>? genres,
    List<String>? genreIds,
    List<String>? officialRatings,
    List<String>? tags,
    List<int>? years,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    String? person,
    List<String>? personIds,
    List<String>? personTypes,
    List<String>? studios,
    List<String>? studioIds,
    String? userId,
    String? nameStartsWithOrGreater,
    String? nameStartsWith,
    String? nameLessThan,
    List<enums.ItemSortBy>? sortBy,
    List<enums.SortOrder>? sortOrder,
    bool? enableImages,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _artistsGet(
        minCommunityRating: minCommunityRating,
        startIndex: startIndex,
        limit: limit,
        searchTerm: searchTerm,
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        filters: itemFilterListToJson(filters),
        isFavorite: isFavorite,
        mediaTypes: mediaTypeListToJson(mediaTypes),
        genres: genres,
        genreIds: genreIds,
        officialRatings: officialRatings,
        tags: tags,
        years: years,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        person: person,
        personIds: personIds,
        personTypes: personTypes,
        studios: studios,
        studioIds: studioIds,
        userId: userId,
        nameStartsWithOrGreater: nameStartsWithOrGreater,
        nameStartsWith: nameStartsWith,
        nameLessThan: nameLessThan,
        sortBy: itemSortByListToJson(sortBy),
        sortOrder: sortOrderListToJson(sortOrder),
        enableImages: enableImages,
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets all artists from a given item, folder, or the entire library.
  ///@param minCommunityRating Optional filter by minimum community rating.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm Optional. Search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
  ///@param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
  ///@param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
  ///@param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
  ///@param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
  ///@param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param person Optional. If specified, results will be filtered to include only those containing the specified person.
  ///@param personIds Optional. If specified, results will be filtered to include only those containing the specified person ids.
  ///@param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
  ///@param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
  ///@param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Total record count.
  @Get(path: '/Artists')
  Future<chopper.Response<BaseItemDtoQueryResult>> _artistsGet({
    @Query('minCommunityRating') num? minCommunityRating,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('searchTerm') String? searchTerm,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('filters') List<Object?>? filters,
    @Query('isFavorite') bool? isFavorite,
    @Query('mediaTypes') List<Object?>? mediaTypes,
    @Query('genres') List<String>? genres,
    @Query('genreIds') List<String>? genreIds,
    @Query('officialRatings') List<String>? officialRatings,
    @Query('tags') List<String>? tags,
    @Query('years') List<int>? years,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('person') String? person,
    @Query('personIds') List<String>? personIds,
    @Query('personTypes') List<String>? personTypes,
    @Query('studios') List<String>? studios,
    @Query('studioIds') List<String>? studioIds,
    @Query('userId') String? userId,
    @Query('nameStartsWithOrGreater') String? nameStartsWithOrGreater,
    @Query('nameStartsWith') String? nameStartsWith,
    @Query('nameLessThan') String? nameLessThan,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('sortOrder') List<Object?>? sortOrder,
    @Query('enableImages') bool? enableImages,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Gets an artist by name.
  ///@param name Studio name.
  ///@param userId Optional. Filter by user id, and attach user data.
  Future<chopper.Response<BaseItemDto>> artistsNameGet({
    required String? name,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _artistsNameGet(name: name, userId: userId);
  }

  ///Gets an artist by name.
  ///@param name Studio name.
  ///@param userId Optional. Filter by user id, and attach user data.
  @Get(path: '/Artists/{name}')
  Future<chopper.Response<BaseItemDto>> _artistsNameGet({
    @Path('name') required String? name,
    @Query('userId') String? userId,
  });

  ///Gets all album artists from a given item, folder, or the entire library.
  ///@param minCommunityRating Optional filter by minimum community rating.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm Optional. Search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
  ///@param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
  ///@param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
  ///@param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
  ///@param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
  ///@param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param person Optional. If specified, results will be filtered to include only those containing the specified person.
  ///@param personIds Optional. If specified, results will be filtered to include only those containing the specified person ids.
  ///@param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
  ///@param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
  ///@param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Total record count.
  Future<chopper.Response<BaseItemDtoQueryResult>> artistsAlbumArtistsGet({
    num? minCommunityRating,
    int? startIndex,
    int? limit,
    String? searchTerm,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.BaseItemKind>? includeItemTypes,
    List<enums.ItemFilter>? filters,
    bool? isFavorite,
    List<enums.MediaType>? mediaTypes,
    List<String>? genres,
    List<String>? genreIds,
    List<String>? officialRatings,
    List<String>? tags,
    List<int>? years,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    String? person,
    List<String>? personIds,
    List<String>? personTypes,
    List<String>? studios,
    List<String>? studioIds,
    String? userId,
    String? nameStartsWithOrGreater,
    String? nameStartsWith,
    String? nameLessThan,
    List<enums.ItemSortBy>? sortBy,
    List<enums.SortOrder>? sortOrder,
    bool? enableImages,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _artistsAlbumArtistsGet(
        minCommunityRating: minCommunityRating,
        startIndex: startIndex,
        limit: limit,
        searchTerm: searchTerm,
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        filters: itemFilterListToJson(filters),
        isFavorite: isFavorite,
        mediaTypes: mediaTypeListToJson(mediaTypes),
        genres: genres,
        genreIds: genreIds,
        officialRatings: officialRatings,
        tags: tags,
        years: years,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        person: person,
        personIds: personIds,
        personTypes: personTypes,
        studios: studios,
        studioIds: studioIds,
        userId: userId,
        nameStartsWithOrGreater: nameStartsWithOrGreater,
        nameStartsWith: nameStartsWith,
        nameLessThan: nameLessThan,
        sortBy: itemSortByListToJson(sortBy),
        sortOrder: sortOrderListToJson(sortOrder),
        enableImages: enableImages,
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets all album artists from a given item, folder, or the entire library.
  ///@param minCommunityRating Optional filter by minimum community rating.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm Optional. Search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
  ///@param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
  ///@param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
  ///@param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
  ///@param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
  ///@param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param person Optional. If specified, results will be filtered to include only those containing the specified person.
  ///@param personIds Optional. If specified, results will be filtered to include only those containing the specified person ids.
  ///@param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
  ///@param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
  ///@param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Total record count.
  @Get(path: '/Artists/AlbumArtists')
  Future<chopper.Response<BaseItemDtoQueryResult>> _artistsAlbumArtistsGet({
    @Query('minCommunityRating') num? minCommunityRating,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('searchTerm') String? searchTerm,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('filters') List<Object?>? filters,
    @Query('isFavorite') bool? isFavorite,
    @Query('mediaTypes') List<Object?>? mediaTypes,
    @Query('genres') List<String>? genres,
    @Query('genreIds') List<String>? genreIds,
    @Query('officialRatings') List<String>? officialRatings,
    @Query('tags') List<String>? tags,
    @Query('years') List<int>? years,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('person') String? person,
    @Query('personIds') List<String>? personIds,
    @Query('personTypes') List<String>? personTypes,
    @Query('studios') List<String>? studios,
    @Query('studioIds') List<String>? studioIds,
    @Query('userId') String? userId,
    @Query('nameStartsWithOrGreater') String? nameStartsWithOrGreater,
    @Query('nameStartsWith') String? nameStartsWith,
    @Query('nameLessThan') String? nameLessThan,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('sortOrder') List<Object?>? sortOrder,
    @Query('enableImages') bool? enableImages,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> audioItemIdStreamGet({
    required String? itemId,
    String? container,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.AudioItemIdStreamGetSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.AudioItemIdStreamGetContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _audioItemIdStreamGet(
        itemId: itemId,
        container: container,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Get(path: '/Audio/{itemId}/stream')
  Future<chopper.Response<String>> _audioItemIdStreamGet({
    @Path('itemId') required String? itemId,
    @Query('container') String? container,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> audioItemIdStreamHead({
    required String? itemId,
    String? container,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.AudioItemIdStreamHeadSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.AudioItemIdStreamHeadContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _audioItemIdStreamHead(
        itemId: itemId,
        container: container,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Head(path: '/Audio/{itemId}/stream')
  Future<chopper.Response<String>> _audioItemIdStreamHead({
    @Path('itemId') required String? itemId,
    @Query('container') String? container,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamporphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> audioItemIdStreamContainerGet({
    required String? itemId,
    required String? container,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.AudioItemIdStreamContainerGetSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.AudioItemIdStreamContainerGetContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _audioItemIdStreamContainerGet(
        itemId: itemId,
        container: container,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamporphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Get(path: '/Audio/{itemId}/stream.{container}')
  Future<chopper.Response<String>> _audioItemIdStreamContainerGet({
    @Path('itemId') required String? itemId,
    @Path('container') required String? container,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamporphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> audioItemIdStreamContainerHead({
    required String? itemId,
    required String? container,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.AudioItemIdStreamContainerHeadSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.AudioItemIdStreamContainerHeadContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _audioItemIdStreamContainerHead(
        itemId: itemId,
        container: container,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamporphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Head(path: '/Audio/{itemId}/stream.{container}')
  Future<chopper.Response<String>> _audioItemIdStreamContainerHead({
    @Path('itemId') required String? itemId,
    @Path('container') required String? container,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets branding configuration.
  Future<chopper.Response<BrandingOptions>> brandingConfigurationGet() {
    generatedMapping.putIfAbsent(
        BrandingOptions, () => BrandingOptions.fromJsonFactory);

    return _brandingConfigurationGet();
  }

  ///Gets branding configuration.
  @Get(path: '/Branding/Configuration')
  Future<chopper.Response<BrandingOptions>> _brandingConfigurationGet();

  ///Gets branding css.
  Future<chopper.Response<String>> brandingCssGet() {
    return _brandingCssGet();
  }

  ///Gets branding css.
  @Get(path: '/Branding/Css')
  Future<chopper.Response<String>> _brandingCssGet();

  ///Gets branding css.
  Future<chopper.Response<String>> brandingCssCssGet() {
    return _brandingCssCssGet();
  }

  ///Gets branding css.
  @Get(path: '/Branding/Css.css')
  Future<chopper.Response<String>> _brandingCssCssGet();

  ///Gets available channels.
  ///@param userId User Id to filter by. Use System.Guid.Empty to not filter by user.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param supportsLatestItems Optional. Filter by channels that support getting latest items.
  ///@param supportsMediaDeletion Optional. Filter by channels that support media deletion.
  ///@param isFavorite Optional. Filter by channels that are favorite.
  Future<chopper.Response<BaseItemDtoQueryResult>> channelsGet({
    String? userId,
    int? startIndex,
    int? limit,
    bool? supportsLatestItems,
    bool? supportsMediaDeletion,
    bool? isFavorite,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _channelsGet(
        userId: userId,
        startIndex: startIndex,
        limit: limit,
        supportsLatestItems: supportsLatestItems,
        supportsMediaDeletion: supportsMediaDeletion,
        isFavorite: isFavorite);
  }

  ///Gets available channels.
  ///@param userId User Id to filter by. Use System.Guid.Empty to not filter by user.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param supportsLatestItems Optional. Filter by channels that support getting latest items.
  ///@param supportsMediaDeletion Optional. Filter by channels that support media deletion.
  ///@param isFavorite Optional. Filter by channels that are favorite.
  @Get(path: '/Channels')
  Future<chopper.Response<BaseItemDtoQueryResult>> _channelsGet({
    @Query('userId') String? userId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('supportsLatestItems') bool? supportsLatestItems,
    @Query('supportsMediaDeletion') bool? supportsMediaDeletion,
    @Query('isFavorite') bool? isFavorite,
  });

  ///Get channel features.
  ///@param channelId Channel id.
  Future<chopper.Response<ChannelFeatures>> channelsChannelIdFeaturesGet(
      {required String? channelId}) {
    generatedMapping.putIfAbsent(
        ChannelFeatures, () => ChannelFeatures.fromJsonFactory);

    return _channelsChannelIdFeaturesGet(channelId: channelId);
  }

  ///Get channel features.
  ///@param channelId Channel id.
  @Get(path: '/Channels/{channelId}/Features')
  Future<chopper.Response<ChannelFeatures>> _channelsChannelIdFeaturesGet(
      {@Path('channelId') required String? channelId});

  ///Get channel items.
  ///@param channelId Channel Id.
  ///@param folderId Optional. Folder Id.
  ///@param userId Optional. User Id.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param sortOrder Optional. Sort Order - Ascending,Descending.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  Future<chopper.Response<BaseItemDtoQueryResult>> channelsChannelIdItemsGet({
    required String? channelId,
    String? folderId,
    String? userId,
    int? startIndex,
    int? limit,
    List<enums.SortOrder>? sortOrder,
    List<enums.ItemFilter>? filters,
    List<enums.ItemSortBy>? sortBy,
    List<enums.ItemFields>? fields,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _channelsChannelIdItemsGet(
        channelId: channelId,
        folderId: folderId,
        userId: userId,
        startIndex: startIndex,
        limit: limit,
        sortOrder: sortOrderListToJson(sortOrder),
        filters: itemFilterListToJson(filters),
        sortBy: itemSortByListToJson(sortBy),
        fields: itemFieldsListToJson(fields));
  }

  ///Get channel items.
  ///@param channelId Channel Id.
  ///@param folderId Optional. Folder Id.
  ///@param userId Optional. User Id.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param sortOrder Optional. Sort Order - Ascending,Descending.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  @Get(path: '/Channels/{channelId}/Items')
  Future<chopper.Response<BaseItemDtoQueryResult>> _channelsChannelIdItemsGet({
    @Path('channelId') required String? channelId,
    @Query('folderId') String? folderId,
    @Query('userId') String? userId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('sortOrder') List<Object?>? sortOrder,
    @Query('filters') List<Object?>? filters,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('fields') List<Object?>? fields,
  });

  ///Get all channel features.
  Future<chopper.Response<List<ChannelFeatures>>> channelsFeaturesGet() {
    generatedMapping.putIfAbsent(
        ChannelFeatures, () => ChannelFeatures.fromJsonFactory);

    return _channelsFeaturesGet();
  }

  ///Get all channel features.
  @Get(path: '/Channels/Features')
  Future<chopper.Response<List<ChannelFeatures>>> _channelsFeaturesGet();

  ///Gets latest channel items.
  ///@param userId Optional. User Id.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param channelIds Optional. Specify one or more channel id's, comma delimited.
  Future<chopper.Response<BaseItemDtoQueryResult>> channelsItemsLatestGet({
    String? userId,
    int? startIndex,
    int? limit,
    List<enums.ItemFilter>? filters,
    List<enums.ItemFields>? fields,
    List<String>? channelIds,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _channelsItemsLatestGet(
        userId: userId,
        startIndex: startIndex,
        limit: limit,
        filters: itemFilterListToJson(filters),
        fields: itemFieldsListToJson(fields),
        channelIds: channelIds);
  }

  ///Gets latest channel items.
  ///@param userId Optional. User Id.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param channelIds Optional. Specify one or more channel id's, comma delimited.
  @Get(path: '/Channels/Items/Latest')
  Future<chopper.Response<BaseItemDtoQueryResult>> _channelsItemsLatestGet({
    @Query('userId') String? userId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('filters') List<Object?>? filters,
    @Query('fields') List<Object?>? fields,
    @Query('channelIds') List<String>? channelIds,
  });

  ///Upload a document.
  Future<chopper.Response<ClientLogDocumentResponseDto>> clientLogDocumentPost(
      {required Object? body}) {
    generatedMapping.putIfAbsent(ClientLogDocumentResponseDto,
        () => ClientLogDocumentResponseDto.fromJsonFactory);

    return _clientLogDocumentPost(body: body);
  }

  ///Upload a document.
  @Post(
    path: '/ClientLog/Document',
    optionalBody: true,
  )
  Future<chopper.Response<ClientLogDocumentResponseDto>> _clientLogDocumentPost(
      {@Body() required Object? body});

  ///Creates a new collection.
  ///@param name The name of the collection.
  ///@param ids Item Ids to add to the collection.
  ///@param parentId Optional. Create the collection within a specific folder.
  ///@param isLocked Whether or not to lock the new collection.
  Future<chopper.Response<CollectionCreationResult>> collectionsPost({
    String? name,
    List<String>? ids,
    String? parentId,
    bool? isLocked,
  }) {
    generatedMapping.putIfAbsent(CollectionCreationResult,
        () => CollectionCreationResult.fromJsonFactory);

    return _collectionsPost(
        name: name, ids: ids, parentId: parentId, isLocked: isLocked);
  }

  ///Creates a new collection.
  ///@param name The name of the collection.
  ///@param ids Item Ids to add to the collection.
  ///@param parentId Optional. Create the collection within a specific folder.
  ///@param isLocked Whether or not to lock the new collection.
  @Post(
    path: '/Collections',
    optionalBody: true,
  )
  Future<chopper.Response<CollectionCreationResult>> _collectionsPost({
    @Query('name') String? name,
    @Query('ids') List<String>? ids,
    @Query('parentId') String? parentId,
    @Query('isLocked') bool? isLocked,
  });

  ///Adds items to a collection.
  ///@param collectionId The collection id.
  ///@param ids Item ids, comma delimited.
  Future<chopper.Response> collectionsCollectionIdItemsPost({
    required String? collectionId,
    required List<String>? ids,
  }) {
    return _collectionsCollectionIdItemsPost(
        collectionId: collectionId, ids: ids);
  }

  ///Adds items to a collection.
  ///@param collectionId The collection id.
  ///@param ids Item ids, comma delimited.
  @Post(
    path: '/Collections/{collectionId}/Items',
    optionalBody: true,
  )
  Future<chopper.Response> _collectionsCollectionIdItemsPost({
    @Path('collectionId') required String? collectionId,
    @Query('ids') required List<String>? ids,
  });

  ///Removes items from a collection.
  ///@param collectionId The collection id.
  ///@param ids Item ids, comma delimited.
  Future<chopper.Response> collectionsCollectionIdItemsDelete({
    required String? collectionId,
    required List<String>? ids,
  }) {
    return _collectionsCollectionIdItemsDelete(
        collectionId: collectionId, ids: ids);
  }

  ///Removes items from a collection.
  ///@param collectionId The collection id.
  ///@param ids Item ids, comma delimited.
  @Delete(path: '/Collections/{collectionId}/Items')
  Future<chopper.Response> _collectionsCollectionIdItemsDelete({
    @Path('collectionId') required String? collectionId,
    @Query('ids') required List<String>? ids,
  });

  ///Gets application configuration.
  Future<chopper.Response<ServerConfiguration>> systemConfigurationGet() {
    generatedMapping.putIfAbsent(
        ServerConfiguration, () => ServerConfiguration.fromJsonFactory);

    return _systemConfigurationGet();
  }

  ///Gets application configuration.
  @Get(path: '/System/Configuration')
  Future<chopper.Response<ServerConfiguration>> _systemConfigurationGet();

  ///Updates application configuration.
  Future<chopper.Response> systemConfigurationPost(
      {required ServerConfiguration? body}) {
    return _systemConfigurationPost(body: body);
  }

  ///Updates application configuration.
  @Post(
    path: '/System/Configuration',
    optionalBody: true,
  )
  Future<chopper.Response> _systemConfigurationPost(
      {@Body() required ServerConfiguration? body});

  ///Gets a named configuration.
  ///@param key Configuration key.
  Future<chopper.Response<String>> systemConfigurationKeyGet(
      {required String? key}) {
    return _systemConfigurationKeyGet(key: key);
  }

  ///Gets a named configuration.
  ///@param key Configuration key.
  @Get(path: '/System/Configuration/{key}')
  Future<chopper.Response<String>> _systemConfigurationKeyGet(
      {@Path('key') required String? key});

  ///Updates named configuration.
  ///@param key Configuration key.
  Future<chopper.Response> systemConfigurationKeyPost({
    required String? key,
    required Object? body,
  }) {
    return _systemConfigurationKeyPost(key: key, body: body);
  }

  ///Updates named configuration.
  ///@param key Configuration key.
  @Post(
    path: '/System/Configuration/{key}',
    optionalBody: true,
  )
  Future<chopper.Response> _systemConfigurationKeyPost({
    @Path('key') required String? key,
    @Body() required Object? body,
  });

  ///Gets a default MetadataOptions object.
  Future<chopper.Response<MetadataOptions>>
      systemConfigurationMetadataOptionsDefaultGet() {
    generatedMapping.putIfAbsent(
        MetadataOptions, () => MetadataOptions.fromJsonFactory);

    return _systemConfigurationMetadataOptionsDefaultGet();
  }

  ///Gets a default MetadataOptions object.
  @Get(path: '/System/Configuration/MetadataOptions/Default')
  Future<chopper.Response<MetadataOptions>>
      _systemConfigurationMetadataOptionsDefaultGet();

  ///Gets a dashboard configuration page.
  ///@param name The name of the page.
  Future<chopper.Response<String>> webConfigurationPageGet({String? name}) {
    return _webConfigurationPageGet(name: name);
  }

  ///Gets a dashboard configuration page.
  ///@param name The name of the page.
  @Get(path: '/web/ConfigurationPage')
  Future<chopper.Response<String>> _webConfigurationPageGet(
      {@Query('name') String? name});

  ///Gets the configuration pages.
  ///@param enableInMainMenu Whether to enable in the main menu.
  Future<chopper.Response<List<ConfigurationPageInfo>>>
      webConfigurationPagesGet({bool? enableInMainMenu}) {
    generatedMapping.putIfAbsent(
        ConfigurationPageInfo, () => ConfigurationPageInfo.fromJsonFactory);

    return _webConfigurationPagesGet(enableInMainMenu: enableInMainMenu);
  }

  ///Gets the configuration pages.
  ///@param enableInMainMenu Whether to enable in the main menu.
  @Get(path: '/web/ConfigurationPages')
  Future<chopper.Response<List<ConfigurationPageInfo>>>
      _webConfigurationPagesGet(
          {@Query('enableInMainMenu') bool? enableInMainMenu});

  ///Get Devices.
  ///@param userId Gets or sets the user identifier.
  Future<chopper.Response<DeviceInfoDtoQueryResult>> devicesGet(
      {String? userId}) {
    generatedMapping.putIfAbsent(DeviceInfoDtoQueryResult,
        () => DeviceInfoDtoQueryResult.fromJsonFactory);

    return _devicesGet(userId: userId);
  }

  ///Get Devices.
  ///@param userId Gets or sets the user identifier.
  @Get(path: '/Devices')
  Future<chopper.Response<DeviceInfoDtoQueryResult>> _devicesGet(
      {@Query('userId') String? userId});

  ///Deletes a device.
  ///@param id Device Id.
  Future<chopper.Response> devicesDelete({required String? id}) {
    return _devicesDelete(id: id);
  }

  ///Deletes a device.
  ///@param id Device Id.
  @Delete(path: '/Devices')
  Future<chopper.Response> _devicesDelete({@Query('id') required String? id});

  ///Get info for a device.
  ///@param id Device Id.
  Future<chopper.Response<DeviceInfoDto>> devicesInfoGet(
      {required String? id}) {
    generatedMapping.putIfAbsent(
        DeviceInfoDto, () => DeviceInfoDto.fromJsonFactory);

    return _devicesInfoGet(id: id);
  }

  ///Get info for a device.
  ///@param id Device Id.
  @Get(path: '/Devices/Info')
  Future<chopper.Response<DeviceInfoDto>> _devicesInfoGet(
      {@Query('id') required String? id});

  ///Get options for a device.
  ///@param id Device Id.
  Future<chopper.Response<DeviceOptionsDto>> devicesOptionsGet(
      {required String? id}) {
    generatedMapping.putIfAbsent(
        DeviceOptionsDto, () => DeviceOptionsDto.fromJsonFactory);

    return _devicesOptionsGet(id: id);
  }

  ///Get options for a device.
  ///@param id Device Id.
  @Get(path: '/Devices/Options')
  Future<chopper.Response<DeviceOptionsDto>> _devicesOptionsGet(
      {@Query('id') required String? id});

  ///Update device options.
  ///@param id Device Id.
  Future<chopper.Response> devicesOptionsPost({
    required String? id,
    required DeviceOptionsDto? body,
  }) {
    return _devicesOptionsPost(id: id, body: body);
  }

  ///Update device options.
  ///@param id Device Id.
  @Post(
    path: '/Devices/Options',
    optionalBody: true,
  )
  Future<chopper.Response> _devicesOptionsPost({
    @Query('id') required String? id,
    @Body() required DeviceOptionsDto? body,
  });

  ///Get Display Preferences.
  ///@param displayPreferencesId Display preferences id.
  ///@param userId User id.
  ///@param client Client.
  Future<chopper.Response<DisplayPreferencesDto>>
      displayPreferencesDisplayPreferencesIdGet({
    required String? displayPreferencesId,
    String? userId,
    required String? $client,
  }) {
    generatedMapping.putIfAbsent(
        DisplayPreferencesDto, () => DisplayPreferencesDto.fromJsonFactory);

    return _displayPreferencesDisplayPreferencesIdGet(
        displayPreferencesId: displayPreferencesId,
        userId: userId,
        $client: $client);
  }

  ///Get Display Preferences.
  ///@param displayPreferencesId Display preferences id.
  ///@param userId User id.
  ///@param client Client.
  @Get(path: '/DisplayPreferences/{displayPreferencesId}')
  Future<chopper.Response<DisplayPreferencesDto>>
      _displayPreferencesDisplayPreferencesIdGet({
    @Path('displayPreferencesId') required String? displayPreferencesId,
    @Query('userId') String? userId,
    @Query('client') required String? $client,
  });

  ///Update Display Preferences.
  ///@param displayPreferencesId Display preferences id.
  ///@param userId User Id.
  ///@param client Client.
  Future<chopper.Response> displayPreferencesDisplayPreferencesIdPost({
    required String? displayPreferencesId,
    String? userId,
    required String? $client,
    required DisplayPreferencesDto? body,
  }) {
    return _displayPreferencesDisplayPreferencesIdPost(
        displayPreferencesId: displayPreferencesId,
        userId: userId,
        $client: $client,
        body: body);
  }

  ///Update Display Preferences.
  ///@param displayPreferencesId Display preferences id.
  ///@param userId User Id.
  ///@param client Client.
  @Post(
    path: '/DisplayPreferences/{displayPreferencesId}',
    optionalBody: true,
  )
  Future<chopper.Response> _displayPreferencesDisplayPreferencesIdPost({
    @Path('displayPreferencesId') required String? displayPreferencesId,
    @Query('userId') String? userId,
    @Query('client') required String? $client,
    @Body() required DisplayPreferencesDto? body,
  });

  ///Gets a video stream using HTTP live streaming.
  ///@param itemId The item id.
  ///@param playlistId The playlist id.
  ///@param segmentId The segment id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param runtimeTicks The position of the requested segment in ticks.
  ///@param actualSegmentLengthTicks The length of the requested segment in ticks.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>>
      audioItemIdHls1PlaylistIdSegmentIdContainerGet({
    required String? itemId,
    required String? playlistId,
    required int? segmentId,
    required String? container,
    required int? runtimeTicks,
    required int? actualSegmentLengthTicks,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? maxStreamingBitrate,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
        subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _audioItemIdHls1PlaylistIdSegmentIdContainerGet(
        itemId: itemId,
        playlistId: playlistId,
        segmentId: segmentId,
        container: container,
        runtimeTicks: runtimeTicks,
        actualSegmentLengthTicks: actualSegmentLengthTicks,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        maxStreamingBitrate: maxStreamingBitrate,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets a video stream using HTTP live streaming.
  ///@param itemId The item id.
  ///@param playlistId The playlist id.
  ///@param segmentId The segment id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param runtimeTicks The position of the requested segment in ticks.
  ///@param actualSegmentLengthTicks The length of the requested segment in ticks.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Get(path: '/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}')
  Future<chopper.Response<String>>
      _audioItemIdHls1PlaylistIdSegmentIdContainerGet({
    @Path('itemId') required String? itemId,
    @Path('playlistId') required String? playlistId,
    @Path('segmentId') required int? segmentId,
    @Path('container') required String? container,
    @Query('runtimeTicks') required int? runtimeTicks,
    @Query('actualSegmentLengthTicks') required int? actualSegmentLengthTicks,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('maxStreamingBitrate') int? maxStreamingBitrate,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets an audio stream using HTTP live streaming.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> audioItemIdMainM3u8Get({
    required String? itemId,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? maxStreamingBitrate,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.AudioItemIdMainM3u8GetSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.AudioItemIdMainM3u8GetContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _audioItemIdMainM3u8Get(
        itemId: itemId,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        maxStreamingBitrate: maxStreamingBitrate,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets an audio stream using HTTP live streaming.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Get(path: '/Audio/{itemId}/main.m3u8')
  Future<chopper.Response<String>> _audioItemIdMainM3u8Get({
    @Path('itemId') required String? itemId,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('maxStreamingBitrate') int? maxStreamingBitrate,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets an audio hls playlist stream.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> audioItemIdMasterM3u8Get({
    required String? itemId,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    required String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? maxStreamingBitrate,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.AudioItemIdMasterM3u8GetSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.AudioItemIdMasterM3u8GetContext? context,
    Object? streamOptions,
    bool? enableAdaptiveBitrateStreaming,
    bool? enableAudioVbrEncoding,
  }) {
    return _audioItemIdMasterM3u8Get(
        itemId: itemId,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        maxStreamingBitrate: maxStreamingBitrate,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAdaptiveBitrateStreaming: enableAdaptiveBitrateStreaming,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets an audio hls playlist stream.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Get(path: '/Audio/{itemId}/master.m3u8')
  Future<chopper.Response<String>> _audioItemIdMasterM3u8Get({
    @Path('itemId') required String? itemId,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') required String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('maxStreamingBitrate') int? maxStreamingBitrate,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAdaptiveBitrateStreaming')
    bool? enableAdaptiveBitrateStreaming,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets an audio hls playlist stream.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> audioItemIdMasterM3u8Head({
    required String? itemId,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    required String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? maxStreamingBitrate,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.AudioItemIdMasterM3u8HeadSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.AudioItemIdMasterM3u8HeadContext? context,
    Object? streamOptions,
    bool? enableAdaptiveBitrateStreaming,
    bool? enableAudioVbrEncoding,
  }) {
    return _audioItemIdMasterM3u8Head(
        itemId: itemId,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        maxStreamingBitrate: maxStreamingBitrate,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAdaptiveBitrateStreaming: enableAdaptiveBitrateStreaming,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets an audio hls playlist stream.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Head(path: '/Audio/{itemId}/master.m3u8')
  Future<chopper.Response<String>> _audioItemIdMasterM3u8Head({
    @Path('itemId') required String? itemId,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') required String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('maxStreamingBitrate') int? maxStreamingBitrate,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAdaptiveBitrateStreaming')
    bool? enableAdaptiveBitrateStreaming,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets a video stream using HTTP live streaming.
  ///@param itemId The item id.
  ///@param playlistId The playlist id.
  ///@param segmentId The segment id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param runtimeTicks The position of the requested segment in ticks.
  ///@param actualSegmentLengthTicks The length of the requested segment in ticks.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The desired segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  Future<chopper.Response<String>>
      videosItemIdHls1PlaylistIdSegmentIdContainerGet({
    required String? itemId,
    required String? playlistId,
    required int? segmentId,
    required String? container,
    required int? runtimeTicks,
    required int? actualSegmentLengthTicks,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? maxWidth,
    int? maxHeight,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
        subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
    bool? alwaysBurnInSubtitleWhenTranscoding,
  }) {
    return _videosItemIdHls1PlaylistIdSegmentIdContainerGet(
        itemId: itemId,
        playlistId: playlistId,
        segmentId: segmentId,
        container: container,
        runtimeTicks: runtimeTicks,
        actualSegmentLengthTicks: actualSegmentLengthTicks,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding,
        alwaysBurnInSubtitleWhenTranscoding:
            alwaysBurnInSubtitleWhenTranscoding);
  }

  ///Gets a video stream using HTTP live streaming.
  ///@param itemId The item id.
  ///@param playlistId The playlist id.
  ///@param segmentId The segment id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param runtimeTicks The position of the requested segment in ticks.
  ///@param actualSegmentLengthTicks The length of the requested segment in ticks.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The desired segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  @Get(path: '/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}')
  Future<chopper.Response<String>>
      _videosItemIdHls1PlaylistIdSegmentIdContainerGet({
    @Path('itemId') required String? itemId,
    @Path('playlistId') required String? playlistId,
    @Path('segmentId') required int? segmentId,
    @Path('container') required String? container,
    @Query('runtimeTicks') required int? runtimeTicks,
    @Query('actualSegmentLengthTicks') required int? actualSegmentLengthTicks,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
    @Query('alwaysBurnInSubtitleWhenTranscoding')
    bool? alwaysBurnInSubtitleWhenTranscoding,
  });

  ///Gets a hls live stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param maxWidth Optional. The max width.
  ///@param maxHeight Optional. The max height.
  ///@param enableSubtitlesInManifest Optional. Whether to enable subtitles in the manifest.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  Future<chopper.Response<String>> videosItemIdLiveM3u8Get({
    required String? itemId,
    String? container,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.VideosItemIdLiveM3u8GetSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.VideosItemIdLiveM3u8GetContext? context,
    Object? streamOptions,
    int? maxWidth,
    int? maxHeight,
    bool? enableSubtitlesInManifest,
    bool? enableAudioVbrEncoding,
    bool? alwaysBurnInSubtitleWhenTranscoding,
  }) {
    return _videosItemIdLiveM3u8Get(
        itemId: itemId,
        container: container,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        enableSubtitlesInManifest: enableSubtitlesInManifest,
        enableAudioVbrEncoding: enableAudioVbrEncoding,
        alwaysBurnInSubtitleWhenTranscoding:
            alwaysBurnInSubtitleWhenTranscoding);
  }

  ///Gets a hls live stream.
  ///@param itemId The item id.
  ///@param container The audio container.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param maxWidth Optional. The max width.
  ///@param maxHeight Optional. The max height.
  ///@param enableSubtitlesInManifest Optional. Whether to enable subtitles in the manifest.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  @Get(path: '/Videos/{itemId}/live.m3u8')
  Future<chopper.Response<String>> _videosItemIdLiveM3u8Get({
    @Path('itemId') required String? itemId,
    @Query('container') String? container,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('enableSubtitlesInManifest') bool? enableSubtitlesInManifest,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
    @Query('alwaysBurnInSubtitleWhenTranscoding')
    bool? alwaysBurnInSubtitleWhenTranscoding,
  });

  ///Gets a video stream using HTTP live streaming.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  Future<chopper.Response<String>> videosItemIdMainM3u8Get({
    required String? itemId,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? maxWidth,
    int? maxHeight,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.VideosItemIdMainM3u8GetSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.VideosItemIdMainM3u8GetContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
    bool? alwaysBurnInSubtitleWhenTranscoding,
  }) {
    return _videosItemIdMainM3u8Get(
        itemId: itemId,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding,
        alwaysBurnInSubtitleWhenTranscoding:
            alwaysBurnInSubtitleWhenTranscoding);
  }

  ///Gets a video stream using HTTP live streaming.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  @Get(path: '/Videos/{itemId}/main.m3u8')
  Future<chopper.Response<String>> _videosItemIdMainM3u8Get({
    @Path('itemId') required String? itemId,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
    @Query('alwaysBurnInSubtitleWhenTranscoding')
    bool? alwaysBurnInSubtitleWhenTranscoding,
  });

  ///Gets a video hls playlist stream.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
  ///@param enableTrickplay Enable trickplay image playlists being added to master playlist.
  ///@param enableAudioVbrEncoding Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  Future<chopper.Response<String>> videosItemIdMasterM3u8Get({
    required String? itemId,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    required String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? maxWidth,
    int? maxHeight,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.VideosItemIdMasterM3u8GetSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.VideosItemIdMasterM3u8GetContext? context,
    Object? streamOptions,
    bool? enableAdaptiveBitrateStreaming,
    bool? enableTrickplay,
    bool? enableAudioVbrEncoding,
    bool? alwaysBurnInSubtitleWhenTranscoding,
  }) {
    return _videosItemIdMasterM3u8Get(
        itemId: itemId,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAdaptiveBitrateStreaming: enableAdaptiveBitrateStreaming,
        enableTrickplay: enableTrickplay,
        enableAudioVbrEncoding: enableAudioVbrEncoding,
        alwaysBurnInSubtitleWhenTranscoding:
            alwaysBurnInSubtitleWhenTranscoding);
  }

  ///Gets a video hls playlist stream.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
  ///@param enableTrickplay Enable trickplay image playlists being added to master playlist.
  ///@param enableAudioVbrEncoding Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  @Get(path: '/Videos/{itemId}/master.m3u8')
  Future<chopper.Response<String>> _videosItemIdMasterM3u8Get({
    @Path('itemId') required String? itemId,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') required String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAdaptiveBitrateStreaming')
    bool? enableAdaptiveBitrateStreaming,
    @Query('enableTrickplay') bool? enableTrickplay,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
    @Query('alwaysBurnInSubtitleWhenTranscoding')
    bool? alwaysBurnInSubtitleWhenTranscoding,
  });

  ///Gets a video hls playlist stream.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
  ///@param enableTrickplay Enable trickplay image playlists being added to master playlist.
  ///@param enableAudioVbrEncoding Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  Future<chopper.Response<String>> videosItemIdMasterM3u8Head({
    required String? itemId,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    required String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? maxWidth,
    int? maxHeight,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.VideosItemIdMasterM3u8HeadSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.VideosItemIdMasterM3u8HeadContext? context,
    Object? streamOptions,
    bool? enableAdaptiveBitrateStreaming,
    bool? enableTrickplay,
    bool? enableAudioVbrEncoding,
    bool? alwaysBurnInSubtitleWhenTranscoding,
  }) {
    return _videosItemIdMasterM3u8Head(
        itemId: itemId,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAdaptiveBitrateStreaming: enableAdaptiveBitrateStreaming,
        enableTrickplay: enableTrickplay,
        enableAudioVbrEncoding: enableAudioVbrEncoding,
        alwaysBurnInSubtitleWhenTranscoding:
            alwaysBurnInSubtitleWhenTranscoding);
  }

  ///Gets a video hls playlist stream.
  ///@param itemId The item id.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
  ///@param enableTrickplay Enable trickplay image playlists being added to master playlist.
  ///@param enableAudioVbrEncoding Whether to enable Audio Encoding.
  ///@param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding.
  @Head(path: '/Videos/{itemId}/master.m3u8')
  Future<chopper.Response<String>> _videosItemIdMasterM3u8Head({
    @Path('itemId') required String? itemId,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') required String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAdaptiveBitrateStreaming')
    bool? enableAdaptiveBitrateStreaming,
    @Query('enableTrickplay') bool? enableTrickplay,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
    @Query('alwaysBurnInSubtitleWhenTranscoding')
    bool? alwaysBurnInSubtitleWhenTranscoding,
  });

  ///Get Default directory browser.
  Future<chopper.Response<DefaultDirectoryBrowserInfoDto>>
      environmentDefaultDirectoryBrowserGet() {
    generatedMapping.putIfAbsent(DefaultDirectoryBrowserInfoDto,
        () => DefaultDirectoryBrowserInfoDto.fromJsonFactory);

    return _environmentDefaultDirectoryBrowserGet();
  }

  ///Get Default directory browser.
  @Get(path: '/Environment/DefaultDirectoryBrowser')
  Future<chopper.Response<DefaultDirectoryBrowserInfoDto>>
      _environmentDefaultDirectoryBrowserGet();

  ///Gets the contents of a given directory in the file system.
  ///@param path The path.
  ///@param includeFiles An optional filter to include or exclude files from the results. true/false.
  ///@param includeDirectories An optional filter to include or exclude folders from the results. true/false.
  Future<chopper.Response<List<FileSystemEntryInfo>>>
      environmentDirectoryContentsGet({
    required String? path,
    bool? includeFiles,
    bool? includeDirectories,
  }) {
    generatedMapping.putIfAbsent(
        FileSystemEntryInfo, () => FileSystemEntryInfo.fromJsonFactory);

    return _environmentDirectoryContentsGet(
        path: path,
        includeFiles: includeFiles,
        includeDirectories: includeDirectories);
  }

  ///Gets the contents of a given directory in the file system.
  ///@param path The path.
  ///@param includeFiles An optional filter to include or exclude files from the results. true/false.
  ///@param includeDirectories An optional filter to include or exclude folders from the results. true/false.
  @Get(path: '/Environment/DirectoryContents')
  Future<chopper.Response<List<FileSystemEntryInfo>>>
      _environmentDirectoryContentsGet({
    @Query('path') required String? path,
    @Query('includeFiles') bool? includeFiles,
    @Query('includeDirectories') bool? includeDirectories,
  });

  ///Gets available drives from the server's file system.
  Future<chopper.Response<List<FileSystemEntryInfo>>> environmentDrivesGet() {
    generatedMapping.putIfAbsent(
        FileSystemEntryInfo, () => FileSystemEntryInfo.fromJsonFactory);

    return _environmentDrivesGet();
  }

  ///Gets available drives from the server's file system.
  @Get(path: '/Environment/Drives')
  Future<chopper.Response<List<FileSystemEntryInfo>>> _environmentDrivesGet();

  ///Gets network paths.
  @deprecated
  Future<chopper.Response<List<FileSystemEntryInfo>>>
      environmentNetworkSharesGet() {
    generatedMapping.putIfAbsent(
        FileSystemEntryInfo, () => FileSystemEntryInfo.fromJsonFactory);

    return _environmentNetworkSharesGet();
  }

  ///Gets network paths.
  @deprecated
  @Get(path: '/Environment/NetworkShares')
  Future<chopper.Response<List<FileSystemEntryInfo>>>
      _environmentNetworkSharesGet();

  ///Gets the parent path of a given path.
  ///@param path The path.
  Future<chopper.Response<String>> environmentParentPathGet(
      {required String? path}) {
    return _environmentParentPathGet(path: path);
  }

  ///Gets the parent path of a given path.
  ///@param path The path.
  @Get(path: '/Environment/ParentPath')
  Future<chopper.Response<String>> _environmentParentPathGet(
      {@Query('path') required String? path});

  ///Validates path.
  Future<chopper.Response> environmentValidatePathPost(
      {required ValidatePathDto? body}) {
    return _environmentValidatePathPost(body: body);
  }

  ///Validates path.
  @Post(
    path: '/Environment/ValidatePath',
    optionalBody: true,
  )
  Future<chopper.Response> _environmentValidatePathPost(
      {@Body() required ValidatePathDto? body});

  ///Gets legacy query filters.
  ///@param userId Optional. User id.
  ///@param parentId Optional. Parent id.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param mediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited.
  Future<chopper.Response<QueryFiltersLegacy>> itemsFiltersGet({
    String? userId,
    String? parentId,
    List<enums.BaseItemKind>? includeItemTypes,
    List<enums.MediaType>? mediaTypes,
  }) {
    generatedMapping.putIfAbsent(
        QueryFiltersLegacy, () => QueryFiltersLegacy.fromJsonFactory);

    return _itemsFiltersGet(
        userId: userId,
        parentId: parentId,
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        mediaTypes: mediaTypeListToJson(mediaTypes));
  }

  ///Gets legacy query filters.
  ///@param userId Optional. User id.
  ///@param parentId Optional. Parent id.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param mediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited.
  @Get(path: '/Items/Filters')
  Future<chopper.Response<QueryFiltersLegacy>> _itemsFiltersGet({
    @Query('userId') String? userId,
    @Query('parentId') String? parentId,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('mediaTypes') List<Object?>? mediaTypes,
  });

  ///Gets query filters.
  ///@param userId Optional. User id.
  ///@param parentId Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param isAiring Optional. Is item airing.
  ///@param isMovie Optional. Is item movie.
  ///@param isSports Optional. Is item sports.
  ///@param isKids Optional. Is item kids.
  ///@param isNews Optional. Is item news.
  ///@param isSeries Optional. Is item series.
  ///@param recursive Optional. Search recursive.
  Future<chopper.Response<QueryFilters>> itemsFilters2Get({
    String? userId,
    String? parentId,
    List<enums.BaseItemKind>? includeItemTypes,
    bool? isAiring,
    bool? isMovie,
    bool? isSports,
    bool? isKids,
    bool? isNews,
    bool? isSeries,
    bool? recursive,
  }) {
    generatedMapping.putIfAbsent(
        QueryFilters, () => QueryFilters.fromJsonFactory);

    return _itemsFilters2Get(
        userId: userId,
        parentId: parentId,
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        isAiring: isAiring,
        isMovie: isMovie,
        isSports: isSports,
        isKids: isKids,
        isNews: isNews,
        isSeries: isSeries,
        recursive: recursive);
  }

  ///Gets query filters.
  ///@param userId Optional. User id.
  ///@param parentId Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param isAiring Optional. Is item airing.
  ///@param isMovie Optional. Is item movie.
  ///@param isSports Optional. Is item sports.
  ///@param isKids Optional. Is item kids.
  ///@param isNews Optional. Is item news.
  ///@param isSeries Optional. Is item series.
  ///@param recursive Optional. Search recursive.
  @Get(path: '/Items/Filters2')
  Future<chopper.Response<QueryFilters>> _itemsFilters2Get({
    @Query('userId') String? userId,
    @Query('parentId') String? parentId,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('isAiring') bool? isAiring,
    @Query('isMovie') bool? isMovie,
    @Query('isSports') bool? isSports,
    @Query('isKids') bool? isKids,
    @Query('isNews') bool? isNews,
    @Query('isSeries') bool? isSeries,
    @Query('recursive') bool? recursive,
  });

  ///Gets all genres from a given item, folder, or the entire library.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm The search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Optional. Include total record count.
  Future<chopper.Response<BaseItemDtoQueryResult>> genresGet({
    int? startIndex,
    int? limit,
    String? searchTerm,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.BaseItemKind>? includeItemTypes,
    bool? isFavorite,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    String? userId,
    String? nameStartsWithOrGreater,
    String? nameStartsWith,
    String? nameLessThan,
    List<enums.ItemSortBy>? sortBy,
    List<enums.SortOrder>? sortOrder,
    bool? enableImages,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _genresGet(
        startIndex: startIndex,
        limit: limit,
        searchTerm: searchTerm,
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        isFavorite: isFavorite,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        userId: userId,
        nameStartsWithOrGreater: nameStartsWithOrGreater,
        nameStartsWith: nameStartsWith,
        nameLessThan: nameLessThan,
        sortBy: itemSortByListToJson(sortBy),
        sortOrder: sortOrderListToJson(sortOrder),
        enableImages: enableImages,
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets all genres from a given item, folder, or the entire library.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm The search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Optional. Include total record count.
  @Get(path: '/Genres')
  Future<chopper.Response<BaseItemDtoQueryResult>> _genresGet({
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('searchTerm') String? searchTerm,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('isFavorite') bool? isFavorite,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('userId') String? userId,
    @Query('nameStartsWithOrGreater') String? nameStartsWithOrGreater,
    @Query('nameStartsWith') String? nameStartsWith,
    @Query('nameLessThan') String? nameLessThan,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('sortOrder') List<Object?>? sortOrder,
    @Query('enableImages') bool? enableImages,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Gets a genre, by name.
  ///@param genreName The genre name.
  ///@param userId The user id.
  Future<chopper.Response<BaseItemDto>> genresGenreNameGet({
    required String? genreName,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _genresGenreNameGet(genreName: genreName, userId: userId);
  }

  ///Gets a genre, by name.
  ///@param genreName The genre name.
  ///@param userId The user id.
  @Get(path: '/Genres/{genreName}')
  Future<chopper.Response<BaseItemDto>> _genresGenreNameGet({
    @Path('genreName') required String? genreName,
    @Query('userId') String? userId,
  });

  ///Gets the specified audio segment for an audio item.
  ///@param itemId The item id.
  ///@param segmentId The segment id.
  Future<chopper.Response<String>> audioItemIdHlsSegmentIdStreamAacGet({
    required String? itemId,
    required String? segmentId,
  }) {
    return _audioItemIdHlsSegmentIdStreamAacGet(
        itemId: itemId, segmentId: segmentId);
  }

  ///Gets the specified audio segment for an audio item.
  ///@param itemId The item id.
  ///@param segmentId The segment id.
  @Get(path: '/Audio/{itemId}/hls/{segmentId}/stream.aac')
  Future<chopper.Response<String>> _audioItemIdHlsSegmentIdStreamAacGet({
    @Path('itemId') required String? itemId,
    @Path('segmentId') required String? segmentId,
  });

  ///Gets the specified audio segment for an audio item.
  ///@param itemId The item id.
  ///@param segmentId The segment id.
  Future<chopper.Response<String>> audioItemIdHlsSegmentIdStreamMp3Get({
    required String? itemId,
    required String? segmentId,
  }) {
    return _audioItemIdHlsSegmentIdStreamMp3Get(
        itemId: itemId, segmentId: segmentId);
  }

  ///Gets the specified audio segment for an audio item.
  ///@param itemId The item id.
  ///@param segmentId The segment id.
  @Get(path: '/Audio/{itemId}/hls/{segmentId}/stream.mp3')
  Future<chopper.Response<String>> _audioItemIdHlsSegmentIdStreamMp3Get({
    @Path('itemId') required String? itemId,
    @Path('segmentId') required String? segmentId,
  });

  ///Gets a hls video segment.
  ///@param itemId The item id.
  ///@param playlistId The playlist id.
  ///@param segmentId The segment id.
  ///@param segmentContainer The segment container.
  Future<chopper.Response<String>>
      videosItemIdHlsPlaylistIdSegmentIdSegmentContainerGet({
    required String? itemId,
    required String? playlistId,
    required String? segmentId,
    required String? segmentContainer,
  }) {
    return _videosItemIdHlsPlaylistIdSegmentIdSegmentContainerGet(
        itemId: itemId,
        playlistId: playlistId,
        segmentId: segmentId,
        segmentContainer: segmentContainer);
  }

  ///Gets a hls video segment.
  ///@param itemId The item id.
  ///@param playlistId The playlist id.
  ///@param segmentId The segment id.
  ///@param segmentContainer The segment container.
  @Get(path: '/Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}')
  Future<chopper.Response<String>>
      _videosItemIdHlsPlaylistIdSegmentIdSegmentContainerGet({
    @Path('itemId') required String? itemId,
    @Path('playlistId') required String? playlistId,
    @Path('segmentId') required String? segmentId,
    @Path('segmentContainer') required String? segmentContainer,
  });

  ///Gets a hls video playlist.
  ///@param itemId The video id.
  ///@param playlistId The playlist id.
  Future<chopper.Response<String>> videosItemIdHlsPlaylistIdStreamM3u8Get({
    required String? itemId,
    required String? playlistId,
  }) {
    return _videosItemIdHlsPlaylistIdStreamM3u8Get(
        itemId: itemId, playlistId: playlistId);
  }

  ///Gets a hls video playlist.
  ///@param itemId The video id.
  ///@param playlistId The playlist id.
  @Get(path: '/Videos/{itemId}/hls/{playlistId}/stream.m3u8')
  Future<chopper.Response<String>> _videosItemIdHlsPlaylistIdStreamM3u8Get({
    @Path('itemId') required String? itemId,
    @Path('playlistId') required String? playlistId,
  });

  ///Stops an active encoding.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param playSessionId The play session id.
  Future<chopper.Response> videosActiveEncodingsDelete({
    required String? deviceId,
    required String? playSessionId,
  }) {
    return _videosActiveEncodingsDelete(
        deviceId: deviceId, playSessionId: playSessionId);
  }

  ///Stops an active encoding.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param playSessionId The play session id.
  @Delete(path: '/Videos/ActiveEncodings')
  Future<chopper.Response> _videosActiveEncodingsDelete({
    @Query('deviceId') required String? deviceId,
    @Query('playSessionId') required String? playSessionId,
  });

  ///Get artist image by name.
  ///@param name Artist name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> artistsNameImagesImageTypeImageIndexGet({
    required String? name,
    required enums.ArtistsNameImagesImageTypeImageIndexGetImageType? imageType,
    String? tag,
    enums.ArtistsNameImagesImageTypeImageIndexGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    required int? imageIndex,
  }) {
    return _artistsNameImagesImageTypeImageIndexGet(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get artist image by name.
  ///@param name Artist name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Get(path: '/Artists/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _artistsNameImagesImageTypeImageIndexGet({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Path('imageIndex') required int? imageIndex,
  });

  ///Get artist image by name.
  ///@param name Artist name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> artistsNameImagesImageTypeImageIndexHead({
    required String? name,
    required enums.ArtistsNameImagesImageTypeImageIndexHeadImageType? imageType,
    String? tag,
    enums.ArtistsNameImagesImageTypeImageIndexHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    required int? imageIndex,
  }) {
    return _artistsNameImagesImageTypeImageIndexHead(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get artist image by name.
  ///@param name Artist name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Head(path: '/Artists/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _artistsNameImagesImageTypeImageIndexHead({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Path('imageIndex') required int? imageIndex,
  });

  ///Generates or gets the splashscreen.
  ///@param tag Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Blur image.
  ///@param backgroundColor Apply a background color for transparent images.
  ///@param foregroundLayer Apply a foreground layer on top of the image.
  ///@param quality Quality setting, from 0-100.
  Future<chopper.Response<String>> brandingSplashscreenGet({
    String? tag,
    enums.BrandingSplashscreenGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    int? width,
    int? height,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? quality,
  }) {
    return _brandingSplashscreenGet(
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: width,
        height: height,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        quality: quality);
  }

  ///Generates or gets the splashscreen.
  ///@param tag Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Blur image.
  ///@param backgroundColor Apply a background color for transparent images.
  ///@param foregroundLayer Apply a foreground layer on top of the image.
  ///@param quality Quality setting, from 0-100.
  @Get(path: '/Branding/Splashscreen')
  Future<chopper.Response<String>> _brandingSplashscreenGet({
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('quality') int? quality,
  });

  ///Uploads a custom splashscreen.
  ///The body is expected to the image contents base64 encoded.
  Future<chopper.Response> brandingSplashscreenPost({required Object? body}) {
    return _brandingSplashscreenPost(body: body);
  }

  ///Uploads a custom splashscreen.
  ///The body is expected to the image contents base64 encoded.
  @Post(
    path: '/Branding/Splashscreen',
    optionalBody: true,
  )
  Future<chopper.Response> _brandingSplashscreenPost(
      {@Body() required Object? body});

  ///Delete a custom splashscreen.
  Future<chopper.Response> brandingSplashscreenDelete() {
    return _brandingSplashscreenDelete();
  }

  ///Delete a custom splashscreen.
  @Delete(path: '/Branding/Splashscreen')
  Future<chopper.Response> _brandingSplashscreenDelete();

  ///Get genre image by name.
  ///@param name Genre name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> genresNameImagesImageTypeGet({
    required String? name,
    required enums.GenresNameImagesImageTypeGetImageType? imageType,
    String? tag,
    enums.GenresNameImagesImageTypeGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _genresNameImagesImageTypeGet(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get genre image by name.
  ///@param name Genre name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Get(path: '/Genres/{name}/Images/{imageType}')
  Future<chopper.Response<String>> _genresNameImagesImageTypeGet({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Get genre image by name.
  ///@param name Genre name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> genresNameImagesImageTypeHead({
    required String? name,
    required enums.GenresNameImagesImageTypeHeadImageType? imageType,
    String? tag,
    enums.GenresNameImagesImageTypeHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _genresNameImagesImageTypeHead(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get genre image by name.
  ///@param name Genre name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Head(path: '/Genres/{name}/Images/{imageType}')
  Future<chopper.Response<String>> _genresNameImagesImageTypeHead({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Get genre image by name.
  ///@param name Genre name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>> genresNameImagesImageTypeImageIndexGet({
    required String? name,
    required enums.GenresNameImagesImageTypeImageIndexGetImageType? imageType,
    required int? imageIndex,
    String? tag,
    enums.GenresNameImagesImageTypeImageIndexGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _genresNameImagesImageTypeImageIndexGet(
        name: name,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Get genre image by name.
  ///@param name Genre name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Get(path: '/Genres/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _genresNameImagesImageTypeImageIndexGet({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Get genre image by name.
  ///@param name Genre name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>> genresNameImagesImageTypeImageIndexHead({
    required String? name,
    required enums.GenresNameImagesImageTypeImageIndexHeadImageType? imageType,
    required int? imageIndex,
    String? tag,
    enums.GenresNameImagesImageTypeImageIndexHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _genresNameImagesImageTypeImageIndexHead(
        name: name,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Get genre image by name.
  ///@param name Genre name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Head(path: '/Genres/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _genresNameImagesImageTypeImageIndexHead({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Get item image infos.
  ///@param itemId Item id.
  Future<chopper.Response<List<ImageInfo>>> itemsItemIdImagesGet(
      {required String? itemId}) {
    generatedMapping.putIfAbsent(ImageInfo, () => ImageInfo.fromJsonFactory);

    return _itemsItemIdImagesGet(itemId: itemId);
  }

  ///Get item image infos.
  ///@param itemId Item id.
  @Get(path: '/Items/{itemId}/Images')
  Future<chopper.Response<List<ImageInfo>>> _itemsItemIdImagesGet(
      {@Path('itemId') required String? itemId});

  ///Delete an item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex The image index.
  Future<chopper.Response> itemsItemIdImagesImageTypeDelete({
    required String? itemId,
    required enums.ItemsItemIdImagesImageTypeDeleteImageType? imageType,
    int? imageIndex,
  }) {
    return _itemsItemIdImagesImageTypeDelete(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex);
  }

  ///Delete an item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex The image index.
  @Delete(path: '/Items/{itemId}/Images/{imageType}')
  Future<chopper.Response> _itemsItemIdImagesImageTypeDelete({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Query('imageIndex') int? imageIndex,
  });

  ///Set item image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  Future<chopper.Response> itemsItemIdImagesImageTypePost({
    required String? itemId,
    required enums.ItemsItemIdImagesImageTypePostImageType? imageType,
    required Object? body,
  }) {
    return _itemsItemIdImagesImageTypePost(
        itemId: itemId, imageType: imageType?.value?.toString(), body: body);
  }

  ///Set item image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  @Post(
    path: '/Items/{itemId}/Images/{imageType}',
    optionalBody: true,
  )
  Future<chopper.Response> _itemsItemIdImagesImageTypePost({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Body() required Object? body,
  });

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> itemsItemIdImagesImageTypeGet({
    required String? itemId,
    required enums.ItemsItemIdImagesImageTypeGetImageType? imageType,
    int? maxWidth,
    int? maxHeight,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    String? tag,
    enums.ItemsItemIdImagesImageTypeGetFormat? format,
    num? percentPlayed,
    int? unplayedCount,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _itemsItemIdImagesImageTypeGet(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        tag: tag,
        format: format?.value?.toString(),
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Get(path: '/Items/{itemId}/Images/{imageType}')
  Future<chopper.Response<String>> _itemsItemIdImagesImageTypeGet({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> itemsItemIdImagesImageTypeHead({
    required String? itemId,
    required enums.ItemsItemIdImagesImageTypeHeadImageType? imageType,
    int? maxWidth,
    int? maxHeight,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    String? tag,
    enums.ItemsItemIdImagesImageTypeHeadFormat? format,
    num? percentPlayed,
    int? unplayedCount,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _itemsItemIdImagesImageTypeHead(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        tag: tag,
        format: format?.value?.toString(),
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Head(path: '/Items/{itemId}/Images/{imageType}')
  Future<chopper.Response<String>> _itemsItemIdImagesImageTypeHead({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Delete an item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex The image index.
  Future<chopper.Response> itemsItemIdImagesImageTypeImageIndexDelete({
    required String? itemId,
    required enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType?
        imageType,
    required int? imageIndex,
  }) {
    return _itemsItemIdImagesImageTypeImageIndexDelete(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex);
  }

  ///Delete an item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex The image index.
  @Delete(path: '/Items/{itemId}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response> _itemsItemIdImagesImageTypeImageIndexDelete({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
  });

  ///Set item image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex (Unused) Image index.
  Future<chopper.Response> itemsItemIdImagesImageTypeImageIndexPost({
    required String? itemId,
    required enums.ItemsItemIdImagesImageTypeImageIndexPostImageType? imageType,
    required int? imageIndex,
    required Object? body,
  }) {
    return _itemsItemIdImagesImageTypeImageIndexPost(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        body: body);
  }

  ///Set item image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex (Unused) Image index.
  @Post(
    path: '/Items/{itemId}/Images/{imageType}/{imageIndex}',
    optionalBody: true,
  )
  Future<chopper.Response> _itemsItemIdImagesImageTypeImageIndexPost({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Body() required Object? body,
  });

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>> itemsItemIdImagesImageTypeImageIndexGet({
    required String? itemId,
    required enums.ItemsItemIdImagesImageTypeImageIndexGetImageType? imageType,
    required int? imageIndex,
    int? maxWidth,
    int? maxHeight,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    String? tag,
    enums.ItemsItemIdImagesImageTypeImageIndexGetFormat? format,
    num? percentPlayed,
    int? unplayedCount,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _itemsItemIdImagesImageTypeImageIndexGet(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        tag: tag,
        format: format?.value?.toString(),
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Get(path: '/Items/{itemId}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _itemsItemIdImagesImageTypeImageIndexGet({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>> itemsItemIdImagesImageTypeImageIndexHead({
    required String? itemId,
    required enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType? imageType,
    required int? imageIndex,
    int? maxWidth,
    int? maxHeight,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    String? tag,
    enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat? format,
    num? percentPlayed,
    int? unplayedCount,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _itemsItemIdImagesImageTypeImageIndexHead(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        tag: tag,
        format: format?.value?.toString(),
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Head(path: '/Items/{itemId}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _itemsItemIdImagesImageTypeImageIndexHead({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>>
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGet({
    required String? itemId,
    required enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType?
        imageType,
    required int? maxWidth,
    required int? maxHeight,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    required String? tag,
    required enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat?
        format,
    required num? percentPlayed,
    required int? unplayedCount,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    required int? imageIndex,
  }) {
    return _itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGet(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        tag: tag,
        format: format?.value?.toString(),
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Get(
      path:
          '/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}')
  Future<chopper.Response<String>>
      _itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGet({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Path('maxWidth') required int? maxWidth,
    @Path('maxHeight') required int? maxHeight,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Path('tag') required String? tag,
    @Path('format') required String? format,
    @Path('percentPlayed') required num? percentPlayed,
    @Path('unplayedCount') required int? unplayedCount,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Path('imageIndex') required int? imageIndex,
  });

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>>
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHead({
    required String? itemId,
    required enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType?
        imageType,
    required int? maxWidth,
    required int? maxHeight,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    required String? tag,
    required enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat?
        format,
    required num? percentPlayed,
    required int? unplayedCount,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    required int? imageIndex,
  }) {
    return _itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHead(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        tag: tag,
        format: format?.value?.toString(),
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Gets the item's image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Head(
      path:
          '/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}')
  Future<chopper.Response<String>>
      _itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHead({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Path('maxWidth') required int? maxWidth,
    @Path('maxHeight') required int? maxHeight,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Path('tag') required String? tag,
    @Path('format') required String? format,
    @Path('percentPlayed') required num? percentPlayed,
    @Path('unplayedCount') required int? unplayedCount,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Path('imageIndex') required int? imageIndex,
  });

  ///Updates the index for an item image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex Old image index.
  ///@param newIndex New image index.
  Future<chopper.Response> itemsItemIdImagesImageTypeImageIndexIndexPost({
    required String? itemId,
    required enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType?
        imageType,
    required int? imageIndex,
    required int? newIndex,
  }) {
    return _itemsItemIdImagesImageTypeImageIndexIndexPost(
        itemId: itemId,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        newIndex: newIndex);
  }

  ///Updates the index for an item image.
  ///@param itemId Item id.
  ///@param imageType Image type.
  ///@param imageIndex Old image index.
  ///@param newIndex New image index.
  @Post(
    path: '/Items/{itemId}/Images/{imageType}/{imageIndex}/Index',
    optionalBody: true,
  )
  Future<chopper.Response> _itemsItemIdImagesImageTypeImageIndexIndexPost({
    @Path('itemId') required String? itemId,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('newIndex') required int? newIndex,
  });

  ///Get music genre image by name.
  ///@param name Music genre name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> musicGenresNameImagesImageTypeGet({
    required String? name,
    required enums.MusicGenresNameImagesImageTypeGetImageType? imageType,
    String? tag,
    enums.MusicGenresNameImagesImageTypeGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _musicGenresNameImagesImageTypeGet(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get music genre image by name.
  ///@param name Music genre name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Get(path: '/MusicGenres/{name}/Images/{imageType}')
  Future<chopper.Response<String>> _musicGenresNameImagesImageTypeGet({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Get music genre image by name.
  ///@param name Music genre name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> musicGenresNameImagesImageTypeHead({
    required String? name,
    required enums.MusicGenresNameImagesImageTypeHeadImageType? imageType,
    String? tag,
    enums.MusicGenresNameImagesImageTypeHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _musicGenresNameImagesImageTypeHead(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get music genre image by name.
  ///@param name Music genre name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Head(path: '/MusicGenres/{name}/Images/{imageType}')
  Future<chopper.Response<String>> _musicGenresNameImagesImageTypeHead({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Get music genre image by name.
  ///@param name Music genre name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>> musicGenresNameImagesImageTypeImageIndexGet({
    required String? name,
    required enums.MusicGenresNameImagesImageTypeImageIndexGetImageType?
        imageType,
    required int? imageIndex,
    String? tag,
    enums.MusicGenresNameImagesImageTypeImageIndexGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _musicGenresNameImagesImageTypeImageIndexGet(
        name: name,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Get music genre image by name.
  ///@param name Music genre name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Get(path: '/MusicGenres/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>>
      _musicGenresNameImagesImageTypeImageIndexGet({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Get music genre image by name.
  ///@param name Music genre name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>>
      musicGenresNameImagesImageTypeImageIndexHead({
    required String? name,
    required enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType?
        imageType,
    required int? imageIndex,
    String? tag,
    enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _musicGenresNameImagesImageTypeImageIndexHead(
        name: name,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Get music genre image by name.
  ///@param name Music genre name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Head(path: '/MusicGenres/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>>
      _musicGenresNameImagesImageTypeImageIndexHead({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Get person image by name.
  ///@param name Person name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> personsNameImagesImageTypeGet({
    required String? name,
    required enums.PersonsNameImagesImageTypeGetImageType? imageType,
    String? tag,
    enums.PersonsNameImagesImageTypeGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _personsNameImagesImageTypeGet(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get person image by name.
  ///@param name Person name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Get(path: '/Persons/{name}/Images/{imageType}')
  Future<chopper.Response<String>> _personsNameImagesImageTypeGet({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Get person image by name.
  ///@param name Person name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> personsNameImagesImageTypeHead({
    required String? name,
    required enums.PersonsNameImagesImageTypeHeadImageType? imageType,
    String? tag,
    enums.PersonsNameImagesImageTypeHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _personsNameImagesImageTypeHead(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get person image by name.
  ///@param name Person name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Head(path: '/Persons/{name}/Images/{imageType}')
  Future<chopper.Response<String>> _personsNameImagesImageTypeHead({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Get person image by name.
  ///@param name Person name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>> personsNameImagesImageTypeImageIndexGet({
    required String? name,
    required enums.PersonsNameImagesImageTypeImageIndexGetImageType? imageType,
    required int? imageIndex,
    String? tag,
    enums.PersonsNameImagesImageTypeImageIndexGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _personsNameImagesImageTypeImageIndexGet(
        name: name,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Get person image by name.
  ///@param name Person name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Get(path: '/Persons/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _personsNameImagesImageTypeImageIndexGet({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Get person image by name.
  ///@param name Person name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>> personsNameImagesImageTypeImageIndexHead({
    required String? name,
    required enums.PersonsNameImagesImageTypeImageIndexHeadImageType? imageType,
    required int? imageIndex,
    String? tag,
    enums.PersonsNameImagesImageTypeImageIndexHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _personsNameImagesImageTypeImageIndexHead(
        name: name,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Get person image by name.
  ///@param name Person name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Head(path: '/Persons/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _personsNameImagesImageTypeImageIndexHead({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Get studio image by name.
  ///@param name Studio name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> studiosNameImagesImageTypeGet({
    required String? name,
    required enums.StudiosNameImagesImageTypeGetImageType? imageType,
    String? tag,
    enums.StudiosNameImagesImageTypeGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _studiosNameImagesImageTypeGet(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get studio image by name.
  ///@param name Studio name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Get(path: '/Studios/{name}/Images/{imageType}')
  Future<chopper.Response<String>> _studiosNameImagesImageTypeGet({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Get studio image by name.
  ///@param name Studio name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> studiosNameImagesImageTypeHead({
    required String? name,
    required enums.StudiosNameImagesImageTypeHeadImageType? imageType,
    String? tag,
    enums.StudiosNameImagesImageTypeHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _studiosNameImagesImageTypeHead(
        name: name,
        imageType: imageType?.value?.toString(),
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get studio image by name.
  ///@param name Studio name.
  ///@param imageType Image type.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Head(path: '/Studios/{name}/Images/{imageType}')
  Future<chopper.Response<String>> _studiosNameImagesImageTypeHead({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Get studio image by name.
  ///@param name Studio name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>> studiosNameImagesImageTypeImageIndexGet({
    required String? name,
    required enums.StudiosNameImagesImageTypeImageIndexGetImageType? imageType,
    required int? imageIndex,
    String? tag,
    enums.StudiosNameImagesImageTypeImageIndexGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _studiosNameImagesImageTypeImageIndexGet(
        name: name,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Get studio image by name.
  ///@param name Studio name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Get(path: '/Studios/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _studiosNameImagesImageTypeImageIndexGet({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Get studio image by name.
  ///@param name Studio name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  Future<chopper.Response<String>> studiosNameImagesImageTypeImageIndexHead({
    required String? name,
    required enums.StudiosNameImagesImageTypeImageIndexHeadImageType? imageType,
    required int? imageIndex,
    String? tag,
    enums.StudiosNameImagesImageTypeImageIndexHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
  }) {
    return _studiosNameImagesImageTypeImageIndexHead(
        name: name,
        imageType: imageType?.value?.toString(),
        imageIndex: imageIndex,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer);
  }

  ///Get studio image by name.
  ///@param name Studio name.
  ///@param imageType Image type.
  ///@param imageIndex Image index.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  @Head(path: '/Studios/{name}/Images/{imageType}/{imageIndex}')
  Future<chopper.Response<String>> _studiosNameImagesImageTypeImageIndexHead({
    @Path('name') required String? name,
    @Path('imageType') required String? imageType,
    @Path('imageIndex') required int? imageIndex,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
  });

  ///Sets the user image.
  ///@param userId User Id.
  Future<chopper.Response> userImagePost({
    String? userId,
    required Object? body,
  }) {
    return _userImagePost(userId: userId, body: body);
  }

  ///Sets the user image.
  ///@param userId User Id.
  @Post(
    path: '/UserImage',
    optionalBody: true,
  )
  Future<chopper.Response> _userImagePost({
    @Query('userId') String? userId,
    @Body() required Object? body,
  });

  ///Delete the user's image.
  ///@param userId User Id.
  Future<chopper.Response> userImageDelete({String? userId}) {
    return _userImageDelete(userId: userId);
  }

  ///Delete the user's image.
  ///@param userId User Id.
  @Delete(path: '/UserImage')
  Future<chopper.Response> _userImageDelete({@Query('userId') String? userId});

  ///Get user profile image.
  ///@param userId User id.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> userImageGet({
    String? userId,
    String? tag,
    enums.UserImageGetFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _userImageGet(
        userId: userId,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get user profile image.
  ///@param userId User id.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Get(path: '/UserImage')
  Future<chopper.Response<String>> _userImageGet({
    @Query('userId') String? userId,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Get user profile image.
  ///@param userId User id.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  Future<chopper.Response<String>> userImageHead({
    String? userId,
    String? tag,
    enums.UserImageHeadFormat? format,
    int? maxWidth,
    int? maxHeight,
    num? percentPlayed,
    int? unplayedCount,
    int? width,
    int? height,
    int? quality,
    int? fillWidth,
    int? fillHeight,
    int? blur,
    String? backgroundColor,
    String? foregroundLayer,
    int? imageIndex,
  }) {
    return _userImageHead(
        userId: userId,
        tag: tag,
        format: format?.value?.toString(),
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        percentPlayed: percentPlayed,
        unplayedCount: unplayedCount,
        width: width,
        height: height,
        quality: quality,
        fillWidth: fillWidth,
        fillHeight: fillHeight,
        blur: blur,
        backgroundColor: backgroundColor,
        foregroundLayer: foregroundLayer,
        imageIndex: imageIndex);
  }

  ///Get user profile image.
  ///@param userId User id.
  ///@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
  ///@param format Determines the output format of the image - original,gif,jpg,png.
  ///@param maxWidth The maximum image width to return.
  ///@param maxHeight The maximum image height to return.
  ///@param percentPlayed Optional. Percent to render for the percent played overlay.
  ///@param unplayedCount Optional. Unplayed count overlay to render.
  ///@param width The fixed image width to return.
  ///@param height The fixed image height to return.
  ///@param quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
  ///@param fillWidth Width of box to fill.
  ///@param fillHeight Height of box to fill.
  ///@param blur Optional. Blur image.
  ///@param backgroundColor Optional. Apply a background color for transparent images.
  ///@param foregroundLayer Optional. Apply a foreground layer on top of the image.
  ///@param imageIndex Image index.
  @Head(path: '/UserImage')
  Future<chopper.Response<String>> _userImageHead({
    @Query('userId') String? userId,
    @Query('tag') String? tag,
    @Query('format') String? format,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('percentPlayed') num? percentPlayed,
    @Query('unplayedCount') int? unplayedCount,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('quality') int? quality,
    @Query('fillWidth') int? fillWidth,
    @Query('fillHeight') int? fillHeight,
    @Query('blur') int? blur,
    @Query('backgroundColor') String? backgroundColor,
    @Query('foregroundLayer') String? foregroundLayer,
    @Query('imageIndex') int? imageIndex,
  });

  ///Creates an instant playlist based on a given album.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  Future<chopper.Response<BaseItemDtoQueryResult>> albumsItemIdInstantMixGet({
    required String? itemId,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
    bool? enableImages,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _albumsItemIdInstantMixGet(
        itemId: itemId,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        enableImages: enableImages,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes));
  }

  ///Creates an instant playlist based on a given album.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @Get(path: '/Albums/{itemId}/InstantMix')
  Future<chopper.Response<BaseItemDtoQueryResult>> _albumsItemIdInstantMixGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('enableImages') bool? enableImages,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
  });

  ///Creates an instant playlist based on a given artist.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  Future<chopper.Response<BaseItemDtoQueryResult>> artistsItemIdInstantMixGet({
    required String? itemId,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
    bool? enableImages,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _artistsItemIdInstantMixGet(
        itemId: itemId,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        enableImages: enableImages,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes));
  }

  ///Creates an instant playlist based on a given artist.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @Get(path: '/Artists/{itemId}/InstantMix')
  Future<chopper.Response<BaseItemDtoQueryResult>> _artistsItemIdInstantMixGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('enableImages') bool? enableImages,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
  });

  ///Creates an instant playlist based on a given artist.
  ///@param id The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @deprecated
  Future<chopper.Response<BaseItemDtoQueryResult>> artistsInstantMixGet({
    required String? id,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
    bool? enableImages,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _artistsInstantMixGet(
        id: id,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        enableImages: enableImages,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes));
  }

  ///Creates an instant playlist based on a given artist.
  ///@param id The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @deprecated
  @Get(path: '/Artists/InstantMix')
  Future<chopper.Response<BaseItemDtoQueryResult>> _artistsInstantMixGet({
    @Query('id') required String? id,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('enableImages') bool? enableImages,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
  });

  ///Creates an instant playlist based on a given item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  Future<chopper.Response<BaseItemDtoQueryResult>> itemsItemIdInstantMixGet({
    required String? itemId,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
    bool? enableImages,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _itemsItemIdInstantMixGet(
        itemId: itemId,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        enableImages: enableImages,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes));
  }

  ///Creates an instant playlist based on a given item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @Get(path: '/Items/{itemId}/InstantMix')
  Future<chopper.Response<BaseItemDtoQueryResult>> _itemsItemIdInstantMixGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('enableImages') bool? enableImages,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
  });

  ///Creates an instant playlist based on a given genre.
  ///@param name The genre name.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  Future<chopper.Response<BaseItemDtoQueryResult>>
      musicGenresNameInstantMixGet({
    required String? name,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
    bool? enableImages,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _musicGenresNameInstantMixGet(
        name: name,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        enableImages: enableImages,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes));
  }

  ///Creates an instant playlist based on a given genre.
  ///@param name The genre name.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @Get(path: '/MusicGenres/{name}/InstantMix')
  Future<chopper.Response<BaseItemDtoQueryResult>>
      _musicGenresNameInstantMixGet({
    @Path('name') required String? name,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('enableImages') bool? enableImages,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
  });

  ///Creates an instant playlist based on a given genre.
  ///@param id The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  Future<chopper.Response<BaseItemDtoQueryResult>> musicGenresInstantMixGet({
    required String? id,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
    bool? enableImages,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _musicGenresInstantMixGet(
        id: id,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        enableImages: enableImages,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes));
  }

  ///Creates an instant playlist based on a given genre.
  ///@param id The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @Get(path: '/MusicGenres/InstantMix')
  Future<chopper.Response<BaseItemDtoQueryResult>> _musicGenresInstantMixGet({
    @Query('id') required String? id,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('enableImages') bool? enableImages,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
  });

  ///Creates an instant playlist based on a given playlist.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  Future<chopper.Response<BaseItemDtoQueryResult>>
      playlistsItemIdInstantMixGet({
    required String? itemId,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
    bool? enableImages,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _playlistsItemIdInstantMixGet(
        itemId: itemId,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        enableImages: enableImages,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes));
  }

  ///Creates an instant playlist based on a given playlist.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @Get(path: '/Playlists/{itemId}/InstantMix')
  Future<chopper.Response<BaseItemDtoQueryResult>>
      _playlistsItemIdInstantMixGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('enableImages') bool? enableImages,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
  });

  ///Creates an instant playlist based on a given song.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  Future<chopper.Response<BaseItemDtoQueryResult>> songsItemIdInstantMixGet({
    required String? itemId,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
    bool? enableImages,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _songsItemIdInstantMixGet(
        itemId: itemId,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        enableImages: enableImages,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes));
  }

  ///Creates an instant playlist based on a given song.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @Get(path: '/Songs/{itemId}/InstantMix')
  Future<chopper.Response<BaseItemDtoQueryResult>> _songsItemIdInstantMixGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('enableImages') bool? enableImages,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
  });

  ///Get the item's external id info.
  ///@param itemId Item id.
  Future<chopper.Response<List<ExternalIdInfo>>> itemsItemIdExternalIdInfosGet(
      {required String? itemId}) {
    generatedMapping.putIfAbsent(
        ExternalIdInfo, () => ExternalIdInfo.fromJsonFactory);

    return _itemsItemIdExternalIdInfosGet(itemId: itemId);
  }

  ///Get the item's external id info.
  ///@param itemId Item id.
  @Get(path: '/Items/{itemId}/ExternalIdInfos')
  Future<chopper.Response<List<ExternalIdInfo>>> _itemsItemIdExternalIdInfosGet(
      {@Path('itemId') required String? itemId});

  ///Applies search criteria to an item and refreshes metadata.
  ///@param itemId Item id.
  ///@param replaceAllImages Optional. Whether or not to replace all images. Default: True.
  Future<chopper.Response> itemsRemoteSearchApplyItemIdPost({
    required String? itemId,
    bool? replaceAllImages,
    required RemoteSearchResult? body,
  }) {
    return _itemsRemoteSearchApplyItemIdPost(
        itemId: itemId, replaceAllImages: replaceAllImages, body: body);
  }

  ///Applies search criteria to an item and refreshes metadata.
  ///@param itemId Item id.
  ///@param replaceAllImages Optional. Whether or not to replace all images. Default: True.
  @Post(
    path: '/Items/RemoteSearch/Apply/{itemId}',
    optionalBody: true,
  )
  Future<chopper.Response> _itemsRemoteSearchApplyItemIdPost({
    @Path('itemId') required String? itemId,
    @Query('replaceAllImages') bool? replaceAllImages,
    @Body() required RemoteSearchResult? body,
  });

  ///Get book remote search.
  Future<chopper.Response<List<RemoteSearchResult>>> itemsRemoteSearchBookPost(
      {required BookInfoRemoteSearchQuery? body}) {
    generatedMapping.putIfAbsent(
        RemoteSearchResult, () => RemoteSearchResult.fromJsonFactory);

    return _itemsRemoteSearchBookPost(body: body);
  }

  ///Get book remote search.
  @Post(
    path: '/Items/RemoteSearch/Book',
    optionalBody: true,
  )
  Future<chopper.Response<List<RemoteSearchResult>>> _itemsRemoteSearchBookPost(
      {@Body() required BookInfoRemoteSearchQuery? body});

  ///Get box set remote search.
  Future<chopper.Response<List<RemoteSearchResult>>>
      itemsRemoteSearchBoxSetPost(
          {required BoxSetInfoRemoteSearchQuery? body}) {
    generatedMapping.putIfAbsent(
        RemoteSearchResult, () => RemoteSearchResult.fromJsonFactory);

    return _itemsRemoteSearchBoxSetPost(body: body);
  }

  ///Get box set remote search.
  @Post(
    path: '/Items/RemoteSearch/BoxSet',
    optionalBody: true,
  )
  Future<chopper.Response<List<RemoteSearchResult>>>
      _itemsRemoteSearchBoxSetPost(
          {@Body() required BoxSetInfoRemoteSearchQuery? body});

  ///Get movie remote search.
  Future<chopper.Response<List<RemoteSearchResult>>> itemsRemoteSearchMoviePost(
      {required MovieInfoRemoteSearchQuery? body}) {
    generatedMapping.putIfAbsent(
        RemoteSearchResult, () => RemoteSearchResult.fromJsonFactory);

    return _itemsRemoteSearchMoviePost(body: body);
  }

  ///Get movie remote search.
  @Post(
    path: '/Items/RemoteSearch/Movie',
    optionalBody: true,
  )
  Future<chopper.Response<List<RemoteSearchResult>>>
      _itemsRemoteSearchMoviePost(
          {@Body() required MovieInfoRemoteSearchQuery? body});

  ///Get music album remote search.
  Future<chopper.Response<List<RemoteSearchResult>>>
      itemsRemoteSearchMusicAlbumPost(
          {required AlbumInfoRemoteSearchQuery? body}) {
    generatedMapping.putIfAbsent(
        RemoteSearchResult, () => RemoteSearchResult.fromJsonFactory);

    return _itemsRemoteSearchMusicAlbumPost(body: body);
  }

  ///Get music album remote search.
  @Post(
    path: '/Items/RemoteSearch/MusicAlbum',
    optionalBody: true,
  )
  Future<chopper.Response<List<RemoteSearchResult>>>
      _itemsRemoteSearchMusicAlbumPost(
          {@Body() required AlbumInfoRemoteSearchQuery? body});

  ///Get music artist remote search.
  Future<chopper.Response<List<RemoteSearchResult>>>
      itemsRemoteSearchMusicArtistPost(
          {required ArtistInfoRemoteSearchQuery? body}) {
    generatedMapping.putIfAbsent(
        RemoteSearchResult, () => RemoteSearchResult.fromJsonFactory);

    return _itemsRemoteSearchMusicArtistPost(body: body);
  }

  ///Get music artist remote search.
  @Post(
    path: '/Items/RemoteSearch/MusicArtist',
    optionalBody: true,
  )
  Future<chopper.Response<List<RemoteSearchResult>>>
      _itemsRemoteSearchMusicArtistPost(
          {@Body() required ArtistInfoRemoteSearchQuery? body});

  ///Get music video remote search.
  Future<chopper.Response<List<RemoteSearchResult>>>
      itemsRemoteSearchMusicVideoPost(
          {required MusicVideoInfoRemoteSearchQuery? body}) {
    generatedMapping.putIfAbsent(
        RemoteSearchResult, () => RemoteSearchResult.fromJsonFactory);

    return _itemsRemoteSearchMusicVideoPost(body: body);
  }

  ///Get music video remote search.
  @Post(
    path: '/Items/RemoteSearch/MusicVideo',
    optionalBody: true,
  )
  Future<chopper.Response<List<RemoteSearchResult>>>
      _itemsRemoteSearchMusicVideoPost(
          {@Body() required MusicVideoInfoRemoteSearchQuery? body});

  ///Get person remote search.
  Future<chopper.Response<List<RemoteSearchResult>>>
      itemsRemoteSearchPersonPost(
          {required PersonLookupInfoRemoteSearchQuery? body}) {
    generatedMapping.putIfAbsent(
        RemoteSearchResult, () => RemoteSearchResult.fromJsonFactory);

    return _itemsRemoteSearchPersonPost(body: body);
  }

  ///Get person remote search.
  @Post(
    path: '/Items/RemoteSearch/Person',
    optionalBody: true,
  )
  Future<chopper.Response<List<RemoteSearchResult>>>
      _itemsRemoteSearchPersonPost(
          {@Body() required PersonLookupInfoRemoteSearchQuery? body});

  ///Get series remote search.
  Future<chopper.Response<List<RemoteSearchResult>>>
      itemsRemoteSearchSeriesPost(
          {required SeriesInfoRemoteSearchQuery? body}) {
    generatedMapping.putIfAbsent(
        RemoteSearchResult, () => RemoteSearchResult.fromJsonFactory);

    return _itemsRemoteSearchSeriesPost(body: body);
  }

  ///Get series remote search.
  @Post(
    path: '/Items/RemoteSearch/Series',
    optionalBody: true,
  )
  Future<chopper.Response<List<RemoteSearchResult>>>
      _itemsRemoteSearchSeriesPost(
          {@Body() required SeriesInfoRemoteSearchQuery? body});

  ///Get trailer remote search.
  Future<chopper.Response<List<RemoteSearchResult>>>
      itemsRemoteSearchTrailerPost(
          {required TrailerInfoRemoteSearchQuery? body}) {
    generatedMapping.putIfAbsent(
        RemoteSearchResult, () => RemoteSearchResult.fromJsonFactory);

    return _itemsRemoteSearchTrailerPost(body: body);
  }

  ///Get trailer remote search.
  @Post(
    path: '/Items/RemoteSearch/Trailer',
    optionalBody: true,
  )
  Future<chopper.Response<List<RemoteSearchResult>>>
      _itemsRemoteSearchTrailerPost(
          {@Body() required TrailerInfoRemoteSearchQuery? body});

  ///Refreshes metadata for an item.
  ///@param itemId Item id.
  ///@param metadataRefreshMode (Optional) Specifies the metadata refresh mode.
  ///@param imageRefreshMode (Optional) Specifies the image refresh mode.
  ///@param replaceAllMetadata (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
  ///@param replaceAllImages (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
  Future<chopper.Response> itemsItemIdRefreshPost({
    required String? itemId,
    enums.ItemsItemIdRefreshPostMetadataRefreshMode? metadataRefreshMode,
    enums.ItemsItemIdRefreshPostImageRefreshMode? imageRefreshMode,
    bool? replaceAllMetadata,
    bool? replaceAllImages,
  }) {
    return _itemsItemIdRefreshPost(
        itemId: itemId,
        metadataRefreshMode: metadataRefreshMode?.value?.toString(),
        imageRefreshMode: imageRefreshMode?.value?.toString(),
        replaceAllMetadata: replaceAllMetadata,
        replaceAllImages: replaceAllImages);
  }

  ///Refreshes metadata for an item.
  ///@param itemId Item id.
  ///@param metadataRefreshMode (Optional) Specifies the metadata refresh mode.
  ///@param imageRefreshMode (Optional) Specifies the image refresh mode.
  ///@param replaceAllMetadata (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
  ///@param replaceAllImages (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
  @Post(
    path: '/Items/{itemId}/Refresh',
    optionalBody: true,
  )
  Future<chopper.Response> _itemsItemIdRefreshPost({
    @Path('itemId') required String? itemId,
    @Query('metadataRefreshMode') String? metadataRefreshMode,
    @Query('imageRefreshMode') String? imageRefreshMode,
    @Query('replaceAllMetadata') bool? replaceAllMetadata,
    @Query('replaceAllImages') bool? replaceAllImages,
  });

  ///Gets items based on a query.
  ///@param userId The user id supplied as query parameter; this is required when not using an API key.
  ///@param maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
  ///@param hasThemeSong Optional filter by items with theme songs.
  ///@param hasThemeVideo Optional filter by items with theme videos.
  ///@param hasSubtitles Optional filter by items with subtitles.
  ///@param hasSpecialFeature Optional filter by items with special features.
  ///@param hasTrailer Optional filter by items with trailers.
  ///@param adjacentTo Optional. Return items that are siblings of a supplied item.
  ///@param indexNumber Optional filter by index number.
  ///@param parentIndexNumber Optional filter by parent index number.
  ///@param hasParentalRating Optional filter by items that have or do not have a parental rating.
  ///@param isHd Optional filter by items that are HD or not.
  ///@param is4K Optional filter by items that are 4K or not.
  ///@param locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
  ///@param excludeLocationTypes Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
  ///@param isMissing Optional filter by items that are missing episodes or not.
  ///@param isUnaired Optional filter by items that are unaired episodes or not.
  ///@param minCommunityRating Optional filter by minimum community rating.
  ///@param minCriticRating Optional filter by minimum critic rating.
  ///@param minPremiereDate Optional. The minimum premiere date. Format = ISO.
  ///@param minDateLastSaved Optional. The minimum last saved date. Format = ISO.
  ///@param minDateLastSavedForUser Optional. The minimum last saved date for the current user. Format = ISO.
  ///@param maxPremiereDate Optional. The maximum premiere date. Format = ISO.
  ///@param hasOverview Optional filter by items that have an overview or not.
  ///@param hasImdbId Optional filter by items that have an IMDb id or not.
  ///@param hasTmdbId Optional filter by items that have a TMDb id or not.
  ///@param hasTvdbId Optional filter by items that have a TVDb id or not.
  ///@param isMovie Optional filter for live tv movies.
  ///@param isSeries Optional filter for live tv series.
  ///@param isNews Optional filter for live tv news.
  ///@param isKids Optional filter for live tv kids.
  ///@param isSports Optional filter for live tv sports.
  ///@param excludeItemIds Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param recursive When searching within folders, this determines whether or not the search will be recursive. true/false.
  ///@param searchTerm Optional. Filter based on a search term.
  ///@param sortOrder Sort Order - Ascending, Descending.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
  ///@param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
  ///@param filters Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
  ///@param imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param isPlayed Optional filter by items that are played, or not.
  ///@param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
  ///@param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
  ///@param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
  ///@param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param person Optional. If specified, results will be filtered to include only those containing the specified person.
  ///@param personIds Optional. If specified, results will be filtered to include only those containing the specified person id.
  ///@param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
  ///@param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
  ///@param artists Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
  ///@param excludeArtistIds Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
  ///@param artistIds Optional. If specified, results will be filtered to include only those containing the specified artist id.
  ///@param albumArtistIds Optional. If specified, results will be filtered to include only those containing the specified album artist id.
  ///@param contributingArtistIds Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
  ///@param albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
  ///@param albumIds Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
  ///@param ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
  ///@param videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
  ///@param minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
  ///@param isLocked Optional filter by items that are locked.
  ///@param isPlaceHolder Optional filter by items that are placeholders.
  ///@param hasOfficialRating Optional filter by items that have official ratings.
  ///@param collapseBoxSetItems Whether or not to hide items behind their boxsets.
  ///@param minWidth Optional. Filter by the minimum width of the item.
  ///@param minHeight Optional. Filter by the minimum height of the item.
  ///@param maxWidth Optional. Filter by the maximum width of the item.
  ///@param maxHeight Optional. Filter by the maximum height of the item.
  ///@param is3D Optional filter by items that are 3D, or not.
  ///@param seriesStatus Optional filter by Series Status. Allows multiple, comma delimited.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
  ///@param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
  ///@param enableTotalRecordCount Optional. Enable the total record count.
  ///@param enableImages Optional, include image information in output.
  Future<chopper.Response<BaseItemDtoQueryResult>> itemsGet({
    String? userId,
    String? maxOfficialRating,
    bool? hasThemeSong,
    bool? hasThemeVideo,
    bool? hasSubtitles,
    bool? hasSpecialFeature,
    bool? hasTrailer,
    String? adjacentTo,
    int? indexNumber,
    int? parentIndexNumber,
    bool? hasParentalRating,
    bool? isHd,
    bool? is4K,
    List<enums.LocationType>? locationTypes,
    List<enums.LocationType>? excludeLocationTypes,
    bool? isMissing,
    bool? isUnaired,
    num? minCommunityRating,
    num? minCriticRating,
    DateTime? minPremiereDate,
    DateTime? minDateLastSaved,
    DateTime? minDateLastSavedForUser,
    DateTime? maxPremiereDate,
    bool? hasOverview,
    bool? hasImdbId,
    bool? hasTmdbId,
    bool? hasTvdbId,
    bool? isMovie,
    bool? isSeries,
    bool? isNews,
    bool? isKids,
    bool? isSports,
    List<String>? excludeItemIds,
    int? startIndex,
    int? limit,
    bool? recursive,
    String? searchTerm,
    List<enums.SortOrder>? sortOrder,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.BaseItemKind>? includeItemTypes,
    List<enums.ItemFilter>? filters,
    bool? isFavorite,
    List<enums.MediaType>? mediaTypes,
    List<enums.ImageType>? imageTypes,
    List<enums.ItemSortBy>? sortBy,
    bool? isPlayed,
    List<String>? genres,
    List<String>? officialRatings,
    List<String>? tags,
    List<int>? years,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    String? person,
    List<String>? personIds,
    List<String>? personTypes,
    List<String>? studios,
    List<String>? artists,
    List<String>? excludeArtistIds,
    List<String>? artistIds,
    List<String>? albumArtistIds,
    List<String>? contributingArtistIds,
    List<String>? albums,
    List<String>? albumIds,
    List<String>? ids,
    List<enums.VideoType>? videoTypes,
    String? minOfficialRating,
    bool? isLocked,
    bool? isPlaceHolder,
    bool? hasOfficialRating,
    bool? collapseBoxSetItems,
    int? minWidth,
    int? minHeight,
    int? maxWidth,
    int? maxHeight,
    bool? is3D,
    List<enums.SeriesStatus>? seriesStatus,
    String? nameStartsWithOrGreater,
    String? nameStartsWith,
    String? nameLessThan,
    List<String>? studioIds,
    List<String>? genreIds,
    bool? enableTotalRecordCount,
    bool? enableImages,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _itemsGet(
        userId: userId,
        maxOfficialRating: maxOfficialRating,
        hasThemeSong: hasThemeSong,
        hasThemeVideo: hasThemeVideo,
        hasSubtitles: hasSubtitles,
        hasSpecialFeature: hasSpecialFeature,
        hasTrailer: hasTrailer,
        adjacentTo: adjacentTo,
        indexNumber: indexNumber,
        parentIndexNumber: parentIndexNumber,
        hasParentalRating: hasParentalRating,
        isHd: isHd,
        is4K: is4K,
        locationTypes: locationTypeListToJson(locationTypes),
        excludeLocationTypes: locationTypeListToJson(excludeLocationTypes),
        isMissing: isMissing,
        isUnaired: isUnaired,
        minCommunityRating: minCommunityRating,
        minCriticRating: minCriticRating,
        minPremiereDate: minPremiereDate,
        minDateLastSaved: minDateLastSaved,
        minDateLastSavedForUser: minDateLastSavedForUser,
        maxPremiereDate: maxPremiereDate,
        hasOverview: hasOverview,
        hasImdbId: hasImdbId,
        hasTmdbId: hasTmdbId,
        hasTvdbId: hasTvdbId,
        isMovie: isMovie,
        isSeries: isSeries,
        isNews: isNews,
        isKids: isKids,
        isSports: isSports,
        excludeItemIds: excludeItemIds,
        startIndex: startIndex,
        limit: limit,
        recursive: recursive,
        searchTerm: searchTerm,
        sortOrder: sortOrderListToJson(sortOrder),
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        filters: itemFilterListToJson(filters),
        isFavorite: isFavorite,
        mediaTypes: mediaTypeListToJson(mediaTypes),
        imageTypes: imageTypeListToJson(imageTypes),
        sortBy: itemSortByListToJson(sortBy),
        isPlayed: isPlayed,
        genres: genres,
        officialRatings: officialRatings,
        tags: tags,
        years: years,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        person: person,
        personIds: personIds,
        personTypes: personTypes,
        studios: studios,
        artists: artists,
        excludeArtistIds: excludeArtistIds,
        artistIds: artistIds,
        albumArtistIds: albumArtistIds,
        contributingArtistIds: contributingArtistIds,
        albums: albums,
        albumIds: albumIds,
        ids: ids,
        videoTypes: videoTypeListToJson(videoTypes),
        minOfficialRating: minOfficialRating,
        isLocked: isLocked,
        isPlaceHolder: isPlaceHolder,
        hasOfficialRating: hasOfficialRating,
        collapseBoxSetItems: collapseBoxSetItems,
        minWidth: minWidth,
        minHeight: minHeight,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        is3D: is3D,
        seriesStatus: seriesStatusListToJson(seriesStatus),
        nameStartsWithOrGreater: nameStartsWithOrGreater,
        nameStartsWith: nameStartsWith,
        nameLessThan: nameLessThan,
        studioIds: studioIds,
        genreIds: genreIds,
        enableTotalRecordCount: enableTotalRecordCount,
        enableImages: enableImages);
  }

  ///Gets items based on a query.
  ///@param userId The user id supplied as query parameter; this is required when not using an API key.
  ///@param maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
  ///@param hasThemeSong Optional filter by items with theme songs.
  ///@param hasThemeVideo Optional filter by items with theme videos.
  ///@param hasSubtitles Optional filter by items with subtitles.
  ///@param hasSpecialFeature Optional filter by items with special features.
  ///@param hasTrailer Optional filter by items with trailers.
  ///@param adjacentTo Optional. Return items that are siblings of a supplied item.
  ///@param indexNumber Optional filter by index number.
  ///@param parentIndexNumber Optional filter by parent index number.
  ///@param hasParentalRating Optional filter by items that have or do not have a parental rating.
  ///@param isHd Optional filter by items that are HD or not.
  ///@param is4K Optional filter by items that are 4K or not.
  ///@param locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
  ///@param excludeLocationTypes Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
  ///@param isMissing Optional filter by items that are missing episodes or not.
  ///@param isUnaired Optional filter by items that are unaired episodes or not.
  ///@param minCommunityRating Optional filter by minimum community rating.
  ///@param minCriticRating Optional filter by minimum critic rating.
  ///@param minPremiereDate Optional. The minimum premiere date. Format = ISO.
  ///@param minDateLastSaved Optional. The minimum last saved date. Format = ISO.
  ///@param minDateLastSavedForUser Optional. The minimum last saved date for the current user. Format = ISO.
  ///@param maxPremiereDate Optional. The maximum premiere date. Format = ISO.
  ///@param hasOverview Optional filter by items that have an overview or not.
  ///@param hasImdbId Optional filter by items that have an IMDb id or not.
  ///@param hasTmdbId Optional filter by items that have a TMDb id or not.
  ///@param hasTvdbId Optional filter by items that have a TVDb id or not.
  ///@param isMovie Optional filter for live tv movies.
  ///@param isSeries Optional filter for live tv series.
  ///@param isNews Optional filter for live tv news.
  ///@param isKids Optional filter for live tv kids.
  ///@param isSports Optional filter for live tv sports.
  ///@param excludeItemIds Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param recursive When searching within folders, this determines whether or not the search will be recursive. true/false.
  ///@param searchTerm Optional. Filter based on a search term.
  ///@param sortOrder Sort Order - Ascending, Descending.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
  ///@param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
  ///@param filters Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
  ///@param imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param isPlayed Optional filter by items that are played, or not.
  ///@param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
  ///@param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
  ///@param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
  ///@param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param person Optional. If specified, results will be filtered to include only those containing the specified person.
  ///@param personIds Optional. If specified, results will be filtered to include only those containing the specified person id.
  ///@param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
  ///@param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
  ///@param artists Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
  ///@param excludeArtistIds Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
  ///@param artistIds Optional. If specified, results will be filtered to include only those containing the specified artist id.
  ///@param albumArtistIds Optional. If specified, results will be filtered to include only those containing the specified album artist id.
  ///@param contributingArtistIds Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
  ///@param albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
  ///@param albumIds Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
  ///@param ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
  ///@param videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
  ///@param minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
  ///@param isLocked Optional filter by items that are locked.
  ///@param isPlaceHolder Optional filter by items that are placeholders.
  ///@param hasOfficialRating Optional filter by items that have official ratings.
  ///@param collapseBoxSetItems Whether or not to hide items behind their boxsets.
  ///@param minWidth Optional. Filter by the minimum width of the item.
  ///@param minHeight Optional. Filter by the minimum height of the item.
  ///@param maxWidth Optional. Filter by the maximum width of the item.
  ///@param maxHeight Optional. Filter by the maximum height of the item.
  ///@param is3D Optional filter by items that are 3D, or not.
  ///@param seriesStatus Optional filter by Series Status. Allows multiple, comma delimited.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
  ///@param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
  ///@param enableTotalRecordCount Optional. Enable the total record count.
  ///@param enableImages Optional, include image information in output.
  @Get(path: '/Items')
  Future<chopper.Response<BaseItemDtoQueryResult>> _itemsGet({
    @Query('userId') String? userId,
    @Query('maxOfficialRating') String? maxOfficialRating,
    @Query('hasThemeSong') bool? hasThemeSong,
    @Query('hasThemeVideo') bool? hasThemeVideo,
    @Query('hasSubtitles') bool? hasSubtitles,
    @Query('hasSpecialFeature') bool? hasSpecialFeature,
    @Query('hasTrailer') bool? hasTrailer,
    @Query('adjacentTo') String? adjacentTo,
    @Query('indexNumber') int? indexNumber,
    @Query('parentIndexNumber') int? parentIndexNumber,
    @Query('hasParentalRating') bool? hasParentalRating,
    @Query('isHd') bool? isHd,
    @Query('is4K') bool? is4K,
    @Query('locationTypes') List<Object?>? locationTypes,
    @Query('excludeLocationTypes') List<Object?>? excludeLocationTypes,
    @Query('isMissing') bool? isMissing,
    @Query('isUnaired') bool? isUnaired,
    @Query('minCommunityRating') num? minCommunityRating,
    @Query('minCriticRating') num? minCriticRating,
    @Query('minPremiereDate') DateTime? minPremiereDate,
    @Query('minDateLastSaved') DateTime? minDateLastSaved,
    @Query('minDateLastSavedForUser') DateTime? minDateLastSavedForUser,
    @Query('maxPremiereDate') DateTime? maxPremiereDate,
    @Query('hasOverview') bool? hasOverview,
    @Query('hasImdbId') bool? hasImdbId,
    @Query('hasTmdbId') bool? hasTmdbId,
    @Query('hasTvdbId') bool? hasTvdbId,
    @Query('isMovie') bool? isMovie,
    @Query('isSeries') bool? isSeries,
    @Query('isNews') bool? isNews,
    @Query('isKids') bool? isKids,
    @Query('isSports') bool? isSports,
    @Query('excludeItemIds') List<String>? excludeItemIds,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('recursive') bool? recursive,
    @Query('searchTerm') String? searchTerm,
    @Query('sortOrder') List<Object?>? sortOrder,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('filters') List<Object?>? filters,
    @Query('isFavorite') bool? isFavorite,
    @Query('mediaTypes') List<Object?>? mediaTypes,
    @Query('imageTypes') List<Object?>? imageTypes,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('isPlayed') bool? isPlayed,
    @Query('genres') List<String>? genres,
    @Query('officialRatings') List<String>? officialRatings,
    @Query('tags') List<String>? tags,
    @Query('years') List<int>? years,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('person') String? person,
    @Query('personIds') List<String>? personIds,
    @Query('personTypes') List<String>? personTypes,
    @Query('studios') List<String>? studios,
    @Query('artists') List<String>? artists,
    @Query('excludeArtistIds') List<String>? excludeArtistIds,
    @Query('artistIds') List<String>? artistIds,
    @Query('albumArtistIds') List<String>? albumArtistIds,
    @Query('contributingArtistIds') List<String>? contributingArtistIds,
    @Query('albums') List<String>? albums,
    @Query('albumIds') List<String>? albumIds,
    @Query('ids') List<String>? ids,
    @Query('videoTypes') List<Object?>? videoTypes,
    @Query('minOfficialRating') String? minOfficialRating,
    @Query('isLocked') bool? isLocked,
    @Query('isPlaceHolder') bool? isPlaceHolder,
    @Query('hasOfficialRating') bool? hasOfficialRating,
    @Query('collapseBoxSetItems') bool? collapseBoxSetItems,
    @Query('minWidth') int? minWidth,
    @Query('minHeight') int? minHeight,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('is3D') bool? is3D,
    @Query('seriesStatus') List<Object?>? seriesStatus,
    @Query('nameStartsWithOrGreater') String? nameStartsWithOrGreater,
    @Query('nameStartsWith') String? nameStartsWith,
    @Query('nameLessThan') String? nameLessThan,
    @Query('studioIds') List<String>? studioIds,
    @Query('genreIds') List<String>? genreIds,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
    @Query('enableImages') bool? enableImages,
  });

  ///Deletes items from the library and filesystem.
  ///@param ids The item ids.
  Future<chopper.Response> itemsDelete({List<String>? ids}) {
    return _itemsDelete(ids: ids);
  }

  ///Deletes items from the library and filesystem.
  ///@param ids The item ids.
  @Delete(path: '/Items')
  Future<chopper.Response> _itemsDelete({@Query('ids') List<String>? ids});

  ///Get Item User Data.
  ///@param userId The user id.
  ///@param itemId The item id.
  Future<chopper.Response<UserItemDataDto>> userItemsItemIdUserDataGet({
    String? userId,
    required String? itemId,
  }) {
    generatedMapping.putIfAbsent(
        UserItemDataDto, () => UserItemDataDto.fromJsonFactory);

    return _userItemsItemIdUserDataGet(userId: userId, itemId: itemId);
  }

  ///Get Item User Data.
  ///@param userId The user id.
  ///@param itemId The item id.
  @Get(path: '/UserItems/{itemId}/UserData')
  Future<chopper.Response<UserItemDataDto>> _userItemsItemIdUserDataGet({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
  });

  ///Update Item User Data.
  ///@param userId The user id.
  ///@param itemId The item id.
  Future<chopper.Response<UserItemDataDto>> userItemsItemIdUserDataPost({
    String? userId,
    required String? itemId,
    required UpdateUserItemDataDto? body,
  }) {
    generatedMapping.putIfAbsent(
        UserItemDataDto, () => UserItemDataDto.fromJsonFactory);

    return _userItemsItemIdUserDataPost(
        userId: userId, itemId: itemId, body: body);
  }

  ///Update Item User Data.
  ///@param userId The user id.
  ///@param itemId The item id.
  @Post(
    path: '/UserItems/{itemId}/UserData',
    optionalBody: true,
  )
  Future<chopper.Response<UserItemDataDto>> _userItemsItemIdUserDataPost({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
    @Body() required UpdateUserItemDataDto? body,
  });

  ///Gets items based on a query.
  ///@param userId The user id.
  ///@param startIndex The start index.
  ///@param limit The item limit.
  ///@param searchTerm The search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
  ///@param mediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
  ///@param enableTotalRecordCount Optional. Enable the total record count.
  ///@param enableImages Optional. Include image information in output.
  ///@param excludeActiveSessions Optional. Whether to exclude the currently active sessions.
  Future<chopper.Response<BaseItemDtoQueryResult>> userItemsResumeGet({
    String? userId,
    int? startIndex,
    int? limit,
    String? searchTerm,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.MediaType>? mediaTypes,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.BaseItemKind>? includeItemTypes,
    bool? enableTotalRecordCount,
    bool? enableImages,
    bool? excludeActiveSessions,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _userItemsResumeGet(
        userId: userId,
        startIndex: startIndex,
        limit: limit,
        searchTerm: searchTerm,
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        mediaTypes: mediaTypeListToJson(mediaTypes),
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        enableTotalRecordCount: enableTotalRecordCount,
        enableImages: enableImages,
        excludeActiveSessions: excludeActiveSessions);
  }

  ///Gets items based on a query.
  ///@param userId The user id.
  ///@param startIndex The start index.
  ///@param limit The item limit.
  ///@param searchTerm The search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
  ///@param mediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
  ///@param enableTotalRecordCount Optional. Enable the total record count.
  ///@param enableImages Optional. Include image information in output.
  ///@param excludeActiveSessions Optional. Whether to exclude the currently active sessions.
  @Get(path: '/UserItems/Resume')
  Future<chopper.Response<BaseItemDtoQueryResult>> _userItemsResumeGet({
    @Query('userId') String? userId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('searchTerm') String? searchTerm,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('mediaTypes') List<Object?>? mediaTypes,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
    @Query('enableImages') bool? enableImages,
    @Query('excludeActiveSessions') bool? excludeActiveSessions,
  });

  ///Updates an item.
  ///@param itemId The item id.
  Future<chopper.Response> itemsItemIdPost({
    required String? itemId,
    required BaseItemDto? body,
  }) {
    return _itemsItemIdPost(itemId: itemId, body: body);
  }

  ///Updates an item.
  ///@param itemId The item id.
  @Post(
    path: '/Items/{itemId}',
    optionalBody: true,
  )
  Future<chopper.Response> _itemsItemIdPost({
    @Path('itemId') required String? itemId,
    @Body() required BaseItemDto? body,
  });

  ///Deletes an item from the library and filesystem.
  ///@param itemId The item id.
  Future<chopper.Response> itemsItemIdDelete({required String? itemId}) {
    return _itemsItemIdDelete(itemId: itemId);
  }

  ///Deletes an item from the library and filesystem.
  ///@param itemId The item id.
  @Delete(path: '/Items/{itemId}')
  Future<chopper.Response> _itemsItemIdDelete(
      {@Path('itemId') required String? itemId});

  ///Gets an item from a user's library.
  ///@param userId User id.
  ///@param itemId Item id.
  Future<chopper.Response<BaseItemDto>> itemsItemIdGet({
    String? userId,
    required String? itemId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _itemsItemIdGet(userId: userId, itemId: itemId);
  }

  ///Gets an item from a user's library.
  ///@param userId User id.
  ///@param itemId Item id.
  @Get(path: '/Items/{itemId}')
  Future<chopper.Response<BaseItemDto>> _itemsItemIdGet({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
  });

  ///Updates an item's content type.
  ///@param itemId The item id.
  ///@param contentType The content type of the item.
  Future<chopper.Response> itemsItemIdContentTypePost({
    required String? itemId,
    String? contentType,
  }) {
    return _itemsItemIdContentTypePost(
        itemId: itemId, contentType: contentType);
  }

  ///Updates an item's content type.
  ///@param itemId The item id.
  ///@param contentType The content type of the item.
  @Post(
    path: '/Items/{itemId}/ContentType',
    optionalBody: true,
  )
  Future<chopper.Response> _itemsItemIdContentTypePost({
    @Path('itemId') required String? itemId,
    @Query('contentType') String? contentType,
  });

  ///Gets metadata editor info for an item.
  ///@param itemId The item id.
  Future<chopper.Response<MetadataEditorInfo>> itemsItemIdMetadataEditorGet(
      {required String? itemId}) {
    generatedMapping.putIfAbsent(
        MetadataEditorInfo, () => MetadataEditorInfo.fromJsonFactory);

    return _itemsItemIdMetadataEditorGet(itemId: itemId);
  }

  ///Gets metadata editor info for an item.
  ///@param itemId The item id.
  @Get(path: '/Items/{itemId}/MetadataEditor')
  Future<chopper.Response<MetadataEditorInfo>> _itemsItemIdMetadataEditorGet(
      {@Path('itemId') required String? itemId});

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  Future<chopper.Response<BaseItemDtoQueryResult>> albumsItemIdSimilarGet({
    required String? itemId,
    List<String>? excludeArtistIds,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _albumsItemIdSimilarGet(
        itemId: itemId,
        excludeArtistIds: excludeArtistIds,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields));
  }

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  @Get(path: '/Albums/{itemId}/Similar')
  Future<chopper.Response<BaseItemDtoQueryResult>> _albumsItemIdSimilarGet({
    @Path('itemId') required String? itemId,
    @Query('excludeArtistIds') List<String>? excludeArtistIds,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
  });

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  Future<chopper.Response<BaseItemDtoQueryResult>> artistsItemIdSimilarGet({
    required String? itemId,
    List<String>? excludeArtistIds,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _artistsItemIdSimilarGet(
        itemId: itemId,
        excludeArtistIds: excludeArtistIds,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields));
  }

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  @Get(path: '/Artists/{itemId}/Similar')
  Future<chopper.Response<BaseItemDtoQueryResult>> _artistsItemIdSimilarGet({
    @Path('itemId') required String? itemId,
    @Query('excludeArtistIds') List<String>? excludeArtistIds,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
  });

  ///Gets all parents of an item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  Future<chopper.Response<List<BaseItemDto>>> itemsItemIdAncestorsGet({
    required String? itemId,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _itemsItemIdAncestorsGet(itemId: itemId, userId: userId);
  }

  ///Gets all parents of an item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  @Get(path: '/Items/{itemId}/Ancestors')
  Future<chopper.Response<List<BaseItemDto>>> _itemsItemIdAncestorsGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
  });

  ///Gets critic review for an item.
  ///@param itemId
  @deprecated
  Future<chopper.Response<BaseItemDtoQueryResult>> itemsItemIdCriticReviewsGet(
      {required String? itemId}) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _itemsItemIdCriticReviewsGet(itemId: itemId);
  }

  ///Gets critic review for an item.
  ///@param itemId
  @deprecated
  @Get(path: '/Items/{itemId}/CriticReviews')
  Future<chopper.Response<BaseItemDtoQueryResult>> _itemsItemIdCriticReviewsGet(
      {@Path('itemId') required String? itemId});

  ///Downloads item media.
  ///@param itemId The item id.
  Future<chopper.Response<String>> itemsItemIdDownloadGet(
      {required String? itemId}) {
    return _itemsItemIdDownloadGet(itemId: itemId);
  }

  ///Downloads item media.
  ///@param itemId The item id.
  @Get(path: '/Items/{itemId}/Download')
  Future<chopper.Response<String>> _itemsItemIdDownloadGet(
      {@Path('itemId') required String? itemId});

  ///Get the original file of an item.
  ///@param itemId The item id.
  Future<chopper.Response<String>> itemsItemIdFileGet(
      {required String? itemId}) {
    return _itemsItemIdFileGet(itemId: itemId);
  }

  ///Get the original file of an item.
  ///@param itemId The item id.
  @Get(path: '/Items/{itemId}/File')
  Future<chopper.Response<String>> _itemsItemIdFileGet(
      {@Path('itemId') required String? itemId});

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  Future<chopper.Response<BaseItemDtoQueryResult>> itemsItemIdSimilarGet({
    required String? itemId,
    List<String>? excludeArtistIds,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _itemsItemIdSimilarGet(
        itemId: itemId,
        excludeArtistIds: excludeArtistIds,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields));
  }

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  @Get(path: '/Items/{itemId}/Similar')
  Future<chopper.Response<BaseItemDtoQueryResult>> _itemsItemIdSimilarGet({
    @Path('itemId') required String? itemId,
    @Query('excludeArtistIds') List<String>? excludeArtistIds,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
  });

  ///Get theme songs and videos for an item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param inheritFromParent Optional. Determines whether or not parent items should be searched for theme media.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param sortOrder Optional. Sort Order - Ascending, Descending.
  Future<chopper.Response<AllThemeMediaResult>> itemsItemIdThemeMediaGet({
    required String? itemId,
    String? userId,
    bool? inheritFromParent,
    List<enums.ItemSortBy>? sortBy,
    List<enums.SortOrder>? sortOrder,
  }) {
    generatedMapping.putIfAbsent(
        AllThemeMediaResult, () => AllThemeMediaResult.fromJsonFactory);

    return _itemsItemIdThemeMediaGet(
        itemId: itemId,
        userId: userId,
        inheritFromParent: inheritFromParent,
        sortBy: itemSortByListToJson(sortBy),
        sortOrder: sortOrderListToJson(sortOrder));
  }

  ///Get theme songs and videos for an item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param inheritFromParent Optional. Determines whether or not parent items should be searched for theme media.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param sortOrder Optional. Sort Order - Ascending, Descending.
  @Get(path: '/Items/{itemId}/ThemeMedia')
  Future<chopper.Response<AllThemeMediaResult>> _itemsItemIdThemeMediaGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
    @Query('inheritFromParent') bool? inheritFromParent,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('sortOrder') List<Object?>? sortOrder,
  });

  ///Get theme songs for an item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param inheritFromParent Optional. Determines whether or not parent items should be searched for theme media.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param sortOrder Optional. Sort Order - Ascending, Descending.
  Future<chopper.Response<ThemeMediaResult>> itemsItemIdThemeSongsGet({
    required String? itemId,
    String? userId,
    bool? inheritFromParent,
    List<enums.ItemSortBy>? sortBy,
    List<enums.SortOrder>? sortOrder,
  }) {
    generatedMapping.putIfAbsent(
        ThemeMediaResult, () => ThemeMediaResult.fromJsonFactory);

    return _itemsItemIdThemeSongsGet(
        itemId: itemId,
        userId: userId,
        inheritFromParent: inheritFromParent,
        sortBy: itemSortByListToJson(sortBy),
        sortOrder: sortOrderListToJson(sortOrder));
  }

  ///Get theme songs for an item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param inheritFromParent Optional. Determines whether or not parent items should be searched for theme media.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param sortOrder Optional. Sort Order - Ascending, Descending.
  @Get(path: '/Items/{itemId}/ThemeSongs')
  Future<chopper.Response<ThemeMediaResult>> _itemsItemIdThemeSongsGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
    @Query('inheritFromParent') bool? inheritFromParent,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('sortOrder') List<Object?>? sortOrder,
  });

  ///Get theme videos for an item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param inheritFromParent Optional. Determines whether or not parent items should be searched for theme media.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param sortOrder Optional. Sort Order - Ascending, Descending.
  Future<chopper.Response<ThemeMediaResult>> itemsItemIdThemeVideosGet({
    required String? itemId,
    String? userId,
    bool? inheritFromParent,
    List<enums.ItemSortBy>? sortBy,
    List<enums.SortOrder>? sortOrder,
  }) {
    generatedMapping.putIfAbsent(
        ThemeMediaResult, () => ThemeMediaResult.fromJsonFactory);

    return _itemsItemIdThemeVideosGet(
        itemId: itemId,
        userId: userId,
        inheritFromParent: inheritFromParent,
        sortBy: itemSortByListToJson(sortBy),
        sortOrder: sortOrderListToJson(sortOrder));
  }

  ///Get theme videos for an item.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param inheritFromParent Optional. Determines whether or not parent items should be searched for theme media.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param sortOrder Optional. Sort Order - Ascending, Descending.
  @Get(path: '/Items/{itemId}/ThemeVideos')
  Future<chopper.Response<ThemeMediaResult>> _itemsItemIdThemeVideosGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
    @Query('inheritFromParent') bool? inheritFromParent,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('sortOrder') List<Object?>? sortOrder,
  });

  ///Get item counts.
  ///@param userId Optional. Get counts from a specific user's library.
  ///@param isFavorite Optional. Get counts of favorite items.
  Future<chopper.Response<ItemCounts>> itemsCountsGet({
    String? userId,
    bool? isFavorite,
  }) {
    generatedMapping.putIfAbsent(ItemCounts, () => ItemCounts.fromJsonFactory);

    return _itemsCountsGet(userId: userId, isFavorite: isFavorite);
  }

  ///Get item counts.
  ///@param userId Optional. Get counts from a specific user's library.
  ///@param isFavorite Optional. Get counts of favorite items.
  @Get(path: '/Items/Counts')
  Future<chopper.Response<ItemCounts>> _itemsCountsGet({
    @Query('userId') String? userId,
    @Query('isFavorite') bool? isFavorite,
  });

  ///Gets the library options info.
  ///@param libraryContentType Library content type.
  ///@param isNewLibrary Whether this is a new library.
  Future<chopper.Response<LibraryOptionsResultDto>>
      librariesAvailableOptionsGet({
    enums.LibrariesAvailableOptionsGetLibraryContentType? libraryContentType,
    bool? isNewLibrary,
  }) {
    generatedMapping.putIfAbsent(
        LibraryOptionsResultDto, () => LibraryOptionsResultDto.fromJsonFactory);

    return _librariesAvailableOptionsGet(
        libraryContentType: libraryContentType?.value?.toString(),
        isNewLibrary: isNewLibrary);
  }

  ///Gets the library options info.
  ///@param libraryContentType Library content type.
  ///@param isNewLibrary Whether this is a new library.
  @Get(path: '/Libraries/AvailableOptions')
  Future<chopper.Response<LibraryOptionsResultDto>>
      _librariesAvailableOptionsGet({
    @Query('libraryContentType') String? libraryContentType,
    @Query('isNewLibrary') bool? isNewLibrary,
  });

  ///Reports that new movies have been added by an external source.
  Future<chopper.Response> libraryMediaUpdatedPost(
      {required MediaUpdateInfoDto? body}) {
    return _libraryMediaUpdatedPost(body: body);
  }

  ///Reports that new movies have been added by an external source.
  @Post(
    path: '/Library/Media/Updated',
    optionalBody: true,
  )
  Future<chopper.Response> _libraryMediaUpdatedPost(
      {@Body() required MediaUpdateInfoDto? body});

  ///Gets all user media folders.
  ///@param isHidden Optional. Filter by folders that are marked hidden, or not.
  Future<chopper.Response<BaseItemDtoQueryResult>> libraryMediaFoldersGet(
      {bool? isHidden}) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _libraryMediaFoldersGet(isHidden: isHidden);
  }

  ///Gets all user media folders.
  ///@param isHidden Optional. Filter by folders that are marked hidden, or not.
  @Get(path: '/Library/MediaFolders')
  Future<chopper.Response<BaseItemDtoQueryResult>> _libraryMediaFoldersGet(
      {@Query('isHidden') bool? isHidden});

  ///Reports that new movies have been added by an external source.
  ///@param tmdbId The tmdbId.
  ///@param imdbId The imdbId.
  Future<chopper.Response> libraryMoviesAddedPost({
    String? tmdbId,
    String? imdbId,
  }) {
    return _libraryMoviesAddedPost(tmdbId: tmdbId, imdbId: imdbId);
  }

  ///Reports that new movies have been added by an external source.
  ///@param tmdbId The tmdbId.
  ///@param imdbId The imdbId.
  @Post(
    path: '/Library/Movies/Added',
    optionalBody: true,
  )
  Future<chopper.Response> _libraryMoviesAddedPost({
    @Query('tmdbId') String? tmdbId,
    @Query('imdbId') String? imdbId,
  });

  ///Reports that new movies have been added by an external source.
  ///@param tmdbId The tmdbId.
  ///@param imdbId The imdbId.
  Future<chopper.Response> libraryMoviesUpdatedPost({
    String? tmdbId,
    String? imdbId,
  }) {
    return _libraryMoviesUpdatedPost(tmdbId: tmdbId, imdbId: imdbId);
  }

  ///Reports that new movies have been added by an external source.
  ///@param tmdbId The tmdbId.
  ///@param imdbId The imdbId.
  @Post(
    path: '/Library/Movies/Updated',
    optionalBody: true,
  )
  Future<chopper.Response> _libraryMoviesUpdatedPost({
    @Query('tmdbId') String? tmdbId,
    @Query('imdbId') String? imdbId,
  });

  ///Gets a list of physical paths from virtual folders.
  Future<chopper.Response<List<String>>> libraryPhysicalPathsGet() {
    return _libraryPhysicalPathsGet();
  }

  ///Gets a list of physical paths from virtual folders.
  @Get(path: '/Library/PhysicalPaths')
  Future<chopper.Response<List<String>>> _libraryPhysicalPathsGet();

  ///Starts a library scan.
  Future<chopper.Response> libraryRefreshPost() {
    return _libraryRefreshPost();
  }

  ///Starts a library scan.
  @Post(
    path: '/Library/Refresh',
    optionalBody: true,
  )
  Future<chopper.Response> _libraryRefreshPost();

  ///Reports that new episodes of a series have been added by an external source.
  ///@param tvdbId The tvdbId.
  Future<chopper.Response> librarySeriesAddedPost({String? tvdbId}) {
    return _librarySeriesAddedPost(tvdbId: tvdbId);
  }

  ///Reports that new episodes of a series have been added by an external source.
  ///@param tvdbId The tvdbId.
  @Post(
    path: '/Library/Series/Added',
    optionalBody: true,
  )
  Future<chopper.Response> _librarySeriesAddedPost(
      {@Query('tvdbId') String? tvdbId});

  ///Reports that new episodes of a series have been added by an external source.
  ///@param tvdbId The tvdbId.
  Future<chopper.Response> librarySeriesUpdatedPost({String? tvdbId}) {
    return _librarySeriesUpdatedPost(tvdbId: tvdbId);
  }

  ///Reports that new episodes of a series have been added by an external source.
  ///@param tvdbId The tvdbId.
  @Post(
    path: '/Library/Series/Updated',
    optionalBody: true,
  )
  Future<chopper.Response> _librarySeriesUpdatedPost(
      {@Query('tvdbId') String? tvdbId});

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  Future<chopper.Response<BaseItemDtoQueryResult>> moviesItemIdSimilarGet({
    required String? itemId,
    List<String>? excludeArtistIds,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _moviesItemIdSimilarGet(
        itemId: itemId,
        excludeArtistIds: excludeArtistIds,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields));
  }

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  @Get(path: '/Movies/{itemId}/Similar')
  Future<chopper.Response<BaseItemDtoQueryResult>> _moviesItemIdSimilarGet({
    @Path('itemId') required String? itemId,
    @Query('excludeArtistIds') List<String>? excludeArtistIds,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
  });

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  Future<chopper.Response<BaseItemDtoQueryResult>> showsItemIdSimilarGet({
    required String? itemId,
    List<String>? excludeArtistIds,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _showsItemIdSimilarGet(
        itemId: itemId,
        excludeArtistIds: excludeArtistIds,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields));
  }

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  @Get(path: '/Shows/{itemId}/Similar')
  Future<chopper.Response<BaseItemDtoQueryResult>> _showsItemIdSimilarGet({
    @Path('itemId') required String? itemId,
    @Query('excludeArtistIds') List<String>? excludeArtistIds,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
  });

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  Future<chopper.Response<BaseItemDtoQueryResult>> trailersItemIdSimilarGet({
    required String? itemId,
    List<String>? excludeArtistIds,
    String? userId,
    int? limit,
    List<enums.ItemFields>? fields,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _trailersItemIdSimilarGet(
        itemId: itemId,
        excludeArtistIds: excludeArtistIds,
        userId: userId,
        limit: limit,
        fields: itemFieldsListToJson(fields));
  }

  ///Gets similar items.
  ///@param itemId The item id.
  ///@param excludeArtistIds Exclude artist ids.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  @Get(path: '/Trailers/{itemId}/Similar')
  Future<chopper.Response<BaseItemDtoQueryResult>> _trailersItemIdSimilarGet({
    @Path('itemId') required String? itemId,
    @Query('excludeArtistIds') List<String>? excludeArtistIds,
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
  });

  ///Gets all virtual folders.
  Future<chopper.Response<List<VirtualFolderInfo>>> libraryVirtualFoldersGet() {
    generatedMapping.putIfAbsent(
        VirtualFolderInfo, () => VirtualFolderInfo.fromJsonFactory);

    return _libraryVirtualFoldersGet();
  }

  ///Gets all virtual folders.
  @Get(path: '/Library/VirtualFolders')
  Future<chopper.Response<List<VirtualFolderInfo>>> _libraryVirtualFoldersGet();

  ///Adds a virtual folder.
  ///@param name The name of the virtual folder.
  ///@param collectionType The type of the collection.
  ///@param paths The paths of the virtual folder.
  ///@param refreshLibrary Whether to refresh the library.
  Future<chopper.Response> libraryVirtualFoldersPost({
    String? name,
    enums.LibraryVirtualFoldersPostCollectionType? collectionType,
    List<String>? paths,
    bool? refreshLibrary,
    required AddVirtualFolderDto? body,
  }) {
    return _libraryVirtualFoldersPost(
        name: name,
        collectionType: collectionType?.value?.toString(),
        paths: paths,
        refreshLibrary: refreshLibrary,
        body: body);
  }

  ///Adds a virtual folder.
  ///@param name The name of the virtual folder.
  ///@param collectionType The type of the collection.
  ///@param paths The paths of the virtual folder.
  ///@param refreshLibrary Whether to refresh the library.
  @Post(
    path: '/Library/VirtualFolders',
    optionalBody: true,
  )
  Future<chopper.Response> _libraryVirtualFoldersPost({
    @Query('name') String? name,
    @Query('collectionType') String? collectionType,
    @Query('paths') List<String>? paths,
    @Query('refreshLibrary') bool? refreshLibrary,
    @Body() required AddVirtualFolderDto? body,
  });

  ///Removes a virtual folder.
  ///@param name The name of the folder.
  ///@param refreshLibrary Whether to refresh the library.
  Future<chopper.Response> libraryVirtualFoldersDelete({
    String? name,
    bool? refreshLibrary,
  }) {
    return _libraryVirtualFoldersDelete(
        name: name, refreshLibrary: refreshLibrary);
  }

  ///Removes a virtual folder.
  ///@param name The name of the folder.
  ///@param refreshLibrary Whether to refresh the library.
  @Delete(path: '/Library/VirtualFolders')
  Future<chopper.Response> _libraryVirtualFoldersDelete({
    @Query('name') String? name,
    @Query('refreshLibrary') bool? refreshLibrary,
  });

  ///Update library options.
  Future<chopper.Response> libraryVirtualFoldersLibraryOptionsPost(
      {required UpdateLibraryOptionsDto? body}) {
    return _libraryVirtualFoldersLibraryOptionsPost(body: body);
  }

  ///Update library options.
  @Post(
    path: '/Library/VirtualFolders/LibraryOptions',
    optionalBody: true,
  )
  Future<chopper.Response> _libraryVirtualFoldersLibraryOptionsPost(
      {@Body() required UpdateLibraryOptionsDto? body});

  ///Renames a virtual folder.
  ///@param name The name of the virtual folder.
  ///@param newName The new name.
  ///@param refreshLibrary Whether to refresh the library.
  Future<chopper.Response> libraryVirtualFoldersNamePost({
    String? name,
    String? newName,
    bool? refreshLibrary,
  }) {
    return _libraryVirtualFoldersNamePost(
        name: name, newName: newName, refreshLibrary: refreshLibrary);
  }

  ///Renames a virtual folder.
  ///@param name The name of the virtual folder.
  ///@param newName The new name.
  ///@param refreshLibrary Whether to refresh the library.
  @Post(
    path: '/Library/VirtualFolders/Name',
    optionalBody: true,
  )
  Future<chopper.Response> _libraryVirtualFoldersNamePost({
    @Query('name') String? name,
    @Query('newName') String? newName,
    @Query('refreshLibrary') bool? refreshLibrary,
  });

  ///Add a media path to a library.
  ///@param refreshLibrary Whether to refresh the library.
  Future<chopper.Response> libraryVirtualFoldersPathsPost({
    bool? refreshLibrary,
    required MediaPathDto? body,
  }) {
    return _libraryVirtualFoldersPathsPost(
        refreshLibrary: refreshLibrary, body: body);
  }

  ///Add a media path to a library.
  ///@param refreshLibrary Whether to refresh the library.
  @Post(
    path: '/Library/VirtualFolders/Paths',
    optionalBody: true,
  )
  Future<chopper.Response> _libraryVirtualFoldersPathsPost({
    @Query('refreshLibrary') bool? refreshLibrary,
    @Body() required MediaPathDto? body,
  });

  ///Remove a media path.
  ///@param name The name of the library.
  ///@param path The path to remove.
  ///@param refreshLibrary Whether to refresh the library.
  Future<chopper.Response> libraryVirtualFoldersPathsDelete({
    String? name,
    String? path,
    bool? refreshLibrary,
  }) {
    return _libraryVirtualFoldersPathsDelete(
        name: name, path: path, refreshLibrary: refreshLibrary);
  }

  ///Remove a media path.
  ///@param name The name of the library.
  ///@param path The path to remove.
  ///@param refreshLibrary Whether to refresh the library.
  @Delete(path: '/Library/VirtualFolders/Paths')
  Future<chopper.Response> _libraryVirtualFoldersPathsDelete({
    @Query('name') String? name,
    @Query('path') String? path,
    @Query('refreshLibrary') bool? refreshLibrary,
  });

  ///Updates a media path.
  Future<chopper.Response> libraryVirtualFoldersPathsUpdatePost(
      {required UpdateMediaPathRequestDto? body}) {
    return _libraryVirtualFoldersPathsUpdatePost(body: body);
  }

  ///Updates a media path.
  @Post(
    path: '/Library/VirtualFolders/Paths/Update',
    optionalBody: true,
  )
  Future<chopper.Response> _libraryVirtualFoldersPathsUpdatePost(
      {@Body() required UpdateMediaPathRequestDto? body});

  ///Get channel mapping options.
  ///@param providerId Provider id.
  Future<chopper.Response<ChannelMappingOptionsDto>>
      liveTvChannelMappingOptionsGet({String? providerId}) {
    generatedMapping.putIfAbsent(ChannelMappingOptionsDto,
        () => ChannelMappingOptionsDto.fromJsonFactory);

    return _liveTvChannelMappingOptionsGet(providerId: providerId);
  }

  ///Get channel mapping options.
  ///@param providerId Provider id.
  @Get(path: '/LiveTv/ChannelMappingOptions')
  Future<chopper.Response<ChannelMappingOptionsDto>>
      _liveTvChannelMappingOptionsGet(
          {@Query('providerId') String? providerId});

  ///Set channel mappings.
  Future<chopper.Response<TunerChannelMapping>> liveTvChannelMappingsPost(
      {required SetChannelMappingDto? body}) {
    generatedMapping.putIfAbsent(
        TunerChannelMapping, () => TunerChannelMapping.fromJsonFactory);

    return _liveTvChannelMappingsPost(body: body);
  }

  ///Set channel mappings.
  @Post(
    path: '/LiveTv/ChannelMappings',
    optionalBody: true,
  )
  Future<chopper.Response<TunerChannelMapping>> _liveTvChannelMappingsPost(
      {@Body() required SetChannelMappingDto? body});

  ///Gets available live tv channels.
  ///@param type Optional. Filter by channel type.
  ///@param userId Optional. Filter by user and attach user data.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param isMovie Optional. Filter for movies.
  ///@param isSeries Optional. Filter for series.
  ///@param isNews Optional. Filter for news.
  ///@param isKids Optional. Filter for kids.
  ///@param isSports Optional. Filter for sports.
  ///@param limit Optional. The maximum number of records to return.
  ///@param isFavorite Optional. Filter by channels that are favorites, or not.
  ///@param isLiked Optional. Filter by channels that are liked, or not.
  ///@param isDisliked Optional. Filter by channels that are disliked, or not.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes "Optional. The image types to include in the output.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param sortBy Optional. Key to sort by.
  ///@param sortOrder Optional. Sort order.
  ///@param enableFavoriteSorting Optional. Incorporate favorite and like status into channel sorting.
  ///@param addCurrentProgram Optional. Adds current program info to each channel.
  Future<chopper.Response<BaseItemDtoQueryResult>> liveTvChannelsGet({
    enums.LiveTvChannelsGetType? type,
    String? userId,
    int? startIndex,
    bool? isMovie,
    bool? isSeries,
    bool? isNews,
    bool? isKids,
    bool? isSports,
    int? limit,
    bool? isFavorite,
    bool? isLiked,
    bool? isDisliked,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    List<enums.ItemFields>? fields,
    bool? enableUserData,
    List<enums.ItemSortBy>? sortBy,
    enums.LiveTvChannelsGetSortOrder? sortOrder,
    bool? enableFavoriteSorting,
    bool? addCurrentProgram,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _liveTvChannelsGet(
        type: type?.value?.toString(),
        userId: userId,
        startIndex: startIndex,
        isMovie: isMovie,
        isSeries: isSeries,
        isNews: isNews,
        isKids: isKids,
        isSports: isSports,
        limit: limit,
        isFavorite: isFavorite,
        isLiked: isLiked,
        isDisliked: isDisliked,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        fields: itemFieldsListToJson(fields),
        enableUserData: enableUserData,
        sortBy: itemSortByListToJson(sortBy),
        sortOrder: sortOrder?.value?.toString(),
        enableFavoriteSorting: enableFavoriteSorting,
        addCurrentProgram: addCurrentProgram);
  }

  ///Gets available live tv channels.
  ///@param type Optional. Filter by channel type.
  ///@param userId Optional. Filter by user and attach user data.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param isMovie Optional. Filter for movies.
  ///@param isSeries Optional. Filter for series.
  ///@param isNews Optional. Filter for news.
  ///@param isKids Optional. Filter for kids.
  ///@param isSports Optional. Filter for sports.
  ///@param limit Optional. The maximum number of records to return.
  ///@param isFavorite Optional. Filter by channels that are favorites, or not.
  ///@param isLiked Optional. Filter by channels that are liked, or not.
  ///@param isDisliked Optional. Filter by channels that are disliked, or not.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes "Optional. The image types to include in the output.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param sortBy Optional. Key to sort by.
  ///@param sortOrder Optional. Sort order.
  ///@param enableFavoriteSorting Optional. Incorporate favorite and like status into channel sorting.
  ///@param addCurrentProgram Optional. Adds current program info to each channel.
  @Get(path: '/LiveTv/Channels')
  Future<chopper.Response<BaseItemDtoQueryResult>> _liveTvChannelsGet({
    @Query('type') String? type,
    @Query('userId') String? userId,
    @Query('startIndex') int? startIndex,
    @Query('isMovie') bool? isMovie,
    @Query('isSeries') bool? isSeries,
    @Query('isNews') bool? isNews,
    @Query('isKids') bool? isKids,
    @Query('isSports') bool? isSports,
    @Query('limit') int? limit,
    @Query('isFavorite') bool? isFavorite,
    @Query('isLiked') bool? isLiked,
    @Query('isDisliked') bool? isDisliked,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('fields') List<Object?>? fields,
    @Query('enableUserData') bool? enableUserData,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('sortOrder') String? sortOrder,
    @Query('enableFavoriteSorting') bool? enableFavoriteSorting,
    @Query('addCurrentProgram') bool? addCurrentProgram,
  });

  ///Gets a live tv channel.
  ///@param channelId Channel id.
  ///@param userId Optional. Attach user data.
  Future<chopper.Response<BaseItemDto>> liveTvChannelsChannelIdGet({
    required String? channelId,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _liveTvChannelsChannelIdGet(channelId: channelId, userId: userId);
  }

  ///Gets a live tv channel.
  ///@param channelId Channel id.
  ///@param userId Optional. Attach user data.
  @Get(path: '/LiveTv/Channels/{channelId}')
  Future<chopper.Response<BaseItemDto>> _liveTvChannelsChannelIdGet({
    @Path('channelId') required String? channelId,
    @Query('userId') String? userId,
  });

  ///Get guid info.
  Future<chopper.Response<GuideInfo>> liveTvGuideInfoGet() {
    generatedMapping.putIfAbsent(GuideInfo, () => GuideInfo.fromJsonFactory);

    return _liveTvGuideInfoGet();
  }

  ///Get guid info.
  @Get(path: '/LiveTv/GuideInfo')
  Future<chopper.Response<GuideInfo>> _liveTvGuideInfoGet();

  ///Gets available live tv services.
  Future<chopper.Response<LiveTvInfo>> liveTvInfoGet() {
    generatedMapping.putIfAbsent(LiveTvInfo, () => LiveTvInfo.fromJsonFactory);

    return _liveTvInfoGet();
  }

  ///Gets available live tv services.
  @Get(path: '/LiveTv/Info')
  Future<chopper.Response<LiveTvInfo>> _liveTvInfoGet();

  ///Adds a listings provider.
  ///@param pw Password.
  ///@param validateListings Validate listings.
  ///@param validateLogin Validate login.
  Future<chopper.Response<ListingsProviderInfo>> liveTvListingProvidersPost({
    String? pw,
    bool? validateListings,
    bool? validateLogin,
    required ListingsProviderInfo? body,
  }) {
    generatedMapping.putIfAbsent(
        ListingsProviderInfo, () => ListingsProviderInfo.fromJsonFactory);

    return _liveTvListingProvidersPost(
        pw: pw,
        validateListings: validateListings,
        validateLogin: validateLogin,
        body: body);
  }

  ///Adds a listings provider.
  ///@param pw Password.
  ///@param validateListings Validate listings.
  ///@param validateLogin Validate login.
  @Post(
    path: '/LiveTv/ListingProviders',
    optionalBody: true,
  )
  Future<chopper.Response<ListingsProviderInfo>> _liveTvListingProvidersPost({
    @Query('pw') String? pw,
    @Query('validateListings') bool? validateListings,
    @Query('validateLogin') bool? validateLogin,
    @Body() required ListingsProviderInfo? body,
  });

  ///Delete listing provider.
  ///@param id Listing provider id.
  Future<chopper.Response> liveTvListingProvidersDelete({String? id}) {
    return _liveTvListingProvidersDelete(id: id);
  }

  ///Delete listing provider.
  ///@param id Listing provider id.
  @Delete(path: '/LiveTv/ListingProviders')
  Future<chopper.Response> _liveTvListingProvidersDelete(
      {@Query('id') String? id});

  ///Gets default listings provider info.
  Future<chopper.Response<ListingsProviderInfo>>
      liveTvListingProvidersDefaultGet() {
    generatedMapping.putIfAbsent(
        ListingsProviderInfo, () => ListingsProviderInfo.fromJsonFactory);

    return _liveTvListingProvidersDefaultGet();
  }

  ///Gets default listings provider info.
  @Get(path: '/LiveTv/ListingProviders/Default')
  Future<chopper.Response<ListingsProviderInfo>>
      _liveTvListingProvidersDefaultGet();

  ///Gets available lineups.
  ///@param id Provider id.
  ///@param type Provider type.
  ///@param location Location.
  ///@param country Country.
  Future<chopper.Response<List<NameIdPair>>> liveTvListingProvidersLineupsGet({
    String? id,
    String? type,
    String? location,
    String? country,
  }) {
    generatedMapping.putIfAbsent(NameIdPair, () => NameIdPair.fromJsonFactory);

    return _liveTvListingProvidersLineupsGet(
        id: id, type: type, location: location, country: country);
  }

  ///Gets available lineups.
  ///@param id Provider id.
  ///@param type Provider type.
  ///@param location Location.
  ///@param country Country.
  @Get(path: '/LiveTv/ListingProviders/Lineups')
  Future<chopper.Response<List<NameIdPair>>> _liveTvListingProvidersLineupsGet({
    @Query('id') String? id,
    @Query('type') String? type,
    @Query('location') String? location,
    @Query('country') String? country,
  });

  ///Gets available countries.
  Future<chopper.Response<String>>
      liveTvListingProvidersSchedulesDirectCountriesGet() {
    return _liveTvListingProvidersSchedulesDirectCountriesGet();
  }

  ///Gets available countries.
  @Get(path: '/LiveTv/ListingProviders/SchedulesDirect/Countries')
  Future<chopper.Response<String>>
      _liveTvListingProvidersSchedulesDirectCountriesGet();

  ///Gets a live tv recording stream.
  ///@param recordingId Recording id.
  Future<chopper.Response<String>> liveTvLiveRecordingsRecordingIdStreamGet(
      {required String? recordingId}) {
    return _liveTvLiveRecordingsRecordingIdStreamGet(recordingId: recordingId);
  }

  ///Gets a live tv recording stream.
  ///@param recordingId Recording id.
  @Get(path: '/LiveTv/LiveRecordings/{recordingId}/stream')
  Future<chopper.Response<String>> _liveTvLiveRecordingsRecordingIdStreamGet(
      {@Path('recordingId') required String? recordingId});

  ///Gets a live tv channel stream.
  ///@param streamId Stream id.
  ///@param container Container type.
  Future<chopper.Response<String>>
      liveTvLiveStreamFilesStreamIdStreamContainerGet({
    required String? streamId,
    required String? container,
  }) {
    return _liveTvLiveStreamFilesStreamIdStreamContainerGet(
        streamId: streamId, container: container);
  }

  ///Gets a live tv channel stream.
  ///@param streamId Stream id.
  ///@param container Container type.
  @Get(path: '/LiveTv/LiveStreamFiles/{streamId}/stream.{container}')
  Future<chopper.Response<String>>
      _liveTvLiveStreamFilesStreamIdStreamContainerGet({
    @Path('streamId') required String? streamId,
    @Path('container') required String? container,
  });

  ///Gets available live tv epgs.
  ///@param channelIds The channels to return guide information for.
  ///@param userId Optional. Filter by user id.
  ///@param minStartDate Optional. The minimum premiere start date.
  ///@param hasAired Optional. Filter by programs that have completed airing, or not.
  ///@param isAiring Optional. Filter by programs that are currently airing, or not.
  ///@param maxStartDate Optional. The maximum premiere start date.
  ///@param minEndDate Optional. The minimum premiere end date.
  ///@param maxEndDate Optional. The maximum premiere end date.
  ///@param isMovie Optional. Filter for movies.
  ///@param isSeries Optional. Filter for series.
  ///@param isNews Optional. Filter for news.
  ///@param isKids Optional. Filter for kids.
  ///@param isSports Optional. Filter for sports.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param genres The genres to return guide information for.
  ///@param genreIds The genre ids to return guide information for.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param seriesTimerId Optional. Filter by series timer id.
  ///@param librarySeriesId Optional. Filter by library series id.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableTotalRecordCount Retrieve total record count.
  Future<chopper.Response<BaseItemDtoQueryResult>> liveTvProgramsGet({
    List<String>? channelIds,
    String? userId,
    DateTime? minStartDate,
    bool? hasAired,
    bool? isAiring,
    DateTime? maxStartDate,
    DateTime? minEndDate,
    DateTime? maxEndDate,
    bool? isMovie,
    bool? isSeries,
    bool? isNews,
    bool? isKids,
    bool? isSports,
    int? startIndex,
    int? limit,
    List<enums.ItemSortBy>? sortBy,
    List<enums.SortOrder>? sortOrder,
    List<String>? genres,
    List<String>? genreIds,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    bool? enableUserData,
    String? seriesTimerId,
    String? librarySeriesId,
    List<enums.ItemFields>? fields,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _liveTvProgramsGet(
        channelIds: channelIds,
        userId: userId,
        minStartDate: minStartDate,
        hasAired: hasAired,
        isAiring: isAiring,
        maxStartDate: maxStartDate,
        minEndDate: minEndDate,
        maxEndDate: maxEndDate,
        isMovie: isMovie,
        isSeries: isSeries,
        isNews: isNews,
        isKids: isKids,
        isSports: isSports,
        startIndex: startIndex,
        limit: limit,
        sortBy: itemSortByListToJson(sortBy),
        sortOrder: sortOrderListToJson(sortOrder),
        genres: genres,
        genreIds: genreIds,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        enableUserData: enableUserData,
        seriesTimerId: seriesTimerId,
        librarySeriesId: librarySeriesId,
        fields: itemFieldsListToJson(fields),
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets available live tv epgs.
  ///@param channelIds The channels to return guide information for.
  ///@param userId Optional. Filter by user id.
  ///@param minStartDate Optional. The minimum premiere start date.
  ///@param hasAired Optional. Filter by programs that have completed airing, or not.
  ///@param isAiring Optional. Filter by programs that are currently airing, or not.
  ///@param maxStartDate Optional. The maximum premiere start date.
  ///@param minEndDate Optional. The minimum premiere end date.
  ///@param maxEndDate Optional. The maximum premiere end date.
  ///@param isMovie Optional. Filter for movies.
  ///@param isSeries Optional. Filter for series.
  ///@param isNews Optional. Filter for news.
  ///@param isKids Optional. Filter for kids.
  ///@param isSports Optional. Filter for sports.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param genres The genres to return guide information for.
  ///@param genreIds The genre ids to return guide information for.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param seriesTimerId Optional. Filter by series timer id.
  ///@param librarySeriesId Optional. Filter by library series id.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableTotalRecordCount Retrieve total record count.
  @Get(path: '/LiveTv/Programs')
  Future<chopper.Response<BaseItemDtoQueryResult>> _liveTvProgramsGet({
    @Query('channelIds') List<String>? channelIds,
    @Query('userId') String? userId,
    @Query('minStartDate') DateTime? minStartDate,
    @Query('hasAired') bool? hasAired,
    @Query('isAiring') bool? isAiring,
    @Query('maxStartDate') DateTime? maxStartDate,
    @Query('minEndDate') DateTime? minEndDate,
    @Query('maxEndDate') DateTime? maxEndDate,
    @Query('isMovie') bool? isMovie,
    @Query('isSeries') bool? isSeries,
    @Query('isNews') bool? isNews,
    @Query('isKids') bool? isKids,
    @Query('isSports') bool? isSports,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('sortOrder') List<Object?>? sortOrder,
    @Query('genres') List<String>? genres,
    @Query('genreIds') List<String>? genreIds,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('enableUserData') bool? enableUserData,
    @Query('seriesTimerId') String? seriesTimerId,
    @Query('librarySeriesId') String? librarySeriesId,
    @Query('fields') List<Object?>? fields,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Gets available live tv epgs.
  Future<chopper.Response<BaseItemDtoQueryResult>> liveTvProgramsPost(
      {required GetProgramsDto? body}) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _liveTvProgramsPost(body: body);
  }

  ///Gets available live tv epgs.
  @Post(
    path: '/LiveTv/Programs',
    optionalBody: true,
  )
  Future<chopper.Response<BaseItemDtoQueryResult>> _liveTvProgramsPost(
      {@Body() required GetProgramsDto? body});

  ///Gets a live tv program.
  ///@param programId Program id.
  ///@param userId Optional. Attach user data.
  Future<chopper.Response<BaseItemDto>> liveTvProgramsProgramIdGet({
    required String? programId,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _liveTvProgramsProgramIdGet(programId: programId, userId: userId);
  }

  ///Gets a live tv program.
  ///@param programId Program id.
  ///@param userId Optional. Attach user data.
  @Get(path: '/LiveTv/Programs/{programId}')
  Future<chopper.Response<BaseItemDto>> _liveTvProgramsProgramIdGet({
    @Path('programId') required String? programId,
    @Query('userId') String? userId,
  });

  ///Gets recommended live tv epgs.
  ///@param userId Optional. filter by user id.
  ///@param limit Optional. The maximum number of records to return.
  ///@param isAiring Optional. Filter by programs that are currently airing, or not.
  ///@param hasAired Optional. Filter by programs that have completed airing, or not.
  ///@param isSeries Optional. Filter for series.
  ///@param isMovie Optional. Filter for movies.
  ///@param isNews Optional. Filter for news.
  ///@param isKids Optional. Filter for kids.
  ///@param isSports Optional. Filter for sports.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param genreIds The genres to return guide information for.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableUserData Optional. include user data.
  ///@param enableTotalRecordCount Retrieve total record count.
  Future<chopper.Response<BaseItemDtoQueryResult>>
      liveTvProgramsRecommendedGet({
    String? userId,
    int? limit,
    bool? isAiring,
    bool? hasAired,
    bool? isSeries,
    bool? isMovie,
    bool? isNews,
    bool? isKids,
    bool? isSports,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    List<String>? genreIds,
    List<enums.ItemFields>? fields,
    bool? enableUserData,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _liveTvProgramsRecommendedGet(
        userId: userId,
        limit: limit,
        isAiring: isAiring,
        hasAired: hasAired,
        isSeries: isSeries,
        isMovie: isMovie,
        isNews: isNews,
        isKids: isKids,
        isSports: isSports,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        genreIds: genreIds,
        fields: itemFieldsListToJson(fields),
        enableUserData: enableUserData,
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets recommended live tv epgs.
  ///@param userId Optional. filter by user id.
  ///@param limit Optional. The maximum number of records to return.
  ///@param isAiring Optional. Filter by programs that are currently airing, or not.
  ///@param hasAired Optional. Filter by programs that have completed airing, or not.
  ///@param isSeries Optional. Filter for series.
  ///@param isMovie Optional. Filter for movies.
  ///@param isNews Optional. Filter for news.
  ///@param isKids Optional. Filter for kids.
  ///@param isSports Optional. Filter for sports.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param genreIds The genres to return guide information for.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableUserData Optional. include user data.
  ///@param enableTotalRecordCount Retrieve total record count.
  @Get(path: '/LiveTv/Programs/Recommended')
  Future<chopper.Response<BaseItemDtoQueryResult>>
      _liveTvProgramsRecommendedGet({
    @Query('userId') String? userId,
    @Query('limit') int? limit,
    @Query('isAiring') bool? isAiring,
    @Query('hasAired') bool? hasAired,
    @Query('isSeries') bool? isSeries,
    @Query('isMovie') bool? isMovie,
    @Query('isNews') bool? isNews,
    @Query('isKids') bool? isKids,
    @Query('isSports') bool? isSports,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('genreIds') List<String>? genreIds,
    @Query('fields') List<Object?>? fields,
    @Query('enableUserData') bool? enableUserData,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Gets live tv recordings.
  ///@param channelId Optional. Filter by channel id.
  ///@param userId Optional. Filter by user and attach user data.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param status Optional. Filter by recording status.
  ///@param isInProgress Optional. Filter by recordings that are in progress, or not.
  ///@param seriesTimerId Optional. Filter by recordings belonging to a series timer.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param isMovie Optional. Filter for movies.
  ///@param isSeries Optional. Filter for series.
  ///@param isKids Optional. Filter for kids.
  ///@param isSports Optional. Filter for sports.
  ///@param isNews Optional. Filter for news.
  ///@param isLibraryItem Optional. Filter for is library item.
  ///@param enableTotalRecordCount Optional. Return total record count.
  Future<chopper.Response<BaseItemDtoQueryResult>> liveTvRecordingsGet({
    String? channelId,
    String? userId,
    int? startIndex,
    int? limit,
    enums.LiveTvRecordingsGetStatus? status,
    bool? isInProgress,
    String? seriesTimerId,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    List<enums.ItemFields>? fields,
    bool? enableUserData,
    bool? isMovie,
    bool? isSeries,
    bool? isKids,
    bool? isSports,
    bool? isNews,
    bool? isLibraryItem,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _liveTvRecordingsGet(
        channelId: channelId,
        userId: userId,
        startIndex: startIndex,
        limit: limit,
        status: status?.value?.toString(),
        isInProgress: isInProgress,
        seriesTimerId: seriesTimerId,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        fields: itemFieldsListToJson(fields),
        enableUserData: enableUserData,
        isMovie: isMovie,
        isSeries: isSeries,
        isKids: isKids,
        isSports: isSports,
        isNews: isNews,
        isLibraryItem: isLibraryItem,
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets live tv recordings.
  ///@param channelId Optional. Filter by channel id.
  ///@param userId Optional. Filter by user and attach user data.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param status Optional. Filter by recording status.
  ///@param isInProgress Optional. Filter by recordings that are in progress, or not.
  ///@param seriesTimerId Optional. Filter by recordings belonging to a series timer.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param isMovie Optional. Filter for movies.
  ///@param isSeries Optional. Filter for series.
  ///@param isKids Optional. Filter for kids.
  ///@param isSports Optional. Filter for sports.
  ///@param isNews Optional. Filter for news.
  ///@param isLibraryItem Optional. Filter for is library item.
  ///@param enableTotalRecordCount Optional. Return total record count.
  @Get(path: '/LiveTv/Recordings')
  Future<chopper.Response<BaseItemDtoQueryResult>> _liveTvRecordingsGet({
    @Query('channelId') String? channelId,
    @Query('userId') String? userId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('status') String? status,
    @Query('isInProgress') bool? isInProgress,
    @Query('seriesTimerId') String? seriesTimerId,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('fields') List<Object?>? fields,
    @Query('enableUserData') bool? enableUserData,
    @Query('isMovie') bool? isMovie,
    @Query('isSeries') bool? isSeries,
    @Query('isKids') bool? isKids,
    @Query('isSports') bool? isSports,
    @Query('isNews') bool? isNews,
    @Query('isLibraryItem') bool? isLibraryItem,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Gets a live tv recording.
  ///@param recordingId Recording id.
  ///@param userId Optional. Attach user data.
  Future<chopper.Response<BaseItemDto>> liveTvRecordingsRecordingIdGet({
    required String? recordingId,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _liveTvRecordingsRecordingIdGet(
        recordingId: recordingId, userId: userId);
  }

  ///Gets a live tv recording.
  ///@param recordingId Recording id.
  ///@param userId Optional. Attach user data.
  @Get(path: '/LiveTv/Recordings/{recordingId}')
  Future<chopper.Response<BaseItemDto>> _liveTvRecordingsRecordingIdGet({
    @Path('recordingId') required String? recordingId,
    @Query('userId') String? userId,
  });

  ///Deletes a live tv recording.
  ///@param recordingId Recording id.
  Future<chopper.Response> liveTvRecordingsRecordingIdDelete(
      {required String? recordingId}) {
    return _liveTvRecordingsRecordingIdDelete(recordingId: recordingId);
  }

  ///Deletes a live tv recording.
  ///@param recordingId Recording id.
  @Delete(path: '/LiveTv/Recordings/{recordingId}')
  Future<chopper.Response> _liveTvRecordingsRecordingIdDelete(
      {@Path('recordingId') required String? recordingId});

  ///Gets recording folders.
  ///@param userId Optional. Filter by user and attach user data.
  Future<chopper.Response<BaseItemDtoQueryResult>> liveTvRecordingsFoldersGet(
      {String? userId}) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _liveTvRecordingsFoldersGet(userId: userId);
  }

  ///Gets recording folders.
  ///@param userId Optional. Filter by user and attach user data.
  @Get(path: '/LiveTv/Recordings/Folders')
  Future<chopper.Response<BaseItemDtoQueryResult>> _liveTvRecordingsFoldersGet(
      {@Query('userId') String? userId});

  ///Gets live tv recording groups.
  ///@param userId Optional. Filter by user and attach user data.
  @deprecated
  Future<chopper.Response<BaseItemDtoQueryResult>> liveTvRecordingsGroupsGet(
      {String? userId}) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _liveTvRecordingsGroupsGet(userId: userId);
  }

  ///Gets live tv recording groups.
  ///@param userId Optional. Filter by user and attach user data.
  @deprecated
  @Get(path: '/LiveTv/Recordings/Groups')
  Future<chopper.Response<BaseItemDtoQueryResult>> _liveTvRecordingsGroupsGet(
      {@Query('userId') String? userId});

  ///Get recording group.
  ///@param groupId Group id.
  @deprecated
  Future<chopper.Response> liveTvRecordingsGroupsGroupIdGet(
      {required String? groupId}) {
    return _liveTvRecordingsGroupsGroupIdGet(groupId: groupId);
  }

  ///Get recording group.
  ///@param groupId Group id.
  @deprecated
  @Get(path: '/LiveTv/Recordings/Groups/{groupId}')
  Future<chopper.Response> _liveTvRecordingsGroupsGroupIdGet(
      {@Path('groupId') required String? groupId});

  ///Gets live tv recording series.
  ///@param channelId Optional. Filter by channel id.
  ///@param userId Optional. Filter by user and attach user data.
  ///@param groupId Optional. Filter by recording group.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param status Optional. Filter by recording status.
  ///@param isInProgress Optional. Filter by recordings that are in progress, or not.
  ///@param seriesTimerId Optional. Filter by recordings belonging to a series timer.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param enableTotalRecordCount Optional. Return total record count.
  @deprecated
  Future<chopper.Response<BaseItemDtoQueryResult>> liveTvRecordingsSeriesGet({
    String? channelId,
    String? userId,
    String? groupId,
    int? startIndex,
    int? limit,
    enums.LiveTvRecordingsSeriesGetStatus? status,
    bool? isInProgress,
    String? seriesTimerId,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    List<enums.ItemFields>? fields,
    bool? enableUserData,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _liveTvRecordingsSeriesGet(
        channelId: channelId,
        userId: userId,
        groupId: groupId,
        startIndex: startIndex,
        limit: limit,
        status: status?.value?.toString(),
        isInProgress: isInProgress,
        seriesTimerId: seriesTimerId,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        fields: itemFieldsListToJson(fields),
        enableUserData: enableUserData,
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets live tv recording series.
  ///@param channelId Optional. Filter by channel id.
  ///@param userId Optional. Filter by user and attach user data.
  ///@param groupId Optional. Filter by recording group.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param status Optional. Filter by recording status.
  ///@param isInProgress Optional. Filter by recordings that are in progress, or not.
  ///@param seriesTimerId Optional. Filter by recordings belonging to a series timer.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param enableTotalRecordCount Optional. Return total record count.
  @deprecated
  @Get(path: '/LiveTv/Recordings/Series')
  Future<chopper.Response<BaseItemDtoQueryResult>> _liveTvRecordingsSeriesGet({
    @Query('channelId') String? channelId,
    @Query('userId') String? userId,
    @Query('groupId') String? groupId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('status') String? status,
    @Query('isInProgress') bool? isInProgress,
    @Query('seriesTimerId') String? seriesTimerId,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('fields') List<Object?>? fields,
    @Query('enableUserData') bool? enableUserData,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Gets live tv series timers.
  ///@param sortBy Optional. Sort by SortName or Priority.
  ///@param sortOrder Optional. Sort in Ascending or Descending order.
  Future<chopper.Response<SeriesTimerInfoDtoQueryResult>>
      liveTvSeriesTimersGet({
    String? sortBy,
    enums.LiveTvSeriesTimersGetSortOrder? sortOrder,
  }) {
    generatedMapping.putIfAbsent(SeriesTimerInfoDtoQueryResult,
        () => SeriesTimerInfoDtoQueryResult.fromJsonFactory);

    return _liveTvSeriesTimersGet(
        sortBy: sortBy, sortOrder: sortOrder?.value?.toString());
  }

  ///Gets live tv series timers.
  ///@param sortBy Optional. Sort by SortName or Priority.
  ///@param sortOrder Optional. Sort in Ascending or Descending order.
  @Get(path: '/LiveTv/SeriesTimers')
  Future<chopper.Response<SeriesTimerInfoDtoQueryResult>>
      _liveTvSeriesTimersGet({
    @Query('sortBy') String? sortBy,
    @Query('sortOrder') String? sortOrder,
  });

  ///Creates a live tv series timer.
  Future<chopper.Response> liveTvSeriesTimersPost(
      {required SeriesTimerInfoDto? body}) {
    return _liveTvSeriesTimersPost(body: body);
  }

  ///Creates a live tv series timer.
  @Post(
    path: '/LiveTv/SeriesTimers',
    optionalBody: true,
  )
  Future<chopper.Response> _liveTvSeriesTimersPost(
      {@Body() required SeriesTimerInfoDto? body});

  ///Gets a live tv series timer.
  ///@param timerId Timer id.
  Future<chopper.Response<SeriesTimerInfoDto>> liveTvSeriesTimersTimerIdGet(
      {required String? timerId}) {
    generatedMapping.putIfAbsent(
        SeriesTimerInfoDto, () => SeriesTimerInfoDto.fromJsonFactory);

    return _liveTvSeriesTimersTimerIdGet(timerId: timerId);
  }

  ///Gets a live tv series timer.
  ///@param timerId Timer id.
  @Get(path: '/LiveTv/SeriesTimers/{timerId}')
  Future<chopper.Response<SeriesTimerInfoDto>> _liveTvSeriesTimersTimerIdGet(
      {@Path('timerId') required String? timerId});

  ///Cancels a live tv series timer.
  ///@param timerId Timer id.
  Future<chopper.Response> liveTvSeriesTimersTimerIdDelete(
      {required String? timerId}) {
    return _liveTvSeriesTimersTimerIdDelete(timerId: timerId);
  }

  ///Cancels a live tv series timer.
  ///@param timerId Timer id.
  @Delete(path: '/LiveTv/SeriesTimers/{timerId}')
  Future<chopper.Response> _liveTvSeriesTimersTimerIdDelete(
      {@Path('timerId') required String? timerId});

  ///Updates a live tv series timer.
  ///@param timerId Timer id.
  Future<chopper.Response> liveTvSeriesTimersTimerIdPost({
    required String? timerId,
    required SeriesTimerInfoDto? body,
  }) {
    return _liveTvSeriesTimersTimerIdPost(timerId: timerId, body: body);
  }

  ///Updates a live tv series timer.
  ///@param timerId Timer id.
  @Post(
    path: '/LiveTv/SeriesTimers/{timerId}',
    optionalBody: true,
  )
  Future<chopper.Response> _liveTvSeriesTimersTimerIdPost({
    @Path('timerId') required String? timerId,
    @Body() required SeriesTimerInfoDto? body,
  });

  ///Gets the live tv timers.
  ///@param channelId Optional. Filter by channel id.
  ///@param seriesTimerId Optional. Filter by timers belonging to a series timer.
  ///@param isActive Optional. Filter by timers that are active.
  ///@param isScheduled Optional. Filter by timers that are scheduled.
  Future<chopper.Response<TimerInfoDtoQueryResult>> liveTvTimersGet({
    String? channelId,
    String? seriesTimerId,
    bool? isActive,
    bool? isScheduled,
  }) {
    generatedMapping.putIfAbsent(
        TimerInfoDtoQueryResult, () => TimerInfoDtoQueryResult.fromJsonFactory);

    return _liveTvTimersGet(
        channelId: channelId,
        seriesTimerId: seriesTimerId,
        isActive: isActive,
        isScheduled: isScheduled);
  }

  ///Gets the live tv timers.
  ///@param channelId Optional. Filter by channel id.
  ///@param seriesTimerId Optional. Filter by timers belonging to a series timer.
  ///@param isActive Optional. Filter by timers that are active.
  ///@param isScheduled Optional. Filter by timers that are scheduled.
  @Get(path: '/LiveTv/Timers')
  Future<chopper.Response<TimerInfoDtoQueryResult>> _liveTvTimersGet({
    @Query('channelId') String? channelId,
    @Query('seriesTimerId') String? seriesTimerId,
    @Query('isActive') bool? isActive,
    @Query('isScheduled') bool? isScheduled,
  });

  ///Creates a live tv timer.
  Future<chopper.Response> liveTvTimersPost({required TimerInfoDto? body}) {
    return _liveTvTimersPost(body: body);
  }

  ///Creates a live tv timer.
  @Post(
    path: '/LiveTv/Timers',
    optionalBody: true,
  )
  Future<chopper.Response> _liveTvTimersPost(
      {@Body() required TimerInfoDto? body});

  ///Gets a timer.
  ///@param timerId Timer id.
  Future<chopper.Response<TimerInfoDto>> liveTvTimersTimerIdGet(
      {required String? timerId}) {
    generatedMapping.putIfAbsent(
        TimerInfoDto, () => TimerInfoDto.fromJsonFactory);

    return _liveTvTimersTimerIdGet(timerId: timerId);
  }

  ///Gets a timer.
  ///@param timerId Timer id.
  @Get(path: '/LiveTv/Timers/{timerId}')
  Future<chopper.Response<TimerInfoDto>> _liveTvTimersTimerIdGet(
      {@Path('timerId') required String? timerId});

  ///Cancels a live tv timer.
  ///@param timerId Timer id.
  Future<chopper.Response> liveTvTimersTimerIdDelete(
      {required String? timerId}) {
    return _liveTvTimersTimerIdDelete(timerId: timerId);
  }

  ///Cancels a live tv timer.
  ///@param timerId Timer id.
  @Delete(path: '/LiveTv/Timers/{timerId}')
  Future<chopper.Response> _liveTvTimersTimerIdDelete(
      {@Path('timerId') required String? timerId});

  ///Updates a live tv timer.
  ///@param timerId Timer id.
  Future<chopper.Response> liveTvTimersTimerIdPost({
    required String? timerId,
    required TimerInfoDto? body,
  }) {
    return _liveTvTimersTimerIdPost(timerId: timerId, body: body);
  }

  ///Updates a live tv timer.
  ///@param timerId Timer id.
  @Post(
    path: '/LiveTv/Timers/{timerId}',
    optionalBody: true,
  )
  Future<chopper.Response> _liveTvTimersTimerIdPost({
    @Path('timerId') required String? timerId,
    @Body() required TimerInfoDto? body,
  });

  ///Gets the default values for a new timer.
  ///@param programId Optional. To attach default values based on a program.
  Future<chopper.Response<SeriesTimerInfoDto>> liveTvTimersDefaultsGet(
      {String? programId}) {
    generatedMapping.putIfAbsent(
        SeriesTimerInfoDto, () => SeriesTimerInfoDto.fromJsonFactory);

    return _liveTvTimersDefaultsGet(programId: programId);
  }

  ///Gets the default values for a new timer.
  ///@param programId Optional. To attach default values based on a program.
  @Get(path: '/LiveTv/Timers/Defaults')
  Future<chopper.Response<SeriesTimerInfoDto>> _liveTvTimersDefaultsGet(
      {@Query('programId') String? programId});

  ///Adds a tuner host.
  Future<chopper.Response<TunerHostInfo>> liveTvTunerHostsPost(
      {required TunerHostInfo? body}) {
    generatedMapping.putIfAbsent(
        TunerHostInfo, () => TunerHostInfo.fromJsonFactory);

    return _liveTvTunerHostsPost(body: body);
  }

  ///Adds a tuner host.
  @Post(
    path: '/LiveTv/TunerHosts',
    optionalBody: true,
  )
  Future<chopper.Response<TunerHostInfo>> _liveTvTunerHostsPost(
      {@Body() required TunerHostInfo? body});

  ///Deletes a tuner host.
  ///@param id Tuner host id.
  Future<chopper.Response> liveTvTunerHostsDelete({String? id}) {
    return _liveTvTunerHostsDelete(id: id);
  }

  ///Deletes a tuner host.
  ///@param id Tuner host id.
  @Delete(path: '/LiveTv/TunerHosts')
  Future<chopper.Response> _liveTvTunerHostsDelete({@Query('id') String? id});

  ///Get tuner host types.
  Future<chopper.Response<List<NameIdPair>>> liveTvTunerHostsTypesGet() {
    generatedMapping.putIfAbsent(NameIdPair, () => NameIdPair.fromJsonFactory);

    return _liveTvTunerHostsTypesGet();
  }

  ///Get tuner host types.
  @Get(path: '/LiveTv/TunerHosts/Types')
  Future<chopper.Response<List<NameIdPair>>> _liveTvTunerHostsTypesGet();

  ///Resets a tv tuner.
  ///@param tunerId Tuner id.
  Future<chopper.Response> liveTvTunersTunerIdResetPost(
      {required String? tunerId}) {
    return _liveTvTunersTunerIdResetPost(tunerId: tunerId);
  }

  ///Resets a tv tuner.
  ///@param tunerId Tuner id.
  @Post(
    path: '/LiveTv/Tuners/{tunerId}/Reset',
    optionalBody: true,
  )
  Future<chopper.Response> _liveTvTunersTunerIdResetPost(
      {@Path('tunerId') required String? tunerId});

  ///Discover tuners.
  ///@param newDevicesOnly Only discover new tuners.
  Future<chopper.Response<List<TunerHostInfo>>> liveTvTunersDiscoverGet(
      {bool? newDevicesOnly}) {
    generatedMapping.putIfAbsent(
        TunerHostInfo, () => TunerHostInfo.fromJsonFactory);

    return _liveTvTunersDiscoverGet(newDevicesOnly: newDevicesOnly);
  }

  ///Discover tuners.
  ///@param newDevicesOnly Only discover new tuners.
  @Get(path: '/LiveTv/Tuners/Discover')
  Future<chopper.Response<List<TunerHostInfo>>> _liveTvTunersDiscoverGet(
      {@Query('newDevicesOnly') bool? newDevicesOnly});

  ///Discover tuners.
  ///@param newDevicesOnly Only discover new tuners.
  Future<chopper.Response<List<TunerHostInfo>>> liveTvTunersDiscvoverGet(
      {bool? newDevicesOnly}) {
    generatedMapping.putIfAbsent(
        TunerHostInfo, () => TunerHostInfo.fromJsonFactory);

    return _liveTvTunersDiscvoverGet(newDevicesOnly: newDevicesOnly);
  }

  ///Discover tuners.
  ///@param newDevicesOnly Only discover new tuners.
  @Get(path: '/LiveTv/Tuners/Discvover')
  Future<chopper.Response<List<TunerHostInfo>>> _liveTvTunersDiscvoverGet(
      {@Query('newDevicesOnly') bool? newDevicesOnly});

  ///Gets known countries.
  Future<chopper.Response<List<CountryInfo>>> localizationCountriesGet() {
    generatedMapping.putIfAbsent(
        CountryInfo, () => CountryInfo.fromJsonFactory);

    return _localizationCountriesGet();
  }

  ///Gets known countries.
  @Get(path: '/Localization/Countries')
  Future<chopper.Response<List<CountryInfo>>> _localizationCountriesGet();

  ///Gets known cultures.
  Future<chopper.Response<List<CultureDto>>> localizationCulturesGet() {
    generatedMapping.putIfAbsent(CultureDto, () => CultureDto.fromJsonFactory);

    return _localizationCulturesGet();
  }

  ///Gets known cultures.
  @Get(path: '/Localization/Cultures')
  Future<chopper.Response<List<CultureDto>>> _localizationCulturesGet();

  ///Gets localization options.
  Future<chopper.Response<List<LocalizationOption>>> localizationOptionsGet() {
    generatedMapping.putIfAbsent(
        LocalizationOption, () => LocalizationOption.fromJsonFactory);

    return _localizationOptionsGet();
  }

  ///Gets localization options.
  @Get(path: '/Localization/Options')
  Future<chopper.Response<List<LocalizationOption>>> _localizationOptionsGet();

  ///Gets known parental ratings.
  Future<chopper.Response<List<ParentalRating>>>
      localizationParentalRatingsGet() {
    generatedMapping.putIfAbsent(
        ParentalRating, () => ParentalRating.fromJsonFactory);

    return _localizationParentalRatingsGet();
  }

  ///Gets known parental ratings.
  @Get(path: '/Localization/ParentalRatings')
  Future<chopper.Response<List<ParentalRating>>>
      _localizationParentalRatingsGet();

  ///Gets an item's lyrics.
  ///@param itemId Item id.
  Future<chopper.Response<LyricDto>> audioItemIdLyricsGet(
      {required String? itemId}) {
    generatedMapping.putIfAbsent(LyricDto, () => LyricDto.fromJsonFactory);

    return _audioItemIdLyricsGet(itemId: itemId);
  }

  ///Gets an item's lyrics.
  ///@param itemId Item id.
  @Get(path: '/Audio/{itemId}/Lyrics')
  Future<chopper.Response<LyricDto>> _audioItemIdLyricsGet(
      {@Path('itemId') required String? itemId});

  ///Upload an external lyric file.
  ///@param itemId The item the lyric belongs to.
  ///@param fileName Name of the file being uploaded.
  Future<chopper.Response<LyricDto>> audioItemIdLyricsPost({
    required String? itemId,
    required String? fileName,
    required Object? body,
  }) {
    generatedMapping.putIfAbsent(LyricDto, () => LyricDto.fromJsonFactory);

    return _audioItemIdLyricsPost(
        itemId: itemId, fileName: fileName, body: body);
  }

  ///Upload an external lyric file.
  ///@param itemId The item the lyric belongs to.
  ///@param fileName Name of the file being uploaded.
  @Post(
    path: '/Audio/{itemId}/Lyrics',
    optionalBody: true,
  )
  Future<chopper.Response<LyricDto>> _audioItemIdLyricsPost({
    @Path('itemId') required String? itemId,
    @Query('fileName') required String? fileName,
    @Body() required Object? body,
  });

  ///Deletes an external lyric file.
  ///@param itemId The item id.
  Future<chopper.Response> audioItemIdLyricsDelete({required String? itemId}) {
    return _audioItemIdLyricsDelete(itemId: itemId);
  }

  ///Deletes an external lyric file.
  ///@param itemId The item id.
  @Delete(path: '/Audio/{itemId}/Lyrics')
  Future<chopper.Response> _audioItemIdLyricsDelete(
      {@Path('itemId') required String? itemId});

  ///Search remote lyrics.
  ///@param itemId The item id.
  Future<chopper.Response<List<RemoteLyricInfoDto>>>
      audioItemIdRemoteSearchLyricsGet({required String? itemId}) {
    generatedMapping.putIfAbsent(
        RemoteLyricInfoDto, () => RemoteLyricInfoDto.fromJsonFactory);

    return _audioItemIdRemoteSearchLyricsGet(itemId: itemId);
  }

  ///Search remote lyrics.
  ///@param itemId The item id.
  @Get(path: '/Audio/{itemId}/RemoteSearch/Lyrics')
  Future<chopper.Response<List<RemoteLyricInfoDto>>>
      _audioItemIdRemoteSearchLyricsGet(
          {@Path('itemId') required String? itemId});

  ///Downloads a remote lyric.
  ///@param itemId The item id.
  ///@param lyricId The lyric id.
  Future<chopper.Response<LyricDto>> audioItemIdRemoteSearchLyricsLyricIdPost({
    required String? itemId,
    required String? lyricId,
  }) {
    generatedMapping.putIfAbsent(LyricDto, () => LyricDto.fromJsonFactory);

    return _audioItemIdRemoteSearchLyricsLyricIdPost(
        itemId: itemId, lyricId: lyricId);
  }

  ///Downloads a remote lyric.
  ///@param itemId The item id.
  ///@param lyricId The lyric id.
  @Post(
    path: '/Audio/{itemId}/RemoteSearch/Lyrics/{lyricId}',
    optionalBody: true,
  )
  Future<chopper.Response<LyricDto>> _audioItemIdRemoteSearchLyricsLyricIdPost({
    @Path('itemId') required String? itemId,
    @Path('lyricId') required String? lyricId,
  });

  ///Gets the remote lyrics.
  ///@param lyricId The remote provider item id.
  Future<chopper.Response<LyricDto>> providersLyricsLyricIdGet(
      {required String? lyricId}) {
    generatedMapping.putIfAbsent(LyricDto, () => LyricDto.fromJsonFactory);

    return _providersLyricsLyricIdGet(lyricId: lyricId);
  }

  ///Gets the remote lyrics.
  ///@param lyricId The remote provider item id.
  @Get(path: '/Providers/Lyrics/{lyricId}')
  Future<chopper.Response<LyricDto>> _providersLyricsLyricIdGet(
      {@Path('lyricId') required String? lyricId});

  ///Gets live playback media info for an item.
  ///@param itemId The item id.
  ///@param userId The user id.
  Future<chopper.Response<PlaybackInfoResponse>> itemsItemIdPlaybackInfoGet({
    required String? itemId,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        PlaybackInfoResponse, () => PlaybackInfoResponse.fromJsonFactory);

    return _itemsItemIdPlaybackInfoGet(itemId: itemId, userId: userId);
  }

  ///Gets live playback media info for an item.
  ///@param itemId The item id.
  ///@param userId The user id.
  @Get(path: '/Items/{itemId}/PlaybackInfo')
  Future<chopper.Response<PlaybackInfoResponse>> _itemsItemIdPlaybackInfoGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
  });

  ///Gets live playback media info for an item.
  ///@param itemId The item id.
  ///@param userId The user id.
  ///@param maxStreamingBitrate The maximum streaming bitrate.
  ///@param startTimeTicks The start time in ticks.
  ///@param audioStreamIndex The audio stream index.
  ///@param subtitleStreamIndex The subtitle stream index.
  ///@param maxAudioChannels The maximum number of audio channels.
  ///@param mediaSourceId The media source id.
  ///@param liveStreamId The livestream id.
  ///@param autoOpenLiveStream Whether to auto open the livestream.
  ///@param enableDirectPlay Whether to enable direct play. Default: true.
  ///@param enableDirectStream Whether to enable direct stream. Default: true.
  ///@param enableTranscoding Whether to enable transcoding. Default: true.
  ///@param allowVideoStreamCopy Whether to allow to copy the video stream. Default: true.
  ///@param allowAudioStreamCopy Whether to allow to copy the audio stream. Default: true.
  Future<chopper.Response<PlaybackInfoResponse>> itemsItemIdPlaybackInfoPost({
    required String? itemId,
    String? userId,
    int? maxStreamingBitrate,
    int? startTimeTicks,
    int? audioStreamIndex,
    int? subtitleStreamIndex,
    int? maxAudioChannels,
    String? mediaSourceId,
    String? liveStreamId,
    bool? autoOpenLiveStream,
    bool? enableDirectPlay,
    bool? enableDirectStream,
    bool? enableTranscoding,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    required PlaybackInfoDto? body,
  }) {
    generatedMapping.putIfAbsent(
        PlaybackInfoResponse, () => PlaybackInfoResponse.fromJsonFactory);

    return _itemsItemIdPlaybackInfoPost(
        itemId: itemId,
        userId: userId,
        maxStreamingBitrate: maxStreamingBitrate,
        startTimeTicks: startTimeTicks,
        audioStreamIndex: audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex,
        maxAudioChannels: maxAudioChannels,
        mediaSourceId: mediaSourceId,
        liveStreamId: liveStreamId,
        autoOpenLiveStream: autoOpenLiveStream,
        enableDirectPlay: enableDirectPlay,
        enableDirectStream: enableDirectStream,
        enableTranscoding: enableTranscoding,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        body: body);
  }

  ///Gets live playback media info for an item.
  ///@param itemId The item id.
  ///@param userId The user id.
  ///@param maxStreamingBitrate The maximum streaming bitrate.
  ///@param startTimeTicks The start time in ticks.
  ///@param audioStreamIndex The audio stream index.
  ///@param subtitleStreamIndex The subtitle stream index.
  ///@param maxAudioChannels The maximum number of audio channels.
  ///@param mediaSourceId The media source id.
  ///@param liveStreamId The livestream id.
  ///@param autoOpenLiveStream Whether to auto open the livestream.
  ///@param enableDirectPlay Whether to enable direct play. Default: true.
  ///@param enableDirectStream Whether to enable direct stream. Default: true.
  ///@param enableTranscoding Whether to enable transcoding. Default: true.
  ///@param allowVideoStreamCopy Whether to allow to copy the video stream. Default: true.
  ///@param allowAudioStreamCopy Whether to allow to copy the audio stream. Default: true.
  @Post(
    path: '/Items/{itemId}/PlaybackInfo',
    optionalBody: true,
  )
  Future<chopper.Response<PlaybackInfoResponse>> _itemsItemIdPlaybackInfoPost({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
    @Query('maxStreamingBitrate') int? maxStreamingBitrate,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('liveStreamId') String? liveStreamId,
    @Query('autoOpenLiveStream') bool? autoOpenLiveStream,
    @Query('enableDirectPlay') bool? enableDirectPlay,
    @Query('enableDirectStream') bool? enableDirectStream,
    @Query('enableTranscoding') bool? enableTranscoding,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Body() required PlaybackInfoDto? body,
  });

  ///Closes a media source.
  ///@param liveStreamId The livestream id.
  Future<chopper.Response> liveStreamsClosePost(
      {required String? liveStreamId}) {
    return _liveStreamsClosePost(liveStreamId: liveStreamId);
  }

  ///Closes a media source.
  ///@param liveStreamId The livestream id.
  @Post(
    path: '/LiveStreams/Close',
    optionalBody: true,
  )
  Future<chopper.Response> _liveStreamsClosePost(
      {@Query('liveStreamId') required String? liveStreamId});

  ///Opens a media source.
  ///@param openToken The open token.
  ///@param userId The user id.
  ///@param playSessionId The play session id.
  ///@param maxStreamingBitrate The maximum streaming bitrate.
  ///@param startTimeTicks The start time in ticks.
  ///@param audioStreamIndex The audio stream index.
  ///@param subtitleStreamIndex The subtitle stream index.
  ///@param maxAudioChannels The maximum number of audio channels.
  ///@param itemId The item id.
  ///@param enableDirectPlay Whether to enable direct play. Default: true.
  ///@param enableDirectStream Whether to enable direct stream. Default: true.
  ///@param alwaysBurnInSubtitleWhenTranscoding Always burn-in subtitle when transcoding.
  Future<chopper.Response<LiveStreamResponse>> liveStreamsOpenPost({
    String? openToken,
    String? userId,
    String? playSessionId,
    int? maxStreamingBitrate,
    int? startTimeTicks,
    int? audioStreamIndex,
    int? subtitleStreamIndex,
    int? maxAudioChannels,
    String? itemId,
    bool? enableDirectPlay,
    bool? enableDirectStream,
    bool? alwaysBurnInSubtitleWhenTranscoding,
    required OpenLiveStreamDto? body,
  }) {
    generatedMapping.putIfAbsent(
        LiveStreamResponse, () => LiveStreamResponse.fromJsonFactory);

    return _liveStreamsOpenPost(
        openToken: openToken,
        userId: userId,
        playSessionId: playSessionId,
        maxStreamingBitrate: maxStreamingBitrate,
        startTimeTicks: startTimeTicks,
        audioStreamIndex: audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex,
        maxAudioChannels: maxAudioChannels,
        itemId: itemId,
        enableDirectPlay: enableDirectPlay,
        enableDirectStream: enableDirectStream,
        alwaysBurnInSubtitleWhenTranscoding:
            alwaysBurnInSubtitleWhenTranscoding,
        body: body);
  }

  ///Opens a media source.
  ///@param openToken The open token.
  ///@param userId The user id.
  ///@param playSessionId The play session id.
  ///@param maxStreamingBitrate The maximum streaming bitrate.
  ///@param startTimeTicks The start time in ticks.
  ///@param audioStreamIndex The audio stream index.
  ///@param subtitleStreamIndex The subtitle stream index.
  ///@param maxAudioChannels The maximum number of audio channels.
  ///@param itemId The item id.
  ///@param enableDirectPlay Whether to enable direct play. Default: true.
  ///@param enableDirectStream Whether to enable direct stream. Default: true.
  ///@param alwaysBurnInSubtitleWhenTranscoding Always burn-in subtitle when transcoding.
  @Post(
    path: '/LiveStreams/Open',
    optionalBody: true,
  )
  Future<chopper.Response<LiveStreamResponse>> _liveStreamsOpenPost({
    @Query('openToken') String? openToken,
    @Query('userId') String? userId,
    @Query('playSessionId') String? playSessionId,
    @Query('maxStreamingBitrate') int? maxStreamingBitrate,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('itemId') String? itemId,
    @Query('enableDirectPlay') bool? enableDirectPlay,
    @Query('enableDirectStream') bool? enableDirectStream,
    @Query('alwaysBurnInSubtitleWhenTranscoding')
    bool? alwaysBurnInSubtitleWhenTranscoding,
    @Body() required OpenLiveStreamDto? body,
  });

  ///Tests the network with a request with the size of the bitrate.
  ///@param size The bitrate. Defaults to 102400.
  Future<chopper.Response<String>> playbackBitrateTestGet({int? size}) {
    return _playbackBitrateTestGet(size: size);
  }

  ///Tests the network with a request with the size of the bitrate.
  ///@param size The bitrate. Defaults to 102400.
  @Get(path: '/Playback/BitrateTest')
  Future<chopper.Response<String>> _playbackBitrateTestGet(
      {@Query('size') int? size});

  ///Gets all media segments based on an itemId.
  ///@param itemId The ItemId.
  ///@param includeSegmentTypes Optional filter of requested segment types.
  Future<chopper.Response<MediaSegmentDtoQueryResult>> mediaSegmentsItemIdGet({
    required String? itemId,
    List<enums.MediaSegmentType>? includeSegmentTypes,
  }) {
    generatedMapping.putIfAbsent(MediaSegmentDtoQueryResult,
        () => MediaSegmentDtoQueryResult.fromJsonFactory);

    return _mediaSegmentsItemIdGet(
        itemId: itemId,
        includeSegmentTypes: mediaSegmentTypeListToJson(includeSegmentTypes));
  }

  ///Gets all media segments based on an itemId.
  ///@param itemId The ItemId.
  ///@param includeSegmentTypes Optional filter of requested segment types.
  @Get(path: '/MediaSegments/{itemId}')
  Future<chopper.Response<MediaSegmentDtoQueryResult>> _mediaSegmentsItemIdGet({
    @Path('itemId') required String? itemId,
    @Query('includeSegmentTypes') List<Object?>? includeSegmentTypes,
  });

  ///Gets movie recommendations.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. The fields to return.
  ///@param categoryLimit The max number of categories to return.
  ///@param itemLimit The max number of items to return per category.
  Future<chopper.Response<List<RecommendationDto>>> moviesRecommendationsGet({
    String? userId,
    String? parentId,
    List<enums.ItemFields>? fields,
    int? categoryLimit,
    int? itemLimit,
  }) {
    generatedMapping.putIfAbsent(
        RecommendationDto, () => RecommendationDto.fromJsonFactory);

    return _moviesRecommendationsGet(
        userId: userId,
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        categoryLimit: categoryLimit,
        itemLimit: itemLimit);
  }

  ///Gets movie recommendations.
  ///@param userId Optional. Filter by user id, and attach user data.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. The fields to return.
  ///@param categoryLimit The max number of categories to return.
  ///@param itemLimit The max number of items to return per category.
  @Get(path: '/Movies/Recommendations')
  Future<chopper.Response<List<RecommendationDto>>> _moviesRecommendationsGet({
    @Query('userId') String? userId,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('categoryLimit') int? categoryLimit,
    @Query('itemLimit') int? itemLimit,
  });

  ///Gets all music genres from a given item, folder, or the entire library.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm The search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Optional. Include total record count.
  @deprecated
  Future<chopper.Response<BaseItemDtoQueryResult>> musicGenresGet({
    int? startIndex,
    int? limit,
    String? searchTerm,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.BaseItemKind>? includeItemTypes,
    bool? isFavorite,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    String? userId,
    String? nameStartsWithOrGreater,
    String? nameStartsWith,
    String? nameLessThan,
    List<enums.ItemSortBy>? sortBy,
    List<enums.SortOrder>? sortOrder,
    bool? enableImages,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _musicGenresGet(
        startIndex: startIndex,
        limit: limit,
        searchTerm: searchTerm,
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        isFavorite: isFavorite,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        userId: userId,
        nameStartsWithOrGreater: nameStartsWithOrGreater,
        nameStartsWith: nameStartsWith,
        nameLessThan: nameLessThan,
        sortBy: itemSortByListToJson(sortBy),
        sortOrder: sortOrderListToJson(sortOrder),
        enableImages: enableImages,
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets all music genres from a given item, folder, or the entire library.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm The search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Optional. Include total record count.
  @deprecated
  @Get(path: '/MusicGenres')
  Future<chopper.Response<BaseItemDtoQueryResult>> _musicGenresGet({
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('searchTerm') String? searchTerm,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('isFavorite') bool? isFavorite,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('userId') String? userId,
    @Query('nameStartsWithOrGreater') String? nameStartsWithOrGreater,
    @Query('nameStartsWith') String? nameStartsWith,
    @Query('nameLessThan') String? nameLessThan,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('sortOrder') List<Object?>? sortOrder,
    @Query('enableImages') bool? enableImages,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Gets a music genre, by name.
  ///@param genreName The genre name.
  ///@param userId Optional. Filter by user id, and attach user data.
  Future<chopper.Response<BaseItemDto>> musicGenresGenreNameGet({
    required String? genreName,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _musicGenresGenreNameGet(genreName: genreName, userId: userId);
  }

  ///Gets a music genre, by name.
  ///@param genreName The genre name.
  ///@param userId Optional. Filter by user id, and attach user data.
  @Get(path: '/MusicGenres/{genreName}')
  Future<chopper.Response<BaseItemDto>> _musicGenresGenreNameGet({
    @Path('genreName') required String? genreName,
    @Query('userId') String? userId,
  });

  ///Gets available packages.
  Future<chopper.Response<List<PackageInfo>>> packagesGet() {
    generatedMapping.putIfAbsent(
        PackageInfo, () => PackageInfo.fromJsonFactory);

    return _packagesGet();
  }

  ///Gets available packages.
  @Get(path: '/Packages')
  Future<chopper.Response<List<PackageInfo>>> _packagesGet();

  ///Gets a package by name or assembly GUID.
  ///@param name The name of the package.
  ///@param assemblyGuid The GUID of the associated assembly.
  Future<chopper.Response<PackageInfo>> packagesNameGet({
    required String? name,
    String? assemblyGuid,
  }) {
    generatedMapping.putIfAbsent(
        PackageInfo, () => PackageInfo.fromJsonFactory);

    return _packagesNameGet(name: name, assemblyGuid: assemblyGuid);
  }

  ///Gets a package by name or assembly GUID.
  ///@param name The name of the package.
  ///@param assemblyGuid The GUID of the associated assembly.
  @Get(path: '/Packages/{name}')
  Future<chopper.Response<PackageInfo>> _packagesNameGet({
    @Path('name') required String? name,
    @Query('assemblyGuid') String? assemblyGuid,
  });

  ///Installs a package.
  ///@param name Package name.
  ///@param assemblyGuid GUID of the associated assembly.
  ///@param version Optional version. Defaults to latest version.
  ///@param repositoryUrl Optional. Specify the repository to install from.
  Future<chopper.Response> packagesInstalledNamePost({
    required String? name,
    String? assemblyGuid,
    String? version,
    String? repositoryUrl,
  }) {
    return _packagesInstalledNamePost(
        name: name,
        assemblyGuid: assemblyGuid,
        version: version,
        repositoryUrl: repositoryUrl);
  }

  ///Installs a package.
  ///@param name Package name.
  ///@param assemblyGuid GUID of the associated assembly.
  ///@param version Optional version. Defaults to latest version.
  ///@param repositoryUrl Optional. Specify the repository to install from.
  @Post(
    path: '/Packages/Installed/{name}',
    optionalBody: true,
  )
  Future<chopper.Response> _packagesInstalledNamePost({
    @Path('name') required String? name,
    @Query('assemblyGuid') String? assemblyGuid,
    @Query('version') String? version,
    @Query('repositoryUrl') String? repositoryUrl,
  });

  ///Cancels a package installation.
  ///@param packageId Installation Id.
  Future<chopper.Response> packagesInstallingPackageIdDelete(
      {required String? packageId}) {
    return _packagesInstallingPackageIdDelete(packageId: packageId);
  }

  ///Cancels a package installation.
  ///@param packageId Installation Id.
  @Delete(path: '/Packages/Installing/{packageId}')
  Future<chopper.Response> _packagesInstallingPackageIdDelete(
      {@Path('packageId') required String? packageId});

  ///Gets all package repositories.
  Future<chopper.Response<List<RepositoryInfo>>> repositoriesGet() {
    generatedMapping.putIfAbsent(
        RepositoryInfo, () => RepositoryInfo.fromJsonFactory);

    return _repositoriesGet();
  }

  ///Gets all package repositories.
  @Get(path: '/Repositories')
  Future<chopper.Response<List<RepositoryInfo>>> _repositoriesGet();

  ///Sets the enabled and existing package repositories.
  Future<chopper.Response> repositoriesPost(
      {required List<RepositoryInfo>? body}) {
    return _repositoriesPost(body: body);
  }

  ///Sets the enabled and existing package repositories.
  @Post(
    path: '/Repositories',
    optionalBody: true,
  )
  Future<chopper.Response> _repositoriesPost(
      {@Body() required List<RepositoryInfo>? body});

  ///Gets all persons.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm The search term.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not. userId is required.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param excludePersonTypes Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.
  ///@param personTypes Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.
  ///@param appearsInItemId Optional. If specified, person results will be filtered on items related to said persons.
  ///@param userId User id.
  ///@param enableImages Optional, include image information in output.
  Future<chopper.Response<BaseItemDtoQueryResult>> personsGet({
    int? limit,
    String? searchTerm,
    List<enums.ItemFields>? fields,
    List<enums.ItemFilter>? filters,
    bool? isFavorite,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    List<String>? excludePersonTypes,
    List<String>? personTypes,
    String? appearsInItemId,
    String? userId,
    bool? enableImages,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _personsGet(
        limit: limit,
        searchTerm: searchTerm,
        fields: itemFieldsListToJson(fields),
        filters: itemFilterListToJson(filters),
        isFavorite: isFavorite,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        excludePersonTypes: excludePersonTypes,
        personTypes: personTypes,
        appearsInItemId: appearsInItemId,
        userId: userId,
        enableImages: enableImages);
  }

  ///Gets all persons.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm The search term.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param filters Optional. Specify additional filters to apply.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not. userId is required.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param excludePersonTypes Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.
  ///@param personTypes Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.
  ///@param appearsInItemId Optional. If specified, person results will be filtered on items related to said persons.
  ///@param userId User id.
  ///@param enableImages Optional, include image information in output.
  @Get(path: '/Persons')
  Future<chopper.Response<BaseItemDtoQueryResult>> _personsGet({
    @Query('limit') int? limit,
    @Query('searchTerm') String? searchTerm,
    @Query('fields') List<Object?>? fields,
    @Query('filters') List<Object?>? filters,
    @Query('isFavorite') bool? isFavorite,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('excludePersonTypes') List<String>? excludePersonTypes,
    @Query('personTypes') List<String>? personTypes,
    @Query('appearsInItemId') String? appearsInItemId,
    @Query('userId') String? userId,
    @Query('enableImages') bool? enableImages,
  });

  ///Get person by name.
  ///@param name Person name.
  ///@param userId Optional. Filter by user id, and attach user data.
  Future<chopper.Response<BaseItemDto>> personsNameGet({
    required String? name,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _personsNameGet(name: name, userId: userId);
  }

  ///Get person by name.
  ///@param name Person name.
  ///@param userId Optional. Filter by user id, and attach user data.
  @Get(path: '/Persons/{name}')
  Future<chopper.Response<BaseItemDto>> _personsNameGet({
    @Path('name') required String? name,
    @Query('userId') String? userId,
  });

  ///Creates a new playlist.
  ///@param name The playlist name.
  ///@param ids The item ids.
  ///@param userId The user id.
  ///@param mediaType The media type.
  Future<chopper.Response<PlaylistCreationResult>> playlistsPost({
    String? name,
    List<String>? ids,
    String? userId,
    enums.PlaylistsPostMediaType? mediaType,
    required CreatePlaylistDto? body,
  }) {
    generatedMapping.putIfAbsent(
        PlaylistCreationResult, () => PlaylistCreationResult.fromJsonFactory);

    return _playlistsPost(
        name: name,
        ids: ids,
        userId: userId,
        mediaType: mediaType?.value?.toString(),
        body: body);
  }

  ///Creates a new playlist.
  ///@param name The playlist name.
  ///@param ids The item ids.
  ///@param userId The user id.
  ///@param mediaType The media type.
  @Post(
    path: '/Playlists',
    optionalBody: true,
  )
  Future<chopper.Response<PlaylistCreationResult>> _playlistsPost({
    @Query('name') String? name,
    @Query('ids') List<String>? ids,
    @Query('userId') String? userId,
    @Query('mediaType') String? mediaType,
    @Body() required CreatePlaylistDto? body,
  });

  ///Updates a playlist.
  ///@param playlistId The playlist id.
  Future<chopper.Response> playlistsPlaylistIdPost({
    required String? playlistId,
    required UpdatePlaylistDto? body,
  }) {
    return _playlistsPlaylistIdPost(playlistId: playlistId, body: body);
  }

  ///Updates a playlist.
  ///@param playlistId The playlist id.
  @Post(
    path: '/Playlists/{playlistId}',
    optionalBody: true,
  )
  Future<chopper.Response> _playlistsPlaylistIdPost({
    @Path('playlistId') required String? playlistId,
    @Body() required UpdatePlaylistDto? body,
  });

  ///Get a playlist.
  ///@param playlistId The playlist id.
  Future<chopper.Response<PlaylistDto>> playlistsPlaylistIdGet(
      {required String? playlistId}) {
    generatedMapping.putIfAbsent(
        PlaylistDto, () => PlaylistDto.fromJsonFactory);

    return _playlistsPlaylistIdGet(playlistId: playlistId);
  }

  ///Get a playlist.
  ///@param playlistId The playlist id.
  @Get(path: '/Playlists/{playlistId}')
  Future<chopper.Response<PlaylistDto>> _playlistsPlaylistIdGet(
      {@Path('playlistId') required String? playlistId});

  ///Adds items to a playlist.
  ///@param playlistId The playlist id.
  ///@param ids Item id, comma delimited.
  ///@param userId The userId.
  Future<chopper.Response> playlistsPlaylistIdItemsPost({
    required String? playlistId,
    List<String>? ids,
    String? userId,
  }) {
    return _playlistsPlaylistIdItemsPost(
        playlistId: playlistId, ids: ids, userId: userId);
  }

  ///Adds items to a playlist.
  ///@param playlistId The playlist id.
  ///@param ids Item id, comma delimited.
  ///@param userId The userId.
  @Post(
    path: '/Playlists/{playlistId}/Items',
    optionalBody: true,
  )
  Future<chopper.Response> _playlistsPlaylistIdItemsPost({
    @Path('playlistId') required String? playlistId,
    @Query('ids') List<String>? ids,
    @Query('userId') String? userId,
  });

  ///Removes items from a playlist.
  ///@param playlistId The playlist id.
  ///@param entryIds The item ids, comma delimited.
  Future<chopper.Response> playlistsPlaylistIdItemsDelete({
    required String? playlistId,
    List<String>? entryIds,
  }) {
    return _playlistsPlaylistIdItemsDelete(
        playlistId: playlistId, entryIds: entryIds);
  }

  ///Removes items from a playlist.
  ///@param playlistId The playlist id.
  ///@param entryIds The item ids, comma delimited.
  @Delete(path: '/Playlists/{playlistId}/Items')
  Future<chopper.Response> _playlistsPlaylistIdItemsDelete({
    @Path('playlistId') required String? playlistId,
    @Query('entryIds') List<String>? entryIds,
  });

  ///Gets the original items of a playlist.
  ///@param playlistId The playlist id.
  ///@param userId User id.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  Future<chopper.Response<BaseItemDtoQueryResult>> playlistsPlaylistIdItemsGet({
    required String? playlistId,
    String? userId,
    int? startIndex,
    int? limit,
    List<enums.ItemFields>? fields,
    bool? enableImages,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _playlistsPlaylistIdItemsGet(
        playlistId: playlistId,
        userId: userId,
        startIndex: startIndex,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        enableImages: enableImages,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes));
  }

  ///Gets the original items of a playlist.
  ///@param playlistId The playlist id.
  ///@param userId User id.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param enableImages Optional. Include image information in output.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  @Get(path: '/Playlists/{playlistId}/Items')
  Future<chopper.Response<BaseItemDtoQueryResult>>
      _playlistsPlaylistIdItemsGet({
    @Path('playlistId') required String? playlistId,
    @Query('userId') String? userId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('enableImages') bool? enableImages,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
  });

  ///Moves a playlist item.
  ///@param playlistId The playlist id.
  ///@param itemId The item id.
  ///@param newIndex The new index.
  Future<chopper.Response> playlistsPlaylistIdItemsItemIdMoveNewIndexPost({
    required String? playlistId,
    required String? itemId,
    required int? newIndex,
  }) {
    return _playlistsPlaylistIdItemsItemIdMoveNewIndexPost(
        playlistId: playlistId, itemId: itemId, newIndex: newIndex);
  }

  ///Moves a playlist item.
  ///@param playlistId The playlist id.
  ///@param itemId The item id.
  ///@param newIndex The new index.
  @Post(
    path: '/Playlists/{playlistId}/Items/{itemId}/Move/{newIndex}',
    optionalBody: true,
  )
  Future<chopper.Response> _playlistsPlaylistIdItemsItemIdMoveNewIndexPost({
    @Path('playlistId') required String? playlistId,
    @Path('itemId') required String? itemId,
    @Path('newIndex') required int? newIndex,
  });

  ///Get a playlist's users.
  ///@param playlistId The playlist id.
  Future<chopper.Response<List<PlaylistUserPermissions>>>
      playlistsPlaylistIdUsersGet({required String? playlistId}) {
    generatedMapping.putIfAbsent(
        PlaylistUserPermissions, () => PlaylistUserPermissions.fromJsonFactory);

    return _playlistsPlaylistIdUsersGet(playlistId: playlistId);
  }

  ///Get a playlist's users.
  ///@param playlistId The playlist id.
  @Get(path: '/Playlists/{playlistId}/Users')
  Future<chopper.Response<List<PlaylistUserPermissions>>>
      _playlistsPlaylistIdUsersGet(
          {@Path('playlistId') required String? playlistId});

  ///Get a playlist user.
  ///@param playlistId The playlist id.
  ///@param userId The user id.
  Future<chopper.Response<PlaylistUserPermissions>>
      playlistsPlaylistIdUsersUserIdGet({
    required String? playlistId,
    required String? userId,
  }) {
    generatedMapping.putIfAbsent(
        PlaylistUserPermissions, () => PlaylistUserPermissions.fromJsonFactory);

    return _playlistsPlaylistIdUsersUserIdGet(
        playlistId: playlistId, userId: userId);
  }

  ///Get a playlist user.
  ///@param playlistId The playlist id.
  ///@param userId The user id.
  @Get(path: '/Playlists/{playlistId}/Users/{userId}')
  Future<chopper.Response<PlaylistUserPermissions>>
      _playlistsPlaylistIdUsersUserIdGet({
    @Path('playlistId') required String? playlistId,
    @Path('userId') required String? userId,
  });

  ///Modify a user of a playlist's users.
  ///@param playlistId The playlist id.
  ///@param userId The user id.
  Future<chopper.Response> playlistsPlaylistIdUsersUserIdPost({
    required String? playlistId,
    required String? userId,
    required UpdatePlaylistUserDto? body,
  }) {
    return _playlistsPlaylistIdUsersUserIdPost(
        playlistId: playlistId, userId: userId, body: body);
  }

  ///Modify a user of a playlist's users.
  ///@param playlistId The playlist id.
  ///@param userId The user id.
  @Post(
    path: '/Playlists/{playlistId}/Users/{userId}',
    optionalBody: true,
  )
  Future<chopper.Response> _playlistsPlaylistIdUsersUserIdPost({
    @Path('playlistId') required String? playlistId,
    @Path('userId') required String? userId,
    @Body() required UpdatePlaylistUserDto? body,
  });

  ///Remove a user from a playlist's users.
  ///@param playlistId The playlist id.
  ///@param userId The user id.
  Future<chopper.Response> playlistsPlaylistIdUsersUserIdDelete({
    required String? playlistId,
    required String? userId,
  }) {
    return _playlistsPlaylistIdUsersUserIdDelete(
        playlistId: playlistId, userId: userId);
  }

  ///Remove a user from a playlist's users.
  ///@param playlistId The playlist id.
  ///@param userId The user id.
  @Delete(path: '/Playlists/{playlistId}/Users/{userId}')
  Future<chopper.Response> _playlistsPlaylistIdUsersUserIdDelete({
    @Path('playlistId') required String? playlistId,
    @Path('userId') required String? userId,
  });

  ///Reports that a session has begun playing an item.
  ///@param itemId Item id.
  ///@param mediaSourceId The id of the MediaSource.
  ///@param audioStreamIndex The audio stream index.
  ///@param subtitleStreamIndex The subtitle stream index.
  ///@param playMethod The play method.
  ///@param liveStreamId The live stream id.
  ///@param playSessionId The play session id.
  ///@param canSeek Indicates if the client can seek.
  Future<chopper.Response> playingItemsItemIdPost({
    required String? itemId,
    String? mediaSourceId,
    int? audioStreamIndex,
    int? subtitleStreamIndex,
    enums.PlayingItemsItemIdPostPlayMethod? playMethod,
    String? liveStreamId,
    String? playSessionId,
    bool? canSeek,
  }) {
    return _playingItemsItemIdPost(
        itemId: itemId,
        mediaSourceId: mediaSourceId,
        audioStreamIndex: audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex,
        playMethod: playMethod?.value?.toString(),
        liveStreamId: liveStreamId,
        playSessionId: playSessionId,
        canSeek: canSeek);
  }

  ///Reports that a session has begun playing an item.
  ///@param itemId Item id.
  ///@param mediaSourceId The id of the MediaSource.
  ///@param audioStreamIndex The audio stream index.
  ///@param subtitleStreamIndex The subtitle stream index.
  ///@param playMethod The play method.
  ///@param liveStreamId The live stream id.
  ///@param playSessionId The play session id.
  ///@param canSeek Indicates if the client can seek.
  @Post(
    path: '/PlayingItems/{itemId}',
    optionalBody: true,
  )
  Future<chopper.Response> _playingItemsItemIdPost({
    @Path('itemId') required String? itemId,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('playMethod') String? playMethod,
    @Query('liveStreamId') String? liveStreamId,
    @Query('playSessionId') String? playSessionId,
    @Query('canSeek') bool? canSeek,
  });

  ///Reports that a session has stopped playing an item.
  ///@param itemId Item id.
  ///@param mediaSourceId The id of the MediaSource.
  ///@param nextMediaType The next media type that will play.
  ///@param positionTicks Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms.
  ///@param liveStreamId The live stream id.
  ///@param playSessionId The play session id.
  Future<chopper.Response> playingItemsItemIdDelete({
    required String? itemId,
    String? mediaSourceId,
    String? nextMediaType,
    int? positionTicks,
    String? liveStreamId,
    String? playSessionId,
  }) {
    return _playingItemsItemIdDelete(
        itemId: itemId,
        mediaSourceId: mediaSourceId,
        nextMediaType: nextMediaType,
        positionTicks: positionTicks,
        liveStreamId: liveStreamId,
        playSessionId: playSessionId);
  }

  ///Reports that a session has stopped playing an item.
  ///@param itemId Item id.
  ///@param mediaSourceId The id of the MediaSource.
  ///@param nextMediaType The next media type that will play.
  ///@param positionTicks Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms.
  ///@param liveStreamId The live stream id.
  ///@param playSessionId The play session id.
  @Delete(path: '/PlayingItems/{itemId}')
  Future<chopper.Response> _playingItemsItemIdDelete({
    @Path('itemId') required String? itemId,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('nextMediaType') String? nextMediaType,
    @Query('positionTicks') int? positionTicks,
    @Query('liveStreamId') String? liveStreamId,
    @Query('playSessionId') String? playSessionId,
  });

  ///Reports a session's playback progress.
  ///@param itemId Item id.
  ///@param mediaSourceId The id of the MediaSource.
  ///@param positionTicks Optional. The current position, in ticks. 1 tick = 10000 ms.
  ///@param audioStreamIndex The audio stream index.
  ///@param subtitleStreamIndex The subtitle stream index.
  ///@param volumeLevel Scale of 0-100.
  ///@param playMethod The play method.
  ///@param liveStreamId The live stream id.
  ///@param playSessionId The play session id.
  ///@param repeatMode The repeat mode.
  ///@param isPaused Indicates if the player is paused.
  ///@param isMuted Indicates if the player is muted.
  Future<chopper.Response> playingItemsItemIdProgressPost({
    required String? itemId,
    String? mediaSourceId,
    int? positionTicks,
    int? audioStreamIndex,
    int? subtitleStreamIndex,
    int? volumeLevel,
    enums.PlayingItemsItemIdProgressPostPlayMethod? playMethod,
    String? liveStreamId,
    String? playSessionId,
    enums.PlayingItemsItemIdProgressPostRepeatMode? repeatMode,
    bool? isPaused,
    bool? isMuted,
  }) {
    return _playingItemsItemIdProgressPost(
        itemId: itemId,
        mediaSourceId: mediaSourceId,
        positionTicks: positionTicks,
        audioStreamIndex: audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex,
        volumeLevel: volumeLevel,
        playMethod: playMethod?.value?.toString(),
        liveStreamId: liveStreamId,
        playSessionId: playSessionId,
        repeatMode: repeatMode?.value?.toString(),
        isPaused: isPaused,
        isMuted: isMuted);
  }

  ///Reports a session's playback progress.
  ///@param itemId Item id.
  ///@param mediaSourceId The id of the MediaSource.
  ///@param positionTicks Optional. The current position, in ticks. 1 tick = 10000 ms.
  ///@param audioStreamIndex The audio stream index.
  ///@param subtitleStreamIndex The subtitle stream index.
  ///@param volumeLevel Scale of 0-100.
  ///@param playMethod The play method.
  ///@param liveStreamId The live stream id.
  ///@param playSessionId The play session id.
  ///@param repeatMode The repeat mode.
  ///@param isPaused Indicates if the player is paused.
  ///@param isMuted Indicates if the player is muted.
  @Post(
    path: '/PlayingItems/{itemId}/Progress',
    optionalBody: true,
  )
  Future<chopper.Response> _playingItemsItemIdProgressPost({
    @Path('itemId') required String? itemId,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('positionTicks') int? positionTicks,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('volumeLevel') int? volumeLevel,
    @Query('playMethod') String? playMethod,
    @Query('liveStreamId') String? liveStreamId,
    @Query('playSessionId') String? playSessionId,
    @Query('repeatMode') String? repeatMode,
    @Query('isPaused') bool? isPaused,
    @Query('isMuted') bool? isMuted,
  });

  ///Reports playback has started within a session.
  Future<chopper.Response> sessionsPlayingPost(
      {required PlaybackStartInfo? body}) {
    return _sessionsPlayingPost(body: body);
  }

  ///Reports playback has started within a session.
  @Post(
    path: '/Sessions/Playing',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsPlayingPost(
      {@Body() required PlaybackStartInfo? body});

  ///Pings a playback session.
  ///@param playSessionId Playback session id.
  Future<chopper.Response> sessionsPlayingPingPost(
      {required String? playSessionId}) {
    return _sessionsPlayingPingPost(playSessionId: playSessionId);
  }

  ///Pings a playback session.
  ///@param playSessionId Playback session id.
  @Post(
    path: '/Sessions/Playing/Ping',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsPlayingPingPost(
      {@Query('playSessionId') required String? playSessionId});

  ///Reports playback progress within a session.
  Future<chopper.Response> sessionsPlayingProgressPost(
      {required PlaybackProgressInfo? body}) {
    return _sessionsPlayingProgressPost(body: body);
  }

  ///Reports playback progress within a session.
  @Post(
    path: '/Sessions/Playing/Progress',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsPlayingProgressPost(
      {@Body() required PlaybackProgressInfo? body});

  ///Reports playback has stopped within a session.
  Future<chopper.Response> sessionsPlayingStoppedPost(
      {required PlaybackStopInfo? body}) {
    return _sessionsPlayingStoppedPost(body: body);
  }

  ///Reports playback has stopped within a session.
  @Post(
    path: '/Sessions/Playing/Stopped',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsPlayingStoppedPost(
      {@Body() required PlaybackStopInfo? body});

  ///Marks an item as played for user.
  ///@param userId User id.
  ///@param itemId Item id.
  ///@param datePlayed Optional. The date the item was played.
  Future<chopper.Response<UserItemDataDto>> userPlayedItemsItemIdPost({
    String? userId,
    required String? itemId,
    DateTime? datePlayed,
  }) {
    generatedMapping.putIfAbsent(
        UserItemDataDto, () => UserItemDataDto.fromJsonFactory);

    return _userPlayedItemsItemIdPost(
        userId: userId, itemId: itemId, datePlayed: datePlayed);
  }

  ///Marks an item as played for user.
  ///@param userId User id.
  ///@param itemId Item id.
  ///@param datePlayed Optional. The date the item was played.
  @Post(
    path: '/UserPlayedItems/{itemId}',
    optionalBody: true,
  )
  Future<chopper.Response<UserItemDataDto>> _userPlayedItemsItemIdPost({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
    @Query('datePlayed') DateTime? datePlayed,
  });

  ///Marks an item as unplayed for user.
  ///@param userId User id.
  ///@param itemId Item id.
  Future<chopper.Response<UserItemDataDto>> userPlayedItemsItemIdDelete({
    String? userId,
    required String? itemId,
  }) {
    generatedMapping.putIfAbsent(
        UserItemDataDto, () => UserItemDataDto.fromJsonFactory);

    return _userPlayedItemsItemIdDelete(userId: userId, itemId: itemId);
  }

  ///Marks an item as unplayed for user.
  ///@param userId User id.
  ///@param itemId Item id.
  @Delete(path: '/UserPlayedItems/{itemId}')
  Future<chopper.Response<UserItemDataDto>> _userPlayedItemsItemIdDelete({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
  });

  ///Gets a list of currently installed plugins.
  Future<chopper.Response<List<PluginInfo>>> pluginsGet() {
    generatedMapping.putIfAbsent(PluginInfo, () => PluginInfo.fromJsonFactory);

    return _pluginsGet();
  }

  ///Gets a list of currently installed plugins.
  @Get(path: '/Plugins')
  Future<chopper.Response<List<PluginInfo>>> _pluginsGet();

  ///Uninstalls a plugin.
  ///@param pluginId Plugin id.
  @deprecated
  Future<chopper.Response> pluginsPluginIdDelete({required String? pluginId}) {
    return _pluginsPluginIdDelete(pluginId: pluginId);
  }

  ///Uninstalls a plugin.
  ///@param pluginId Plugin id.
  @deprecated
  @Delete(path: '/Plugins/{pluginId}')
  Future<chopper.Response> _pluginsPluginIdDelete(
      {@Path('pluginId') required String? pluginId});

  ///Uninstalls a plugin by version.
  ///@param pluginId Plugin id.
  ///@param version Plugin version.
  Future<chopper.Response> pluginsPluginIdVersionDelete({
    required String? pluginId,
    required String? version,
  }) {
    return _pluginsPluginIdVersionDelete(pluginId: pluginId, version: version);
  }

  ///Uninstalls a plugin by version.
  ///@param pluginId Plugin id.
  ///@param version Plugin version.
  @Delete(path: '/Plugins/{pluginId}/{version}')
  Future<chopper.Response> _pluginsPluginIdVersionDelete({
    @Path('pluginId') required String? pluginId,
    @Path('version') required String? version,
  });

  ///Disable a plugin.
  ///@param pluginId Plugin id.
  ///@param version Plugin version.
  Future<chopper.Response> pluginsPluginIdVersionDisablePost({
    required String? pluginId,
    required String? version,
  }) {
    return _pluginsPluginIdVersionDisablePost(
        pluginId: pluginId, version: version);
  }

  ///Disable a plugin.
  ///@param pluginId Plugin id.
  ///@param version Plugin version.
  @Post(
    path: '/Plugins/{pluginId}/{version}/Disable',
    optionalBody: true,
  )
  Future<chopper.Response> _pluginsPluginIdVersionDisablePost({
    @Path('pluginId') required String? pluginId,
    @Path('version') required String? version,
  });

  ///Enables a disabled plugin.
  ///@param pluginId Plugin id.
  ///@param version Plugin version.
  Future<chopper.Response> pluginsPluginIdVersionEnablePost({
    required String? pluginId,
    required String? version,
  }) {
    return _pluginsPluginIdVersionEnablePost(
        pluginId: pluginId, version: version);
  }

  ///Enables a disabled plugin.
  ///@param pluginId Plugin id.
  ///@param version Plugin version.
  @Post(
    path: '/Plugins/{pluginId}/{version}/Enable',
    optionalBody: true,
  )
  Future<chopper.Response> _pluginsPluginIdVersionEnablePost({
    @Path('pluginId') required String? pluginId,
    @Path('version') required String? version,
  });

  ///Gets a plugin's image.
  ///@param pluginId Plugin id.
  ///@param version Plugin version.
  Future<chopper.Response<String>> pluginsPluginIdVersionImageGet({
    required String? pluginId,
    required String? version,
  }) {
    return _pluginsPluginIdVersionImageGet(
        pluginId: pluginId, version: version);
  }

  ///Gets a plugin's image.
  ///@param pluginId Plugin id.
  ///@param version Plugin version.
  @Get(path: '/Plugins/{pluginId}/{version}/Image')
  Future<chopper.Response<String>> _pluginsPluginIdVersionImageGet({
    @Path('pluginId') required String? pluginId,
    @Path('version') required String? version,
  });

  ///Gets plugin configuration.
  ///@param pluginId Plugin id.
  Future<chopper.Response<BasePluginConfiguration>>
      pluginsPluginIdConfigurationGet({required String? pluginId}) {
    generatedMapping.putIfAbsent(
        BasePluginConfiguration, () => BasePluginConfiguration.fromJsonFactory);

    return _pluginsPluginIdConfigurationGet(pluginId: pluginId);
  }

  ///Gets plugin configuration.
  ///@param pluginId Plugin id.
  @Get(path: '/Plugins/{pluginId}/Configuration')
  Future<chopper.Response<BasePluginConfiguration>>
      _pluginsPluginIdConfigurationGet(
          {@Path('pluginId') required String? pluginId});

  ///Updates plugin configuration.
  ///@param pluginId Plugin id.
  Future<chopper.Response> pluginsPluginIdConfigurationPost(
      {required String? pluginId}) {
    return _pluginsPluginIdConfigurationPost(pluginId: pluginId);
  }

  ///Updates plugin configuration.
  ///@param pluginId Plugin id.
  @Post(
    path: '/Plugins/{pluginId}/Configuration',
    optionalBody: true,
  )
  Future<chopper.Response> _pluginsPluginIdConfigurationPost(
      {@Path('pluginId') required String? pluginId});

  ///Gets a plugin's manifest.
  ///@param pluginId Plugin id.
  Future<chopper.Response> pluginsPluginIdManifestPost(
      {required String? pluginId}) {
    return _pluginsPluginIdManifestPost(pluginId: pluginId);
  }

  ///Gets a plugin's manifest.
  ///@param pluginId Plugin id.
  @Post(
    path: '/Plugins/{pluginId}/Manifest',
    optionalBody: true,
  )
  Future<chopper.Response> _pluginsPluginIdManifestPost(
      {@Path('pluginId') required String? pluginId});

  ///Authorizes a pending quick connect request.
  ///@param code Quick connect code to authorize.
  ///@param userId The user the authorize. Access to the requested user is required.
  Future<chopper.Response<bool>> quickConnectAuthorizePost({
    required String? code,
    String? userId,
  }) {
    return _quickConnectAuthorizePost(code: code, userId: userId);
  }

  ///Authorizes a pending quick connect request.
  ///@param code Quick connect code to authorize.
  ///@param userId The user the authorize. Access to the requested user is required.
  @Post(
    path: '/QuickConnect/Authorize',
    optionalBody: true,
  )
  Future<chopper.Response<bool>> _quickConnectAuthorizePost({
    @Query('code') required String? code,
    @Query('userId') String? userId,
  });

  ///Attempts to retrieve authentication information.
  ///@param secret Secret previously returned from the Initiate endpoint.
  Future<chopper.Response<QuickConnectResult>> quickConnectConnectGet(
      {required String? secret}) {
    generatedMapping.putIfAbsent(
        QuickConnectResult, () => QuickConnectResult.fromJsonFactory);

    return _quickConnectConnectGet(secret: secret);
  }

  ///Attempts to retrieve authentication information.
  ///@param secret Secret previously returned from the Initiate endpoint.
  @Get(path: '/QuickConnect/Connect')
  Future<chopper.Response<QuickConnectResult>> _quickConnectConnectGet(
      {@Query('secret') required String? secret});

  ///Gets the current quick connect state.
  Future<chopper.Response<bool>> quickConnectEnabledGet() {
    return _quickConnectEnabledGet();
  }

  ///Gets the current quick connect state.
  @Get(path: '/QuickConnect/Enabled')
  Future<chopper.Response<bool>> _quickConnectEnabledGet();

  ///Initiate a new quick connect request.
  Future<chopper.Response<QuickConnectResult>> quickConnectInitiatePost() {
    generatedMapping.putIfAbsent(
        QuickConnectResult, () => QuickConnectResult.fromJsonFactory);

    return _quickConnectInitiatePost();
  }

  ///Initiate a new quick connect request.
  @Post(
    path: '/QuickConnect/Initiate',
    optionalBody: true,
  )
  Future<chopper.Response<QuickConnectResult>> _quickConnectInitiatePost();

  ///Gets available remote images for an item.
  ///@param itemId Item Id.
  ///@param type The image type.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param providerName Optional. The image provider to use.
  ///@param includeAllLanguages Optional. Include all languages.
  Future<chopper.Response<RemoteImageResult>> itemsItemIdRemoteImagesGet({
    required String? itemId,
    enums.ItemsItemIdRemoteImagesGetType? type,
    int? startIndex,
    int? limit,
    String? providerName,
    bool? includeAllLanguages,
  }) {
    generatedMapping.putIfAbsent(
        RemoteImageResult, () => RemoteImageResult.fromJsonFactory);

    return _itemsItemIdRemoteImagesGet(
        itemId: itemId,
        type: type?.value?.toString(),
        startIndex: startIndex,
        limit: limit,
        providerName: providerName,
        includeAllLanguages: includeAllLanguages);
  }

  ///Gets available remote images for an item.
  ///@param itemId Item Id.
  ///@param type The image type.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param providerName Optional. The image provider to use.
  ///@param includeAllLanguages Optional. Include all languages.
  @Get(path: '/Items/{itemId}/RemoteImages')
  Future<chopper.Response<RemoteImageResult>> _itemsItemIdRemoteImagesGet({
    @Path('itemId') required String? itemId,
    @Query('type') String? type,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('providerName') String? providerName,
    @Query('includeAllLanguages') bool? includeAllLanguages,
  });

  ///Downloads a remote image for an item.
  ///@param itemId Item Id.
  ///@param type The image type.
  ///@param imageUrl The image url.
  Future<chopper.Response> itemsItemIdRemoteImagesDownloadPost({
    required String? itemId,
    required enums.ItemsItemIdRemoteImagesDownloadPostType? type,
    String? imageUrl,
  }) {
    return _itemsItemIdRemoteImagesDownloadPost(
        itemId: itemId, type: type?.value?.toString(), imageUrl: imageUrl);
  }

  ///Downloads a remote image for an item.
  ///@param itemId Item Id.
  ///@param type The image type.
  ///@param imageUrl The image url.
  @Post(
    path: '/Items/{itemId}/RemoteImages/Download',
    optionalBody: true,
  )
  Future<chopper.Response> _itemsItemIdRemoteImagesDownloadPost({
    @Path('itemId') required String? itemId,
    @Query('type') required String? type,
    @Query('imageUrl') String? imageUrl,
  });

  ///Gets available remote image providers for an item.
  ///@param itemId Item Id.
  Future<chopper.Response<List<ImageProviderInfo>>>
      itemsItemIdRemoteImagesProvidersGet({required String? itemId}) {
    generatedMapping.putIfAbsent(
        ImageProviderInfo, () => ImageProviderInfo.fromJsonFactory);

    return _itemsItemIdRemoteImagesProvidersGet(itemId: itemId);
  }

  ///Gets available remote image providers for an item.
  ///@param itemId Item Id.
  @Get(path: '/Items/{itemId}/RemoteImages/Providers')
  Future<chopper.Response<List<ImageProviderInfo>>>
      _itemsItemIdRemoteImagesProvidersGet(
          {@Path('itemId') required String? itemId});

  ///Get tasks.
  ///@param isHidden Optional filter tasks that are hidden, or not.
  ///@param isEnabled Optional filter tasks that are enabled, or not.
  Future<chopper.Response<List<TaskInfo>>> scheduledTasksGet({
    bool? isHidden,
    bool? isEnabled,
  }) {
    generatedMapping.putIfAbsent(TaskInfo, () => TaskInfo.fromJsonFactory);

    return _scheduledTasksGet(isHidden: isHidden, isEnabled: isEnabled);
  }

  ///Get tasks.
  ///@param isHidden Optional filter tasks that are hidden, or not.
  ///@param isEnabled Optional filter tasks that are enabled, or not.
  @Get(path: '/ScheduledTasks')
  Future<chopper.Response<List<TaskInfo>>> _scheduledTasksGet({
    @Query('isHidden') bool? isHidden,
    @Query('isEnabled') bool? isEnabled,
  });

  ///Get task by id.
  ///@param taskId Task Id.
  Future<chopper.Response<TaskInfo>> scheduledTasksTaskIdGet(
      {required String? taskId}) {
    generatedMapping.putIfAbsent(TaskInfo, () => TaskInfo.fromJsonFactory);

    return _scheduledTasksTaskIdGet(taskId: taskId);
  }

  ///Get task by id.
  ///@param taskId Task Id.
  @Get(path: '/ScheduledTasks/{taskId}')
  Future<chopper.Response<TaskInfo>> _scheduledTasksTaskIdGet(
      {@Path('taskId') required String? taskId});

  ///Update specified task triggers.
  ///@param taskId Task Id.
  Future<chopper.Response> scheduledTasksTaskIdTriggersPost({
    required String? taskId,
    required List<TaskTriggerInfo>? body,
  }) {
    return _scheduledTasksTaskIdTriggersPost(taskId: taskId, body: body);
  }

  ///Update specified task triggers.
  ///@param taskId Task Id.
  @Post(
    path: '/ScheduledTasks/{taskId}/Triggers',
    optionalBody: true,
  )
  Future<chopper.Response> _scheduledTasksTaskIdTriggersPost({
    @Path('taskId') required String? taskId,
    @Body() required List<TaskTriggerInfo>? body,
  });

  ///Start specified task.
  ///@param taskId Task Id.
  Future<chopper.Response> scheduledTasksRunningTaskIdPost(
      {required String? taskId}) {
    return _scheduledTasksRunningTaskIdPost(taskId: taskId);
  }

  ///Start specified task.
  ///@param taskId Task Id.
  @Post(
    path: '/ScheduledTasks/Running/{taskId}',
    optionalBody: true,
  )
  Future<chopper.Response> _scheduledTasksRunningTaskIdPost(
      {@Path('taskId') required String? taskId});

  ///Stop specified task.
  ///@param taskId Task Id.
  Future<chopper.Response> scheduledTasksRunningTaskIdDelete(
      {required String? taskId}) {
    return _scheduledTasksRunningTaskIdDelete(taskId: taskId);
  }

  ///Stop specified task.
  ///@param taskId Task Id.
  @Delete(path: '/ScheduledTasks/Running/{taskId}')
  Future<chopper.Response> _scheduledTasksRunningTaskIdDelete(
      {@Path('taskId') required String? taskId});

  ///Gets the search hint result.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param userId Optional. Supply a user id to search within a user's library or omit to search all.
  ///@param searchTerm The search term to filter on.
  ///@param includeItemTypes If specified, only results with the specified item types are returned. This allows multiple, comma delimited.
  ///@param excludeItemTypes If specified, results with these item types are filtered out. This allows multiple, comma delimited.
  ///@param mediaTypes If specified, only results with the specified media types are returned. This allows multiple, comma delimited.
  ///@param parentId If specified, only children of the parent are returned.
  ///@param isMovie Optional filter for movies.
  ///@param isSeries Optional filter for series.
  ///@param isNews Optional filter for news.
  ///@param isKids Optional filter for kids.
  ///@param isSports Optional filter for sports.
  ///@param includePeople Optional filter whether to include people.
  ///@param includeMedia Optional filter whether to include media.
  ///@param includeGenres Optional filter whether to include genres.
  ///@param includeStudios Optional filter whether to include studios.
  ///@param includeArtists Optional filter whether to include artists.
  Future<chopper.Response<SearchHintResult>> searchHintsGet({
    int? startIndex,
    int? limit,
    String? userId,
    required String? searchTerm,
    List<enums.BaseItemKind>? includeItemTypes,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.MediaType>? mediaTypes,
    String? parentId,
    bool? isMovie,
    bool? isSeries,
    bool? isNews,
    bool? isKids,
    bool? isSports,
    bool? includePeople,
    bool? includeMedia,
    bool? includeGenres,
    bool? includeStudios,
    bool? includeArtists,
  }) {
    generatedMapping.putIfAbsent(
        SearchHintResult, () => SearchHintResult.fromJsonFactory);

    return _searchHintsGet(
        startIndex: startIndex,
        limit: limit,
        userId: userId,
        searchTerm: searchTerm,
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        mediaTypes: mediaTypeListToJson(mediaTypes),
        parentId: parentId,
        isMovie: isMovie,
        isSeries: isSeries,
        isNews: isNews,
        isKids: isKids,
        isSports: isSports,
        includePeople: includePeople,
        includeMedia: includeMedia,
        includeGenres: includeGenres,
        includeStudios: includeStudios,
        includeArtists: includeArtists);
  }

  ///Gets the search hint result.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param userId Optional. Supply a user id to search within a user's library or omit to search all.
  ///@param searchTerm The search term to filter on.
  ///@param includeItemTypes If specified, only results with the specified item types are returned. This allows multiple, comma delimited.
  ///@param excludeItemTypes If specified, results with these item types are filtered out. This allows multiple, comma delimited.
  ///@param mediaTypes If specified, only results with the specified media types are returned. This allows multiple, comma delimited.
  ///@param parentId If specified, only children of the parent are returned.
  ///@param isMovie Optional filter for movies.
  ///@param isSeries Optional filter for series.
  ///@param isNews Optional filter for news.
  ///@param isKids Optional filter for kids.
  ///@param isSports Optional filter for sports.
  ///@param includePeople Optional filter whether to include people.
  ///@param includeMedia Optional filter whether to include media.
  ///@param includeGenres Optional filter whether to include genres.
  ///@param includeStudios Optional filter whether to include studios.
  ///@param includeArtists Optional filter whether to include artists.
  @Get(path: '/Search/Hints')
  Future<chopper.Response<SearchHintResult>> _searchHintsGet({
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('userId') String? userId,
    @Query('searchTerm') required String? searchTerm,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('mediaTypes') List<Object?>? mediaTypes,
    @Query('parentId') String? parentId,
    @Query('isMovie') bool? isMovie,
    @Query('isSeries') bool? isSeries,
    @Query('isNews') bool? isNews,
    @Query('isKids') bool? isKids,
    @Query('isSports') bool? isSports,
    @Query('includePeople') bool? includePeople,
    @Query('includeMedia') bool? includeMedia,
    @Query('includeGenres') bool? includeGenres,
    @Query('includeStudios') bool? includeStudios,
    @Query('includeArtists') bool? includeArtists,
  });

  ///Get all password reset providers.
  Future<chopper.Response<List<NameIdPair>>> authPasswordResetProvidersGet() {
    generatedMapping.putIfAbsent(NameIdPair, () => NameIdPair.fromJsonFactory);

    return _authPasswordResetProvidersGet();
  }

  ///Get all password reset providers.
  @Get(path: '/Auth/PasswordResetProviders')
  Future<chopper.Response<List<NameIdPair>>> _authPasswordResetProvidersGet();

  ///Get all auth providers.
  Future<chopper.Response<List<NameIdPair>>> authProvidersGet() {
    generatedMapping.putIfAbsent(NameIdPair, () => NameIdPair.fromJsonFactory);

    return _authProvidersGet();
  }

  ///Get all auth providers.
  @Get(path: '/Auth/Providers')
  Future<chopper.Response<List<NameIdPair>>> _authProvidersGet();

  ///Gets a list of sessions.
  ///@param controllableByUserId Filter by sessions that a given user is allowed to remote control.
  ///@param deviceId Filter by device Id.
  ///@param activeWithinSeconds Optional. Filter by sessions that were active in the last n seconds.
  Future<chopper.Response<List<SessionInfoDto>>> sessionsGet({
    String? controllableByUserId,
    String? deviceId,
    int? activeWithinSeconds,
  }) {
    generatedMapping.putIfAbsent(
        SessionInfoDto, () => SessionInfoDto.fromJsonFactory);

    return _sessionsGet(
        controllableByUserId: controllableByUserId,
        deviceId: deviceId,
        activeWithinSeconds: activeWithinSeconds);
  }

  ///Gets a list of sessions.
  ///@param controllableByUserId Filter by sessions that a given user is allowed to remote control.
  ///@param deviceId Filter by device Id.
  ///@param activeWithinSeconds Optional. Filter by sessions that were active in the last n seconds.
  @Get(path: '/Sessions')
  Future<chopper.Response<List<SessionInfoDto>>> _sessionsGet({
    @Query('controllableByUserId') String? controllableByUserId,
    @Query('deviceId') String? deviceId,
    @Query('activeWithinSeconds') int? activeWithinSeconds,
  });

  ///Issues a full general command to a client.
  ///@param sessionId The session id.
  Future<chopper.Response> sessionsSessionIdCommandPost({
    required String? sessionId,
    required GeneralCommand? body,
  }) {
    return _sessionsSessionIdCommandPost(sessionId: sessionId, body: body);
  }

  ///Issues a full general command to a client.
  ///@param sessionId The session id.
  @Post(
    path: '/Sessions/{sessionId}/Command',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsSessionIdCommandPost({
    @Path('sessionId') required String? sessionId,
    @Body() required GeneralCommand? body,
  });

  ///Issues a general command to a client.
  ///@param sessionId The session id.
  ///@param command The command to send.
  Future<chopper.Response> sessionsSessionIdCommandCommandPost({
    required String? sessionId,
    required enums.SessionsSessionIdCommandCommandPostCommand? command,
  }) {
    return _sessionsSessionIdCommandCommandPost(
        sessionId: sessionId, command: command?.value?.toString());
  }

  ///Issues a general command to a client.
  ///@param sessionId The session id.
  ///@param command The command to send.
  @Post(
    path: '/Sessions/{sessionId}/Command/{command}',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsSessionIdCommandCommandPost({
    @Path('sessionId') required String? sessionId,
    @Path('command') required String? command,
  });

  ///Issues a command to a client to display a message to the user.
  ///@param sessionId The session id.
  Future<chopper.Response> sessionsSessionIdMessagePost({
    required String? sessionId,
    required MessageCommand? body,
  }) {
    return _sessionsSessionIdMessagePost(sessionId: sessionId, body: body);
  }

  ///Issues a command to a client to display a message to the user.
  ///@param sessionId The session id.
  @Post(
    path: '/Sessions/{sessionId}/Message',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsSessionIdMessagePost({
    @Path('sessionId') required String? sessionId,
    @Body() required MessageCommand? body,
  });

  ///Instructs a session to play an item.
  ///@param sessionId The session id.
  ///@param playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
  ///@param itemIds The ids of the items to play, comma delimited.
  ///@param startPositionTicks The starting position of the first item.
  ///@param mediaSourceId Optional. The media source id.
  ///@param audioStreamIndex Optional. The index of the audio stream to play.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to play.
  ///@param startIndex Optional. The start index.
  Future<chopper.Response> sessionsSessionIdPlayingPost({
    required String? sessionId,
    required enums.SessionsSessionIdPlayingPostPlayCommand? playCommand,
    required List<String>? itemIds,
    int? startPositionTicks,
    String? mediaSourceId,
    int? audioStreamIndex,
    int? subtitleStreamIndex,
    int? startIndex,
  }) {
    return _sessionsSessionIdPlayingPost(
        sessionId: sessionId,
        playCommand: playCommand?.value?.toString(),
        itemIds: itemIds,
        startPositionTicks: startPositionTicks,
        mediaSourceId: mediaSourceId,
        audioStreamIndex: audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex,
        startIndex: startIndex);
  }

  ///Instructs a session to play an item.
  ///@param sessionId The session id.
  ///@param playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
  ///@param itemIds The ids of the items to play, comma delimited.
  ///@param startPositionTicks The starting position of the first item.
  ///@param mediaSourceId Optional. The media source id.
  ///@param audioStreamIndex Optional. The index of the audio stream to play.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to play.
  ///@param startIndex Optional. The start index.
  @Post(
    path: '/Sessions/{sessionId}/Playing',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsSessionIdPlayingPost({
    @Path('sessionId') required String? sessionId,
    @Query('playCommand') required String? playCommand,
    @Query('itemIds') required List<String>? itemIds,
    @Query('startPositionTicks') int? startPositionTicks,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('startIndex') int? startIndex,
  });

  ///Issues a playstate command to a client.
  ///@param sessionId The session id.
  ///@param command The MediaBrowser.Model.Session.PlaystateCommand.
  ///@param seekPositionTicks The optional position ticks.
  ///@param controllingUserId The optional controlling user id.
  Future<chopper.Response> sessionsSessionIdPlayingCommandPost({
    required String? sessionId,
    required enums.SessionsSessionIdPlayingCommandPostCommand? command,
    int? seekPositionTicks,
    String? controllingUserId,
  }) {
    return _sessionsSessionIdPlayingCommandPost(
        sessionId: sessionId,
        command: command?.value?.toString(),
        seekPositionTicks: seekPositionTicks,
        controllingUserId: controllingUserId);
  }

  ///Issues a playstate command to a client.
  ///@param sessionId The session id.
  ///@param command The MediaBrowser.Model.Session.PlaystateCommand.
  ///@param seekPositionTicks The optional position ticks.
  ///@param controllingUserId The optional controlling user id.
  @Post(
    path: '/Sessions/{sessionId}/Playing/{command}',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsSessionIdPlayingCommandPost({
    @Path('sessionId') required String? sessionId,
    @Path('command') required String? command,
    @Query('seekPositionTicks') int? seekPositionTicks,
    @Query('controllingUserId') String? controllingUserId,
  });

  ///Issues a system command to a client.
  ///@param sessionId The session id.
  ///@param command The command to send.
  Future<chopper.Response> sessionsSessionIdSystemCommandPost({
    required String? sessionId,
    required enums.SessionsSessionIdSystemCommandPostCommand? command,
  }) {
    return _sessionsSessionIdSystemCommandPost(
        sessionId: sessionId, command: command?.value?.toString());
  }

  ///Issues a system command to a client.
  ///@param sessionId The session id.
  ///@param command The command to send.
  @Post(
    path: '/Sessions/{sessionId}/System/{command}',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsSessionIdSystemCommandPost({
    @Path('sessionId') required String? sessionId,
    @Path('command') required String? command,
  });

  ///Adds an additional user to a session.
  ///@param sessionId The session id.
  ///@param userId The user id.
  Future<chopper.Response> sessionsSessionIdUserUserIdPost({
    required String? sessionId,
    required String? userId,
  }) {
    return _sessionsSessionIdUserUserIdPost(
        sessionId: sessionId, userId: userId);
  }

  ///Adds an additional user to a session.
  ///@param sessionId The session id.
  ///@param userId The user id.
  @Post(
    path: '/Sessions/{sessionId}/User/{userId}',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsSessionIdUserUserIdPost({
    @Path('sessionId') required String? sessionId,
    @Path('userId') required String? userId,
  });

  ///Removes an additional user from a session.
  ///@param sessionId The session id.
  ///@param userId The user id.
  Future<chopper.Response> sessionsSessionIdUserUserIdDelete({
    required String? sessionId,
    required String? userId,
  }) {
    return _sessionsSessionIdUserUserIdDelete(
        sessionId: sessionId, userId: userId);
  }

  ///Removes an additional user from a session.
  ///@param sessionId The session id.
  ///@param userId The user id.
  @Delete(path: '/Sessions/{sessionId}/User/{userId}')
  Future<chopper.Response> _sessionsSessionIdUserUserIdDelete({
    @Path('sessionId') required String? sessionId,
    @Path('userId') required String? userId,
  });

  ///Instructs a session to browse to an item or view.
  ///@param sessionId The session Id.
  ///@param itemType The type of item to browse to.
  ///@param itemId The Id of the item.
  ///@param itemName The name of the item.
  Future<chopper.Response> sessionsSessionIdViewingPost({
    required String? sessionId,
    required enums.SessionsSessionIdViewingPostItemType? itemType,
    required String? itemId,
    required String? itemName,
  }) {
    return _sessionsSessionIdViewingPost(
        sessionId: sessionId,
        itemType: itemType?.value?.toString(),
        itemId: itemId,
        itemName: itemName);
  }

  ///Instructs a session to browse to an item or view.
  ///@param sessionId The session Id.
  ///@param itemType The type of item to browse to.
  ///@param itemId The Id of the item.
  ///@param itemName The name of the item.
  @Post(
    path: '/Sessions/{sessionId}/Viewing',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsSessionIdViewingPost({
    @Path('sessionId') required String? sessionId,
    @Query('itemType') required String? itemType,
    @Query('itemId') required String? itemId,
    @Query('itemName') required String? itemName,
  });

  ///Updates capabilities for a device.
  ///@param id The session id.
  ///@param playableMediaTypes A list of playable media types, comma delimited. Audio, Video, Book, Photo.
  ///@param supportedCommands A list of supported remote control commands, comma delimited.
  ///@param supportsMediaControl Determines whether media can be played remotely..
  ///@param supportsPersistentIdentifier Determines whether the device supports a unique identifier.
  Future<chopper.Response> sessionsCapabilitiesPost({
    String? id,
    List<enums.MediaType>? playableMediaTypes,
    List<enums.GeneralCommandType>? supportedCommands,
    bool? supportsMediaControl,
    bool? supportsPersistentIdentifier,
  }) {
    return _sessionsCapabilitiesPost(
        id: id,
        playableMediaTypes: mediaTypeListToJson(playableMediaTypes),
        supportedCommands: generalCommandTypeListToJson(supportedCommands),
        supportsMediaControl: supportsMediaControl,
        supportsPersistentIdentifier: supportsPersistentIdentifier);
  }

  ///Updates capabilities for a device.
  ///@param id The session id.
  ///@param playableMediaTypes A list of playable media types, comma delimited. Audio, Video, Book, Photo.
  ///@param supportedCommands A list of supported remote control commands, comma delimited.
  ///@param supportsMediaControl Determines whether media can be played remotely..
  ///@param supportsPersistentIdentifier Determines whether the device supports a unique identifier.
  @Post(
    path: '/Sessions/Capabilities',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsCapabilitiesPost({
    @Query('id') String? id,
    @Query('playableMediaTypes') List<Object?>? playableMediaTypes,
    @Query('supportedCommands') List<Object?>? supportedCommands,
    @Query('supportsMediaControl') bool? supportsMediaControl,
    @Query('supportsPersistentIdentifier') bool? supportsPersistentIdentifier,
  });

  ///Updates capabilities for a device.
  ///@param id The session id.
  Future<chopper.Response> sessionsCapabilitiesFullPost({
    String? id,
    required ClientCapabilitiesDto? body,
  }) {
    return _sessionsCapabilitiesFullPost(id: id, body: body);
  }

  ///Updates capabilities for a device.
  ///@param id The session id.
  @Post(
    path: '/Sessions/Capabilities/Full',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsCapabilitiesFullPost({
    @Query('id') String? id,
    @Body() required ClientCapabilitiesDto? body,
  });

  ///Reports that a session has ended.
  Future<chopper.Response> sessionsLogoutPost() {
    return _sessionsLogoutPost();
  }

  ///Reports that a session has ended.
  @Post(
    path: '/Sessions/Logout',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsLogoutPost();

  ///Reports that a session is viewing an item.
  ///@param sessionId The session id.
  ///@param itemId The item id.
  Future<chopper.Response> sessionsViewingPost({
    String? sessionId,
    required String? itemId,
  }) {
    return _sessionsViewingPost(sessionId: sessionId, itemId: itemId);
  }

  ///Reports that a session is viewing an item.
  ///@param sessionId The session id.
  ///@param itemId The item id.
  @Post(
    path: '/Sessions/Viewing',
    optionalBody: true,
  )
  Future<chopper.Response> _sessionsViewingPost({
    @Query('sessionId') String? sessionId,
    @Query('itemId') required String? itemId,
  });

  ///Completes the startup wizard.
  Future<chopper.Response> startupCompletePost() {
    return _startupCompletePost();
  }

  ///Completes the startup wizard.
  @Post(
    path: '/Startup/Complete',
    optionalBody: true,
  )
  Future<chopper.Response> _startupCompletePost();

  ///Gets the initial startup wizard configuration.
  Future<chopper.Response<StartupConfigurationDto>> startupConfigurationGet() {
    generatedMapping.putIfAbsent(
        StartupConfigurationDto, () => StartupConfigurationDto.fromJsonFactory);

    return _startupConfigurationGet();
  }

  ///Gets the initial startup wizard configuration.
  @Get(path: '/Startup/Configuration')
  Future<chopper.Response<StartupConfigurationDto>> _startupConfigurationGet();

  ///Sets the initial startup wizard configuration.
  Future<chopper.Response> startupConfigurationPost(
      {required StartupConfigurationDto? body}) {
    return _startupConfigurationPost(body: body);
  }

  ///Sets the initial startup wizard configuration.
  @Post(
    path: '/Startup/Configuration',
    optionalBody: true,
  )
  Future<chopper.Response> _startupConfigurationPost(
      {@Body() required StartupConfigurationDto? body});

  ///Gets the first user.
  Future<chopper.Response<StartupUserDto>> startupFirstUserGet() {
    generatedMapping.putIfAbsent(
        StartupUserDto, () => StartupUserDto.fromJsonFactory);

    return _startupFirstUserGet();
  }

  ///Gets the first user.
  @Get(path: '/Startup/FirstUser')
  Future<chopper.Response<StartupUserDto>> _startupFirstUserGet();

  ///Sets remote access and UPnP.
  Future<chopper.Response> startupRemoteAccessPost(
      {required StartupRemoteAccessDto? body}) {
    return _startupRemoteAccessPost(body: body);
  }

  ///Sets remote access and UPnP.
  @Post(
    path: '/Startup/RemoteAccess',
    optionalBody: true,
  )
  Future<chopper.Response> _startupRemoteAccessPost(
      {@Body() required StartupRemoteAccessDto? body});

  ///Gets the first user.
  Future<chopper.Response<StartupUserDto>> startupUserGet() {
    generatedMapping.putIfAbsent(
        StartupUserDto, () => StartupUserDto.fromJsonFactory);

    return _startupUserGet();
  }

  ///Gets the first user.
  @Get(path: '/Startup/User')
  Future<chopper.Response<StartupUserDto>> _startupUserGet();

  ///Sets the user name and password.
  Future<chopper.Response> startupUserPost({required StartupUserDto? body}) {
    return _startupUserPost(body: body);
  }

  ///Sets the user name and password.
  @Post(
    path: '/Startup/User',
    optionalBody: true,
  )
  Future<chopper.Response> _startupUserPost(
      {@Body() required StartupUserDto? body});

  ///Gets all studios from a given item, folder, or the entire library.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm Optional. Search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Total record count.
  Future<chopper.Response<BaseItemDtoQueryResult>> studiosGet({
    int? startIndex,
    int? limit,
    String? searchTerm,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.BaseItemKind>? includeItemTypes,
    bool? isFavorite,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    String? userId,
    String? nameStartsWithOrGreater,
    String? nameStartsWith,
    String? nameLessThan,
    bool? enableImages,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _studiosGet(
        startIndex: startIndex,
        limit: limit,
        searchTerm: searchTerm,
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        isFavorite: isFavorite,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        userId: userId,
        nameStartsWithOrGreater: nameStartsWithOrGreater,
        nameStartsWith: nameStartsWith,
        nameLessThan: nameLessThan,
        enableImages: enableImages,
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets all studios from a given item, folder, or the entire library.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param searchTerm Optional. Search term.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param userId User id.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param enableImages Optional, include image information in output.
  ///@param enableTotalRecordCount Total record count.
  @Get(path: '/Studios')
  Future<chopper.Response<BaseItemDtoQueryResult>> _studiosGet({
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('searchTerm') String? searchTerm,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('isFavorite') bool? isFavorite,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('userId') String? userId,
    @Query('nameStartsWithOrGreater') String? nameStartsWithOrGreater,
    @Query('nameStartsWith') String? nameStartsWith,
    @Query('nameLessThan') String? nameLessThan,
    @Query('enableImages') bool? enableImages,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Gets a studio by name.
  ///@param name Studio name.
  ///@param userId Optional. Filter by user id, and attach user data.
  Future<chopper.Response<BaseItemDto>> studiosNameGet({
    required String? name,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _studiosNameGet(name: name, userId: userId);
  }

  ///Gets a studio by name.
  ///@param name Studio name.
  ///@param userId Optional. Filter by user id, and attach user data.
  @Get(path: '/Studios/{name}')
  Future<chopper.Response<BaseItemDto>> _studiosNameGet({
    @Path('name') required String? name,
    @Query('userId') String? userId,
  });

  ///Gets a list of available fallback font files.
  Future<chopper.Response<List<FontFile>>> fallbackFontFontsGet() {
    generatedMapping.putIfAbsent(FontFile, () => FontFile.fromJsonFactory);

    return _fallbackFontFontsGet();
  }

  ///Gets a list of available fallback font files.
  @Get(path: '/FallbackFont/Fonts')
  Future<chopper.Response<List<FontFile>>> _fallbackFontFontsGet();

  ///Gets a fallback font file.
  ///@param name The name of the fallback font file to get.
  Future<chopper.Response<String>> fallbackFontFontsNameGet(
      {required String? name}) {
    return _fallbackFontFontsNameGet(name: name);
  }

  ///Gets a fallback font file.
  ///@param name The name of the fallback font file to get.
  @Get(path: '/FallbackFont/Fonts/{name}')
  Future<chopper.Response<String>> _fallbackFontFontsNameGet(
      {@Path('name') required String? name});

  ///Search remote subtitles.
  ///@param itemId The item id.
  ///@param language The language of the subtitles.
  ///@param isPerfectMatch Optional. Only show subtitles which are a perfect match.
  Future<chopper.Response<List<RemoteSubtitleInfo>>>
      itemsItemIdRemoteSearchSubtitlesLanguageGet({
    required String? itemId,
    required String? language,
    bool? isPerfectMatch,
  }) {
    generatedMapping.putIfAbsent(
        RemoteSubtitleInfo, () => RemoteSubtitleInfo.fromJsonFactory);

    return _itemsItemIdRemoteSearchSubtitlesLanguageGet(
        itemId: itemId, language: language, isPerfectMatch: isPerfectMatch);
  }

  ///Search remote subtitles.
  ///@param itemId The item id.
  ///@param language The language of the subtitles.
  ///@param isPerfectMatch Optional. Only show subtitles which are a perfect match.
  @Get(path: '/Items/{itemId}/RemoteSearch/Subtitles/{language}')
  Future<chopper.Response<List<RemoteSubtitleInfo>>>
      _itemsItemIdRemoteSearchSubtitlesLanguageGet({
    @Path('itemId') required String? itemId,
    @Path('language') required String? language,
    @Query('isPerfectMatch') bool? isPerfectMatch,
  });

  ///Downloads a remote subtitle.
  ///@param itemId The item id.
  ///@param subtitleId The subtitle id.
  Future<chopper.Response> itemsItemIdRemoteSearchSubtitlesSubtitleIdPost({
    required String? itemId,
    required String? subtitleId,
  }) {
    return _itemsItemIdRemoteSearchSubtitlesSubtitleIdPost(
        itemId: itemId, subtitleId: subtitleId);
  }

  ///Downloads a remote subtitle.
  ///@param itemId The item id.
  ///@param subtitleId The subtitle id.
  @Post(
    path: '/Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}',
    optionalBody: true,
  )
  Future<chopper.Response> _itemsItemIdRemoteSearchSubtitlesSubtitleIdPost({
    @Path('itemId') required String? itemId,
    @Path('subtitleId') required String? subtitleId,
  });

  ///Gets the remote subtitles.
  ///@param subtitleId The item id.
  Future<chopper.Response<String>> providersSubtitlesSubtitlesSubtitleIdGet(
      {required String? subtitleId}) {
    return _providersSubtitlesSubtitlesSubtitleIdGet(subtitleId: subtitleId);
  }

  ///Gets the remote subtitles.
  ///@param subtitleId The item id.
  @Get(path: '/Providers/Subtitles/Subtitles/{subtitleId}')
  Future<chopper.Response<String>> _providersSubtitlesSubtitlesSubtitleIdGet(
      {@Path('subtitleId') required String? subtitleId});

  ///Gets an HLS subtitle playlist.
  ///@param itemId The item id.
  ///@param index The subtitle stream index.
  ///@param mediaSourceId The media source id.
  ///@param segmentLength The subtitle segment length.
  Future<chopper.Response<String>>
      videosItemIdMediaSourceIdSubtitlesIndexSubtitlesM3u8Get({
    required String? itemId,
    required int? index,
    required String? mediaSourceId,
    required int? segmentLength,
  }) {
    return _videosItemIdMediaSourceIdSubtitlesIndexSubtitlesM3u8Get(
        itemId: itemId,
        index: index,
        mediaSourceId: mediaSourceId,
        segmentLength: segmentLength);
  }

  ///Gets an HLS subtitle playlist.
  ///@param itemId The item id.
  ///@param index The subtitle stream index.
  ///@param mediaSourceId The media source id.
  ///@param segmentLength The subtitle segment length.
  @Get(
      path: '/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8')
  Future<chopper.Response<String>>
      _videosItemIdMediaSourceIdSubtitlesIndexSubtitlesM3u8Get({
    @Path('itemId') required String? itemId,
    @Path('index') required int? index,
    @Path('mediaSourceId') required String? mediaSourceId,
    @Query('segmentLength') required int? segmentLength,
  });

  ///Upload an external subtitle file.
  ///@param itemId The item the subtitle belongs to.
  Future<chopper.Response> videosItemIdSubtitlesPost({
    required String? itemId,
    required UploadSubtitleDto? body,
  }) {
    return _videosItemIdSubtitlesPost(itemId: itemId, body: body);
  }

  ///Upload an external subtitle file.
  ///@param itemId The item the subtitle belongs to.
  @Post(
    path: '/Videos/{itemId}/Subtitles',
    optionalBody: true,
  )
  Future<chopper.Response> _videosItemIdSubtitlesPost({
    @Path('itemId') required String? itemId,
    @Body() required UploadSubtitleDto? body,
  });

  ///Deletes an external subtitle file.
  ///@param itemId The item id.
  ///@param index The index of the subtitle file.
  Future<chopper.Response> videosItemIdSubtitlesIndexDelete({
    required String? itemId,
    required int? index,
  }) {
    return _videosItemIdSubtitlesIndexDelete(itemId: itemId, index: index);
  }

  ///Deletes an external subtitle file.
  ///@param itemId The item id.
  ///@param index The index of the subtitle file.
  @Delete(path: '/Videos/{itemId}/Subtitles/{index}')
  Future<chopper.Response> _videosItemIdSubtitlesIndexDelete({
    @Path('itemId') required String? itemId,
    @Path('index') required int? index,
  });

  ///Gets subtitles in a specified format.
  ///@param routeItemId The (route) item id.
  ///@param routeMediaSourceId The (route) media source id.
  ///@param routeIndex The (route) subtitle stream index.
  ///@param routeStartPositionTicks The (route) start position of the subtitle in ticks.
  ///@param routeFormat The (route) format of the returned subtitle.
  ///@param itemId The item id.
  ///@param mediaSourceId The media source id.
  ///@param index The subtitle stream index.
  ///@param startPositionTicks The start position of the subtitle in ticks.
  ///@param format The format of the returned subtitle.
  ///@param endPositionTicks Optional. The end position of the subtitle in ticks.
  ///@param copyTimestamps Optional. Whether to copy the timestamps.
  ///@param addVttTimeMap Optional. Whether to add a VTT time map.
  Future<chopper.Response<String>>
      videosRouteItemIdRouteMediaSourceIdSubtitlesRouteIndexRouteStartPositionTicksStreamRouteFormatGet({
    required String? routeItemId,
    required String? routeMediaSourceId,
    required int? routeIndex,
    required int? routeStartPositionTicks,
    required String? routeFormat,
    String? itemId,
    String? mediaSourceId,
    int? index,
    int? startPositionTicks,
    String? format,
    int? endPositionTicks,
    bool? copyTimestamps,
    bool? addVttTimeMap,
  }) {
    return _videosRouteItemIdRouteMediaSourceIdSubtitlesRouteIndexRouteStartPositionTicksStreamRouteFormatGet(
        routeItemId: routeItemId,
        routeMediaSourceId: routeMediaSourceId,
        routeIndex: routeIndex,
        routeStartPositionTicks: routeStartPositionTicks,
        routeFormat: routeFormat,
        itemId: itemId,
        mediaSourceId: mediaSourceId,
        index: index,
        startPositionTicks: startPositionTicks,
        format: format,
        endPositionTicks: endPositionTicks,
        copyTimestamps: copyTimestamps,
        addVttTimeMap: addVttTimeMap);
  }

  ///Gets subtitles in a specified format.
  ///@param routeItemId The (route) item id.
  ///@param routeMediaSourceId The (route) media source id.
  ///@param routeIndex The (route) subtitle stream index.
  ///@param routeStartPositionTicks The (route) start position of the subtitle in ticks.
  ///@param routeFormat The (route) format of the returned subtitle.
  ///@param itemId The item id.
  ///@param mediaSourceId The media source id.
  ///@param index The subtitle stream index.
  ///@param startPositionTicks The start position of the subtitle in ticks.
  ///@param format The format of the returned subtitle.
  ///@param endPositionTicks Optional. The end position of the subtitle in ticks.
  ///@param copyTimestamps Optional. Whether to copy the timestamps.
  ///@param addVttTimeMap Optional. Whether to add a VTT time map.
  @Get(
      path:
          '/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/{routeStartPositionTicks}/Stream.{routeFormat}')
  Future<chopper.Response<String>>
      _videosRouteItemIdRouteMediaSourceIdSubtitlesRouteIndexRouteStartPositionTicksStreamRouteFormatGet({
    @Path('routeItemId') required String? routeItemId,
    @Path('routeMediaSourceId') required String? routeMediaSourceId,
    @Path('routeIndex') required int? routeIndex,
    @Path('routeStartPositionTicks') required int? routeStartPositionTicks,
    @Path('routeFormat') required String? routeFormat,
    @Query('itemId') String? itemId,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('index') int? index,
    @Query('startPositionTicks') int? startPositionTicks,
    @Query('format') String? format,
    @Query('endPositionTicks') int? endPositionTicks,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('addVttTimeMap') bool? addVttTimeMap,
  });

  ///Gets subtitles in a specified format.
  ///@param routeItemId The (route) item id.
  ///@param routeMediaSourceId The (route) media source id.
  ///@param routeIndex The (route) subtitle stream index.
  ///@param routeFormat The (route) format of the returned subtitle.
  ///@param itemId The item id.
  ///@param mediaSourceId The media source id.
  ///@param index The subtitle stream index.
  ///@param format The format of the returned subtitle.
  ///@param endPositionTicks Optional. The end position of the subtitle in ticks.
  ///@param copyTimestamps Optional. Whether to copy the timestamps.
  ///@param addVttTimeMap Optional. Whether to add a VTT time map.
  ///@param startPositionTicks The start position of the subtitle in ticks.
  Future<chopper.Response<String>>
      videosRouteItemIdRouteMediaSourceIdSubtitlesRouteIndexStreamRouteFormatGet({
    required String? routeItemId,
    required String? routeMediaSourceId,
    required int? routeIndex,
    required String? routeFormat,
    String? itemId,
    String? mediaSourceId,
    int? index,
    String? format,
    int? endPositionTicks,
    bool? copyTimestamps,
    bool? addVttTimeMap,
    int? startPositionTicks,
  }) {
    return _videosRouteItemIdRouteMediaSourceIdSubtitlesRouteIndexStreamRouteFormatGet(
        routeItemId: routeItemId,
        routeMediaSourceId: routeMediaSourceId,
        routeIndex: routeIndex,
        routeFormat: routeFormat,
        itemId: itemId,
        mediaSourceId: mediaSourceId,
        index: index,
        format: format,
        endPositionTicks: endPositionTicks,
        copyTimestamps: copyTimestamps,
        addVttTimeMap: addVttTimeMap,
        startPositionTicks: startPositionTicks);
  }

  ///Gets subtitles in a specified format.
  ///@param routeItemId The (route) item id.
  ///@param routeMediaSourceId The (route) media source id.
  ///@param routeIndex The (route) subtitle stream index.
  ///@param routeFormat The (route) format of the returned subtitle.
  ///@param itemId The item id.
  ///@param mediaSourceId The media source id.
  ///@param index The subtitle stream index.
  ///@param format The format of the returned subtitle.
  ///@param endPositionTicks Optional. The end position of the subtitle in ticks.
  ///@param copyTimestamps Optional. Whether to copy the timestamps.
  ///@param addVttTimeMap Optional. Whether to add a VTT time map.
  ///@param startPositionTicks The start position of the subtitle in ticks.
  @Get(
      path:
          '/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/Stream.{routeFormat}')
  Future<chopper.Response<String>>
      _videosRouteItemIdRouteMediaSourceIdSubtitlesRouteIndexStreamRouteFormatGet({
    @Path('routeItemId') required String? routeItemId,
    @Path('routeMediaSourceId') required String? routeMediaSourceId,
    @Path('routeIndex') required int? routeIndex,
    @Path('routeFormat') required String? routeFormat,
    @Query('itemId') String? itemId,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('index') int? index,
    @Query('format') String? format,
    @Query('endPositionTicks') int? endPositionTicks,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('addVttTimeMap') bool? addVttTimeMap,
    @Query('startPositionTicks') int? startPositionTicks,
  });

  ///Gets suggestions.
  ///@param userId The user id.
  ///@param mediaType The media types.
  ///@param type The type.
  ///@param startIndex Optional. The start index.
  ///@param limit Optional. The limit.
  ///@param enableTotalRecordCount Whether to enable the total record count.
  Future<chopper.Response<BaseItemDtoQueryResult>> itemsSuggestionsGet({
    String? userId,
    List<enums.MediaType>? mediaType,
    List<enums.BaseItemKind>? type,
    int? startIndex,
    int? limit,
    bool? enableTotalRecordCount,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _itemsSuggestionsGet(
        userId: userId,
        mediaType: mediaTypeListToJson(mediaType),
        type: baseItemKindListToJson(type),
        startIndex: startIndex,
        limit: limit,
        enableTotalRecordCount: enableTotalRecordCount);
  }

  ///Gets suggestions.
  ///@param userId The user id.
  ///@param mediaType The media types.
  ///@param type The type.
  ///@param startIndex Optional. The start index.
  ///@param limit Optional. The limit.
  ///@param enableTotalRecordCount Whether to enable the total record count.
  @Get(path: '/Items/Suggestions')
  Future<chopper.Response<BaseItemDtoQueryResult>> _itemsSuggestionsGet({
    @Query('userId') String? userId,
    @Query('mediaType') List<Object?>? mediaType,
    @Query('type') List<Object?>? type,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
  });

  ///Notify SyncPlay group that member is buffering.
  Future<chopper.Response> syncPlayBufferingPost(
      {required BufferRequestDto? body}) {
    return _syncPlayBufferingPost(body: body);
  }

  ///Notify SyncPlay group that member is buffering.
  @Post(
    path: '/SyncPlay/Buffering',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayBufferingPost(
      {@Body() required BufferRequestDto? body});

  ///Join an existing SyncPlay group.
  Future<chopper.Response> syncPlayJoinPost(
      {required JoinGroupRequestDto? body}) {
    return _syncPlayJoinPost(body: body);
  }

  ///Join an existing SyncPlay group.
  @Post(
    path: '/SyncPlay/Join',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayJoinPost(
      {@Body() required JoinGroupRequestDto? body});

  ///Leave the joined SyncPlay group.
  Future<chopper.Response> syncPlayLeavePost() {
    return _syncPlayLeavePost();
  }

  ///Leave the joined SyncPlay group.
  @Post(
    path: '/SyncPlay/Leave',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayLeavePost();

  ///Gets all SyncPlay groups.
  Future<chopper.Response<List<GroupInfoDto>>> syncPlayListGet() {
    generatedMapping.putIfAbsent(
        GroupInfoDto, () => GroupInfoDto.fromJsonFactory);

    return _syncPlayListGet();
  }

  ///Gets all SyncPlay groups.
  @Get(path: '/SyncPlay/List')
  Future<chopper.Response<List<GroupInfoDto>>> _syncPlayListGet();

  ///Request to move an item in the playlist in SyncPlay group.
  Future<chopper.Response> syncPlayMovePlaylistItemPost(
      {required MovePlaylistItemRequestDto? body}) {
    return _syncPlayMovePlaylistItemPost(body: body);
  }

  ///Request to move an item in the playlist in SyncPlay group.
  @Post(
    path: '/SyncPlay/MovePlaylistItem',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayMovePlaylistItemPost(
      {@Body() required MovePlaylistItemRequestDto? body});

  ///Create a new SyncPlay group.
  Future<chopper.Response> syncPlayNewPost(
      {required NewGroupRequestDto? body}) {
    return _syncPlayNewPost(body: body);
  }

  ///Create a new SyncPlay group.
  @Post(
    path: '/SyncPlay/New',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayNewPost(
      {@Body() required NewGroupRequestDto? body});

  ///Request next item in SyncPlay group.
  Future<chopper.Response> syncPlayNextItemPost(
      {required NextItemRequestDto? body}) {
    return _syncPlayNextItemPost(body: body);
  }

  ///Request next item in SyncPlay group.
  @Post(
    path: '/SyncPlay/NextItem',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayNextItemPost(
      {@Body() required NextItemRequestDto? body});

  ///Request pause in SyncPlay group.
  Future<chopper.Response> syncPlayPausePost() {
    return _syncPlayPausePost();
  }

  ///Request pause in SyncPlay group.
  @Post(
    path: '/SyncPlay/Pause',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayPausePost();

  ///Update session ping.
  Future<chopper.Response> syncPlayPingPost({required PingRequestDto? body}) {
    return _syncPlayPingPost(body: body);
  }

  ///Update session ping.
  @Post(
    path: '/SyncPlay/Ping',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayPingPost(
      {@Body() required PingRequestDto? body});

  ///Request previous item in SyncPlay group.
  Future<chopper.Response> syncPlayPreviousItemPost(
      {required PreviousItemRequestDto? body}) {
    return _syncPlayPreviousItemPost(body: body);
  }

  ///Request previous item in SyncPlay group.
  @Post(
    path: '/SyncPlay/PreviousItem',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayPreviousItemPost(
      {@Body() required PreviousItemRequestDto? body});

  ///Request to queue items to the playlist of a SyncPlay group.
  Future<chopper.Response> syncPlayQueuePost({required QueueRequestDto? body}) {
    return _syncPlayQueuePost(body: body);
  }

  ///Request to queue items to the playlist of a SyncPlay group.
  @Post(
    path: '/SyncPlay/Queue',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayQueuePost(
      {@Body() required QueueRequestDto? body});

  ///Notify SyncPlay group that member is ready for playback.
  Future<chopper.Response> syncPlayReadyPost({required ReadyRequestDto? body}) {
    return _syncPlayReadyPost(body: body);
  }

  ///Notify SyncPlay group that member is ready for playback.
  @Post(
    path: '/SyncPlay/Ready',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayReadyPost(
      {@Body() required ReadyRequestDto? body});

  ///Request to remove items from the playlist in SyncPlay group.
  Future<chopper.Response> syncPlayRemoveFromPlaylistPost(
      {required RemoveFromPlaylistRequestDto? body}) {
    return _syncPlayRemoveFromPlaylistPost(body: body);
  }

  ///Request to remove items from the playlist in SyncPlay group.
  @Post(
    path: '/SyncPlay/RemoveFromPlaylist',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayRemoveFromPlaylistPost(
      {@Body() required RemoveFromPlaylistRequestDto? body});

  ///Request seek in SyncPlay group.
  Future<chopper.Response> syncPlaySeekPost({required SeekRequestDto? body}) {
    return _syncPlaySeekPost(body: body);
  }

  ///Request seek in SyncPlay group.
  @Post(
    path: '/SyncPlay/Seek',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlaySeekPost(
      {@Body() required SeekRequestDto? body});

  ///Request SyncPlay group to ignore member during group-wait.
  Future<chopper.Response> syncPlaySetIgnoreWaitPost(
      {required IgnoreWaitRequestDto? body}) {
    return _syncPlaySetIgnoreWaitPost(body: body);
  }

  ///Request SyncPlay group to ignore member during group-wait.
  @Post(
    path: '/SyncPlay/SetIgnoreWait',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlaySetIgnoreWaitPost(
      {@Body() required IgnoreWaitRequestDto? body});

  ///Request to set new playlist in SyncPlay group.
  Future<chopper.Response> syncPlaySetNewQueuePost(
      {required PlayRequestDto? body}) {
    return _syncPlaySetNewQueuePost(body: body);
  }

  ///Request to set new playlist in SyncPlay group.
  @Post(
    path: '/SyncPlay/SetNewQueue',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlaySetNewQueuePost(
      {@Body() required PlayRequestDto? body});

  ///Request to change playlist item in SyncPlay group.
  Future<chopper.Response> syncPlaySetPlaylistItemPost(
      {required SetPlaylistItemRequestDto? body}) {
    return _syncPlaySetPlaylistItemPost(body: body);
  }

  ///Request to change playlist item in SyncPlay group.
  @Post(
    path: '/SyncPlay/SetPlaylistItem',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlaySetPlaylistItemPost(
      {@Body() required SetPlaylistItemRequestDto? body});

  ///Request to set repeat mode in SyncPlay group.
  Future<chopper.Response> syncPlaySetRepeatModePost(
      {required SetRepeatModeRequestDto? body}) {
    return _syncPlaySetRepeatModePost(body: body);
  }

  ///Request to set repeat mode in SyncPlay group.
  @Post(
    path: '/SyncPlay/SetRepeatMode',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlaySetRepeatModePost(
      {@Body() required SetRepeatModeRequestDto? body});

  ///Request to set shuffle mode in SyncPlay group.
  Future<chopper.Response> syncPlaySetShuffleModePost(
      {required SetShuffleModeRequestDto? body}) {
    return _syncPlaySetShuffleModePost(body: body);
  }

  ///Request to set shuffle mode in SyncPlay group.
  @Post(
    path: '/SyncPlay/SetShuffleMode',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlaySetShuffleModePost(
      {@Body() required SetShuffleModeRequestDto? body});

  ///Request stop in SyncPlay group.
  Future<chopper.Response> syncPlayStopPost() {
    return _syncPlayStopPost();
  }

  ///Request stop in SyncPlay group.
  @Post(
    path: '/SyncPlay/Stop',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayStopPost();

  ///Request unpause in SyncPlay group.
  Future<chopper.Response> syncPlayUnpausePost() {
    return _syncPlayUnpausePost();
  }

  ///Request unpause in SyncPlay group.
  @Post(
    path: '/SyncPlay/Unpause',
    optionalBody: true,
  )
  Future<chopper.Response> _syncPlayUnpausePost();

  ///Gets information about the request endpoint.
  Future<chopper.Response<EndPointInfo>> systemEndpointGet() {
    generatedMapping.putIfAbsent(
        EndPointInfo, () => EndPointInfo.fromJsonFactory);

    return _systemEndpointGet();
  }

  ///Gets information about the request endpoint.
  @Get(path: '/System/Endpoint')
  Future<chopper.Response<EndPointInfo>> _systemEndpointGet();

  ///Gets information about the server.
  Future<chopper.Response<SystemInfo>> systemInfoGet() {
    generatedMapping.putIfAbsent(SystemInfo, () => SystemInfo.fromJsonFactory);

    return _systemInfoGet();
  }

  ///Gets information about the server.
  @Get(path: '/System/Info')
  Future<chopper.Response<SystemInfo>> _systemInfoGet();

  ///Gets public information about the server.
  Future<chopper.Response<PublicSystemInfo>> systemInfoPublicGet() {
    generatedMapping.putIfAbsent(
        PublicSystemInfo, () => PublicSystemInfo.fromJsonFactory);

    return _systemInfoPublicGet();
  }

  ///Gets public information about the server.
  @Get(path: '/System/Info/Public')
  Future<chopper.Response<PublicSystemInfo>> _systemInfoPublicGet();

  ///Gets a list of available server log files.
  Future<chopper.Response<List<LogFile>>> systemLogsGet() {
    generatedMapping.putIfAbsent(LogFile, () => LogFile.fromJsonFactory);

    return _systemLogsGet();
  }

  ///Gets a list of available server log files.
  @Get(path: '/System/Logs')
  Future<chopper.Response<List<LogFile>>> _systemLogsGet();

  ///Gets a log file.
  ///@param name The name of the log file to get.
  Future<chopper.Response<String>> systemLogsLogGet({required String? name}) {
    return _systemLogsLogGet(name: name);
  }

  ///Gets a log file.
  ///@param name The name of the log file to get.
  @Get(path: '/System/Logs/Log')
  Future<chopper.Response<String>> _systemLogsLogGet(
      {@Query('name') required String? name});

  ///Pings the system.
  Future<chopper.Response<String>> systemPingGet() {
    return _systemPingGet();
  }

  ///Pings the system.
  @Get(path: '/System/Ping')
  Future<chopper.Response<String>> _systemPingGet();

  ///Pings the system.
  Future<chopper.Response<String>> systemPingPost() {
    return _systemPingPost();
  }

  ///Pings the system.
  @Post(
    path: '/System/Ping',
    optionalBody: true,
  )
  Future<chopper.Response<String>> _systemPingPost();

  ///Restarts the application.
  Future<chopper.Response> systemRestartPost() {
    return _systemRestartPost();
  }

  ///Restarts the application.
  @Post(
    path: '/System/Restart',
    optionalBody: true,
  )
  Future<chopper.Response> _systemRestartPost();

  ///Shuts down the application.
  Future<chopper.Response> systemShutdownPost() {
    return _systemShutdownPost();
  }

  ///Shuts down the application.
  @Post(
    path: '/System/Shutdown',
    optionalBody: true,
  )
  Future<chopper.Response> _systemShutdownPost();

  ///Gets wake on lan information.
  @deprecated
  Future<chopper.Response<List<WakeOnLanInfo>>> systemWakeOnLanInfoGet() {
    generatedMapping.putIfAbsent(
        WakeOnLanInfo, () => WakeOnLanInfo.fromJsonFactory);

    return _systemWakeOnLanInfoGet();
  }

  ///Gets wake on lan information.
  @deprecated
  @Get(path: '/System/WakeOnLanInfo')
  Future<chopper.Response<List<WakeOnLanInfo>>> _systemWakeOnLanInfoGet();

  ///Gets the current UTC time.
  Future<chopper.Response<UtcTimeResponse>> getUtcTimeGet() {
    generatedMapping.putIfAbsent(
        UtcTimeResponse, () => UtcTimeResponse.fromJsonFactory);

    return _getUtcTimeGet();
  }

  ///Gets the current UTC time.
  @Get(path: '/GetUtcTime')
  Future<chopper.Response<UtcTimeResponse>> _getUtcTimeGet();

  ///Gets the TMDb image configuration options.
  Future<chopper.Response<ConfigImageTypes>> tmdbClientConfigurationGet() {
    generatedMapping.putIfAbsent(
        ConfigImageTypes, () => ConfigImageTypes.fromJsonFactory);

    return _tmdbClientConfigurationGet();
  }

  ///Gets the TMDb image configuration options.
  @Get(path: '/Tmdb/ClientConfiguration')
  Future<chopper.Response<ConfigImageTypes>> _tmdbClientConfigurationGet();

  ///Finds movies and trailers similar to a given trailer.
  ///@param userId The user id supplied as query parameter; this is required when not using an API key.
  ///@param maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
  ///@param hasThemeSong Optional filter by items with theme songs.
  ///@param hasThemeVideo Optional filter by items with theme videos.
  ///@param hasSubtitles Optional filter by items with subtitles.
  ///@param hasSpecialFeature Optional filter by items with special features.
  ///@param hasTrailer Optional filter by items with trailers.
  ///@param adjacentTo Optional. Return items that are siblings of a supplied item.
  ///@param parentIndexNumber Optional filter by parent index number.
  ///@param hasParentalRating Optional filter by items that have or do not have a parental rating.
  ///@param isHd Optional filter by items that are HD or not.
  ///@param is4K Optional filter by items that are 4K or not.
  ///@param locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
  ///@param excludeLocationTypes Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
  ///@param isMissing Optional filter by items that are missing episodes or not.
  ///@param isUnaired Optional filter by items that are unaired episodes or not.
  ///@param minCommunityRating Optional filter by minimum community rating.
  ///@param minCriticRating Optional filter by minimum critic rating.
  ///@param minPremiereDate Optional. The minimum premiere date. Format = ISO.
  ///@param minDateLastSaved Optional. The minimum last saved date. Format = ISO.
  ///@param minDateLastSavedForUser Optional. The minimum last saved date for the current user. Format = ISO.
  ///@param maxPremiereDate Optional. The maximum premiere date. Format = ISO.
  ///@param hasOverview Optional filter by items that have an overview or not.
  ///@param hasImdbId Optional filter by items that have an IMDb id or not.
  ///@param hasTmdbId Optional filter by items that have a TMDb id or not.
  ///@param hasTvdbId Optional filter by items that have a TVDb id or not.
  ///@param isMovie Optional filter for live tv movies.
  ///@param isSeries Optional filter for live tv series.
  ///@param isNews Optional filter for live tv news.
  ///@param isKids Optional filter for live tv kids.
  ///@param isSports Optional filter for live tv sports.
  ///@param excludeItemIds Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param recursive When searching within folders, this determines whether or not the search will be recursive. true/false.
  ///@param searchTerm Optional. Filter based on a search term.
  ///@param sortOrder Sort Order - Ascending, Descending.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
  ///@param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param filters Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
  ///@param imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param isPlayed Optional filter by items that are played, or not.
  ///@param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
  ///@param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
  ///@param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
  ///@param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param person Optional. If specified, results will be filtered to include only those containing the specified person.
  ///@param personIds Optional. If specified, results will be filtered to include only those containing the specified person id.
  ///@param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
  ///@param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
  ///@param artists Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
  ///@param excludeArtistIds Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
  ///@param artistIds Optional. If specified, results will be filtered to include only those containing the specified artist id.
  ///@param albumArtistIds Optional. If specified, results will be filtered to include only those containing the specified album artist id.
  ///@param contributingArtistIds Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
  ///@param albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
  ///@param albumIds Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
  ///@param ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
  ///@param videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
  ///@param minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
  ///@param isLocked Optional filter by items that are locked.
  ///@param isPlaceHolder Optional filter by items that are placeholders.
  ///@param hasOfficialRating Optional filter by items that have official ratings.
  ///@param collapseBoxSetItems Whether or not to hide items behind their boxsets.
  ///@param minWidth Optional. Filter by the minimum width of the item.
  ///@param minHeight Optional. Filter by the minimum height of the item.
  ///@param maxWidth Optional. Filter by the maximum width of the item.
  ///@param maxHeight Optional. Filter by the maximum height of the item.
  ///@param is3D Optional filter by items that are 3D, or not.
  ///@param seriesStatus Optional filter by Series Status. Allows multiple, comma delimited.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
  ///@param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
  ///@param enableTotalRecordCount Optional. Enable the total record count.
  ///@param enableImages Optional, include image information in output.
  Future<chopper.Response<BaseItemDtoQueryResult>> trailersGet({
    String? userId,
    String? maxOfficialRating,
    bool? hasThemeSong,
    bool? hasThemeVideo,
    bool? hasSubtitles,
    bool? hasSpecialFeature,
    bool? hasTrailer,
    String? adjacentTo,
    int? parentIndexNumber,
    bool? hasParentalRating,
    bool? isHd,
    bool? is4K,
    List<enums.LocationType>? locationTypes,
    List<enums.LocationType>? excludeLocationTypes,
    bool? isMissing,
    bool? isUnaired,
    num? minCommunityRating,
    num? minCriticRating,
    DateTime? minPremiereDate,
    DateTime? minDateLastSaved,
    DateTime? minDateLastSavedForUser,
    DateTime? maxPremiereDate,
    bool? hasOverview,
    bool? hasImdbId,
    bool? hasTmdbId,
    bool? hasTvdbId,
    bool? isMovie,
    bool? isSeries,
    bool? isNews,
    bool? isKids,
    bool? isSports,
    List<String>? excludeItemIds,
    int? startIndex,
    int? limit,
    bool? recursive,
    String? searchTerm,
    List<enums.SortOrder>? sortOrder,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.ItemFilter>? filters,
    bool? isFavorite,
    List<enums.MediaType>? mediaTypes,
    List<enums.ImageType>? imageTypes,
    List<enums.ItemSortBy>? sortBy,
    bool? isPlayed,
    List<String>? genres,
    List<String>? officialRatings,
    List<String>? tags,
    List<int>? years,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    String? person,
    List<String>? personIds,
    List<String>? personTypes,
    List<String>? studios,
    List<String>? artists,
    List<String>? excludeArtistIds,
    List<String>? artistIds,
    List<String>? albumArtistIds,
    List<String>? contributingArtistIds,
    List<String>? albums,
    List<String>? albumIds,
    List<String>? ids,
    List<enums.VideoType>? videoTypes,
    String? minOfficialRating,
    bool? isLocked,
    bool? isPlaceHolder,
    bool? hasOfficialRating,
    bool? collapseBoxSetItems,
    int? minWidth,
    int? minHeight,
    int? maxWidth,
    int? maxHeight,
    bool? is3D,
    List<enums.SeriesStatus>? seriesStatus,
    String? nameStartsWithOrGreater,
    String? nameStartsWith,
    String? nameLessThan,
    List<String>? studioIds,
    List<String>? genreIds,
    bool? enableTotalRecordCount,
    bool? enableImages,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _trailersGet(
        userId: userId,
        maxOfficialRating: maxOfficialRating,
        hasThemeSong: hasThemeSong,
        hasThemeVideo: hasThemeVideo,
        hasSubtitles: hasSubtitles,
        hasSpecialFeature: hasSpecialFeature,
        hasTrailer: hasTrailer,
        adjacentTo: adjacentTo,
        parentIndexNumber: parentIndexNumber,
        hasParentalRating: hasParentalRating,
        isHd: isHd,
        is4K: is4K,
        locationTypes: locationTypeListToJson(locationTypes),
        excludeLocationTypes: locationTypeListToJson(excludeLocationTypes),
        isMissing: isMissing,
        isUnaired: isUnaired,
        minCommunityRating: minCommunityRating,
        minCriticRating: minCriticRating,
        minPremiereDate: minPremiereDate,
        minDateLastSaved: minDateLastSaved,
        minDateLastSavedForUser: minDateLastSavedForUser,
        maxPremiereDate: maxPremiereDate,
        hasOverview: hasOverview,
        hasImdbId: hasImdbId,
        hasTmdbId: hasTmdbId,
        hasTvdbId: hasTvdbId,
        isMovie: isMovie,
        isSeries: isSeries,
        isNews: isNews,
        isKids: isKids,
        isSports: isSports,
        excludeItemIds: excludeItemIds,
        startIndex: startIndex,
        limit: limit,
        recursive: recursive,
        searchTerm: searchTerm,
        sortOrder: sortOrderListToJson(sortOrder),
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        filters: itemFilterListToJson(filters),
        isFavorite: isFavorite,
        mediaTypes: mediaTypeListToJson(mediaTypes),
        imageTypes: imageTypeListToJson(imageTypes),
        sortBy: itemSortByListToJson(sortBy),
        isPlayed: isPlayed,
        genres: genres,
        officialRatings: officialRatings,
        tags: tags,
        years: years,
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        person: person,
        personIds: personIds,
        personTypes: personTypes,
        studios: studios,
        artists: artists,
        excludeArtistIds: excludeArtistIds,
        artistIds: artistIds,
        albumArtistIds: albumArtistIds,
        contributingArtistIds: contributingArtistIds,
        albums: albums,
        albumIds: albumIds,
        ids: ids,
        videoTypes: videoTypeListToJson(videoTypes),
        minOfficialRating: minOfficialRating,
        isLocked: isLocked,
        isPlaceHolder: isPlaceHolder,
        hasOfficialRating: hasOfficialRating,
        collapseBoxSetItems: collapseBoxSetItems,
        minWidth: minWidth,
        minHeight: minHeight,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        is3D: is3D,
        seriesStatus: seriesStatusListToJson(seriesStatus),
        nameStartsWithOrGreater: nameStartsWithOrGreater,
        nameStartsWith: nameStartsWith,
        nameLessThan: nameLessThan,
        studioIds: studioIds,
        genreIds: genreIds,
        enableTotalRecordCount: enableTotalRecordCount,
        enableImages: enableImages);
  }

  ///Finds movies and trailers similar to a given trailer.
  ///@param userId The user id supplied as query parameter; this is required when not using an API key.
  ///@param maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
  ///@param hasThemeSong Optional filter by items with theme songs.
  ///@param hasThemeVideo Optional filter by items with theme videos.
  ///@param hasSubtitles Optional filter by items with subtitles.
  ///@param hasSpecialFeature Optional filter by items with special features.
  ///@param hasTrailer Optional filter by items with trailers.
  ///@param adjacentTo Optional. Return items that are siblings of a supplied item.
  ///@param parentIndexNumber Optional filter by parent index number.
  ///@param hasParentalRating Optional filter by items that have or do not have a parental rating.
  ///@param isHd Optional filter by items that are HD or not.
  ///@param is4K Optional filter by items that are 4K or not.
  ///@param locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
  ///@param excludeLocationTypes Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
  ///@param isMissing Optional filter by items that are missing episodes or not.
  ///@param isUnaired Optional filter by items that are unaired episodes or not.
  ///@param minCommunityRating Optional filter by minimum community rating.
  ///@param minCriticRating Optional filter by minimum critic rating.
  ///@param minPremiereDate Optional. The minimum premiere date. Format = ISO.
  ///@param minDateLastSaved Optional. The minimum last saved date. Format = ISO.
  ///@param minDateLastSavedForUser Optional. The minimum last saved date for the current user. Format = ISO.
  ///@param maxPremiereDate Optional. The maximum premiere date. Format = ISO.
  ///@param hasOverview Optional filter by items that have an overview or not.
  ///@param hasImdbId Optional filter by items that have an IMDb id or not.
  ///@param hasTmdbId Optional filter by items that have a TMDb id or not.
  ///@param hasTvdbId Optional filter by items that have a TVDb id or not.
  ///@param isMovie Optional filter for live tv movies.
  ///@param isSeries Optional filter for live tv series.
  ///@param isNews Optional filter for live tv news.
  ///@param isKids Optional filter for live tv kids.
  ///@param isSports Optional filter for live tv sports.
  ///@param excludeItemIds Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param recursive When searching within folders, this determines whether or not the search will be recursive. true/false.
  ///@param searchTerm Optional. Filter based on a search term.
  ///@param sortOrder Sort Order - Ascending, Descending.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
  ///@param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param filters Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
  ///@param isFavorite Optional filter by items that are marked as favorite, or not.
  ///@param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
  ///@param imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param isPlayed Optional filter by items that are played, or not.
  ///@param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
  ///@param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
  ///@param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
  ///@param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
  ///@param enableUserData Optional, include user data.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param person Optional. If specified, results will be filtered to include only those containing the specified person.
  ///@param personIds Optional. If specified, results will be filtered to include only those containing the specified person id.
  ///@param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
  ///@param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
  ///@param artists Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
  ///@param excludeArtistIds Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
  ///@param artistIds Optional. If specified, results will be filtered to include only those containing the specified artist id.
  ///@param albumArtistIds Optional. If specified, results will be filtered to include only those containing the specified album artist id.
  ///@param contributingArtistIds Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
  ///@param albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
  ///@param albumIds Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
  ///@param ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
  ///@param videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
  ///@param minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
  ///@param isLocked Optional filter by items that are locked.
  ///@param isPlaceHolder Optional filter by items that are placeholders.
  ///@param hasOfficialRating Optional filter by items that have official ratings.
  ///@param collapseBoxSetItems Whether or not to hide items behind their boxsets.
  ///@param minWidth Optional. Filter by the minimum width of the item.
  ///@param minHeight Optional. Filter by the minimum height of the item.
  ///@param maxWidth Optional. Filter by the maximum width of the item.
  ///@param maxHeight Optional. Filter by the maximum height of the item.
  ///@param is3D Optional filter by items that are 3D, or not.
  ///@param seriesStatus Optional filter by Series Status. Allows multiple, comma delimited.
  ///@param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
  ///@param nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
  ///@param nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
  ///@param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
  ///@param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
  ///@param enableTotalRecordCount Optional. Enable the total record count.
  ///@param enableImages Optional, include image information in output.
  @Get(path: '/Trailers')
  Future<chopper.Response<BaseItemDtoQueryResult>> _trailersGet({
    @Query('userId') String? userId,
    @Query('maxOfficialRating') String? maxOfficialRating,
    @Query('hasThemeSong') bool? hasThemeSong,
    @Query('hasThemeVideo') bool? hasThemeVideo,
    @Query('hasSubtitles') bool? hasSubtitles,
    @Query('hasSpecialFeature') bool? hasSpecialFeature,
    @Query('hasTrailer') bool? hasTrailer,
    @Query('adjacentTo') String? adjacentTo,
    @Query('parentIndexNumber') int? parentIndexNumber,
    @Query('hasParentalRating') bool? hasParentalRating,
    @Query('isHd') bool? isHd,
    @Query('is4K') bool? is4K,
    @Query('locationTypes') List<Object?>? locationTypes,
    @Query('excludeLocationTypes') List<Object?>? excludeLocationTypes,
    @Query('isMissing') bool? isMissing,
    @Query('isUnaired') bool? isUnaired,
    @Query('minCommunityRating') num? minCommunityRating,
    @Query('minCriticRating') num? minCriticRating,
    @Query('minPremiereDate') DateTime? minPremiereDate,
    @Query('minDateLastSaved') DateTime? minDateLastSaved,
    @Query('minDateLastSavedForUser') DateTime? minDateLastSavedForUser,
    @Query('maxPremiereDate') DateTime? maxPremiereDate,
    @Query('hasOverview') bool? hasOverview,
    @Query('hasImdbId') bool? hasImdbId,
    @Query('hasTmdbId') bool? hasTmdbId,
    @Query('hasTvdbId') bool? hasTvdbId,
    @Query('isMovie') bool? isMovie,
    @Query('isSeries') bool? isSeries,
    @Query('isNews') bool? isNews,
    @Query('isKids') bool? isKids,
    @Query('isSports') bool? isSports,
    @Query('excludeItemIds') List<String>? excludeItemIds,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('recursive') bool? recursive,
    @Query('searchTerm') String? searchTerm,
    @Query('sortOrder') List<Object?>? sortOrder,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('filters') List<Object?>? filters,
    @Query('isFavorite') bool? isFavorite,
    @Query('mediaTypes') List<Object?>? mediaTypes,
    @Query('imageTypes') List<Object?>? imageTypes,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('isPlayed') bool? isPlayed,
    @Query('genres') List<String>? genres,
    @Query('officialRatings') List<String>? officialRatings,
    @Query('tags') List<String>? tags,
    @Query('years') List<int>? years,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('person') String? person,
    @Query('personIds') List<String>? personIds,
    @Query('personTypes') List<String>? personTypes,
    @Query('studios') List<String>? studios,
    @Query('artists') List<String>? artists,
    @Query('excludeArtistIds') List<String>? excludeArtistIds,
    @Query('artistIds') List<String>? artistIds,
    @Query('albumArtistIds') List<String>? albumArtistIds,
    @Query('contributingArtistIds') List<String>? contributingArtistIds,
    @Query('albums') List<String>? albums,
    @Query('albumIds') List<String>? albumIds,
    @Query('ids') List<String>? ids,
    @Query('videoTypes') List<Object?>? videoTypes,
    @Query('minOfficialRating') String? minOfficialRating,
    @Query('isLocked') bool? isLocked,
    @Query('isPlaceHolder') bool? isPlaceHolder,
    @Query('hasOfficialRating') bool? hasOfficialRating,
    @Query('collapseBoxSetItems') bool? collapseBoxSetItems,
    @Query('minWidth') int? minWidth,
    @Query('minHeight') int? minHeight,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('is3D') bool? is3D,
    @Query('seriesStatus') List<Object?>? seriesStatus,
    @Query('nameStartsWithOrGreater') String? nameStartsWithOrGreater,
    @Query('nameStartsWith') String? nameStartsWith,
    @Query('nameLessThan') String? nameLessThan,
    @Query('studioIds') List<String>? studioIds,
    @Query('genreIds') List<String>? genreIds,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
    @Query('enableImages') bool? enableImages,
  });

  ///Gets a trickplay tile image.
  ///@param itemId The item id.
  ///@param width The width of a single tile.
  ///@param index The index of the desired tile.
  ///@param mediaSourceId The media version id, if using an alternate version.
  Future<chopper.Response<String>> videosItemIdTrickplayWidthIndexJpgGet({
    required String? itemId,
    required int? width,
    required int? index,
    String? mediaSourceId,
  }) {
    return _videosItemIdTrickplayWidthIndexJpgGet(
        itemId: itemId,
        width: width,
        index: index,
        mediaSourceId: mediaSourceId);
  }

  ///Gets a trickplay tile image.
  ///@param itemId The item id.
  ///@param width The width of a single tile.
  ///@param index The index of the desired tile.
  ///@param mediaSourceId The media version id, if using an alternate version.
  @Get(path: '/Videos/{itemId}/Trickplay/{width}/{index}.jpg')
  Future<chopper.Response<String>> _videosItemIdTrickplayWidthIndexJpgGet({
    @Path('itemId') required String? itemId,
    @Path('width') required int? width,
    @Path('index') required int? index,
    @Query('mediaSourceId') String? mediaSourceId,
  });

  ///Gets an image tiles playlist for trickplay.
  ///@param itemId The item id.
  ///@param width The width of a single tile.
  ///@param mediaSourceId The media version id, if using an alternate version.
  Future<chopper.Response<String>> videosItemIdTrickplayWidthTilesM3u8Get({
    required String? itemId,
    required int? width,
    String? mediaSourceId,
  }) {
    return _videosItemIdTrickplayWidthTilesM3u8Get(
        itemId: itemId, width: width, mediaSourceId: mediaSourceId);
  }

  ///Gets an image tiles playlist for trickplay.
  ///@param itemId The item id.
  ///@param width The width of a single tile.
  ///@param mediaSourceId The media version id, if using an alternate version.
  @Get(path: '/Videos/{itemId}/Trickplay/{width}/tiles.m3u8')
  Future<chopper.Response<String>> _videosItemIdTrickplayWidthTilesM3u8Get({
    @Path('itemId') required String? itemId,
    @Path('width') required int? width,
    @Query('mediaSourceId') String? mediaSourceId,
  });

  ///Gets episodes for a tv season.
  ///@param seriesId The series id.
  ///@param userId The user id.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  ///@param season Optional filter by season number.
  ///@param seasonId Optional. Filter by season id.
  ///@param isMissing Optional. Filter by items that are missing episodes or not.
  ///@param adjacentTo Optional. Return items that are siblings of a supplied item.
  ///@param startItemId Optional. Skip through the list until a given item is found.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param enableImages Optional, include image information in output.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  Future<chopper.Response<BaseItemDtoQueryResult>> showsSeriesIdEpisodesGet({
    required String? seriesId,
    String? userId,
    List<enums.ItemFields>? fields,
    int? season,
    String? seasonId,
    bool? isMissing,
    String? adjacentTo,
    String? startItemId,
    int? startIndex,
    int? limit,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    bool? enableUserData,
    enums.ShowsSeriesIdEpisodesGetSortBy? sortBy,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _showsSeriesIdEpisodesGet(
        seriesId: seriesId,
        userId: userId,
        fields: itemFieldsListToJson(fields),
        season: season,
        seasonId: seasonId,
        isMissing: isMissing,
        adjacentTo: adjacentTo,
        startItemId: startItemId,
        startIndex: startIndex,
        limit: limit,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        enableUserData: enableUserData,
        sortBy: sortBy?.value?.toString());
  }

  ///Gets episodes for a tv season.
  ///@param seriesId The series id.
  ///@param userId The user id.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  ///@param season Optional filter by season number.
  ///@param seasonId Optional. Filter by season id.
  ///@param isMissing Optional. Filter by items that are missing episodes or not.
  ///@param adjacentTo Optional. Return items that are siblings of a supplied item.
  ///@param startItemId Optional. Skip through the list until a given item is found.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param enableImages Optional, include image information in output.
  ///@param imageTypeLimit Optional, the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  @Get(path: '/Shows/{seriesId}/Episodes')
  Future<chopper.Response<BaseItemDtoQueryResult>> _showsSeriesIdEpisodesGet({
    @Path('seriesId') required String? seriesId,
    @Query('userId') String? userId,
    @Query('fields') List<Object?>? fields,
    @Query('season') int? season,
    @Query('seasonId') String? seasonId,
    @Query('isMissing') bool? isMissing,
    @Query('adjacentTo') String? adjacentTo,
    @Query('startItemId') String? startItemId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('enableUserData') bool? enableUserData,
    @Query('sortBy') String? sortBy,
  });

  ///Gets seasons for a tv series.
  ///@param seriesId The series id.
  ///@param userId The user id.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  ///@param isSpecialSeason Optional. Filter by special season.
  ///@param isMissing Optional. Filter by items that are missing episodes or not.
  ///@param adjacentTo Optional. Return items that are siblings of a supplied item.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  Future<chopper.Response<BaseItemDtoQueryResult>> showsSeriesIdSeasonsGet({
    required String? seriesId,
    String? userId,
    List<enums.ItemFields>? fields,
    bool? isSpecialSeason,
    bool? isMissing,
    String? adjacentTo,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    bool? enableUserData,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _showsSeriesIdSeasonsGet(
        seriesId: seriesId,
        userId: userId,
        fields: itemFieldsListToJson(fields),
        isSpecialSeason: isSpecialSeason,
        isMissing: isMissing,
        adjacentTo: adjacentTo,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        enableUserData: enableUserData);
  }

  ///Gets seasons for a tv series.
  ///@param seriesId The series id.
  ///@param userId The user id.
  ///@param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
  ///@param isSpecialSeason Optional. Filter by special season.
  ///@param isMissing Optional. Filter by items that are missing episodes or not.
  ///@param adjacentTo Optional. Return items that are siblings of a supplied item.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  @Get(path: '/Shows/{seriesId}/Seasons')
  Future<chopper.Response<BaseItemDtoQueryResult>> _showsSeriesIdSeasonsGet({
    @Path('seriesId') required String? seriesId,
    @Query('userId') String? userId,
    @Query('fields') List<Object?>? fields,
    @Query('isSpecialSeason') bool? isSpecialSeason,
    @Query('isMissing') bool? isMissing,
    @Query('adjacentTo') String? adjacentTo,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('enableUserData') bool? enableUserData,
  });

  ///Gets a list of next up episodes.
  ///@param userId The user id of the user to get the next up episodes for.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param seriesId Optional. Filter by series id.
  ///@param parentId Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param nextUpDateCutoff Optional. Starting date of shows to show in Next Up section.
  ///@param enableTotalRecordCount Whether to enable the total records count. Defaults to true.
  ///@param disableFirstEpisode Whether to disable sending the first episode in a series as next up.
  ///@param enableResumable Whether to include resumable episodes in next up results.
  ///@param enableRewatching Whether to include watched episodes in next up results.
  Future<chopper.Response<BaseItemDtoQueryResult>> showsNextUpGet({
    String? userId,
    int? startIndex,
    int? limit,
    List<enums.ItemFields>? fields,
    String? seriesId,
    String? parentId,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    bool? enableUserData,
    DateTime? nextUpDateCutoff,
    bool? enableTotalRecordCount,
    bool? disableFirstEpisode,
    bool? enableResumable,
    bool? enableRewatching,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _showsNextUpGet(
        userId: userId,
        startIndex: startIndex,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        seriesId: seriesId,
        parentId: parentId,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        enableUserData: enableUserData,
        nextUpDateCutoff: nextUpDateCutoff,
        enableTotalRecordCount: enableTotalRecordCount,
        disableFirstEpisode: disableFirstEpisode,
        enableResumable: enableResumable,
        enableRewatching: enableRewatching);
  }

  ///Gets a list of next up episodes.
  ///@param userId The user id of the user to get the next up episodes for.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param seriesId Optional. Filter by series id.
  ///@param parentId Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  ///@param nextUpDateCutoff Optional. Starting date of shows to show in Next Up section.
  ///@param enableTotalRecordCount Whether to enable the total records count. Defaults to true.
  ///@param disableFirstEpisode Whether to disable sending the first episode in a series as next up.
  ///@param enableResumable Whether to include resumable episodes in next up results.
  ///@param enableRewatching Whether to include watched episodes in next up results.
  @Get(path: '/Shows/NextUp')
  Future<chopper.Response<BaseItemDtoQueryResult>> _showsNextUpGet({
    @Query('userId') String? userId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('seriesId') String? seriesId,
    @Query('parentId') String? parentId,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('enableUserData') bool? enableUserData,
    @Query('nextUpDateCutoff') DateTime? nextUpDateCutoff,
    @Query('enableTotalRecordCount') bool? enableTotalRecordCount,
    @Query('disableFirstEpisode') bool? disableFirstEpisode,
    @Query('enableResumable') bool? enableResumable,
    @Query('enableRewatching') bool? enableRewatching,
  });

  ///Gets a list of upcoming episodes.
  ///@param userId The user id of the user to get the upcoming episodes for.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param parentId Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  Future<chopper.Response<BaseItemDtoQueryResult>> showsUpcomingGet({
    String? userId,
    int? startIndex,
    int? limit,
    List<enums.ItemFields>? fields,
    String? parentId,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    bool? enableUserData,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _showsUpcomingGet(
        userId: userId,
        startIndex: startIndex,
        limit: limit,
        fields: itemFieldsListToJson(fields),
        parentId: parentId,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        enableUserData: enableUserData);
  }

  ///Gets a list of upcoming episodes.
  ///@param userId The user id of the user to get the upcoming episodes for.
  ///@param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
  ///@param limit Optional. The maximum number of records to return.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param parentId Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param enableImages Optional. Include image information in output.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. Include user data.
  @Get(path: '/Shows/Upcoming')
  Future<chopper.Response<BaseItemDtoQueryResult>> _showsUpcomingGet({
    @Query('userId') String? userId,
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('fields') List<Object?>? fields,
    @Query('parentId') String? parentId,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('enableUserData') bool? enableUserData,
  });

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container Optional. The audio container.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param userId Optional. The user id.
  ///@param audioCodec Optional. The audio codec to transcode to.
  ///@param maxAudioChannels Optional. The maximum number of audio channels.
  ///@param transcodingAudioChannels Optional. The number of how many audio channels to transcode to.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param transcodingContainer Optional. The container to transcode to.
  ///@param transcodingProtocol Optional. The transcoding protocol.
  ///@param maxAudioSampleRate Optional. The maximum audio sample rate.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param enableRemoteMedia Optional. Whether to enable remote media.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param enableRedirection Whether to enable redirection. Defaults to true.
  Future<chopper.Response<String>> audioItemIdUniversalGet({
    required String? itemId,
    List<String>? container,
    String? mediaSourceId,
    String? deviceId,
    String? userId,
    String? audioCodec,
    int? maxAudioChannels,
    int? transcodingAudioChannels,
    int? maxStreamingBitrate,
    int? audioBitRate,
    int? startTimeTicks,
    String? transcodingContainer,
    enums.AudioItemIdUniversalGetTranscodingProtocol? transcodingProtocol,
    int? maxAudioSampleRate,
    int? maxAudioBitDepth,
    bool? enableRemoteMedia,
    bool? enableAudioVbrEncoding,
    bool? breakOnNonKeyFrames,
    bool? enableRedirection,
  }) {
    return _audioItemIdUniversalGet(
        itemId: itemId,
        container: container,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        userId: userId,
        audioCodec: audioCodec,
        maxAudioChannels: maxAudioChannels,
        transcodingAudioChannels: transcodingAudioChannels,
        maxStreamingBitrate: maxStreamingBitrate,
        audioBitRate: audioBitRate,
        startTimeTicks: startTimeTicks,
        transcodingContainer: transcodingContainer,
        transcodingProtocol: transcodingProtocol?.value?.toString(),
        maxAudioSampleRate: maxAudioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        enableRemoteMedia: enableRemoteMedia,
        enableAudioVbrEncoding: enableAudioVbrEncoding,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        enableRedirection: enableRedirection);
  }

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container Optional. The audio container.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param userId Optional. The user id.
  ///@param audioCodec Optional. The audio codec to transcode to.
  ///@param maxAudioChannels Optional. The maximum number of audio channels.
  ///@param transcodingAudioChannels Optional. The number of how many audio channels to transcode to.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param transcodingContainer Optional. The container to transcode to.
  ///@param transcodingProtocol Optional. The transcoding protocol.
  ///@param maxAudioSampleRate Optional. The maximum audio sample rate.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param enableRemoteMedia Optional. Whether to enable remote media.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param enableRedirection Whether to enable redirection. Defaults to true.
  @Get(path: '/Audio/{itemId}/universal')
  Future<chopper.Response<String>> _audioItemIdUniversalGet({
    @Path('itemId') required String? itemId,
    @Query('container') List<String>? container,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('userId') String? userId,
    @Query('audioCodec') String? audioCodec,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('transcodingAudioChannels') int? transcodingAudioChannels,
    @Query('maxStreamingBitrate') int? maxStreamingBitrate,
    @Query('audioBitRate') int? audioBitRate,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('transcodingContainer') String? transcodingContainer,
    @Query('transcodingProtocol') String? transcodingProtocol,
    @Query('maxAudioSampleRate') int? maxAudioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('enableRemoteMedia') bool? enableRemoteMedia,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('enableRedirection') bool? enableRedirection,
  });

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container Optional. The audio container.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param userId Optional. The user id.
  ///@param audioCodec Optional. The audio codec to transcode to.
  ///@param maxAudioChannels Optional. The maximum number of audio channels.
  ///@param transcodingAudioChannels Optional. The number of how many audio channels to transcode to.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param transcodingContainer Optional. The container to transcode to.
  ///@param transcodingProtocol Optional. The transcoding protocol.
  ///@param maxAudioSampleRate Optional. The maximum audio sample rate.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param enableRemoteMedia Optional. Whether to enable remote media.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param enableRedirection Whether to enable redirection. Defaults to true.
  Future<chopper.Response<String>> audioItemIdUniversalHead({
    required String? itemId,
    List<String>? container,
    String? mediaSourceId,
    String? deviceId,
    String? userId,
    String? audioCodec,
    int? maxAudioChannels,
    int? transcodingAudioChannels,
    int? maxStreamingBitrate,
    int? audioBitRate,
    int? startTimeTicks,
    String? transcodingContainer,
    enums.AudioItemIdUniversalHeadTranscodingProtocol? transcodingProtocol,
    int? maxAudioSampleRate,
    int? maxAudioBitDepth,
    bool? enableRemoteMedia,
    bool? enableAudioVbrEncoding,
    bool? breakOnNonKeyFrames,
    bool? enableRedirection,
  }) {
    return _audioItemIdUniversalHead(
        itemId: itemId,
        container: container,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        userId: userId,
        audioCodec: audioCodec,
        maxAudioChannels: maxAudioChannels,
        transcodingAudioChannels: transcodingAudioChannels,
        maxStreamingBitrate: maxStreamingBitrate,
        audioBitRate: audioBitRate,
        startTimeTicks: startTimeTicks,
        transcodingContainer: transcodingContainer,
        transcodingProtocol: transcodingProtocol?.value?.toString(),
        maxAudioSampleRate: maxAudioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        enableRemoteMedia: enableRemoteMedia,
        enableAudioVbrEncoding: enableAudioVbrEncoding,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        enableRedirection: enableRedirection);
  }

  ///Gets an audio stream.
  ///@param itemId The item id.
  ///@param container Optional. The audio container.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param userId Optional. The user id.
  ///@param audioCodec Optional. The audio codec to transcode to.
  ///@param maxAudioChannels Optional. The maximum number of audio channels.
  ///@param transcodingAudioChannels Optional. The number of how many audio channels to transcode to.
  ///@param maxStreamingBitrate Optional. The maximum streaming bitrate.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param transcodingContainer Optional. The container to transcode to.
  ///@param transcodingProtocol Optional. The transcoding protocol.
  ///@param maxAudioSampleRate Optional. The maximum audio sample rate.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param enableRemoteMedia Optional. Whether to enable remote media.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param enableRedirection Whether to enable redirection. Defaults to true.
  @Head(path: '/Audio/{itemId}/universal')
  Future<chopper.Response<String>> _audioItemIdUniversalHead({
    @Path('itemId') required String? itemId,
    @Query('container') List<String>? container,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('userId') String? userId,
    @Query('audioCodec') String? audioCodec,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('transcodingAudioChannels') int? transcodingAudioChannels,
    @Query('maxStreamingBitrate') int? maxStreamingBitrate,
    @Query('audioBitRate') int? audioBitRate,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('transcodingContainer') String? transcodingContainer,
    @Query('transcodingProtocol') String? transcodingProtocol,
    @Query('maxAudioSampleRate') int? maxAudioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('enableRemoteMedia') bool? enableRemoteMedia,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('enableRedirection') bool? enableRedirection,
  });

  ///Gets a list of users.
  ///@param isHidden Optional filter by IsHidden=true or false.
  ///@param isDisabled Optional filter by IsDisabled=true or false.
  Future<chopper.Response<List<UserDto>>> usersGet({
    bool? isHidden,
    bool? isDisabled,
  }) {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _usersGet(isHidden: isHidden, isDisabled: isDisabled);
  }

  ///Gets a list of users.
  ///@param isHidden Optional filter by IsHidden=true or false.
  ///@param isDisabled Optional filter by IsDisabled=true or false.
  @Get(path: '/Users')
  Future<chopper.Response<List<UserDto>>> _usersGet({
    @Query('isHidden') bool? isHidden,
    @Query('isDisabled') bool? isDisabled,
  });

  ///Updates a user.
  ///@param userId The user id.
  Future<chopper.Response> usersPost({
    String? userId,
    required UserDto? body,
  }) {
    return _usersPost(userId: userId, body: body);
  }

  ///Updates a user.
  ///@param userId The user id.
  @Post(
    path: '/Users',
    optionalBody: true,
  )
  Future<chopper.Response> _usersPost({
    @Query('userId') String? userId,
    @Body() required UserDto? body,
  });

  ///Gets a user by Id.
  ///@param userId The user id.
  Future<chopper.Response<UserDto>> usersUserIdGet({required String? userId}) {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _usersUserIdGet(userId: userId);
  }

  ///Gets a user by Id.
  ///@param userId The user id.
  @Get(path: '/Users/{userId}')
  Future<chopper.Response<UserDto>> _usersUserIdGet(
      {@Path('userId') required String? userId});

  ///Deletes a user.
  ///@param userId The user id.
  Future<chopper.Response> usersUserIdDelete({required String? userId}) {
    return _usersUserIdDelete(userId: userId);
  }

  ///Deletes a user.
  ///@param userId The user id.
  @Delete(path: '/Users/{userId}')
  Future<chopper.Response> _usersUserIdDelete(
      {@Path('userId') required String? userId});

  ///Updates a user policy.
  ///@param userId The user id.
  Future<chopper.Response> usersUserIdPolicyPost({
    required String? userId,
    required UserPolicy? body,
  }) {
    return _usersUserIdPolicyPost(userId: userId, body: body);
  }

  ///Updates a user policy.
  ///@param userId The user id.
  @Post(
    path: '/Users/{userId}/Policy',
    optionalBody: true,
  )
  Future<chopper.Response> _usersUserIdPolicyPost({
    @Path('userId') required String? userId,
    @Body() required UserPolicy? body,
  });

  ///Authenticates a user by name.
  Future<chopper.Response<AuthenticationResult>> usersAuthenticateByNamePost(
      {required AuthenticateUserByName? body}) {
    generatedMapping.putIfAbsent(
        AuthenticationResult, () => AuthenticationResult.fromJsonFactory);

    return _usersAuthenticateByNamePost(body: body);
  }

  ///Authenticates a user by name.
  @Post(
    path: '/Users/AuthenticateByName',
    optionalBody: true,
  )
  Future<chopper.Response<AuthenticationResult>> _usersAuthenticateByNamePost(
      {@Body() required AuthenticateUserByName? body});

  ///Authenticates a user with quick connect.
  Future<chopper.Response<AuthenticationResult>>
      usersAuthenticateWithQuickConnectPost({required QuickConnectDto? body}) {
    generatedMapping.putIfAbsent(
        AuthenticationResult, () => AuthenticationResult.fromJsonFactory);

    return _usersAuthenticateWithQuickConnectPost(body: body);
  }

  ///Authenticates a user with quick connect.
  @Post(
    path: '/Users/AuthenticateWithQuickConnect',
    optionalBody: true,
  )
  Future<chopper.Response<AuthenticationResult>>
      _usersAuthenticateWithQuickConnectPost(
          {@Body() required QuickConnectDto? body});

  ///Updates a user configuration.
  ///@param userId The user id.
  Future<chopper.Response> usersConfigurationPost({
    String? userId,
    required UserConfiguration? body,
  }) {
    return _usersConfigurationPost(userId: userId, body: body);
  }

  ///Updates a user configuration.
  ///@param userId The user id.
  @Post(
    path: '/Users/Configuration',
    optionalBody: true,
  )
  Future<chopper.Response> _usersConfigurationPost({
    @Query('userId') String? userId,
    @Body() required UserConfiguration? body,
  });

  ///Initiates the forgot password process for a local user.
  Future<chopper.Response<ForgotPasswordResult>> usersForgotPasswordPost(
      {required ForgotPasswordDto? body}) {
    generatedMapping.putIfAbsent(
        ForgotPasswordResult, () => ForgotPasswordResult.fromJsonFactory);

    return _usersForgotPasswordPost(body: body);
  }

  ///Initiates the forgot password process for a local user.
  @Post(
    path: '/Users/ForgotPassword',
    optionalBody: true,
  )
  Future<chopper.Response<ForgotPasswordResult>> _usersForgotPasswordPost(
      {@Body() required ForgotPasswordDto? body});

  ///Redeems a forgot password pin.
  Future<chopper.Response<PinRedeemResult>> usersForgotPasswordPinPost(
      {required ForgotPasswordPinDto? body}) {
    generatedMapping.putIfAbsent(
        PinRedeemResult, () => PinRedeemResult.fromJsonFactory);

    return _usersForgotPasswordPinPost(body: body);
  }

  ///Redeems a forgot password pin.
  @Post(
    path: '/Users/ForgotPassword/Pin',
    optionalBody: true,
  )
  Future<chopper.Response<PinRedeemResult>> _usersForgotPasswordPinPost(
      {@Body() required ForgotPasswordPinDto? body});

  ///Gets the user based on auth token.
  Future<chopper.Response<UserDto>> usersMeGet() {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _usersMeGet();
  }

  ///Gets the user based on auth token.
  @Get(path: '/Users/Me')
  Future<chopper.Response<UserDto>> _usersMeGet();

  ///Creates a user.
  Future<chopper.Response<UserDto>> usersNewPost(
      {required CreateUserByName? body}) {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _usersNewPost(body: body);
  }

  ///Creates a user.
  @Post(
    path: '/Users/New',
    optionalBody: true,
  )
  Future<chopper.Response<UserDto>> _usersNewPost(
      {@Body() required CreateUserByName? body});

  ///Updates a user's password.
  ///@param userId The user id.
  Future<chopper.Response> usersPasswordPost({
    String? userId,
    required UpdateUserPassword? body,
  }) {
    return _usersPasswordPost(userId: userId, body: body);
  }

  ///Updates a user's password.
  ///@param userId The user id.
  @Post(
    path: '/Users/Password',
    optionalBody: true,
  )
  Future<chopper.Response> _usersPasswordPost({
    @Query('userId') String? userId,
    @Body() required UpdateUserPassword? body,
  });

  ///Gets a list of publicly visible users for display on a login screen.
  Future<chopper.Response<List<UserDto>>> usersPublicGet() {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _usersPublicGet();
  }

  ///Gets a list of publicly visible users for display on a login screen.
  @Get(path: '/Users/Public')
  Future<chopper.Response<List<UserDto>>> _usersPublicGet();

  ///Gets intros to play before the main media item plays.
  ///@param userId User id.
  ///@param itemId Item id.
  Future<chopper.Response<BaseItemDtoQueryResult>> itemsItemIdIntrosGet({
    String? userId,
    required String? itemId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _itemsItemIdIntrosGet(userId: userId, itemId: itemId);
  }

  ///Gets intros to play before the main media item plays.
  ///@param userId User id.
  ///@param itemId Item id.
  @Get(path: '/Items/{itemId}/Intros')
  Future<chopper.Response<BaseItemDtoQueryResult>> _itemsItemIdIntrosGet({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
  });

  ///Gets local trailers for an item.
  ///@param userId User id.
  ///@param itemId Item id.
  Future<chopper.Response<List<BaseItemDto>>> itemsItemIdLocalTrailersGet({
    String? userId,
    required String? itemId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _itemsItemIdLocalTrailersGet(userId: userId, itemId: itemId);
  }

  ///Gets local trailers for an item.
  ///@param userId User id.
  ///@param itemId Item id.
  @Get(path: '/Items/{itemId}/LocalTrailers')
  Future<chopper.Response<List<BaseItemDto>>> _itemsItemIdLocalTrailersGet({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
  });

  ///Gets special features for an item.
  ///@param userId User id.
  ///@param itemId Item id.
  Future<chopper.Response<List<BaseItemDto>>> itemsItemIdSpecialFeaturesGet({
    String? userId,
    required String? itemId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _itemsItemIdSpecialFeaturesGet(userId: userId, itemId: itemId);
  }

  ///Gets special features for an item.
  ///@param userId User id.
  ///@param itemId Item id.
  @Get(path: '/Items/{itemId}/SpecialFeatures')
  Future<chopper.Response<List<BaseItemDto>>> _itemsItemIdSpecialFeaturesGet({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
  });

  ///Gets latest media.
  ///@param userId User id.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param isPlayed Filter by items that are played, or not.
  ///@param enableImages Optional. include image information in output.
  ///@param imageTypeLimit Optional. the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. include user data.
  ///@param limit Return item limit.
  ///@param groupItems Whether or not to group items into a parent container.
  Future<chopper.Response<List<BaseItemDto>>> itemsLatestGet({
    String? userId,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.BaseItemKind>? includeItemTypes,
    bool? isPlayed,
    bool? enableImages,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    bool? enableUserData,
    int? limit,
    bool? groupItems,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _itemsLatestGet(
        userId: userId,
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        isPlayed: isPlayed,
        enableImages: enableImages,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        enableUserData: enableUserData,
        limit: limit,
        groupItems: groupItems);
  }

  ///Gets latest media.
  ///@param userId User id.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
  ///@param isPlayed Filter by items that are played, or not.
  ///@param enableImages Optional. include image information in output.
  ///@param imageTypeLimit Optional. the max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param enableUserData Optional. include user data.
  ///@param limit Return item limit.
  ///@param groupItems Whether or not to group items into a parent container.
  @Get(path: '/Items/Latest')
  Future<chopper.Response<List<BaseItemDto>>> _itemsLatestGet({
    @Query('userId') String? userId,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('isPlayed') bool? isPlayed,
    @Query('enableImages') bool? enableImages,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('enableUserData') bool? enableUserData,
    @Query('limit') int? limit,
    @Query('groupItems') bool? groupItems,
  });

  ///Gets the root folder from a user's library.
  ///@param userId User id.
  Future<chopper.Response<BaseItemDto>> itemsRootGet({String? userId}) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _itemsRootGet(userId: userId);
  }

  ///Gets the root folder from a user's library.
  ///@param userId User id.
  @Get(path: '/Items/Root')
  Future<chopper.Response<BaseItemDto>> _itemsRootGet(
      {@Query('userId') String? userId});

  ///Marks an item as a favorite.
  ///@param userId User id.
  ///@param itemId Item id.
  Future<chopper.Response<UserItemDataDto>> userFavoriteItemsItemIdPost({
    String? userId,
    required String? itemId,
  }) {
    generatedMapping.putIfAbsent(
        UserItemDataDto, () => UserItemDataDto.fromJsonFactory);

    return _userFavoriteItemsItemIdPost(userId: userId, itemId: itemId);
  }

  ///Marks an item as a favorite.
  ///@param userId User id.
  ///@param itemId Item id.
  @Post(
    path: '/UserFavoriteItems/{itemId}',
    optionalBody: true,
  )
  Future<chopper.Response<UserItemDataDto>> _userFavoriteItemsItemIdPost({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
  });

  ///Unmarks item as a favorite.
  ///@param userId User id.
  ///@param itemId Item id.
  Future<chopper.Response<UserItemDataDto>> userFavoriteItemsItemIdDelete({
    String? userId,
    required String? itemId,
  }) {
    generatedMapping.putIfAbsent(
        UserItemDataDto, () => UserItemDataDto.fromJsonFactory);

    return _userFavoriteItemsItemIdDelete(userId: userId, itemId: itemId);
  }

  ///Unmarks item as a favorite.
  ///@param userId User id.
  ///@param itemId Item id.
  @Delete(path: '/UserFavoriteItems/{itemId}')
  Future<chopper.Response<UserItemDataDto>> _userFavoriteItemsItemIdDelete({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
  });

  ///Deletes a user's saved personal rating for an item.
  ///@param userId User id.
  ///@param itemId Item id.
  Future<chopper.Response<UserItemDataDto>> userItemsItemIdRatingDelete({
    String? userId,
    required String? itemId,
  }) {
    generatedMapping.putIfAbsent(
        UserItemDataDto, () => UserItemDataDto.fromJsonFactory);

    return _userItemsItemIdRatingDelete(userId: userId, itemId: itemId);
  }

  ///Deletes a user's saved personal rating for an item.
  ///@param userId User id.
  ///@param itemId Item id.
  @Delete(path: '/UserItems/{itemId}/Rating')
  Future<chopper.Response<UserItemDataDto>> _userItemsItemIdRatingDelete({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
  });

  ///Updates a user's rating for an item.
  ///@param userId User id.
  ///@param itemId Item id.
  ///@param likes Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Nullable{System.Guid},System.Guid,System.Nullable{System.Boolean}) is likes.
  Future<chopper.Response<UserItemDataDto>> userItemsItemIdRatingPost({
    String? userId,
    required String? itemId,
    bool? likes,
  }) {
    generatedMapping.putIfAbsent(
        UserItemDataDto, () => UserItemDataDto.fromJsonFactory);

    return _userItemsItemIdRatingPost(
        userId: userId, itemId: itemId, likes: likes);
  }

  ///Updates a user's rating for an item.
  ///@param userId User id.
  ///@param itemId Item id.
  ///@param likes Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Nullable{System.Guid},System.Guid,System.Nullable{System.Boolean}) is likes.
  @Post(
    path: '/UserItems/{itemId}/Rating',
    optionalBody: true,
  )
  Future<chopper.Response<UserItemDataDto>> _userItemsItemIdRatingPost({
    @Query('userId') String? userId,
    @Path('itemId') required String? itemId,
    @Query('likes') bool? likes,
  });

  ///Get user views.
  ///@param userId User id.
  ///@param includeExternalContent Whether or not to include external views such as channels or live tv.
  ///@param presetViews Preset views.
  ///@param includeHidden Whether or not to include hidden content.
  Future<chopper.Response<BaseItemDtoQueryResult>> userViewsGet({
    String? userId,
    bool? includeExternalContent,
    List<enums.CollectionType>? presetViews,
    bool? includeHidden,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _userViewsGet(
        userId: userId,
        includeExternalContent: includeExternalContent,
        presetViews: collectionTypeListToJson(presetViews),
        includeHidden: includeHidden);
  }

  ///Get user views.
  ///@param userId User id.
  ///@param includeExternalContent Whether or not to include external views such as channels or live tv.
  ///@param presetViews Preset views.
  ///@param includeHidden Whether or not to include hidden content.
  @Get(path: '/UserViews')
  Future<chopper.Response<BaseItemDtoQueryResult>> _userViewsGet({
    @Query('userId') String? userId,
    @Query('includeExternalContent') bool? includeExternalContent,
    @Query('presetViews') List<Object?>? presetViews,
    @Query('includeHidden') bool? includeHidden,
  });

  ///Get user view grouping options.
  ///@param userId User id.
  Future<chopper.Response<List<SpecialViewOptionDto>>>
      userViewsGroupingOptionsGet({String? userId}) {
    generatedMapping.putIfAbsent(
        SpecialViewOptionDto, () => SpecialViewOptionDto.fromJsonFactory);

    return _userViewsGroupingOptionsGet(userId: userId);
  }

  ///Get user view grouping options.
  ///@param userId User id.
  @Get(path: '/UserViews/GroupingOptions')
  Future<chopper.Response<List<SpecialViewOptionDto>>>
      _userViewsGroupingOptionsGet({@Query('userId') String? userId});

  ///Get video attachment.
  ///@param videoId Video ID.
  ///@param mediaSourceId Media Source ID.
  ///@param index Attachment Index.
  Future<chopper.Response<String>>
      videosVideoIdMediaSourceIdAttachmentsIndexGet({
    required String? videoId,
    required String? mediaSourceId,
    required int? index,
  }) {
    return _videosVideoIdMediaSourceIdAttachmentsIndexGet(
        videoId: videoId, mediaSourceId: mediaSourceId, index: index);
  }

  ///Get video attachment.
  ///@param videoId Video ID.
  ///@param mediaSourceId Media Source ID.
  ///@param index Attachment Index.
  @Get(path: '/Videos/{videoId}/{mediaSourceId}/Attachments/{index}')
  Future<chopper.Response<String>>
      _videosVideoIdMediaSourceIdAttachmentsIndexGet({
    @Path('videoId') required String? videoId,
    @Path('mediaSourceId') required String? mediaSourceId,
    @Path('index') required int? index,
  });

  ///Gets additional parts for a video.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  Future<chopper.Response<BaseItemDtoQueryResult>>
      videosItemIdAdditionalPartsGet({
    required String? itemId,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _videosItemIdAdditionalPartsGet(itemId: itemId, userId: userId);
  }

  ///Gets additional parts for a video.
  ///@param itemId The item id.
  ///@param userId Optional. Filter by user id, and attach user data.
  @Get(path: '/Videos/{itemId}/AdditionalParts')
  Future<chopper.Response<BaseItemDtoQueryResult>>
      _videosItemIdAdditionalPartsGet({
    @Path('itemId') required String? itemId,
    @Query('userId') String? userId,
  });

  ///Removes alternate video sources.
  ///@param itemId The item id.
  Future<chopper.Response> videosItemIdAlternateSourcesDelete(
      {required String? itemId}) {
    return _videosItemIdAlternateSourcesDelete(itemId: itemId);
  }

  ///Removes alternate video sources.
  ///@param itemId The item id.
  @Delete(path: '/Videos/{itemId}/AlternateSources')
  Future<chopper.Response> _videosItemIdAlternateSourcesDelete(
      {@Path('itemId') required String? itemId});

  ///Gets a video stream.
  ///@param itemId The item id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> videosItemIdStreamGet({
    required String? itemId,
    String? container,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? maxWidth,
    int? maxHeight,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.VideosItemIdStreamGetSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.VideosItemIdStreamGetContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _videosItemIdStreamGet(
        itemId: itemId,
        container: container,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets a video stream.
  ///@param itemId The item id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Get(path: '/Videos/{itemId}/stream')
  Future<chopper.Response<String>> _videosItemIdStreamGet({
    @Path('itemId') required String? itemId,
    @Query('container') String? container,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets a video stream.
  ///@param itemId The item id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> videosItemIdStreamHead({
    required String? itemId,
    String? container,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? maxWidth,
    int? maxHeight,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.VideosItemIdStreamHeadSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.VideosItemIdStreamHeadContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _videosItemIdStreamHead(
        itemId: itemId,
        container: container,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets a video stream.
  ///@param itemId The item id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Head(path: '/Videos/{itemId}/stream')
  Future<chopper.Response<String>> _videosItemIdStreamHead({
    @Path('itemId') required String? itemId,
    @Query('container') String? container,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets a video stream.
  ///@param itemId The item id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> videosItemIdStreamContainerGet({
    required String? itemId,
    required String? container,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? maxWidth,
    int? maxHeight,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.VideosItemIdStreamContainerGetSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.VideosItemIdStreamContainerGetContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _videosItemIdStreamContainerGet(
        itemId: itemId,
        container: container,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets a video stream.
  ///@param itemId The item id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Get(path: '/Videos/{itemId}/stream.{container}')
  Future<chopper.Response<String>> _videosItemIdStreamContainerGet({
    @Path('itemId') required String? itemId,
    @Path('container') required String? container,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Gets a video stream.
  ///@param itemId The item id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  Future<chopper.Response<String>> videosItemIdStreamContainerHead({
    required String? itemId,
    required String? container,
    bool? $static,
    String? params,
    String? tag,
    String? deviceProfileId,
    String? playSessionId,
    String? segmentContainer,
    int? segmentLength,
    int? minSegments,
    String? mediaSourceId,
    String? deviceId,
    String? audioCodec,
    bool? enableAutoStreamCopy,
    bool? allowVideoStreamCopy,
    bool? allowAudioStreamCopy,
    bool? breakOnNonKeyFrames,
    int? audioSampleRate,
    int? maxAudioBitDepth,
    int? audioBitRate,
    int? audioChannels,
    int? maxAudioChannels,
    String? profile,
    String? level,
    num? framerate,
    num? maxFramerate,
    bool? copyTimestamps,
    int? startTimeTicks,
    int? width,
    int? height,
    int? maxWidth,
    int? maxHeight,
    int? videoBitRate,
    int? subtitleStreamIndex,
    enums.VideosItemIdStreamContainerHeadSubtitleMethod? subtitleMethod,
    int? maxRefFrames,
    int? maxVideoBitDepth,
    bool? requireAvc,
    bool? deInterlace,
    bool? requireNonAnamorphic,
    int? transcodingMaxAudioChannels,
    int? cpuCoreLimit,
    String? liveStreamId,
    bool? enableMpegtsM2TsMode,
    String? videoCodec,
    String? subtitleCodec,
    String? transcodeReasons,
    int? audioStreamIndex,
    int? videoStreamIndex,
    enums.VideosItemIdStreamContainerHeadContext? context,
    Object? streamOptions,
    bool? enableAudioVbrEncoding,
  }) {
    return _videosItemIdStreamContainerHead(
        itemId: itemId,
        container: container,
        $static: $static,
        params: params,
        tag: tag,
        deviceProfileId: deviceProfileId,
        playSessionId: playSessionId,
        segmentContainer: segmentContainer,
        segmentLength: segmentLength,
        minSegments: minSegments,
        mediaSourceId: mediaSourceId,
        deviceId: deviceId,
        audioCodec: audioCodec,
        enableAutoStreamCopy: enableAutoStreamCopy,
        allowVideoStreamCopy: allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy,
        breakOnNonKeyFrames: breakOnNonKeyFrames,
        audioSampleRate: audioSampleRate,
        maxAudioBitDepth: maxAudioBitDepth,
        audioBitRate: audioBitRate,
        audioChannels: audioChannels,
        maxAudioChannels: maxAudioChannels,
        profile: profile,
        level: level,
        framerate: framerate,
        maxFramerate: maxFramerate,
        copyTimestamps: copyTimestamps,
        startTimeTicks: startTimeTicks,
        width: width,
        height: height,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        videoBitRate: videoBitRate,
        subtitleStreamIndex: subtitleStreamIndex,
        subtitleMethod: subtitleMethod?.value?.toString(),
        maxRefFrames: maxRefFrames,
        maxVideoBitDepth: maxVideoBitDepth,
        requireAvc: requireAvc,
        deInterlace: deInterlace,
        requireNonAnamorphic: requireNonAnamorphic,
        transcodingMaxAudioChannels: transcodingMaxAudioChannels,
        cpuCoreLimit: cpuCoreLimit,
        liveStreamId: liveStreamId,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode,
        videoCodec: videoCodec,
        subtitleCodec: subtitleCodec,
        transcodeReasons: transcodeReasons,
        audioStreamIndex: audioStreamIndex,
        videoStreamIndex: videoStreamIndex,
        context: context?.value?.toString(),
        streamOptions: streamOptions,
        enableAudioVbrEncoding: enableAudioVbrEncoding);
  }

  ///Gets a video stream.
  ///@param itemId The item id.
  ///@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
  ///@param static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
  ///@param params The streaming parameters.
  ///@param tag The tag.
  ///@param deviceProfileId Optional. The dlna device profile id to utilize.
  ///@param playSessionId The play session id.
  ///@param segmentContainer The segment container.
  ///@param segmentLength The segment length.
  ///@param minSegments The minimum number of segments.
  ///@param mediaSourceId The media version id, if playing an alternate version.
  ///@param deviceId The device id of the client requesting. Used to stop encoding processes when needed.
  ///@param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension.
  ///@param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
  ///@param allowVideoStreamCopy Whether or not to allow copying of the video stream url.
  ///@param allowAudioStreamCopy Whether or not to allow copying of the audio stream url.
  ///@param breakOnNonKeyFrames Optional. Whether to break on non key frames.
  ///@param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
  ///@param maxAudioBitDepth Optional. The maximum audio bit depth.
  ///@param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
  ///@param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
  ///@param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
  ///@param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
  ///@param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
  ///@param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
  ///@param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
  ///@param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
  ///@param width Optional. The fixed horizontal resolution of the encoded video.
  ///@param height Optional. The fixed vertical resolution of the encoded video.
  ///@param maxWidth Optional. The maximum horizontal resolution of the encoded video.
  ///@param maxHeight Optional. The maximum vertical resolution of the encoded video.
  ///@param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
  ///@param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
  ///@param subtitleMethod Optional. Specify the subtitle delivery method.
  ///@param maxRefFrames Optional.
  ///@param maxVideoBitDepth Optional. The maximum video bit depth.
  ///@param requireAvc Optional. Whether to require avc.
  ///@param deInterlace Optional. Whether to deinterlace the video.
  ///@param requireNonAnamorphic Optional. Whether to require a non anamorphic stream.
  ///@param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
  ///@param cpuCoreLimit Optional. The limit of how many cpu cores to use.
  ///@param liveStreamId The live stream id.
  ///@param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
  ///@param videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension.
  ///@param subtitleCodec Optional. Specify a subtitle codec to encode to.
  ///@param transcodeReasons Optional. The transcoding reason.
  ///@param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
  ///@param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
  ///@param context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
  ///@param streamOptions Optional. The streaming options.
  ///@param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding.
  @Head(path: '/Videos/{itemId}/stream.{container}')
  Future<chopper.Response<String>> _videosItemIdStreamContainerHead({
    @Path('itemId') required String? itemId,
    @Path('container') required String? container,
    @Query('static') bool? $static,
    @Query('params') String? params,
    @Query('tag') String? tag,
    @Query('deviceProfileId') String? deviceProfileId,
    @Query('playSessionId') String? playSessionId,
    @Query('segmentContainer') String? segmentContainer,
    @Query('segmentLength') int? segmentLength,
    @Query('minSegments') int? minSegments,
    @Query('mediaSourceId') String? mediaSourceId,
    @Query('deviceId') String? deviceId,
    @Query('audioCodec') String? audioCodec,
    @Query('enableAutoStreamCopy') bool? enableAutoStreamCopy,
    @Query('allowVideoStreamCopy') bool? allowVideoStreamCopy,
    @Query('allowAudioStreamCopy') bool? allowAudioStreamCopy,
    @Query('breakOnNonKeyFrames') bool? breakOnNonKeyFrames,
    @Query('audioSampleRate') int? audioSampleRate,
    @Query('maxAudioBitDepth') int? maxAudioBitDepth,
    @Query('audioBitRate') int? audioBitRate,
    @Query('audioChannels') int? audioChannels,
    @Query('maxAudioChannels') int? maxAudioChannels,
    @Query('profile') String? profile,
    @Query('level') String? level,
    @Query('framerate') num? framerate,
    @Query('maxFramerate') num? maxFramerate,
    @Query('copyTimestamps') bool? copyTimestamps,
    @Query('startTimeTicks') int? startTimeTicks,
    @Query('width') int? width,
    @Query('height') int? height,
    @Query('maxWidth') int? maxWidth,
    @Query('maxHeight') int? maxHeight,
    @Query('videoBitRate') int? videoBitRate,
    @Query('subtitleStreamIndex') int? subtitleStreamIndex,
    @Query('subtitleMethod') String? subtitleMethod,
    @Query('maxRefFrames') int? maxRefFrames,
    @Query('maxVideoBitDepth') int? maxVideoBitDepth,
    @Query('requireAvc') bool? requireAvc,
    @Query('deInterlace') bool? deInterlace,
    @Query('requireNonAnamorphic') bool? requireNonAnamorphic,
    @Query('transcodingMaxAudioChannels') int? transcodingMaxAudioChannels,
    @Query('cpuCoreLimit') int? cpuCoreLimit,
    @Query('liveStreamId') String? liveStreamId,
    @Query('enableMpegtsM2TsMode') bool? enableMpegtsM2TsMode,
    @Query('videoCodec') String? videoCodec,
    @Query('subtitleCodec') String? subtitleCodec,
    @Query('transcodeReasons') String? transcodeReasons,
    @Query('audioStreamIndex') int? audioStreamIndex,
    @Query('videoStreamIndex') int? videoStreamIndex,
    @Query('context') String? context,
    @Query('streamOptions') Object? streamOptions,
    @Query('enableAudioVbrEncoding') bool? enableAudioVbrEncoding,
  });

  ///Merges videos into a single record.
  ///@param ids Item id list. This allows multiple, comma delimited.
  Future<chopper.Response> videosMergeVersionsPost(
      {required List<String>? ids}) {
    return _videosMergeVersionsPost(ids: ids);
  }

  ///Merges videos into a single record.
  ///@param ids Item id list. This allows multiple, comma delimited.
  @Post(
    path: '/Videos/MergeVersions',
    optionalBody: true,
  )
  Future<chopper.Response> _videosMergeVersionsPost(
      {@Query('ids') required List<String>? ids});

  ///Get years.
  ///@param startIndex Skips over a given number of items within the results. Use for paging.
  ///@param limit Optional. The maximum number of records to return.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
  ///@param mediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param userId User Id.
  ///@param recursive Search recursively.
  ///@param enableImages Optional. Include image information in output.
  Future<chopper.Response<BaseItemDtoQueryResult>> yearsGet({
    int? startIndex,
    int? limit,
    List<enums.SortOrder>? sortOrder,
    String? parentId,
    List<enums.ItemFields>? fields,
    List<enums.BaseItemKind>? excludeItemTypes,
    List<enums.BaseItemKind>? includeItemTypes,
    List<enums.MediaType>? mediaTypes,
    List<enums.ItemSortBy>? sortBy,
    bool? enableUserData,
    int? imageTypeLimit,
    List<enums.ImageType>? enableImageTypes,
    String? userId,
    bool? recursive,
    bool? enableImages,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDtoQueryResult, () => BaseItemDtoQueryResult.fromJsonFactory);

    return _yearsGet(
        startIndex: startIndex,
        limit: limit,
        sortOrder: sortOrderListToJson(sortOrder),
        parentId: parentId,
        fields: itemFieldsListToJson(fields),
        excludeItemTypes: baseItemKindListToJson(excludeItemTypes),
        includeItemTypes: baseItemKindListToJson(includeItemTypes),
        mediaTypes: mediaTypeListToJson(mediaTypes),
        sortBy: itemSortByListToJson(sortBy),
        enableUserData: enableUserData,
        imageTypeLimit: imageTypeLimit,
        enableImageTypes: imageTypeListToJson(enableImageTypes),
        userId: userId,
        recursive: recursive,
        enableImages: enableImages);
  }

  ///Get years.
  ///@param startIndex Skips over a given number of items within the results. Use for paging.
  ///@param limit Optional. The maximum number of records to return.
  ///@param sortOrder Sort Order - Ascending,Descending.
  ///@param parentId Specify this to localize the search to a specific item or folder. Omit to use the root.
  ///@param fields Optional. Specify additional fields of information to return in the output.
  ///@param excludeItemTypes Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
  ///@param includeItemTypes Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
  ///@param mediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited.
  ///@param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
  ///@param enableUserData Optional. Include user data.
  ///@param imageTypeLimit Optional. The max number of images to return, per image type.
  ///@param enableImageTypes Optional. The image types to include in the output.
  ///@param userId User Id.
  ///@param recursive Search recursively.
  ///@param enableImages Optional. Include image information in output.
  @Get(path: '/Years')
  Future<chopper.Response<BaseItemDtoQueryResult>> _yearsGet({
    @Query('startIndex') int? startIndex,
    @Query('limit') int? limit,
    @Query('sortOrder') List<Object?>? sortOrder,
    @Query('parentId') String? parentId,
    @Query('fields') List<Object?>? fields,
    @Query('excludeItemTypes') List<Object?>? excludeItemTypes,
    @Query('includeItemTypes') List<Object?>? includeItemTypes,
    @Query('mediaTypes') List<Object?>? mediaTypes,
    @Query('sortBy') List<Object?>? sortBy,
    @Query('enableUserData') bool? enableUserData,
    @Query('imageTypeLimit') int? imageTypeLimit,
    @Query('enableImageTypes') List<Object?>? enableImageTypes,
    @Query('userId') String? userId,
    @Query('recursive') bool? recursive,
    @Query('enableImages') bool? enableImages,
  });

  ///Gets a year.
  ///@param year The year.
  ///@param userId Optional. Filter by user id, and attach user data.
  Future<chopper.Response<BaseItemDto>> yearsYearGet({
    required int? year,
    String? userId,
  }) {
    generatedMapping.putIfAbsent(
        BaseItemDto, () => BaseItemDto.fromJsonFactory);

    return _yearsYearGet(year: year, userId: userId);
  }

  ///Gets a year.
  ///@param year The year.
  ///@param userId Optional. Filter by user id, and attach user data.
  @Get(path: '/Years/{year}')
  Future<chopper.Response<BaseItemDto>> _yearsYearGet({
    @Path('year') required int? year,
    @Query('userId') String? userId,
  });
}

@JsonSerializable(explicitToJson: true)
class AccessSchedule {
  const AccessSchedule({
    this.id,
    this.userId,
    this.dayOfWeek,
    this.startHour,
    this.endHour,
  });

  factory AccessSchedule.fromJson(Map<String, dynamic> json) =>
      _$AccessScheduleFromJson(json);

  static const toJsonFactory = _$AccessScheduleToJson;
  Map<String, dynamic> toJson() => _$AccessScheduleToJson(this);

  @JsonKey(name: 'Id')
  final int? id;
  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(
    name: 'DayOfWeek',
    toJson: dynamicDayOfWeekNullableToJson,
    fromJson: dynamicDayOfWeekNullableFromJson,
  )
  final enums.DynamicDayOfWeek? dayOfWeek;
  @JsonKey(name: 'StartHour')
  final double? startHour;
  @JsonKey(name: 'EndHour')
  final double? endHour;
  static const fromJsonFactory = _$AccessScheduleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AccessSchedule &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.dayOfWeek, dayOfWeek) ||
                const DeepCollectionEquality()
                    .equals(other.dayOfWeek, dayOfWeek)) &&
            (identical(other.startHour, startHour) ||
                const DeepCollectionEquality()
                    .equals(other.startHour, startHour)) &&
            (identical(other.endHour, endHour) ||
                const DeepCollectionEquality().equals(other.endHour, endHour)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(dayOfWeek) ^
      const DeepCollectionEquality().hash(startHour) ^
      const DeepCollectionEquality().hash(endHour) ^
      runtimeType.hashCode;
}

extension $AccessScheduleExtension on AccessSchedule {
  AccessSchedule copyWith(
      {int? id,
      String? userId,
      enums.DynamicDayOfWeek? dayOfWeek,
      double? startHour,
      double? endHour}) {
    return AccessSchedule(
        id: id ?? this.id,
        userId: userId ?? this.userId,
        dayOfWeek: dayOfWeek ?? this.dayOfWeek,
        startHour: startHour ?? this.startHour,
        endHour: endHour ?? this.endHour);
  }

  AccessSchedule copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? userId,
      Wrapped<enums.DynamicDayOfWeek?>? dayOfWeek,
      Wrapped<double?>? startHour,
      Wrapped<double?>? endHour}) {
    return AccessSchedule(
        id: (id != null ? id.value : this.id),
        userId: (userId != null ? userId.value : this.userId),
        dayOfWeek: (dayOfWeek != null ? dayOfWeek.value : this.dayOfWeek),
        startHour: (startHour != null ? startHour.value : this.startHour),
        endHour: (endHour != null ? endHour.value : this.endHour));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityLogEntry {
  const ActivityLogEntry({
    this.id,
    this.name,
    this.overview,
    this.shortOverview,
    this.type,
    this.itemId,
    this.date,
    this.userId,
    this.userPrimaryImageTag,
    this.severity,
  });

  factory ActivityLogEntry.fromJson(Map<String, dynamic> json) =>
      _$ActivityLogEntryFromJson(json);

  static const toJsonFactory = _$ActivityLogEntryToJson;
  Map<String, dynamic> toJson() => _$ActivityLogEntryToJson(this);

  @JsonKey(name: 'Id')
  final int? id;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Overview')
  final String? overview;
  @JsonKey(name: 'ShortOverview')
  final String? shortOverview;
  @JsonKey(name: 'Type')
  final String? type;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'Date')
  final DateTime? date;
  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'UserPrimaryImageTag')
  @deprecated
  final String? userPrimaryImageTag;
  @JsonKey(
    name: 'Severity',
    toJson: logLevelNullableToJson,
    fromJson: logLevelNullableFromJson,
  )
  final enums.LogLevel? severity;
  static const fromJsonFactory = _$ActivityLogEntryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivityLogEntry &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.overview, overview) ||
                const DeepCollectionEquality()
                    .equals(other.overview, overview)) &&
            (identical(other.shortOverview, shortOverview) ||
                const DeepCollectionEquality()
                    .equals(other.shortOverview, shortOverview)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userPrimaryImageTag, userPrimaryImageTag) ||
                const DeepCollectionEquality()
                    .equals(other.userPrimaryImageTag, userPrimaryImageTag)) &&
            (identical(other.severity, severity) ||
                const DeepCollectionEquality()
                    .equals(other.severity, severity)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(overview) ^
      const DeepCollectionEquality().hash(shortOverview) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userPrimaryImageTag) ^
      const DeepCollectionEquality().hash(severity) ^
      runtimeType.hashCode;
}

extension $ActivityLogEntryExtension on ActivityLogEntry {
  ActivityLogEntry copyWith(
      {int? id,
      String? name,
      String? overview,
      String? shortOverview,
      String? type,
      String? itemId,
      DateTime? date,
      String? userId,
      String? userPrimaryImageTag,
      enums.LogLevel? severity}) {
    return ActivityLogEntry(
        id: id ?? this.id,
        name: name ?? this.name,
        overview: overview ?? this.overview,
        shortOverview: shortOverview ?? this.shortOverview,
        type: type ?? this.type,
        itemId: itemId ?? this.itemId,
        date: date ?? this.date,
        userId: userId ?? this.userId,
        userPrimaryImageTag: userPrimaryImageTag ?? this.userPrimaryImageTag,
        severity: severity ?? this.severity);
  }

  ActivityLogEntry copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? overview,
      Wrapped<String?>? shortOverview,
      Wrapped<String?>? type,
      Wrapped<String?>? itemId,
      Wrapped<DateTime?>? date,
      Wrapped<String?>? userId,
      Wrapped<String?>? userPrimaryImageTag,
      Wrapped<enums.LogLevel?>? severity}) {
    return ActivityLogEntry(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        overview: (overview != null ? overview.value : this.overview),
        shortOverview:
            (shortOverview != null ? shortOverview.value : this.shortOverview),
        type: (type != null ? type.value : this.type),
        itemId: (itemId != null ? itemId.value : this.itemId),
        date: (date != null ? date.value : this.date),
        userId: (userId != null ? userId.value : this.userId),
        userPrimaryImageTag: (userPrimaryImageTag != null
            ? userPrimaryImageTag.value
            : this.userPrimaryImageTag),
        severity: (severity != null ? severity.value : this.severity));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityLogEntryMessage {
  const ActivityLogEntryMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory ActivityLogEntryMessage.fromJson(Map<String, dynamic> json) =>
      _$ActivityLogEntryMessageFromJson(json);

  static const toJsonFactory = _$ActivityLogEntryMessageToJson;
  Map<String, dynamic> toJson() => _$ActivityLogEntryMessageToJson(this);

  @JsonKey(name: 'Data', defaultValue: <ActivityLogEntry>[])
  final List<ActivityLogEntry>? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.activitylogentry);

  static const fromJsonFactory = _$ActivityLogEntryMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivityLogEntryMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $ActivityLogEntryMessageExtension on ActivityLogEntryMessage {
  ActivityLogEntryMessage copyWith(
      {List<ActivityLogEntry>? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return ActivityLogEntryMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  ActivityLogEntryMessage copyWithWrapped(
      {Wrapped<List<ActivityLogEntry>?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return ActivityLogEntryMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityLogEntryQueryResult {
  const ActivityLogEntryQueryResult({
    this.items,
    this.totalRecordCount,
    this.startIndex,
  });

  factory ActivityLogEntryQueryResult.fromJson(Map<String, dynamic> json) =>
      _$ActivityLogEntryQueryResultFromJson(json);

  static const toJsonFactory = _$ActivityLogEntryQueryResultToJson;
  Map<String, dynamic> toJson() => _$ActivityLogEntryQueryResultToJson(this);

  @JsonKey(name: 'Items', defaultValue: <ActivityLogEntry>[])
  final List<ActivityLogEntry>? items;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  static const fromJsonFactory = _$ActivityLogEntryQueryResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivityLogEntryQueryResult &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      const DeepCollectionEquality().hash(startIndex) ^
      runtimeType.hashCode;
}

extension $ActivityLogEntryQueryResultExtension on ActivityLogEntryQueryResult {
  ActivityLogEntryQueryResult copyWith(
      {List<ActivityLogEntry>? items, int? totalRecordCount, int? startIndex}) {
    return ActivityLogEntryQueryResult(
        items: items ?? this.items,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount,
        startIndex: startIndex ?? this.startIndex);
  }

  ActivityLogEntryQueryResult copyWithWrapped(
      {Wrapped<List<ActivityLogEntry>?>? items,
      Wrapped<int?>? totalRecordCount,
      Wrapped<int?>? startIndex}) {
    return ActivityLogEntryQueryResult(
        items: (items != null ? items.value : this.items),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityLogEntryStartMessage {
  const ActivityLogEntryStartMessage({
    this.data,
    this.messageType,
  });

  factory ActivityLogEntryStartMessage.fromJson(Map<String, dynamic> json) =>
      _$ActivityLogEntryStartMessageFromJson(json);

  static const toJsonFactory = _$ActivityLogEntryStartMessageToJson;
  Map<String, dynamic> toJson() => _$ActivityLogEntryStartMessageToJson(this);

  @JsonKey(name: 'Data')
  final String? data;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.activitylogentrystart);

  static const fromJsonFactory = _$ActivityLogEntryStartMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivityLogEntryStartMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $ActivityLogEntryStartMessageExtension
    on ActivityLogEntryStartMessage {
  ActivityLogEntryStartMessage copyWith(
      {String? data, enums.SessionMessageType? messageType}) {
    return ActivityLogEntryStartMessage(
        data: data ?? this.data, messageType: messageType ?? this.messageType);
  }

  ActivityLogEntryStartMessage copyWithWrapped(
      {Wrapped<String?>? data,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return ActivityLogEntryStartMessage(
        data: (data != null ? data.value : this.data),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class ActivityLogEntryStopMessage {
  const ActivityLogEntryStopMessage({
    this.messageType,
  });

  factory ActivityLogEntryStopMessage.fromJson(Map<String, dynamic> json) =>
      _$ActivityLogEntryStopMessageFromJson(json);

  static const toJsonFactory = _$ActivityLogEntryStopMessageToJson;
  Map<String, dynamic> toJson() => _$ActivityLogEntryStopMessageToJson(this);

  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.activitylogentrystop);

  static const fromJsonFactory = _$ActivityLogEntryStopMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ActivityLogEntryStopMessage &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(messageType) ^ runtimeType.hashCode;
}

extension $ActivityLogEntryStopMessageExtension on ActivityLogEntryStopMessage {
  ActivityLogEntryStopMessage copyWith(
      {enums.SessionMessageType? messageType}) {
    return ActivityLogEntryStopMessage(
        messageType: messageType ?? this.messageType);
  }

  ActivityLogEntryStopMessage copyWithWrapped(
      {Wrapped<enums.SessionMessageType?>? messageType}) {
    return ActivityLogEntryStopMessage(
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class AddVirtualFolderDto {
  const AddVirtualFolderDto({
    this.libraryOptions,
  });

  factory AddVirtualFolderDto.fromJson(Map<String, dynamic> json) =>
      _$AddVirtualFolderDtoFromJson(json);

  static const toJsonFactory = _$AddVirtualFolderDtoToJson;
  Map<String, dynamic> toJson() => _$AddVirtualFolderDtoToJson(this);

  @JsonKey(name: 'LibraryOptions')
  final LibraryOptions? libraryOptions;
  static const fromJsonFactory = _$AddVirtualFolderDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddVirtualFolderDto &&
            (identical(other.libraryOptions, libraryOptions) ||
                const DeepCollectionEquality()
                    .equals(other.libraryOptions, libraryOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(libraryOptions) ^
      runtimeType.hashCode;
}

extension $AddVirtualFolderDtoExtension on AddVirtualFolderDto {
  AddVirtualFolderDto copyWith({LibraryOptions? libraryOptions}) {
    return AddVirtualFolderDto(
        libraryOptions: libraryOptions ?? this.libraryOptions);
  }

  AddVirtualFolderDto copyWithWrapped(
      {Wrapped<LibraryOptions?>? libraryOptions}) {
    return AddVirtualFolderDto(
        libraryOptions: (libraryOptions != null
            ? libraryOptions.value
            : this.libraryOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class AlbumInfo {
  const AlbumInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
    this.albumArtists,
    this.artistProviderIds,
    this.songInfos,
  });

  factory AlbumInfo.fromJson(Map<String, dynamic> json) =>
      _$AlbumInfoFromJson(json);

  static const toJsonFactory = _$AlbumInfoToJson;
  Map<String, dynamic> toJson() => _$AlbumInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  @JsonKey(name: 'AlbumArtists', defaultValue: <String>[])
  final List<String>? albumArtists;
  @JsonKey(name: 'ArtistProviderIds')
  final Map<String, dynamic>? artistProviderIds;
  @JsonKey(name: 'SongInfos', defaultValue: <SongInfo>[])
  final List<SongInfo>? songInfos;
  static const fromJsonFactory = _$AlbumInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlbumInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)) &&
            (identical(other.albumArtists, albumArtists) ||
                const DeepCollectionEquality()
                    .equals(other.albumArtists, albumArtists)) &&
            (identical(other.artistProviderIds, artistProviderIds) ||
                const DeepCollectionEquality()
                    .equals(other.artistProviderIds, artistProviderIds)) &&
            (identical(other.songInfos, songInfos) ||
                const DeepCollectionEquality()
                    .equals(other.songInfos, songInfos)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      const DeepCollectionEquality().hash(albumArtists) ^
      const DeepCollectionEquality().hash(artistProviderIds) ^
      const DeepCollectionEquality().hash(songInfos) ^
      runtimeType.hashCode;
}

extension $AlbumInfoExtension on AlbumInfo {
  AlbumInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated,
      List<String>? albumArtists,
      Map<String, dynamic>? artistProviderIds,
      List<SongInfo>? songInfos}) {
    return AlbumInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated,
        albumArtists: albumArtists ?? this.albumArtists,
        artistProviderIds: artistProviderIds ?? this.artistProviderIds,
        songInfos: songInfos ?? this.songInfos);
  }

  AlbumInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated,
      Wrapped<List<String>?>? albumArtists,
      Wrapped<Map<String, dynamic>?>? artistProviderIds,
      Wrapped<List<SongInfo>?>? songInfos}) {
    return AlbumInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated),
        albumArtists:
            (albumArtists != null ? albumArtists.value : this.albumArtists),
        artistProviderIds: (artistProviderIds != null
            ? artistProviderIds.value
            : this.artistProviderIds),
        songInfos: (songInfos != null ? songInfos.value : this.songInfos));
  }
}

@JsonSerializable(explicitToJson: true)
class AlbumInfoRemoteSearchQuery {
  const AlbumInfoRemoteSearchQuery({
    this.searchInfo,
    this.itemId,
    this.searchProviderName,
    this.includeDisabledProviders,
  });

  factory AlbumInfoRemoteSearchQuery.fromJson(Map<String, dynamic> json) =>
      _$AlbumInfoRemoteSearchQueryFromJson(json);

  static const toJsonFactory = _$AlbumInfoRemoteSearchQueryToJson;
  Map<String, dynamic> toJson() => _$AlbumInfoRemoteSearchQueryToJson(this);

  @JsonKey(name: 'SearchInfo')
  final AlbumInfo? searchInfo;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'IncludeDisabledProviders')
  final bool? includeDisabledProviders;
  static const fromJsonFactory = _$AlbumInfoRemoteSearchQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AlbumInfoRemoteSearchQuery &&
            (identical(other.searchInfo, searchInfo) ||
                const DeepCollectionEquality()
                    .equals(other.searchInfo, searchInfo)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(
                    other.includeDisabledProviders, includeDisabledProviders) ||
                const DeepCollectionEquality().equals(
                    other.includeDisabledProviders, includeDisabledProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchInfo) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(includeDisabledProviders) ^
      runtimeType.hashCode;
}

extension $AlbumInfoRemoteSearchQueryExtension on AlbumInfoRemoteSearchQuery {
  AlbumInfoRemoteSearchQuery copyWith(
      {AlbumInfo? searchInfo,
      String? itemId,
      String? searchProviderName,
      bool? includeDisabledProviders}) {
    return AlbumInfoRemoteSearchQuery(
        searchInfo: searchInfo ?? this.searchInfo,
        itemId: itemId ?? this.itemId,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        includeDisabledProviders:
            includeDisabledProviders ?? this.includeDisabledProviders);
  }

  AlbumInfoRemoteSearchQuery copyWithWrapped(
      {Wrapped<AlbumInfo?>? searchInfo,
      Wrapped<String?>? itemId,
      Wrapped<String?>? searchProviderName,
      Wrapped<bool?>? includeDisabledProviders}) {
    return AlbumInfoRemoteSearchQuery(
        searchInfo: (searchInfo != null ? searchInfo.value : this.searchInfo),
        itemId: (itemId != null ? itemId.value : this.itemId),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        includeDisabledProviders: (includeDisabledProviders != null
            ? includeDisabledProviders.value
            : this.includeDisabledProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class AllThemeMediaResult {
  const AllThemeMediaResult({
    this.themeVideosResult,
    this.themeSongsResult,
    this.soundtrackSongsResult,
  });

  factory AllThemeMediaResult.fromJson(Map<String, dynamic> json) =>
      _$AllThemeMediaResultFromJson(json);

  static const toJsonFactory = _$AllThemeMediaResultToJson;
  Map<String, dynamic> toJson() => _$AllThemeMediaResultToJson(this);

  @JsonKey(name: 'ThemeVideosResult')
  final ThemeMediaResult? themeVideosResult;
  @JsonKey(name: 'ThemeSongsResult')
  final ThemeMediaResult? themeSongsResult;
  @JsonKey(name: 'SoundtrackSongsResult')
  final ThemeMediaResult? soundtrackSongsResult;
  static const fromJsonFactory = _$AllThemeMediaResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AllThemeMediaResult &&
            (identical(other.themeVideosResult, themeVideosResult) ||
                const DeepCollectionEquality()
                    .equals(other.themeVideosResult, themeVideosResult)) &&
            (identical(other.themeSongsResult, themeSongsResult) ||
                const DeepCollectionEquality()
                    .equals(other.themeSongsResult, themeSongsResult)) &&
            (identical(other.soundtrackSongsResult, soundtrackSongsResult) ||
                const DeepCollectionEquality().equals(
                    other.soundtrackSongsResult, soundtrackSongsResult)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(themeVideosResult) ^
      const DeepCollectionEquality().hash(themeSongsResult) ^
      const DeepCollectionEquality().hash(soundtrackSongsResult) ^
      runtimeType.hashCode;
}

extension $AllThemeMediaResultExtension on AllThemeMediaResult {
  AllThemeMediaResult copyWith(
      {ThemeMediaResult? themeVideosResult,
      ThemeMediaResult? themeSongsResult,
      ThemeMediaResult? soundtrackSongsResult}) {
    return AllThemeMediaResult(
        themeVideosResult: themeVideosResult ?? this.themeVideosResult,
        themeSongsResult: themeSongsResult ?? this.themeSongsResult,
        soundtrackSongsResult:
            soundtrackSongsResult ?? this.soundtrackSongsResult);
  }

  AllThemeMediaResult copyWithWrapped(
      {Wrapped<ThemeMediaResult?>? themeVideosResult,
      Wrapped<ThemeMediaResult?>? themeSongsResult,
      Wrapped<ThemeMediaResult?>? soundtrackSongsResult}) {
    return AllThemeMediaResult(
        themeVideosResult: (themeVideosResult != null
            ? themeVideosResult.value
            : this.themeVideosResult),
        themeSongsResult: (themeSongsResult != null
            ? themeSongsResult.value
            : this.themeSongsResult),
        soundtrackSongsResult: (soundtrackSongsResult != null
            ? soundtrackSongsResult.value
            : this.soundtrackSongsResult));
  }
}

@JsonSerializable(explicitToJson: true)
class ArtistInfo {
  const ArtistInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
    this.songInfos,
  });

  factory ArtistInfo.fromJson(Map<String, dynamic> json) =>
      _$ArtistInfoFromJson(json);

  static const toJsonFactory = _$ArtistInfoToJson;
  Map<String, dynamic> toJson() => _$ArtistInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  @JsonKey(name: 'SongInfos', defaultValue: <SongInfo>[])
  final List<SongInfo>? songInfos;
  static const fromJsonFactory = _$ArtistInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ArtistInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)) &&
            (identical(other.songInfos, songInfos) ||
                const DeepCollectionEquality()
                    .equals(other.songInfos, songInfos)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      const DeepCollectionEquality().hash(songInfos) ^
      runtimeType.hashCode;
}

extension $ArtistInfoExtension on ArtistInfo {
  ArtistInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated,
      List<SongInfo>? songInfos}) {
    return ArtistInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated,
        songInfos: songInfos ?? this.songInfos);
  }

  ArtistInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated,
      Wrapped<List<SongInfo>?>? songInfos}) {
    return ArtistInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated),
        songInfos: (songInfos != null ? songInfos.value : this.songInfos));
  }
}

@JsonSerializable(explicitToJson: true)
class ArtistInfoRemoteSearchQuery {
  const ArtistInfoRemoteSearchQuery({
    this.searchInfo,
    this.itemId,
    this.searchProviderName,
    this.includeDisabledProviders,
  });

  factory ArtistInfoRemoteSearchQuery.fromJson(Map<String, dynamic> json) =>
      _$ArtistInfoRemoteSearchQueryFromJson(json);

  static const toJsonFactory = _$ArtistInfoRemoteSearchQueryToJson;
  Map<String, dynamic> toJson() => _$ArtistInfoRemoteSearchQueryToJson(this);

  @JsonKey(name: 'SearchInfo')
  final ArtistInfo? searchInfo;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'IncludeDisabledProviders')
  final bool? includeDisabledProviders;
  static const fromJsonFactory = _$ArtistInfoRemoteSearchQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ArtistInfoRemoteSearchQuery &&
            (identical(other.searchInfo, searchInfo) ||
                const DeepCollectionEquality()
                    .equals(other.searchInfo, searchInfo)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(
                    other.includeDisabledProviders, includeDisabledProviders) ||
                const DeepCollectionEquality().equals(
                    other.includeDisabledProviders, includeDisabledProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchInfo) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(includeDisabledProviders) ^
      runtimeType.hashCode;
}

extension $ArtistInfoRemoteSearchQueryExtension on ArtistInfoRemoteSearchQuery {
  ArtistInfoRemoteSearchQuery copyWith(
      {ArtistInfo? searchInfo,
      String? itemId,
      String? searchProviderName,
      bool? includeDisabledProviders}) {
    return ArtistInfoRemoteSearchQuery(
        searchInfo: searchInfo ?? this.searchInfo,
        itemId: itemId ?? this.itemId,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        includeDisabledProviders:
            includeDisabledProviders ?? this.includeDisabledProviders);
  }

  ArtistInfoRemoteSearchQuery copyWithWrapped(
      {Wrapped<ArtistInfo?>? searchInfo,
      Wrapped<String?>? itemId,
      Wrapped<String?>? searchProviderName,
      Wrapped<bool?>? includeDisabledProviders}) {
    return ArtistInfoRemoteSearchQuery(
        searchInfo: (searchInfo != null ? searchInfo.value : this.searchInfo),
        itemId: (itemId != null ? itemId.value : this.itemId),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        includeDisabledProviders: (includeDisabledProviders != null
            ? includeDisabledProviders.value
            : this.includeDisabledProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthenticateUserByName {
  const AuthenticateUserByName({
    this.username,
    this.pw,
  });

  factory AuthenticateUserByName.fromJson(Map<String, dynamic> json) =>
      _$AuthenticateUserByNameFromJson(json);

  static const toJsonFactory = _$AuthenticateUserByNameToJson;
  Map<String, dynamic> toJson() => _$AuthenticateUserByNameToJson(this);

  @JsonKey(name: 'Username')
  final String? username;
  @JsonKey(name: 'Pw')
  final String? pw;
  static const fromJsonFactory = _$AuthenticateUserByNameFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AuthenticateUserByName &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.pw, pw) ||
                const DeepCollectionEquality().equals(other.pw, pw)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(pw) ^
      runtimeType.hashCode;
}

extension $AuthenticateUserByNameExtension on AuthenticateUserByName {
  AuthenticateUserByName copyWith({String? username, String? pw}) {
    return AuthenticateUserByName(
        username: username ?? this.username, pw: pw ?? this.pw);
  }

  AuthenticateUserByName copyWithWrapped(
      {Wrapped<String?>? username, Wrapped<String?>? pw}) {
    return AuthenticateUserByName(
        username: (username != null ? username.value : this.username),
        pw: (pw != null ? pw.value : this.pw));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthenticationInfo {
  const AuthenticationInfo({
    this.id,
    this.accessToken,
    this.deviceId,
    this.appName,
    this.appVersion,
    this.deviceName,
    this.userId,
    this.isActive,
    this.dateCreated,
    this.dateRevoked,
    this.dateLastActivity,
    this.userName,
  });

  factory AuthenticationInfo.fromJson(Map<String, dynamic> json) =>
      _$AuthenticationInfoFromJson(json);

  static const toJsonFactory = _$AuthenticationInfoToJson;
  Map<String, dynamic> toJson() => _$AuthenticationInfoToJson(this);

  @JsonKey(name: 'Id')
  final int? id;
  @JsonKey(name: 'AccessToken')
  final String? accessToken;
  @JsonKey(name: 'DeviceId')
  final String? deviceId;
  @JsonKey(name: 'AppName')
  final String? appName;
  @JsonKey(name: 'AppVersion')
  final String? appVersion;
  @JsonKey(name: 'DeviceName')
  final String? deviceName;
  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'IsActive')
  final bool? isActive;
  @JsonKey(name: 'DateCreated')
  final DateTime? dateCreated;
  @JsonKey(name: 'DateRevoked')
  final DateTime? dateRevoked;
  @JsonKey(name: 'DateLastActivity')
  final DateTime? dateLastActivity;
  @JsonKey(name: 'UserName')
  final String? userName;
  static const fromJsonFactory = _$AuthenticationInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AuthenticationInfo &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.appName, appName) ||
                const DeepCollectionEquality()
                    .equals(other.appName, appName)) &&
            (identical(other.appVersion, appVersion) ||
                const DeepCollectionEquality()
                    .equals(other.appVersion, appVersion)) &&
            (identical(other.deviceName, deviceName) ||
                const DeepCollectionEquality()
                    .equals(other.deviceName, deviceName)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.dateCreated, dateCreated) ||
                const DeepCollectionEquality()
                    .equals(other.dateCreated, dateCreated)) &&
            (identical(other.dateRevoked, dateRevoked) ||
                const DeepCollectionEquality()
                    .equals(other.dateRevoked, dateRevoked)) &&
            (identical(other.dateLastActivity, dateLastActivity) ||
                const DeepCollectionEquality()
                    .equals(other.dateLastActivity, dateLastActivity)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(appName) ^
      const DeepCollectionEquality().hash(appVersion) ^
      const DeepCollectionEquality().hash(deviceName) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(dateCreated) ^
      const DeepCollectionEquality().hash(dateRevoked) ^
      const DeepCollectionEquality().hash(dateLastActivity) ^
      const DeepCollectionEquality().hash(userName) ^
      runtimeType.hashCode;
}

extension $AuthenticationInfoExtension on AuthenticationInfo {
  AuthenticationInfo copyWith(
      {int? id,
      String? accessToken,
      String? deviceId,
      String? appName,
      String? appVersion,
      String? deviceName,
      String? userId,
      bool? isActive,
      DateTime? dateCreated,
      DateTime? dateRevoked,
      DateTime? dateLastActivity,
      String? userName}) {
    return AuthenticationInfo(
        id: id ?? this.id,
        accessToken: accessToken ?? this.accessToken,
        deviceId: deviceId ?? this.deviceId,
        appName: appName ?? this.appName,
        appVersion: appVersion ?? this.appVersion,
        deviceName: deviceName ?? this.deviceName,
        userId: userId ?? this.userId,
        isActive: isActive ?? this.isActive,
        dateCreated: dateCreated ?? this.dateCreated,
        dateRevoked: dateRevoked ?? this.dateRevoked,
        dateLastActivity: dateLastActivity ?? this.dateLastActivity,
        userName: userName ?? this.userName);
  }

  AuthenticationInfo copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? accessToken,
      Wrapped<String?>? deviceId,
      Wrapped<String?>? appName,
      Wrapped<String?>? appVersion,
      Wrapped<String?>? deviceName,
      Wrapped<String?>? userId,
      Wrapped<bool?>? isActive,
      Wrapped<DateTime?>? dateCreated,
      Wrapped<DateTime?>? dateRevoked,
      Wrapped<DateTime?>? dateLastActivity,
      Wrapped<String?>? userName}) {
    return AuthenticationInfo(
        id: (id != null ? id.value : this.id),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        appName: (appName != null ? appName.value : this.appName),
        appVersion: (appVersion != null ? appVersion.value : this.appVersion),
        deviceName: (deviceName != null ? deviceName.value : this.deviceName),
        userId: (userId != null ? userId.value : this.userId),
        isActive: (isActive != null ? isActive.value : this.isActive),
        dateCreated:
            (dateCreated != null ? dateCreated.value : this.dateCreated),
        dateRevoked:
            (dateRevoked != null ? dateRevoked.value : this.dateRevoked),
        dateLastActivity: (dateLastActivity != null
            ? dateLastActivity.value
            : this.dateLastActivity),
        userName: (userName != null ? userName.value : this.userName));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthenticationInfoQueryResult {
  const AuthenticationInfoQueryResult({
    this.items,
    this.totalRecordCount,
    this.startIndex,
  });

  factory AuthenticationInfoQueryResult.fromJson(Map<String, dynamic> json) =>
      _$AuthenticationInfoQueryResultFromJson(json);

  static const toJsonFactory = _$AuthenticationInfoQueryResultToJson;
  Map<String, dynamic> toJson() => _$AuthenticationInfoQueryResultToJson(this);

  @JsonKey(name: 'Items', defaultValue: <AuthenticationInfo>[])
  final List<AuthenticationInfo>? items;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  static const fromJsonFactory = _$AuthenticationInfoQueryResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AuthenticationInfoQueryResult &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      const DeepCollectionEquality().hash(startIndex) ^
      runtimeType.hashCode;
}

extension $AuthenticationInfoQueryResultExtension
    on AuthenticationInfoQueryResult {
  AuthenticationInfoQueryResult copyWith(
      {List<AuthenticationInfo>? items,
      int? totalRecordCount,
      int? startIndex}) {
    return AuthenticationInfoQueryResult(
        items: items ?? this.items,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount,
        startIndex: startIndex ?? this.startIndex);
  }

  AuthenticationInfoQueryResult copyWithWrapped(
      {Wrapped<List<AuthenticationInfo>?>? items,
      Wrapped<int?>? totalRecordCount,
      Wrapped<int?>? startIndex}) {
    return AuthenticationInfoQueryResult(
        items: (items != null ? items.value : this.items),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthenticationResult {
  const AuthenticationResult({
    this.user,
    this.sessionInfo,
    this.accessToken,
    this.serverId,
  });

  factory AuthenticationResult.fromJson(Map<String, dynamic> json) =>
      _$AuthenticationResultFromJson(json);

  static const toJsonFactory = _$AuthenticationResultToJson;
  Map<String, dynamic> toJson() => _$AuthenticationResultToJson(this);

  @JsonKey(name: 'User')
  final UserDto? user;
  @JsonKey(name: 'SessionInfo')
  final SessionInfoDto? sessionInfo;
  @JsonKey(name: 'AccessToken')
  final String? accessToken;
  @JsonKey(name: 'ServerId')
  final String? serverId;
  static const fromJsonFactory = _$AuthenticationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AuthenticationResult &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.sessionInfo, sessionInfo) ||
                const DeepCollectionEquality()
                    .equals(other.sessionInfo, sessionInfo)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.serverId, serverId) ||
                const DeepCollectionEquality()
                    .equals(other.serverId, serverId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(sessionInfo) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(serverId) ^
      runtimeType.hashCode;
}

extension $AuthenticationResultExtension on AuthenticationResult {
  AuthenticationResult copyWith(
      {UserDto? user,
      SessionInfoDto? sessionInfo,
      String? accessToken,
      String? serverId}) {
    return AuthenticationResult(
        user: user ?? this.user,
        sessionInfo: sessionInfo ?? this.sessionInfo,
        accessToken: accessToken ?? this.accessToken,
        serverId: serverId ?? this.serverId);
  }

  AuthenticationResult copyWithWrapped(
      {Wrapped<UserDto?>? user,
      Wrapped<SessionInfoDto?>? sessionInfo,
      Wrapped<String?>? accessToken,
      Wrapped<String?>? serverId}) {
    return AuthenticationResult(
        user: (user != null ? user.value : this.user),
        sessionInfo:
            (sessionInfo != null ? sessionInfo.value : this.sessionInfo),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        serverId: (serverId != null ? serverId.value : this.serverId));
  }
}

@JsonSerializable(explicitToJson: true)
class BaseItemDto {
  const BaseItemDto({
    this.name,
    this.originalTitle,
    this.serverId,
    this.id,
    this.etag,
    this.sourceType,
    this.playlistItemId,
    this.dateCreated,
    this.dateLastMediaAdded,
    this.extraType,
    this.airsBeforeSeasonNumber,
    this.airsAfterSeasonNumber,
    this.airsBeforeEpisodeNumber,
    this.canDelete,
    this.canDownload,
    this.hasLyrics,
    this.hasSubtitles,
    this.preferredMetadataLanguage,
    this.preferredMetadataCountryCode,
    this.container,
    this.sortName,
    this.forcedSortName,
    this.video3DFormat,
    this.premiereDate,
    this.externalUrls,
    this.mediaSources,
    this.criticRating,
    this.productionLocations,
    this.path,
    this.enableMediaSourceDisplay,
    this.officialRating,
    this.customRating,
    this.channelId,
    this.channelName,
    this.overview,
    this.taglines,
    this.genres,
    this.communityRating,
    this.cumulativeRunTimeTicks,
    this.runTimeTicks,
    this.playAccess,
    this.aspectRatio,
    this.productionYear,
    this.isPlaceHolder,
    this.number,
    this.channelNumber,
    this.indexNumber,
    this.indexNumberEnd,
    this.parentIndexNumber,
    this.remoteTrailers,
    this.providerIds,
    this.isHD,
    this.isFolder,
    this.parentId,
    this.type,
    this.people,
    this.studios,
    this.genreItems,
    this.parentLogoItemId,
    this.parentBackdropItemId,
    this.parentBackdropImageTags,
    this.localTrailerCount,
    this.userData,
    this.recursiveItemCount,
    this.childCount,
    this.seriesName,
    this.seriesId,
    this.seasonId,
    this.specialFeatureCount,
    this.displayPreferencesId,
    this.status,
    this.airTime,
    this.airDays,
    this.tags,
    this.primaryImageAspectRatio,
    this.artists,
    this.artistItems,
    this.album,
    this.collectionType,
    this.displayOrder,
    this.albumId,
    this.albumPrimaryImageTag,
    this.seriesPrimaryImageTag,
    this.albumArtist,
    this.albumArtists,
    this.seasonName,
    this.mediaStreams,
    this.videoType,
    this.partCount,
    this.mediaSourceCount,
    this.imageTags,
    this.backdropImageTags,
    this.screenshotImageTags,
    this.parentLogoImageTag,
    this.parentArtItemId,
    this.parentArtImageTag,
    this.seriesThumbImageTag,
    this.imageBlurHashes,
    this.seriesStudio,
    this.parentThumbItemId,
    this.parentThumbImageTag,
    this.parentPrimaryImageItemId,
    this.parentPrimaryImageTag,
    this.chapters,
    this.trickplay,
    this.locationType,
    this.isoType,
    this.mediaType,
    this.endDate,
    this.lockedFields,
    this.trailerCount,
    this.movieCount,
    this.seriesCount,
    this.programCount,
    this.episodeCount,
    this.songCount,
    this.albumCount,
    this.artistCount,
    this.musicVideoCount,
    this.lockData,
    this.width,
    this.height,
    this.cameraMake,
    this.cameraModel,
    this.software,
    this.exposureTime,
    this.focalLength,
    this.imageOrientation,
    this.aperture,
    this.shutterSpeed,
    this.latitude,
    this.longitude,
    this.altitude,
    this.isoSpeedRating,
    this.seriesTimerId,
    this.programId,
    this.channelPrimaryImageTag,
    this.startDate,
    this.completionPercentage,
    this.isRepeat,
    this.episodeTitle,
    this.channelType,
    this.audio,
    this.isMovie,
    this.isSports,
    this.isSeries,
    this.isLive,
    this.isNews,
    this.isKids,
    this.isPremiere,
    this.timerId,
    this.normalizationGain,
    this.currentProgram,
  });

  factory BaseItemDto.fromJson(Map<String, dynamic> json) =>
      _$BaseItemDtoFromJson(json);

  static const toJsonFactory = _$BaseItemDtoToJson;
  Map<String, dynamic> toJson() => _$BaseItemDtoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'ServerId')
  final String? serverId;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Etag')
  final String? etag;
  @JsonKey(name: 'SourceType')
  final String? sourceType;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  @JsonKey(name: 'DateCreated')
  final DateTime? dateCreated;
  @JsonKey(name: 'DateLastMediaAdded')
  final DateTime? dateLastMediaAdded;
  @JsonKey(
    name: 'ExtraType',
    toJson: extraTypeNullableToJson,
    fromJson: extraTypeNullableFromJson,
  )
  final enums.ExtraType? extraType;
  @JsonKey(name: 'AirsBeforeSeasonNumber')
  final int? airsBeforeSeasonNumber;
  @JsonKey(name: 'AirsAfterSeasonNumber')
  final int? airsAfterSeasonNumber;
  @JsonKey(name: 'AirsBeforeEpisodeNumber')
  final int? airsBeforeEpisodeNumber;
  @JsonKey(name: 'CanDelete')
  final bool? canDelete;
  @JsonKey(name: 'CanDownload')
  final bool? canDownload;
  @JsonKey(name: 'HasLyrics')
  final bool? hasLyrics;
  @JsonKey(name: 'HasSubtitles')
  final bool? hasSubtitles;
  @JsonKey(name: 'PreferredMetadataLanguage')
  final String? preferredMetadataLanguage;
  @JsonKey(name: 'PreferredMetadataCountryCode')
  final String? preferredMetadataCountryCode;
  @JsonKey(name: 'Container')
  final String? container;
  @JsonKey(name: 'SortName')
  final String? sortName;
  @JsonKey(name: 'ForcedSortName')
  final String? forcedSortName;
  @JsonKey(
    name: 'Video3DFormat',
    toJson: video3DFormatNullableToJson,
    fromJson: video3DFormatNullableFromJson,
  )
  final enums.Video3DFormat? video3DFormat;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'ExternalUrls', defaultValue: <ExternalUrl>[])
  final List<ExternalUrl>? externalUrls;
  @JsonKey(name: 'MediaSources', defaultValue: <MediaSourceInfo>[])
  final List<MediaSourceInfo>? mediaSources;
  @JsonKey(name: 'CriticRating')
  final double? criticRating;
  @JsonKey(name: 'ProductionLocations', defaultValue: <String>[])
  final List<String>? productionLocations;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'EnableMediaSourceDisplay')
  final bool? enableMediaSourceDisplay;
  @JsonKey(name: 'OfficialRating')
  final String? officialRating;
  @JsonKey(name: 'CustomRating')
  final String? customRating;
  @JsonKey(name: 'ChannelId')
  final String? channelId;
  @JsonKey(name: 'ChannelName')
  final String? channelName;
  @JsonKey(name: 'Overview')
  final String? overview;
  @JsonKey(name: 'Taglines', defaultValue: <String>[])
  final List<String>? taglines;
  @JsonKey(name: 'Genres', defaultValue: <String>[])
  final List<String>? genres;
  @JsonKey(name: 'CommunityRating')
  final double? communityRating;
  @JsonKey(name: 'CumulativeRunTimeTicks')
  final int? cumulativeRunTimeTicks;
  @JsonKey(name: 'RunTimeTicks')
  final int? runTimeTicks;
  @JsonKey(
    name: 'PlayAccess',
    toJson: playAccessNullableToJson,
    fromJson: playAccessNullableFromJson,
  )
  final enums.PlayAccess? playAccess;
  @JsonKey(name: 'AspectRatio')
  final String? aspectRatio;
  @JsonKey(name: 'ProductionYear')
  final int? productionYear;
  @JsonKey(name: 'IsPlaceHolder')
  final bool? isPlaceHolder;
  @JsonKey(name: 'Number')
  final String? number;
  @JsonKey(name: 'ChannelNumber')
  final String? channelNumber;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'IndexNumberEnd')
  final int? indexNumberEnd;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'RemoteTrailers', defaultValue: <MediaUrl>[])
  final List<MediaUrl>? remoteTrailers;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'IsHD')
  final bool? isHD;
  @JsonKey(name: 'IsFolder')
  final bool? isFolder;
  @JsonKey(name: 'ParentId')
  final String? parentId;
  @JsonKey(
    name: 'Type',
    toJson: baseItemKindNullableToJson,
    fromJson: baseItemKindNullableFromJson,
  )
  final enums.BaseItemKind? type;
  @JsonKey(name: 'People', defaultValue: <BaseItemPerson>[])
  final List<BaseItemPerson>? people;
  @JsonKey(name: 'Studios', defaultValue: <NameGuidPair>[])
  final List<NameGuidPair>? studios;
  @JsonKey(name: 'GenreItems', defaultValue: <NameGuidPair>[])
  final List<NameGuidPair>? genreItems;
  @JsonKey(name: 'ParentLogoItemId')
  final String? parentLogoItemId;
  @JsonKey(name: 'ParentBackdropItemId')
  final String? parentBackdropItemId;
  @JsonKey(name: 'ParentBackdropImageTags', defaultValue: <String>[])
  final List<String>? parentBackdropImageTags;
  @JsonKey(name: 'LocalTrailerCount')
  final int? localTrailerCount;
  @JsonKey(name: 'UserData')
  final UserItemDataDto? userData;
  @JsonKey(name: 'RecursiveItemCount')
  final int? recursiveItemCount;
  @JsonKey(name: 'ChildCount')
  final int? childCount;
  @JsonKey(name: 'SeriesName')
  final String? seriesName;
  @JsonKey(name: 'SeriesId')
  final String? seriesId;
  @JsonKey(name: 'SeasonId')
  final String? seasonId;
  @JsonKey(name: 'SpecialFeatureCount')
  final int? specialFeatureCount;
  @JsonKey(name: 'DisplayPreferencesId')
  final String? displayPreferencesId;
  @JsonKey(name: 'Status')
  final String? status;
  @JsonKey(name: 'AirTime')
  final String? airTime;
  @JsonKey(
    name: 'AirDays',
    toJson: dayOfWeekListToJson,
    fromJson: dayOfWeekListFromJson,
  )
  final List<enums.DayOfWeek>? airDays;
  @JsonKey(name: 'Tags', defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'PrimaryImageAspectRatio')
  final double? primaryImageAspectRatio;
  @JsonKey(name: 'Artists', defaultValue: <String>[])
  final List<String>? artists;
  @JsonKey(name: 'ArtistItems', defaultValue: <NameGuidPair>[])
  final List<NameGuidPair>? artistItems;
  @JsonKey(name: 'Album')
  final String? album;
  @JsonKey(
    name: 'CollectionType',
    toJson: collectionTypeNullableToJson,
    fromJson: collectionTypeNullableFromJson,
  )
  final enums.CollectionType? collectionType;
  @JsonKey(name: 'DisplayOrder')
  final String? displayOrder;
  @JsonKey(name: 'AlbumId')
  final String? albumId;
  @JsonKey(name: 'AlbumPrimaryImageTag')
  final String? albumPrimaryImageTag;
  @JsonKey(name: 'SeriesPrimaryImageTag')
  final String? seriesPrimaryImageTag;
  @JsonKey(name: 'AlbumArtist')
  final String? albumArtist;
  @JsonKey(name: 'AlbumArtists', defaultValue: <NameGuidPair>[])
  final List<NameGuidPair>? albumArtists;
  @JsonKey(name: 'SeasonName')
  final String? seasonName;
  @JsonKey(name: 'MediaStreams', defaultValue: <MediaStream>[])
  final List<MediaStream>? mediaStreams;
  @JsonKey(
    name: 'VideoType',
    toJson: videoTypeNullableToJson,
    fromJson: videoTypeNullableFromJson,
  )
  final enums.VideoType? videoType;
  @JsonKey(name: 'PartCount')
  final int? partCount;
  @JsonKey(name: 'MediaSourceCount')
  final int? mediaSourceCount;
  @JsonKey(name: 'ImageTags')
  final Map<String, dynamic>? imageTags;
  @JsonKey(name: 'BackdropImageTags', defaultValue: <String>[])
  final List<String>? backdropImageTags;
  @JsonKey(name: 'ScreenshotImageTags', defaultValue: <String>[])
  final List<String>? screenshotImageTags;
  @JsonKey(name: 'ParentLogoImageTag')
  final String? parentLogoImageTag;
  @JsonKey(name: 'ParentArtItemId')
  final String? parentArtItemId;
  @JsonKey(name: 'ParentArtImageTag')
  final String? parentArtImageTag;
  @JsonKey(name: 'SeriesThumbImageTag')
  final String? seriesThumbImageTag;
  @JsonKey(name: 'ImageBlurHashes')
  final BaseItemDto$ImageBlurHashes? imageBlurHashes;
  @JsonKey(name: 'SeriesStudio')
  final String? seriesStudio;
  @JsonKey(name: 'ParentThumbItemId')
  final String? parentThumbItemId;
  @JsonKey(name: 'ParentThumbImageTag')
  final String? parentThumbImageTag;
  @JsonKey(name: 'ParentPrimaryImageItemId')
  final String? parentPrimaryImageItemId;
  @JsonKey(name: 'ParentPrimaryImageTag')
  final String? parentPrimaryImageTag;
  @JsonKey(name: 'Chapters', defaultValue: <ChapterInfo>[])
  final List<ChapterInfo>? chapters;
  @JsonKey(name: 'Trickplay')
  final Map<String, dynamic>? trickplay;
  @JsonKey(
    name: 'LocationType',
    toJson: locationTypeNullableToJson,
    fromJson: locationTypeNullableFromJson,
  )
  final enums.LocationType? locationType;
  @JsonKey(
    name: 'IsoType',
    toJson: isoTypeNullableToJson,
    fromJson: isoTypeNullableFromJson,
  )
  final enums.IsoType? isoType;
  @JsonKey(
    name: 'MediaType',
    toJson: mediaTypeNullableToJson,
    fromJson: mediaTypeNullableFromJson,
  )
  final enums.MediaType? mediaType;
  @JsonKey(name: 'EndDate')
  final DateTime? endDate;
  @JsonKey(
    name: 'LockedFields',
    toJson: metadataFieldListToJson,
    fromJson: metadataFieldListFromJson,
  )
  final List<enums.MetadataField>? lockedFields;
  @JsonKey(name: 'TrailerCount')
  final int? trailerCount;
  @JsonKey(name: 'MovieCount')
  final int? movieCount;
  @JsonKey(name: 'SeriesCount')
  final int? seriesCount;
  @JsonKey(name: 'ProgramCount')
  final int? programCount;
  @JsonKey(name: 'EpisodeCount')
  final int? episodeCount;
  @JsonKey(name: 'SongCount')
  final int? songCount;
  @JsonKey(name: 'AlbumCount')
  final int? albumCount;
  @JsonKey(name: 'ArtistCount')
  final int? artistCount;
  @JsonKey(name: 'MusicVideoCount')
  final int? musicVideoCount;
  @JsonKey(name: 'LockData')
  final bool? lockData;
  @JsonKey(name: 'Width')
  final int? width;
  @JsonKey(name: 'Height')
  final int? height;
  @JsonKey(name: 'CameraMake')
  final String? cameraMake;
  @JsonKey(name: 'CameraModel')
  final String? cameraModel;
  @JsonKey(name: 'Software')
  final String? software;
  @JsonKey(name: 'ExposureTime')
  final double? exposureTime;
  @JsonKey(name: 'FocalLength')
  final double? focalLength;
  @JsonKey(
    name: 'ImageOrientation',
    toJson: imageOrientationNullableToJson,
    fromJson: imageOrientationNullableFromJson,
  )
  final enums.ImageOrientation? imageOrientation;
  @JsonKey(name: 'Aperture')
  final double? aperture;
  @JsonKey(name: 'ShutterSpeed')
  final double? shutterSpeed;
  @JsonKey(name: 'Latitude')
  final double? latitude;
  @JsonKey(name: 'Longitude')
  final double? longitude;
  @JsonKey(name: 'Altitude')
  final double? altitude;
  @JsonKey(name: 'IsoSpeedRating')
  final int? isoSpeedRating;
  @JsonKey(name: 'SeriesTimerId')
  final String? seriesTimerId;
  @JsonKey(name: 'ProgramId')
  final String? programId;
  @JsonKey(name: 'ChannelPrimaryImageTag')
  final String? channelPrimaryImageTag;
  @JsonKey(name: 'StartDate')
  final DateTime? startDate;
  @JsonKey(name: 'CompletionPercentage')
  final double? completionPercentage;
  @JsonKey(name: 'IsRepeat')
  final bool? isRepeat;
  @JsonKey(name: 'EpisodeTitle')
  final String? episodeTitle;
  @JsonKey(
    name: 'ChannelType',
    toJson: channelTypeNullableToJson,
    fromJson: channelTypeNullableFromJson,
  )
  final enums.ChannelType? channelType;
  @JsonKey(
    name: 'Audio',
    toJson: programAudioNullableToJson,
    fromJson: programAudioNullableFromJson,
  )
  final enums.ProgramAudio? audio;
  @JsonKey(name: 'IsMovie')
  final bool? isMovie;
  @JsonKey(name: 'IsSports')
  final bool? isSports;
  @JsonKey(name: 'IsSeries')
  final bool? isSeries;
  @JsonKey(name: 'IsLive')
  final bool? isLive;
  @JsonKey(name: 'IsNews')
  final bool? isNews;
  @JsonKey(name: 'IsKids')
  final bool? isKids;
  @JsonKey(name: 'IsPremiere')
  final bool? isPremiere;
  @JsonKey(name: 'TimerId')
  final String? timerId;
  @JsonKey(name: 'NormalizationGain')
  final double? normalizationGain;
  @JsonKey(name: 'CurrentProgram')
  final BaseItemDto? currentProgram;
  static const fromJsonFactory = _$BaseItemDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseItemDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.serverId, serverId) ||
                const DeepCollectionEquality()
                    .equals(other.serverId, serverId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.etag, etag) ||
                const DeepCollectionEquality().equals(other.etag, etag)) &&
            (identical(other.sourceType, sourceType) ||
                const DeepCollectionEquality()
                    .equals(other.sourceType, sourceType)) &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)) &&
            (identical(other.dateCreated, dateCreated) ||
                const DeepCollectionEquality()
                    .equals(other.dateCreated, dateCreated)) &&
            (identical(other.dateLastMediaAdded, dateLastMediaAdded) ||
                const DeepCollectionEquality()
                    .equals(other.dateLastMediaAdded, dateLastMediaAdded)) &&
            (identical(other.extraType, extraType) ||
                const DeepCollectionEquality()
                    .equals(other.extraType, extraType)) &&
            (identical(other.airsBeforeSeasonNumber, airsBeforeSeasonNumber) ||
                const DeepCollectionEquality().equals(
                    other.airsBeforeSeasonNumber, airsBeforeSeasonNumber)) &&
            (identical(other.airsAfterSeasonNumber, airsAfterSeasonNumber) ||
                const DeepCollectionEquality().equals(
                    other.airsAfterSeasonNumber, airsAfterSeasonNumber)) &&
            (identical(other.airsBeforeEpisodeNumber, airsBeforeEpisodeNumber) ||
                const DeepCollectionEquality().equals(
                    other.airsBeforeEpisodeNumber, airsBeforeEpisodeNumber)) &&
            (identical(other.canDelete, canDelete) ||
                const DeepCollectionEquality()
                    .equals(other.canDelete, canDelete)) &&
            (identical(other.canDownload, canDownload) ||
                const DeepCollectionEquality()
                    .equals(other.canDownload, canDownload)) &&
            (identical(other.hasLyrics, hasLyrics) ||
                const DeepCollectionEquality()
                    .equals(other.hasLyrics, hasLyrics)) &&
            (identical(other.hasSubtitles, hasSubtitles) ||
                const DeepCollectionEquality()
                    .equals(other.hasSubtitles, hasSubtitles)) &&
            (identical(other.preferredMetadataLanguage, preferredMetadataLanguage) ||
                const DeepCollectionEquality().equals(
                    other.preferredMetadataLanguage,
                    preferredMetadataLanguage)) &&
            (identical(other.preferredMetadataCountryCode, preferredMetadataCountryCode) ||
                const DeepCollectionEquality().equals(
                    other.preferredMetadataCountryCode,
                    preferredMetadataCountryCode)) &&
            (identical(other.container, container) || const DeepCollectionEquality().equals(other.container, container)) &&
            (identical(other.sortName, sortName) || const DeepCollectionEquality().equals(other.sortName, sortName)) &&
            (identical(other.forcedSortName, forcedSortName) || const DeepCollectionEquality().equals(other.forcedSortName, forcedSortName)) &&
            (identical(other.video3DFormat, video3DFormat) || const DeepCollectionEquality().equals(other.video3DFormat, video3DFormat)) &&
            (identical(other.premiereDate, premiereDate) || const DeepCollectionEquality().equals(other.premiereDate, premiereDate)) &&
            (identical(other.externalUrls, externalUrls) || const DeepCollectionEquality().equals(other.externalUrls, externalUrls)) &&
            (identical(other.mediaSources, mediaSources) || const DeepCollectionEquality().equals(other.mediaSources, mediaSources)) &&
            (identical(other.criticRating, criticRating) || const DeepCollectionEquality().equals(other.criticRating, criticRating)) &&
            (identical(other.productionLocations, productionLocations) || const DeepCollectionEquality().equals(other.productionLocations, productionLocations)) &&
            (identical(other.path, path) || const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.enableMediaSourceDisplay, enableMediaSourceDisplay) || const DeepCollectionEquality().equals(other.enableMediaSourceDisplay, enableMediaSourceDisplay)) &&
            (identical(other.officialRating, officialRating) || const DeepCollectionEquality().equals(other.officialRating, officialRating)) &&
            (identical(other.customRating, customRating) || const DeepCollectionEquality().equals(other.customRating, customRating)) &&
            (identical(other.channelId, channelId) || const DeepCollectionEquality().equals(other.channelId, channelId)) &&
            (identical(other.channelName, channelName) || const DeepCollectionEquality().equals(other.channelName, channelName)) &&
            (identical(other.overview, overview) || const DeepCollectionEquality().equals(other.overview, overview)) &&
            (identical(other.taglines, taglines) || const DeepCollectionEquality().equals(other.taglines, taglines)) &&
            (identical(other.genres, genres) || const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.communityRating, communityRating) || const DeepCollectionEquality().equals(other.communityRating, communityRating)) &&
            (identical(other.cumulativeRunTimeTicks, cumulativeRunTimeTicks) || const DeepCollectionEquality().equals(other.cumulativeRunTimeTicks, cumulativeRunTimeTicks)) &&
            (identical(other.runTimeTicks, runTimeTicks) || const DeepCollectionEquality().equals(other.runTimeTicks, runTimeTicks)) &&
            (identical(other.playAccess, playAccess) || const DeepCollectionEquality().equals(other.playAccess, playAccess)) &&
            (identical(other.aspectRatio, aspectRatio) || const DeepCollectionEquality().equals(other.aspectRatio, aspectRatio)) &&
            (identical(other.productionYear, productionYear) || const DeepCollectionEquality().equals(other.productionYear, productionYear)) &&
            (identical(other.isPlaceHolder, isPlaceHolder) || const DeepCollectionEquality().equals(other.isPlaceHolder, isPlaceHolder)) &&
            (identical(other.number, number) || const DeepCollectionEquality().equals(other.number, number)) &&
            (identical(other.channelNumber, channelNumber) || const DeepCollectionEquality().equals(other.channelNumber, channelNumber)) &&
            (identical(other.indexNumber, indexNumber) || const DeepCollectionEquality().equals(other.indexNumber, indexNumber)) &&
            (identical(other.indexNumberEnd, indexNumberEnd) || const DeepCollectionEquality().equals(other.indexNumberEnd, indexNumberEnd)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) || const DeepCollectionEquality().equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.remoteTrailers, remoteTrailers) || const DeepCollectionEquality().equals(other.remoteTrailers, remoteTrailers)) &&
            (identical(other.providerIds, providerIds) || const DeepCollectionEquality().equals(other.providerIds, providerIds)) &&
            (identical(other.isHD, isHD) || const DeepCollectionEquality().equals(other.isHD, isHD)) &&
            (identical(other.isFolder, isFolder) || const DeepCollectionEquality().equals(other.isFolder, isFolder)) &&
            (identical(other.parentId, parentId) || const DeepCollectionEquality().equals(other.parentId, parentId)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.people, people) || const DeepCollectionEquality().equals(other.people, people)) &&
            (identical(other.studios, studios) || const DeepCollectionEquality().equals(other.studios, studios)) &&
            (identical(other.genreItems, genreItems) || const DeepCollectionEquality().equals(other.genreItems, genreItems)) &&
            (identical(other.parentLogoItemId, parentLogoItemId) || const DeepCollectionEquality().equals(other.parentLogoItemId, parentLogoItemId)) &&
            (identical(other.parentBackdropItemId, parentBackdropItemId) || const DeepCollectionEquality().equals(other.parentBackdropItemId, parentBackdropItemId)) &&
            (identical(other.parentBackdropImageTags, parentBackdropImageTags) || const DeepCollectionEquality().equals(other.parentBackdropImageTags, parentBackdropImageTags)) &&
            (identical(other.localTrailerCount, localTrailerCount) || const DeepCollectionEquality().equals(other.localTrailerCount, localTrailerCount)) &&
            (identical(other.userData, userData) || const DeepCollectionEquality().equals(other.userData, userData)) &&
            (identical(other.recursiveItemCount, recursiveItemCount) || const DeepCollectionEquality().equals(other.recursiveItemCount, recursiveItemCount)) &&
            (identical(other.childCount, childCount) || const DeepCollectionEquality().equals(other.childCount, childCount)) &&
            (identical(other.seriesName, seriesName) || const DeepCollectionEquality().equals(other.seriesName, seriesName)) &&
            (identical(other.seriesId, seriesId) || const DeepCollectionEquality().equals(other.seriesId, seriesId)) &&
            (identical(other.seasonId, seasonId) || const DeepCollectionEquality().equals(other.seasonId, seasonId)) &&
            (identical(other.specialFeatureCount, specialFeatureCount) || const DeepCollectionEquality().equals(other.specialFeatureCount, specialFeatureCount)) &&
            (identical(other.displayPreferencesId, displayPreferencesId) || const DeepCollectionEquality().equals(other.displayPreferencesId, displayPreferencesId)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.airTime, airTime) || const DeepCollectionEquality().equals(other.airTime, airTime)) &&
            (identical(other.airDays, airDays) || const DeepCollectionEquality().equals(other.airDays, airDays)) &&
            (identical(other.tags, tags) || const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.primaryImageAspectRatio, primaryImageAspectRatio) || const DeepCollectionEquality().equals(other.primaryImageAspectRatio, primaryImageAspectRatio)) &&
            (identical(other.artists, artists) || const DeepCollectionEquality().equals(other.artists, artists)) &&
            (identical(other.artistItems, artistItems) || const DeepCollectionEquality().equals(other.artistItems, artistItems)) &&
            (identical(other.album, album) || const DeepCollectionEquality().equals(other.album, album)) &&
            (identical(other.collectionType, collectionType) || const DeepCollectionEquality().equals(other.collectionType, collectionType)) &&
            (identical(other.displayOrder, displayOrder) || const DeepCollectionEquality().equals(other.displayOrder, displayOrder)) &&
            (identical(other.albumId, albumId) || const DeepCollectionEquality().equals(other.albumId, albumId)) &&
            (identical(other.albumPrimaryImageTag, albumPrimaryImageTag) || const DeepCollectionEquality().equals(other.albumPrimaryImageTag, albumPrimaryImageTag)) &&
            (identical(other.seriesPrimaryImageTag, seriesPrimaryImageTag) || const DeepCollectionEquality().equals(other.seriesPrimaryImageTag, seriesPrimaryImageTag)) &&
            (identical(other.albumArtist, albumArtist) || const DeepCollectionEquality().equals(other.albumArtist, albumArtist)) &&
            (identical(other.albumArtists, albumArtists) || const DeepCollectionEquality().equals(other.albumArtists, albumArtists)) &&
            (identical(other.seasonName, seasonName) || const DeepCollectionEquality().equals(other.seasonName, seasonName)) &&
            (identical(other.mediaStreams, mediaStreams) || const DeepCollectionEquality().equals(other.mediaStreams, mediaStreams)) &&
            (identical(other.videoType, videoType) || const DeepCollectionEquality().equals(other.videoType, videoType)) &&
            (identical(other.partCount, partCount) || const DeepCollectionEquality().equals(other.partCount, partCount)) &&
            (identical(other.mediaSourceCount, mediaSourceCount) || const DeepCollectionEquality().equals(other.mediaSourceCount, mediaSourceCount)) &&
            (identical(other.imageTags, imageTags) || const DeepCollectionEquality().equals(other.imageTags, imageTags)) &&
            (identical(other.backdropImageTags, backdropImageTags) || const DeepCollectionEquality().equals(other.backdropImageTags, backdropImageTags)) &&
            (identical(other.screenshotImageTags, screenshotImageTags) || const DeepCollectionEquality().equals(other.screenshotImageTags, screenshotImageTags)) &&
            (identical(other.parentLogoImageTag, parentLogoImageTag) || const DeepCollectionEquality().equals(other.parentLogoImageTag, parentLogoImageTag)) &&
            (identical(other.parentArtItemId, parentArtItemId) || const DeepCollectionEquality().equals(other.parentArtItemId, parentArtItemId)) &&
            (identical(other.parentArtImageTag, parentArtImageTag) || const DeepCollectionEquality().equals(other.parentArtImageTag, parentArtImageTag)) &&
            (identical(other.seriesThumbImageTag, seriesThumbImageTag) || const DeepCollectionEquality().equals(other.seriesThumbImageTag, seriesThumbImageTag)) &&
            (identical(other.imageBlurHashes, imageBlurHashes) || const DeepCollectionEquality().equals(other.imageBlurHashes, imageBlurHashes)) &&
            (identical(other.seriesStudio, seriesStudio) || const DeepCollectionEquality().equals(other.seriesStudio, seriesStudio)) &&
            (identical(other.parentThumbItemId, parentThumbItemId) || const DeepCollectionEquality().equals(other.parentThumbItemId, parentThumbItemId)) &&
            (identical(other.parentThumbImageTag, parentThumbImageTag) || const DeepCollectionEquality().equals(other.parentThumbImageTag, parentThumbImageTag)) &&
            (identical(other.parentPrimaryImageItemId, parentPrimaryImageItemId) || const DeepCollectionEquality().equals(other.parentPrimaryImageItemId, parentPrimaryImageItemId)) &&
            (identical(other.parentPrimaryImageTag, parentPrimaryImageTag) || const DeepCollectionEquality().equals(other.parentPrimaryImageTag, parentPrimaryImageTag)) &&
            (identical(other.chapters, chapters) || const DeepCollectionEquality().equals(other.chapters, chapters)) &&
            (identical(other.trickplay, trickplay) || const DeepCollectionEquality().equals(other.trickplay, trickplay)) &&
            (identical(other.locationType, locationType) || const DeepCollectionEquality().equals(other.locationType, locationType)) &&
            (identical(other.isoType, isoType) || const DeepCollectionEquality().equals(other.isoType, isoType)) &&
            (identical(other.mediaType, mediaType) || const DeepCollectionEquality().equals(other.mediaType, mediaType)) &&
            (identical(other.endDate, endDate) || const DeepCollectionEquality().equals(other.endDate, endDate)) &&
            (identical(other.lockedFields, lockedFields) || const DeepCollectionEquality().equals(other.lockedFields, lockedFields)) &&
            (identical(other.trailerCount, trailerCount) || const DeepCollectionEquality().equals(other.trailerCount, trailerCount)) &&
            (identical(other.movieCount, movieCount) || const DeepCollectionEquality().equals(other.movieCount, movieCount)) &&
            (identical(other.seriesCount, seriesCount) || const DeepCollectionEquality().equals(other.seriesCount, seriesCount)) &&
            (identical(other.programCount, programCount) || const DeepCollectionEquality().equals(other.programCount, programCount)) &&
            (identical(other.episodeCount, episodeCount) || const DeepCollectionEquality().equals(other.episodeCount, episodeCount)) &&
            (identical(other.songCount, songCount) || const DeepCollectionEquality().equals(other.songCount, songCount)) &&
            (identical(other.albumCount, albumCount) || const DeepCollectionEquality().equals(other.albumCount, albumCount)) &&
            (identical(other.artistCount, artistCount) || const DeepCollectionEquality().equals(other.artistCount, artistCount)) &&
            (identical(other.musicVideoCount, musicVideoCount) || const DeepCollectionEquality().equals(other.musicVideoCount, musicVideoCount)) &&
            (identical(other.lockData, lockData) || const DeepCollectionEquality().equals(other.lockData, lockData)) &&
            (identical(other.width, width) || const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) || const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.cameraMake, cameraMake) || const DeepCollectionEquality().equals(other.cameraMake, cameraMake)) &&
            (identical(other.cameraModel, cameraModel) || const DeepCollectionEquality().equals(other.cameraModel, cameraModel)) &&
            (identical(other.software, software) || const DeepCollectionEquality().equals(other.software, software)) &&
            (identical(other.exposureTime, exposureTime) || const DeepCollectionEquality().equals(other.exposureTime, exposureTime)) &&
            (identical(other.focalLength, focalLength) || const DeepCollectionEquality().equals(other.focalLength, focalLength)) &&
            (identical(other.imageOrientation, imageOrientation) || const DeepCollectionEquality().equals(other.imageOrientation, imageOrientation)) &&
            (identical(other.aperture, aperture) || const DeepCollectionEquality().equals(other.aperture, aperture)) &&
            (identical(other.shutterSpeed, shutterSpeed) || const DeepCollectionEquality().equals(other.shutterSpeed, shutterSpeed)) &&
            (identical(other.latitude, latitude) || const DeepCollectionEquality().equals(other.latitude, latitude)) &&
            (identical(other.longitude, longitude) || const DeepCollectionEquality().equals(other.longitude, longitude)) &&
            (identical(other.altitude, altitude) || const DeepCollectionEquality().equals(other.altitude, altitude)) &&
            (identical(other.isoSpeedRating, isoSpeedRating) || const DeepCollectionEquality().equals(other.isoSpeedRating, isoSpeedRating)) &&
            (identical(other.seriesTimerId, seriesTimerId) || const DeepCollectionEquality().equals(other.seriesTimerId, seriesTimerId)) &&
            (identical(other.programId, programId) || const DeepCollectionEquality().equals(other.programId, programId)) &&
            (identical(other.channelPrimaryImageTag, channelPrimaryImageTag) || const DeepCollectionEquality().equals(other.channelPrimaryImageTag, channelPrimaryImageTag)) &&
            (identical(other.startDate, startDate) || const DeepCollectionEquality().equals(other.startDate, startDate)) &&
            (identical(other.completionPercentage, completionPercentage) || const DeepCollectionEquality().equals(other.completionPercentage, completionPercentage)) &&
            (identical(other.isRepeat, isRepeat) || const DeepCollectionEquality().equals(other.isRepeat, isRepeat)) &&
            (identical(other.episodeTitle, episodeTitle) || const DeepCollectionEquality().equals(other.episodeTitle, episodeTitle)) &&
            (identical(other.channelType, channelType) || const DeepCollectionEquality().equals(other.channelType, channelType)) &&
            (identical(other.audio, audio) || const DeepCollectionEquality().equals(other.audio, audio)) &&
            (identical(other.isMovie, isMovie) || const DeepCollectionEquality().equals(other.isMovie, isMovie)) &&
            (identical(other.isSports, isSports) || const DeepCollectionEquality().equals(other.isSports, isSports)) &&
            (identical(other.isSeries, isSeries) || const DeepCollectionEquality().equals(other.isSeries, isSeries)) &&
            (identical(other.isLive, isLive) || const DeepCollectionEquality().equals(other.isLive, isLive)) &&
            (identical(other.isNews, isNews) || const DeepCollectionEquality().equals(other.isNews, isNews)) &&
            (identical(other.isKids, isKids) || const DeepCollectionEquality().equals(other.isKids, isKids)) &&
            (identical(other.isPremiere, isPremiere) || const DeepCollectionEquality().equals(other.isPremiere, isPremiere)) &&
            (identical(other.timerId, timerId) || const DeepCollectionEquality().equals(other.timerId, timerId)) &&
            (identical(other.normalizationGain, normalizationGain) || const DeepCollectionEquality().equals(other.normalizationGain, normalizationGain)) &&
            (identical(other.currentProgram, currentProgram) || const DeepCollectionEquality().equals(other.currentProgram, currentProgram)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(serverId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(etag) ^
      const DeepCollectionEquality().hash(sourceType) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      const DeepCollectionEquality().hash(dateCreated) ^
      const DeepCollectionEquality().hash(dateLastMediaAdded) ^
      const DeepCollectionEquality().hash(extraType) ^
      const DeepCollectionEquality().hash(airsBeforeSeasonNumber) ^
      const DeepCollectionEquality().hash(airsAfterSeasonNumber) ^
      const DeepCollectionEquality().hash(airsBeforeEpisodeNumber) ^
      const DeepCollectionEquality().hash(canDelete) ^
      const DeepCollectionEquality().hash(canDownload) ^
      const DeepCollectionEquality().hash(hasLyrics) ^
      const DeepCollectionEquality().hash(hasSubtitles) ^
      const DeepCollectionEquality().hash(preferredMetadataLanguage) ^
      const DeepCollectionEquality().hash(preferredMetadataCountryCode) ^
      const DeepCollectionEquality().hash(container) ^
      const DeepCollectionEquality().hash(sortName) ^
      const DeepCollectionEquality().hash(forcedSortName) ^
      const DeepCollectionEquality().hash(video3DFormat) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(externalUrls) ^
      const DeepCollectionEquality().hash(mediaSources) ^
      const DeepCollectionEquality().hash(criticRating) ^
      const DeepCollectionEquality().hash(productionLocations) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(enableMediaSourceDisplay) ^
      const DeepCollectionEquality().hash(officialRating) ^
      const DeepCollectionEquality().hash(customRating) ^
      const DeepCollectionEquality().hash(channelId) ^
      const DeepCollectionEquality().hash(channelName) ^
      const DeepCollectionEquality().hash(overview) ^
      const DeepCollectionEquality().hash(taglines) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(communityRating) ^
      const DeepCollectionEquality().hash(cumulativeRunTimeTicks) ^
      const DeepCollectionEquality().hash(runTimeTicks) ^
      const DeepCollectionEquality().hash(playAccess) ^
      const DeepCollectionEquality().hash(aspectRatio) ^
      const DeepCollectionEquality().hash(productionYear) ^
      const DeepCollectionEquality().hash(isPlaceHolder) ^
      const DeepCollectionEquality().hash(number) ^
      const DeepCollectionEquality().hash(channelNumber) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(indexNumberEnd) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(remoteTrailers) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(isHD) ^
      const DeepCollectionEquality().hash(isFolder) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(people) ^
      const DeepCollectionEquality().hash(studios) ^
      const DeepCollectionEquality().hash(genreItems) ^
      const DeepCollectionEquality().hash(parentLogoItemId) ^
      const DeepCollectionEquality().hash(parentBackdropItemId) ^
      const DeepCollectionEquality().hash(parentBackdropImageTags) ^
      const DeepCollectionEquality().hash(localTrailerCount) ^
      const DeepCollectionEquality().hash(userData) ^
      const DeepCollectionEquality().hash(recursiveItemCount) ^
      const DeepCollectionEquality().hash(childCount) ^
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(seasonId) ^
      const DeepCollectionEquality().hash(specialFeatureCount) ^
      const DeepCollectionEquality().hash(displayPreferencesId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(airTime) ^
      const DeepCollectionEquality().hash(airDays) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(primaryImageAspectRatio) ^
      const DeepCollectionEquality().hash(artists) ^
      const DeepCollectionEquality().hash(artistItems) ^
      const DeepCollectionEquality().hash(album) ^
      const DeepCollectionEquality().hash(collectionType) ^
      const DeepCollectionEquality().hash(displayOrder) ^
      const DeepCollectionEquality().hash(albumId) ^
      const DeepCollectionEquality().hash(albumPrimaryImageTag) ^
      const DeepCollectionEquality().hash(seriesPrimaryImageTag) ^
      const DeepCollectionEquality().hash(albumArtist) ^
      const DeepCollectionEquality().hash(albumArtists) ^
      const DeepCollectionEquality().hash(seasonName) ^
      const DeepCollectionEquality().hash(mediaStreams) ^
      const DeepCollectionEquality().hash(videoType) ^
      const DeepCollectionEquality().hash(partCount) ^
      const DeepCollectionEquality().hash(mediaSourceCount) ^
      const DeepCollectionEquality().hash(imageTags) ^
      const DeepCollectionEquality().hash(backdropImageTags) ^
      const DeepCollectionEquality().hash(screenshotImageTags) ^
      const DeepCollectionEquality().hash(parentLogoImageTag) ^
      const DeepCollectionEquality().hash(parentArtItemId) ^
      const DeepCollectionEquality().hash(parentArtImageTag) ^
      const DeepCollectionEquality().hash(seriesThumbImageTag) ^
      const DeepCollectionEquality().hash(imageBlurHashes) ^
      const DeepCollectionEquality().hash(seriesStudio) ^
      const DeepCollectionEquality().hash(parentThumbItemId) ^
      const DeepCollectionEquality().hash(parentThumbImageTag) ^
      const DeepCollectionEquality().hash(parentPrimaryImageItemId) ^
      const DeepCollectionEquality().hash(parentPrimaryImageTag) ^
      const DeepCollectionEquality().hash(chapters) ^
      const DeepCollectionEquality().hash(trickplay) ^
      const DeepCollectionEquality().hash(locationType) ^
      const DeepCollectionEquality().hash(isoType) ^
      const DeepCollectionEquality().hash(mediaType) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(lockedFields) ^
      const DeepCollectionEquality().hash(trailerCount) ^
      const DeepCollectionEquality().hash(movieCount) ^
      const DeepCollectionEquality().hash(seriesCount) ^
      const DeepCollectionEquality().hash(programCount) ^
      const DeepCollectionEquality().hash(episodeCount) ^
      const DeepCollectionEquality().hash(songCount) ^
      const DeepCollectionEquality().hash(albumCount) ^
      const DeepCollectionEquality().hash(artistCount) ^
      const DeepCollectionEquality().hash(musicVideoCount) ^
      const DeepCollectionEquality().hash(lockData) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(cameraMake) ^
      const DeepCollectionEquality().hash(cameraModel) ^
      const DeepCollectionEquality().hash(software) ^
      const DeepCollectionEquality().hash(exposureTime) ^
      const DeepCollectionEquality().hash(focalLength) ^
      const DeepCollectionEquality().hash(imageOrientation) ^
      const DeepCollectionEquality().hash(aperture) ^
      const DeepCollectionEquality().hash(shutterSpeed) ^
      const DeepCollectionEquality().hash(latitude) ^
      const DeepCollectionEquality().hash(longitude) ^
      const DeepCollectionEquality().hash(altitude) ^
      const DeepCollectionEquality().hash(isoSpeedRating) ^
      const DeepCollectionEquality().hash(seriesTimerId) ^
      const DeepCollectionEquality().hash(programId) ^
      const DeepCollectionEquality().hash(channelPrimaryImageTag) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(completionPercentage) ^
      const DeepCollectionEquality().hash(isRepeat) ^
      const DeepCollectionEquality().hash(episodeTitle) ^
      const DeepCollectionEquality().hash(channelType) ^
      const DeepCollectionEquality().hash(audio) ^
      const DeepCollectionEquality().hash(isMovie) ^
      const DeepCollectionEquality().hash(isSports) ^
      const DeepCollectionEquality().hash(isSeries) ^
      const DeepCollectionEquality().hash(isLive) ^
      const DeepCollectionEquality().hash(isNews) ^
      const DeepCollectionEquality().hash(isKids) ^
      const DeepCollectionEquality().hash(isPremiere) ^
      const DeepCollectionEquality().hash(timerId) ^
      const DeepCollectionEquality().hash(normalizationGain) ^
      const DeepCollectionEquality().hash(currentProgram) ^
      runtimeType.hashCode;
}

extension $BaseItemDtoExtension on BaseItemDto {
  BaseItemDto copyWith(
      {String? name,
      String? originalTitle,
      String? serverId,
      String? id,
      String? etag,
      String? sourceType,
      String? playlistItemId,
      DateTime? dateCreated,
      DateTime? dateLastMediaAdded,
      enums.ExtraType? extraType,
      int? airsBeforeSeasonNumber,
      int? airsAfterSeasonNumber,
      int? airsBeforeEpisodeNumber,
      bool? canDelete,
      bool? canDownload,
      bool? hasLyrics,
      bool? hasSubtitles,
      String? preferredMetadataLanguage,
      String? preferredMetadataCountryCode,
      String? container,
      String? sortName,
      String? forcedSortName,
      enums.Video3DFormat? video3DFormat,
      DateTime? premiereDate,
      List<ExternalUrl>? externalUrls,
      List<MediaSourceInfo>? mediaSources,
      double? criticRating,
      List<String>? productionLocations,
      String? path,
      bool? enableMediaSourceDisplay,
      String? officialRating,
      String? customRating,
      String? channelId,
      String? channelName,
      String? overview,
      List<String>? taglines,
      List<String>? genres,
      double? communityRating,
      int? cumulativeRunTimeTicks,
      int? runTimeTicks,
      enums.PlayAccess? playAccess,
      String? aspectRatio,
      int? productionYear,
      bool? isPlaceHolder,
      String? number,
      String? channelNumber,
      int? indexNumber,
      int? indexNumberEnd,
      int? parentIndexNumber,
      List<MediaUrl>? remoteTrailers,
      Map<String, dynamic>? providerIds,
      bool? isHD,
      bool? isFolder,
      String? parentId,
      enums.BaseItemKind? type,
      List<BaseItemPerson>? people,
      List<NameGuidPair>? studios,
      List<NameGuidPair>? genreItems,
      String? parentLogoItemId,
      String? parentBackdropItemId,
      List<String>? parentBackdropImageTags,
      int? localTrailerCount,
      UserItemDataDto? userData,
      int? recursiveItemCount,
      int? childCount,
      String? seriesName,
      String? seriesId,
      String? seasonId,
      int? specialFeatureCount,
      String? displayPreferencesId,
      String? status,
      String? airTime,
      List<enums.DayOfWeek>? airDays,
      List<String>? tags,
      double? primaryImageAspectRatio,
      List<String>? artists,
      List<NameGuidPair>? artistItems,
      String? album,
      enums.CollectionType? collectionType,
      String? displayOrder,
      String? albumId,
      String? albumPrimaryImageTag,
      String? seriesPrimaryImageTag,
      String? albumArtist,
      List<NameGuidPair>? albumArtists,
      String? seasonName,
      List<MediaStream>? mediaStreams,
      enums.VideoType? videoType,
      int? partCount,
      int? mediaSourceCount,
      Map<String, dynamic>? imageTags,
      List<String>? backdropImageTags,
      List<String>? screenshotImageTags,
      String? parentLogoImageTag,
      String? parentArtItemId,
      String? parentArtImageTag,
      String? seriesThumbImageTag,
      BaseItemDto$ImageBlurHashes? imageBlurHashes,
      String? seriesStudio,
      String? parentThumbItemId,
      String? parentThumbImageTag,
      String? parentPrimaryImageItemId,
      String? parentPrimaryImageTag,
      List<ChapterInfo>? chapters,
      Map<String, dynamic>? trickplay,
      enums.LocationType? locationType,
      enums.IsoType? isoType,
      enums.MediaType? mediaType,
      DateTime? endDate,
      List<enums.MetadataField>? lockedFields,
      int? trailerCount,
      int? movieCount,
      int? seriesCount,
      int? programCount,
      int? episodeCount,
      int? songCount,
      int? albumCount,
      int? artistCount,
      int? musicVideoCount,
      bool? lockData,
      int? width,
      int? height,
      String? cameraMake,
      String? cameraModel,
      String? software,
      double? exposureTime,
      double? focalLength,
      enums.ImageOrientation? imageOrientation,
      double? aperture,
      double? shutterSpeed,
      double? latitude,
      double? longitude,
      double? altitude,
      int? isoSpeedRating,
      String? seriesTimerId,
      String? programId,
      String? channelPrimaryImageTag,
      DateTime? startDate,
      double? completionPercentage,
      bool? isRepeat,
      String? episodeTitle,
      enums.ChannelType? channelType,
      enums.ProgramAudio? audio,
      bool? isMovie,
      bool? isSports,
      bool? isSeries,
      bool? isLive,
      bool? isNews,
      bool? isKids,
      bool? isPremiere,
      String? timerId,
      double? normalizationGain,
      BaseItemDto? currentProgram}) {
    return BaseItemDto(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        serverId: serverId ?? this.serverId,
        id: id ?? this.id,
        etag: etag ?? this.etag,
        sourceType: sourceType ?? this.sourceType,
        playlistItemId: playlistItemId ?? this.playlistItemId,
        dateCreated: dateCreated ?? this.dateCreated,
        dateLastMediaAdded: dateLastMediaAdded ?? this.dateLastMediaAdded,
        extraType: extraType ?? this.extraType,
        airsBeforeSeasonNumber:
            airsBeforeSeasonNumber ?? this.airsBeforeSeasonNumber,
        airsAfterSeasonNumber:
            airsAfterSeasonNumber ?? this.airsAfterSeasonNumber,
        airsBeforeEpisodeNumber:
            airsBeforeEpisodeNumber ?? this.airsBeforeEpisodeNumber,
        canDelete: canDelete ?? this.canDelete,
        canDownload: canDownload ?? this.canDownload,
        hasLyrics: hasLyrics ?? this.hasLyrics,
        hasSubtitles: hasSubtitles ?? this.hasSubtitles,
        preferredMetadataLanguage:
            preferredMetadataLanguage ?? this.preferredMetadataLanguage,
        preferredMetadataCountryCode:
            preferredMetadataCountryCode ?? this.preferredMetadataCountryCode,
        container: container ?? this.container,
        sortName: sortName ?? this.sortName,
        forcedSortName: forcedSortName ?? this.forcedSortName,
        video3DFormat: video3DFormat ?? this.video3DFormat,
        premiereDate: premiereDate ?? this.premiereDate,
        externalUrls: externalUrls ?? this.externalUrls,
        mediaSources: mediaSources ?? this.mediaSources,
        criticRating: criticRating ?? this.criticRating,
        productionLocations: productionLocations ?? this.productionLocations,
        path: path ?? this.path,
        enableMediaSourceDisplay:
            enableMediaSourceDisplay ?? this.enableMediaSourceDisplay,
        officialRating: officialRating ?? this.officialRating,
        customRating: customRating ?? this.customRating,
        channelId: channelId ?? this.channelId,
        channelName: channelName ?? this.channelName,
        overview: overview ?? this.overview,
        taglines: taglines ?? this.taglines,
        genres: genres ?? this.genres,
        communityRating: communityRating ?? this.communityRating,
        cumulativeRunTimeTicks:
            cumulativeRunTimeTicks ?? this.cumulativeRunTimeTicks,
        runTimeTicks: runTimeTicks ?? this.runTimeTicks,
        playAccess: playAccess ?? this.playAccess,
        aspectRatio: aspectRatio ?? this.aspectRatio,
        productionYear: productionYear ?? this.productionYear,
        isPlaceHolder: isPlaceHolder ?? this.isPlaceHolder,
        number: number ?? this.number,
        channelNumber: channelNumber ?? this.channelNumber,
        indexNumber: indexNumber ?? this.indexNumber,
        indexNumberEnd: indexNumberEnd ?? this.indexNumberEnd,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        remoteTrailers: remoteTrailers ?? this.remoteTrailers,
        providerIds: providerIds ?? this.providerIds,
        isHD: isHD ?? this.isHD,
        isFolder: isFolder ?? this.isFolder,
        parentId: parentId ?? this.parentId,
        type: type ?? this.type,
        people: people ?? this.people,
        studios: studios ?? this.studios,
        genreItems: genreItems ?? this.genreItems,
        parentLogoItemId: parentLogoItemId ?? this.parentLogoItemId,
        parentBackdropItemId: parentBackdropItemId ?? this.parentBackdropItemId,
        parentBackdropImageTags:
            parentBackdropImageTags ?? this.parentBackdropImageTags,
        localTrailerCount: localTrailerCount ?? this.localTrailerCount,
        userData: userData ?? this.userData,
        recursiveItemCount: recursiveItemCount ?? this.recursiveItemCount,
        childCount: childCount ?? this.childCount,
        seriesName: seriesName ?? this.seriesName,
        seriesId: seriesId ?? this.seriesId,
        seasonId: seasonId ?? this.seasonId,
        specialFeatureCount: specialFeatureCount ?? this.specialFeatureCount,
        displayPreferencesId: displayPreferencesId ?? this.displayPreferencesId,
        status: status ?? this.status,
        airTime: airTime ?? this.airTime,
        airDays: airDays ?? this.airDays,
        tags: tags ?? this.tags,
        primaryImageAspectRatio:
            primaryImageAspectRatio ?? this.primaryImageAspectRatio,
        artists: artists ?? this.artists,
        artistItems: artistItems ?? this.artistItems,
        album: album ?? this.album,
        collectionType: collectionType ?? this.collectionType,
        displayOrder: displayOrder ?? this.displayOrder,
        albumId: albumId ?? this.albumId,
        albumPrimaryImageTag: albumPrimaryImageTag ?? this.albumPrimaryImageTag,
        seriesPrimaryImageTag:
            seriesPrimaryImageTag ?? this.seriesPrimaryImageTag,
        albumArtist: albumArtist ?? this.albumArtist,
        albumArtists: albumArtists ?? this.albumArtists,
        seasonName: seasonName ?? this.seasonName,
        mediaStreams: mediaStreams ?? this.mediaStreams,
        videoType: videoType ?? this.videoType,
        partCount: partCount ?? this.partCount,
        mediaSourceCount: mediaSourceCount ?? this.mediaSourceCount,
        imageTags: imageTags ?? this.imageTags,
        backdropImageTags: backdropImageTags ?? this.backdropImageTags,
        screenshotImageTags: screenshotImageTags ?? this.screenshotImageTags,
        parentLogoImageTag: parentLogoImageTag ?? this.parentLogoImageTag,
        parentArtItemId: parentArtItemId ?? this.parentArtItemId,
        parentArtImageTag: parentArtImageTag ?? this.parentArtImageTag,
        seriesThumbImageTag: seriesThumbImageTag ?? this.seriesThumbImageTag,
        imageBlurHashes: imageBlurHashes ?? this.imageBlurHashes,
        seriesStudio: seriesStudio ?? this.seriesStudio,
        parentThumbItemId: parentThumbItemId ?? this.parentThumbItemId,
        parentThumbImageTag: parentThumbImageTag ?? this.parentThumbImageTag,
        parentPrimaryImageItemId:
            parentPrimaryImageItemId ?? this.parentPrimaryImageItemId,
        parentPrimaryImageTag:
            parentPrimaryImageTag ?? this.parentPrimaryImageTag,
        chapters: chapters ?? this.chapters,
        trickplay: trickplay ?? this.trickplay,
        locationType: locationType ?? this.locationType,
        isoType: isoType ?? this.isoType,
        mediaType: mediaType ?? this.mediaType,
        endDate: endDate ?? this.endDate,
        lockedFields: lockedFields ?? this.lockedFields,
        trailerCount: trailerCount ?? this.trailerCount,
        movieCount: movieCount ?? this.movieCount,
        seriesCount: seriesCount ?? this.seriesCount,
        programCount: programCount ?? this.programCount,
        episodeCount: episodeCount ?? this.episodeCount,
        songCount: songCount ?? this.songCount,
        albumCount: albumCount ?? this.albumCount,
        artistCount: artistCount ?? this.artistCount,
        musicVideoCount: musicVideoCount ?? this.musicVideoCount,
        lockData: lockData ?? this.lockData,
        width: width ?? this.width,
        height: height ?? this.height,
        cameraMake: cameraMake ?? this.cameraMake,
        cameraModel: cameraModel ?? this.cameraModel,
        software: software ?? this.software,
        exposureTime: exposureTime ?? this.exposureTime,
        focalLength: focalLength ?? this.focalLength,
        imageOrientation: imageOrientation ?? this.imageOrientation,
        aperture: aperture ?? this.aperture,
        shutterSpeed: shutterSpeed ?? this.shutterSpeed,
        latitude: latitude ?? this.latitude,
        longitude: longitude ?? this.longitude,
        altitude: altitude ?? this.altitude,
        isoSpeedRating: isoSpeedRating ?? this.isoSpeedRating,
        seriesTimerId: seriesTimerId ?? this.seriesTimerId,
        programId: programId ?? this.programId,
        channelPrimaryImageTag:
            channelPrimaryImageTag ?? this.channelPrimaryImageTag,
        startDate: startDate ?? this.startDate,
        completionPercentage: completionPercentage ?? this.completionPercentage,
        isRepeat: isRepeat ?? this.isRepeat,
        episodeTitle: episodeTitle ?? this.episodeTitle,
        channelType: channelType ?? this.channelType,
        audio: audio ?? this.audio,
        isMovie: isMovie ?? this.isMovie,
        isSports: isSports ?? this.isSports,
        isSeries: isSeries ?? this.isSeries,
        isLive: isLive ?? this.isLive,
        isNews: isNews ?? this.isNews,
        isKids: isKids ?? this.isKids,
        isPremiere: isPremiere ?? this.isPremiere,
        timerId: timerId ?? this.timerId,
        normalizationGain: normalizationGain ?? this.normalizationGain,
        currentProgram: currentProgram ?? this.currentProgram);
  }

  BaseItemDto copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? serverId,
      Wrapped<String?>? id,
      Wrapped<String?>? etag,
      Wrapped<String?>? sourceType,
      Wrapped<String?>? playlistItemId,
      Wrapped<DateTime?>? dateCreated,
      Wrapped<DateTime?>? dateLastMediaAdded,
      Wrapped<enums.ExtraType?>? extraType,
      Wrapped<int?>? airsBeforeSeasonNumber,
      Wrapped<int?>? airsAfterSeasonNumber,
      Wrapped<int?>? airsBeforeEpisodeNumber,
      Wrapped<bool?>? canDelete,
      Wrapped<bool?>? canDownload,
      Wrapped<bool?>? hasLyrics,
      Wrapped<bool?>? hasSubtitles,
      Wrapped<String?>? preferredMetadataLanguage,
      Wrapped<String?>? preferredMetadataCountryCode,
      Wrapped<String?>? container,
      Wrapped<String?>? sortName,
      Wrapped<String?>? forcedSortName,
      Wrapped<enums.Video3DFormat?>? video3DFormat,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<List<ExternalUrl>?>? externalUrls,
      Wrapped<List<MediaSourceInfo>?>? mediaSources,
      Wrapped<double?>? criticRating,
      Wrapped<List<String>?>? productionLocations,
      Wrapped<String?>? path,
      Wrapped<bool?>? enableMediaSourceDisplay,
      Wrapped<String?>? officialRating,
      Wrapped<String?>? customRating,
      Wrapped<String?>? channelId,
      Wrapped<String?>? channelName,
      Wrapped<String?>? overview,
      Wrapped<List<String>?>? taglines,
      Wrapped<List<String>?>? genres,
      Wrapped<double?>? communityRating,
      Wrapped<int?>? cumulativeRunTimeTicks,
      Wrapped<int?>? runTimeTicks,
      Wrapped<enums.PlayAccess?>? playAccess,
      Wrapped<String?>? aspectRatio,
      Wrapped<int?>? productionYear,
      Wrapped<bool?>? isPlaceHolder,
      Wrapped<String?>? number,
      Wrapped<String?>? channelNumber,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? indexNumberEnd,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<List<MediaUrl>?>? remoteTrailers,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<bool?>? isHD,
      Wrapped<bool?>? isFolder,
      Wrapped<String?>? parentId,
      Wrapped<enums.BaseItemKind?>? type,
      Wrapped<List<BaseItemPerson>?>? people,
      Wrapped<List<NameGuidPair>?>? studios,
      Wrapped<List<NameGuidPair>?>? genreItems,
      Wrapped<String?>? parentLogoItemId,
      Wrapped<String?>? parentBackdropItemId,
      Wrapped<List<String>?>? parentBackdropImageTags,
      Wrapped<int?>? localTrailerCount,
      Wrapped<UserItemDataDto?>? userData,
      Wrapped<int?>? recursiveItemCount,
      Wrapped<int?>? childCount,
      Wrapped<String?>? seriesName,
      Wrapped<String?>? seriesId,
      Wrapped<String?>? seasonId,
      Wrapped<int?>? specialFeatureCount,
      Wrapped<String?>? displayPreferencesId,
      Wrapped<String?>? status,
      Wrapped<String?>? airTime,
      Wrapped<List<enums.DayOfWeek>?>? airDays,
      Wrapped<List<String>?>? tags,
      Wrapped<double?>? primaryImageAspectRatio,
      Wrapped<List<String>?>? artists,
      Wrapped<List<NameGuidPair>?>? artistItems,
      Wrapped<String?>? album,
      Wrapped<enums.CollectionType?>? collectionType,
      Wrapped<String?>? displayOrder,
      Wrapped<String?>? albumId,
      Wrapped<String?>? albumPrimaryImageTag,
      Wrapped<String?>? seriesPrimaryImageTag,
      Wrapped<String?>? albumArtist,
      Wrapped<List<NameGuidPair>?>? albumArtists,
      Wrapped<String?>? seasonName,
      Wrapped<List<MediaStream>?>? mediaStreams,
      Wrapped<enums.VideoType?>? videoType,
      Wrapped<int?>? partCount,
      Wrapped<int?>? mediaSourceCount,
      Wrapped<Map<String, dynamic>?>? imageTags,
      Wrapped<List<String>?>? backdropImageTags,
      Wrapped<List<String>?>? screenshotImageTags,
      Wrapped<String?>? parentLogoImageTag,
      Wrapped<String?>? parentArtItemId,
      Wrapped<String?>? parentArtImageTag,
      Wrapped<String?>? seriesThumbImageTag,
      Wrapped<BaseItemDto$ImageBlurHashes?>? imageBlurHashes,
      Wrapped<String?>? seriesStudio,
      Wrapped<String?>? parentThumbItemId,
      Wrapped<String?>? parentThumbImageTag,
      Wrapped<String?>? parentPrimaryImageItemId,
      Wrapped<String?>? parentPrimaryImageTag,
      Wrapped<List<ChapterInfo>?>? chapters,
      Wrapped<Map<String, dynamic>?>? trickplay,
      Wrapped<enums.LocationType?>? locationType,
      Wrapped<enums.IsoType?>? isoType,
      Wrapped<enums.MediaType?>? mediaType,
      Wrapped<DateTime?>? endDate,
      Wrapped<List<enums.MetadataField>?>? lockedFields,
      Wrapped<int?>? trailerCount,
      Wrapped<int?>? movieCount,
      Wrapped<int?>? seriesCount,
      Wrapped<int?>? programCount,
      Wrapped<int?>? episodeCount,
      Wrapped<int?>? songCount,
      Wrapped<int?>? albumCount,
      Wrapped<int?>? artistCount,
      Wrapped<int?>? musicVideoCount,
      Wrapped<bool?>? lockData,
      Wrapped<int?>? width,
      Wrapped<int?>? height,
      Wrapped<String?>? cameraMake,
      Wrapped<String?>? cameraModel,
      Wrapped<String?>? software,
      Wrapped<double?>? exposureTime,
      Wrapped<double?>? focalLength,
      Wrapped<enums.ImageOrientation?>? imageOrientation,
      Wrapped<double?>? aperture,
      Wrapped<double?>? shutterSpeed,
      Wrapped<double?>? latitude,
      Wrapped<double?>? longitude,
      Wrapped<double?>? altitude,
      Wrapped<int?>? isoSpeedRating,
      Wrapped<String?>? seriesTimerId,
      Wrapped<String?>? programId,
      Wrapped<String?>? channelPrimaryImageTag,
      Wrapped<DateTime?>? startDate,
      Wrapped<double?>? completionPercentage,
      Wrapped<bool?>? isRepeat,
      Wrapped<String?>? episodeTitle,
      Wrapped<enums.ChannelType?>? channelType,
      Wrapped<enums.ProgramAudio?>? audio,
      Wrapped<bool?>? isMovie,
      Wrapped<bool?>? isSports,
      Wrapped<bool?>? isSeries,
      Wrapped<bool?>? isLive,
      Wrapped<bool?>? isNews,
      Wrapped<bool?>? isKids,
      Wrapped<bool?>? isPremiere,
      Wrapped<String?>? timerId,
      Wrapped<double?>? normalizationGain,
      Wrapped<BaseItemDto?>? currentProgram}) {
    return BaseItemDto(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        serverId: (serverId != null ? serverId.value : this.serverId),
        id: (id != null ? id.value : this.id),
        etag: (etag != null ? etag.value : this.etag),
        sourceType: (sourceType != null ? sourceType.value : this.sourceType),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId),
        dateCreated:
            (dateCreated != null ? dateCreated.value : this.dateCreated),
        dateLastMediaAdded: (dateLastMediaAdded != null
            ? dateLastMediaAdded.value
            : this.dateLastMediaAdded),
        extraType: (extraType != null ? extraType.value : this.extraType),
        airsBeforeSeasonNumber: (airsBeforeSeasonNumber != null
            ? airsBeforeSeasonNumber.value
            : this.airsBeforeSeasonNumber),
        airsAfterSeasonNumber: (airsAfterSeasonNumber != null
            ? airsAfterSeasonNumber.value
            : this.airsAfterSeasonNumber),
        airsBeforeEpisodeNumber: (airsBeforeEpisodeNumber != null
            ? airsBeforeEpisodeNumber.value
            : this.airsBeforeEpisodeNumber),
        canDelete: (canDelete != null ? canDelete.value : this.canDelete),
        canDownload:
            (canDownload != null ? canDownload.value : this.canDownload),
        hasLyrics: (hasLyrics != null ? hasLyrics.value : this.hasLyrics),
        hasSubtitles:
            (hasSubtitles != null ? hasSubtitles.value : this.hasSubtitles),
        preferredMetadataLanguage: (preferredMetadataLanguage != null
            ? preferredMetadataLanguage.value
            : this.preferredMetadataLanguage),
        preferredMetadataCountryCode: (preferredMetadataCountryCode != null
            ? preferredMetadataCountryCode.value
            : this.preferredMetadataCountryCode),
        container: (container != null ? container.value : this.container),
        sortName: (sortName != null ? sortName.value : this.sortName),
        forcedSortName: (forcedSortName != null
            ? forcedSortName.value
            : this.forcedSortName),
        video3DFormat:
            (video3DFormat != null ? video3DFormat.value : this.video3DFormat),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        externalUrls:
            (externalUrls != null ? externalUrls.value : this.externalUrls),
        mediaSources:
            (mediaSources != null ? mediaSources.value : this.mediaSources),
        criticRating:
            (criticRating != null ? criticRating.value : this.criticRating),
        productionLocations: (productionLocations != null
            ? productionLocations.value
            : this.productionLocations),
        path: (path != null ? path.value : this.path),
        enableMediaSourceDisplay: (enableMediaSourceDisplay != null
            ? enableMediaSourceDisplay.value
            : this.enableMediaSourceDisplay),
        officialRating: (officialRating != null
            ? officialRating.value
            : this.officialRating),
        customRating:
            (customRating != null ? customRating.value : this.customRating),
        channelId: (channelId != null ? channelId.value : this.channelId),
        channelName:
            (channelName != null ? channelName.value : this.channelName),
        overview: (overview != null ? overview.value : this.overview),
        taglines: (taglines != null ? taglines.value : this.taglines),
        genres: (genres != null ? genres.value : this.genres),
        communityRating: (communityRating != null
            ? communityRating.value
            : this.communityRating),
        cumulativeRunTimeTicks: (cumulativeRunTimeTicks != null
            ? cumulativeRunTimeTicks.value
            : this.cumulativeRunTimeTicks),
        runTimeTicks:
            (runTimeTicks != null ? runTimeTicks.value : this.runTimeTicks),
        playAccess: (playAccess != null ? playAccess.value : this.playAccess),
        aspectRatio:
            (aspectRatio != null ? aspectRatio.value : this.aspectRatio),
        productionYear: (productionYear != null
            ? productionYear.value
            : this.productionYear),
        isPlaceHolder:
            (isPlaceHolder != null ? isPlaceHolder.value : this.isPlaceHolder),
        number: (number != null ? number.value : this.number),
        channelNumber:
            (channelNumber != null ? channelNumber.value : this.channelNumber),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        indexNumberEnd: (indexNumberEnd != null
            ? indexNumberEnd.value
            : this.indexNumberEnd),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        remoteTrailers: (remoteTrailers != null
            ? remoteTrailers.value
            : this.remoteTrailers),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        isHD: (isHD != null ? isHD.value : this.isHD),
        isFolder: (isFolder != null ? isFolder.value : this.isFolder),
        parentId: (parentId != null ? parentId.value : this.parentId),
        type: (type != null ? type.value : this.type),
        people: (people != null ? people.value : this.people),
        studios: (studios != null ? studios.value : this.studios),
        genreItems: (genreItems != null ? genreItems.value : this.genreItems),
        parentLogoItemId: (parentLogoItemId != null
            ? parentLogoItemId.value
            : this.parentLogoItemId),
        parentBackdropItemId: (parentBackdropItemId != null
            ? parentBackdropItemId.value
            : this.parentBackdropItemId),
        parentBackdropImageTags: (parentBackdropImageTags != null
            ? parentBackdropImageTags.value
            : this.parentBackdropImageTags),
        localTrailerCount: (localTrailerCount != null
            ? localTrailerCount.value
            : this.localTrailerCount),
        userData: (userData != null ? userData.value : this.userData),
        recursiveItemCount: (recursiveItemCount != null
            ? recursiveItemCount.value
            : this.recursiveItemCount),
        childCount: (childCount != null ? childCount.value : this.childCount),
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        seasonId: (seasonId != null ? seasonId.value : this.seasonId),
        specialFeatureCount: (specialFeatureCount != null
            ? specialFeatureCount.value
            : this.specialFeatureCount),
        displayPreferencesId: (displayPreferencesId != null
            ? displayPreferencesId.value
            : this.displayPreferencesId),
        status: (status != null ? status.value : this.status),
        airTime: (airTime != null ? airTime.value : this.airTime),
        airDays: (airDays != null ? airDays.value : this.airDays),
        tags: (tags != null ? tags.value : this.tags),
        primaryImageAspectRatio: (primaryImageAspectRatio != null
            ? primaryImageAspectRatio.value
            : this.primaryImageAspectRatio),
        artists: (artists != null ? artists.value : this.artists),
        artistItems:
            (artistItems != null ? artistItems.value : this.artistItems),
        album: (album != null ? album.value : this.album),
        collectionType: (collectionType != null
            ? collectionType.value
            : this.collectionType),
        displayOrder:
            (displayOrder != null ? displayOrder.value : this.displayOrder),
        albumId: (albumId != null ? albumId.value : this.albumId),
        albumPrimaryImageTag: (albumPrimaryImageTag != null
            ? albumPrimaryImageTag.value
            : this.albumPrimaryImageTag),
        seriesPrimaryImageTag: (seriesPrimaryImageTag != null
            ? seriesPrimaryImageTag.value
            : this.seriesPrimaryImageTag),
        albumArtist:
            (albumArtist != null ? albumArtist.value : this.albumArtist),
        albumArtists:
            (albumArtists != null ? albumArtists.value : this.albumArtists),
        seasonName: (seasonName != null ? seasonName.value : this.seasonName),
        mediaStreams:
            (mediaStreams != null ? mediaStreams.value : this.mediaStreams),
        videoType: (videoType != null ? videoType.value : this.videoType),
        partCount: (partCount != null ? partCount.value : this.partCount),
        mediaSourceCount: (mediaSourceCount != null
            ? mediaSourceCount.value
            : this.mediaSourceCount),
        imageTags: (imageTags != null ? imageTags.value : this.imageTags),
        backdropImageTags: (backdropImageTags != null
            ? backdropImageTags.value
            : this.backdropImageTags),
        screenshotImageTags: (screenshotImageTags != null
            ? screenshotImageTags.value
            : this.screenshotImageTags),
        parentLogoImageTag: (parentLogoImageTag != null
            ? parentLogoImageTag.value
            : this.parentLogoImageTag),
        parentArtItemId: (parentArtItemId != null
            ? parentArtItemId.value
            : this.parentArtItemId),
        parentArtImageTag: (parentArtImageTag != null
            ? parentArtImageTag.value
            : this.parentArtImageTag),
        seriesThumbImageTag: (seriesThumbImageTag != null
            ? seriesThumbImageTag.value
            : this.seriesThumbImageTag),
        imageBlurHashes: (imageBlurHashes != null
            ? imageBlurHashes.value
            : this.imageBlurHashes),
        seriesStudio:
            (seriesStudio != null ? seriesStudio.value : this.seriesStudio),
        parentThumbItemId: (parentThumbItemId != null ? parentThumbItemId.value : this.parentThumbItemId),
        parentThumbImageTag: (parentThumbImageTag != null ? parentThumbImageTag.value : this.parentThumbImageTag),
        parentPrimaryImageItemId: (parentPrimaryImageItemId != null ? parentPrimaryImageItemId.value : this.parentPrimaryImageItemId),
        parentPrimaryImageTag: (parentPrimaryImageTag != null ? parentPrimaryImageTag.value : this.parentPrimaryImageTag),
        chapters: (chapters != null ? chapters.value : this.chapters),
        trickplay: (trickplay != null ? trickplay.value : this.trickplay),
        locationType: (locationType != null ? locationType.value : this.locationType),
        isoType: (isoType != null ? isoType.value : this.isoType),
        mediaType: (mediaType != null ? mediaType.value : this.mediaType),
        endDate: (endDate != null ? endDate.value : this.endDate),
        lockedFields: (lockedFields != null ? lockedFields.value : this.lockedFields),
        trailerCount: (trailerCount != null ? trailerCount.value : this.trailerCount),
        movieCount: (movieCount != null ? movieCount.value : this.movieCount),
        seriesCount: (seriesCount != null ? seriesCount.value : this.seriesCount),
        programCount: (programCount != null ? programCount.value : this.programCount),
        episodeCount: (episodeCount != null ? episodeCount.value : this.episodeCount),
        songCount: (songCount != null ? songCount.value : this.songCount),
        albumCount: (albumCount != null ? albumCount.value : this.albumCount),
        artistCount: (artistCount != null ? artistCount.value : this.artistCount),
        musicVideoCount: (musicVideoCount != null ? musicVideoCount.value : this.musicVideoCount),
        lockData: (lockData != null ? lockData.value : this.lockData),
        width: (width != null ? width.value : this.width),
        height: (height != null ? height.value : this.height),
        cameraMake: (cameraMake != null ? cameraMake.value : this.cameraMake),
        cameraModel: (cameraModel != null ? cameraModel.value : this.cameraModel),
        software: (software != null ? software.value : this.software),
        exposureTime: (exposureTime != null ? exposureTime.value : this.exposureTime),
        focalLength: (focalLength != null ? focalLength.value : this.focalLength),
        imageOrientation: (imageOrientation != null ? imageOrientation.value : this.imageOrientation),
        aperture: (aperture != null ? aperture.value : this.aperture),
        shutterSpeed: (shutterSpeed != null ? shutterSpeed.value : this.shutterSpeed),
        latitude: (latitude != null ? latitude.value : this.latitude),
        longitude: (longitude != null ? longitude.value : this.longitude),
        altitude: (altitude != null ? altitude.value : this.altitude),
        isoSpeedRating: (isoSpeedRating != null ? isoSpeedRating.value : this.isoSpeedRating),
        seriesTimerId: (seriesTimerId != null ? seriesTimerId.value : this.seriesTimerId),
        programId: (programId != null ? programId.value : this.programId),
        channelPrimaryImageTag: (channelPrimaryImageTag != null ? channelPrimaryImageTag.value : this.channelPrimaryImageTag),
        startDate: (startDate != null ? startDate.value : this.startDate),
        completionPercentage: (completionPercentage != null ? completionPercentage.value : this.completionPercentage),
        isRepeat: (isRepeat != null ? isRepeat.value : this.isRepeat),
        episodeTitle: (episodeTitle != null ? episodeTitle.value : this.episodeTitle),
        channelType: (channelType != null ? channelType.value : this.channelType),
        audio: (audio != null ? audio.value : this.audio),
        isMovie: (isMovie != null ? isMovie.value : this.isMovie),
        isSports: (isSports != null ? isSports.value : this.isSports),
        isSeries: (isSeries != null ? isSeries.value : this.isSeries),
        isLive: (isLive != null ? isLive.value : this.isLive),
        isNews: (isNews != null ? isNews.value : this.isNews),
        isKids: (isKids != null ? isKids.value : this.isKids),
        isPremiere: (isPremiere != null ? isPremiere.value : this.isPremiere),
        timerId: (timerId != null ? timerId.value : this.timerId),
        normalizationGain: (normalizationGain != null ? normalizationGain.value : this.normalizationGain),
        currentProgram: (currentProgram != null ? currentProgram.value : this.currentProgram));
  }
}

@JsonSerializable(explicitToJson: true)
class BaseItemDtoQueryResult {
  const BaseItemDtoQueryResult({
    this.items,
    this.totalRecordCount,
    this.startIndex,
  });

  factory BaseItemDtoQueryResult.fromJson(Map<String, dynamic> json) =>
      _$BaseItemDtoQueryResultFromJson(json);

  static const toJsonFactory = _$BaseItemDtoQueryResultToJson;
  Map<String, dynamic> toJson() => _$BaseItemDtoQueryResultToJson(this);

  @JsonKey(name: 'Items', defaultValue: <BaseItemDto>[])
  final List<BaseItemDto>? items;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  static const fromJsonFactory = _$BaseItemDtoQueryResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseItemDtoQueryResult &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      const DeepCollectionEquality().hash(startIndex) ^
      runtimeType.hashCode;
}

extension $BaseItemDtoQueryResultExtension on BaseItemDtoQueryResult {
  BaseItemDtoQueryResult copyWith(
      {List<BaseItemDto>? items, int? totalRecordCount, int? startIndex}) {
    return BaseItemDtoQueryResult(
        items: items ?? this.items,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount,
        startIndex: startIndex ?? this.startIndex);
  }

  BaseItemDtoQueryResult copyWithWrapped(
      {Wrapped<List<BaseItemDto>?>? items,
      Wrapped<int?>? totalRecordCount,
      Wrapped<int?>? startIndex}) {
    return BaseItemDtoQueryResult(
        items: (items != null ? items.value : this.items),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex));
  }
}

@JsonSerializable(explicitToJson: true)
class BaseItemPerson {
  const BaseItemPerson({
    this.name,
    this.id,
    this.role,
    this.type,
    this.primaryImageTag,
    this.imageBlurHashes,
  });

  factory BaseItemPerson.fromJson(Map<String, dynamic> json) =>
      _$BaseItemPersonFromJson(json);

  static const toJsonFactory = _$BaseItemPersonToJson;
  Map<String, dynamic> toJson() => _$BaseItemPersonToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Role')
  final String? role;
  @JsonKey(
    name: 'Type',
    toJson: personKindNullableToJson,
    fromJson: personKindNullableFromJson,
  )
  final enums.PersonKind? type;
  @JsonKey(name: 'PrimaryImageTag')
  final String? primaryImageTag;
  @JsonKey(name: 'ImageBlurHashes')
  final BaseItemPerson$ImageBlurHashes? imageBlurHashes;
  static const fromJsonFactory = _$BaseItemPersonFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseItemPerson &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.primaryImageTag, primaryImageTag) ||
                const DeepCollectionEquality()
                    .equals(other.primaryImageTag, primaryImageTag)) &&
            (identical(other.imageBlurHashes, imageBlurHashes) ||
                const DeepCollectionEquality()
                    .equals(other.imageBlurHashes, imageBlurHashes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(primaryImageTag) ^
      const DeepCollectionEquality().hash(imageBlurHashes) ^
      runtimeType.hashCode;
}

extension $BaseItemPersonExtension on BaseItemPerson {
  BaseItemPerson copyWith(
      {String? name,
      String? id,
      String? role,
      enums.PersonKind? type,
      String? primaryImageTag,
      BaseItemPerson$ImageBlurHashes? imageBlurHashes}) {
    return BaseItemPerson(
        name: name ?? this.name,
        id: id ?? this.id,
        role: role ?? this.role,
        type: type ?? this.type,
        primaryImageTag: primaryImageTag ?? this.primaryImageTag,
        imageBlurHashes: imageBlurHashes ?? this.imageBlurHashes);
  }

  BaseItemPerson copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? id,
      Wrapped<String?>? role,
      Wrapped<enums.PersonKind?>? type,
      Wrapped<String?>? primaryImageTag,
      Wrapped<BaseItemPerson$ImageBlurHashes?>? imageBlurHashes}) {
    return BaseItemPerson(
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id),
        role: (role != null ? role.value : this.role),
        type: (type != null ? type.value : this.type),
        primaryImageTag: (primaryImageTag != null
            ? primaryImageTag.value
            : this.primaryImageTag),
        imageBlurHashes: (imageBlurHashes != null
            ? imageBlurHashes.value
            : this.imageBlurHashes));
  }
}

@JsonSerializable(explicitToJson: true)
class BasePluginConfiguration {
  const BasePluginConfiguration();

  factory BasePluginConfiguration.fromJson(Map<String, dynamic> json) =>
      _$BasePluginConfigurationFromJson(json);

  static const toJsonFactory = _$BasePluginConfigurationToJson;
  Map<String, dynamic> toJson() => _$BasePluginConfigurationToJson(this);

  static const fromJsonFactory = _$BasePluginConfigurationFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class BookInfo {
  const BookInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
    this.seriesName,
  });

  factory BookInfo.fromJson(Map<String, dynamic> json) =>
      _$BookInfoFromJson(json);

  static const toJsonFactory = _$BookInfoToJson;
  Map<String, dynamic> toJson() => _$BookInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  @JsonKey(name: 'SeriesName')
  final String? seriesName;
  static const fromJsonFactory = _$BookInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BookInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)) &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      const DeepCollectionEquality().hash(seriesName) ^
      runtimeType.hashCode;
}

extension $BookInfoExtension on BookInfo {
  BookInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated,
      String? seriesName}) {
    return BookInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated,
        seriesName: seriesName ?? this.seriesName);
  }

  BookInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated,
      Wrapped<String?>? seriesName}) {
    return BookInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated),
        seriesName: (seriesName != null ? seriesName.value : this.seriesName));
  }
}

@JsonSerializable(explicitToJson: true)
class BookInfoRemoteSearchQuery {
  const BookInfoRemoteSearchQuery({
    this.searchInfo,
    this.itemId,
    this.searchProviderName,
    this.includeDisabledProviders,
  });

  factory BookInfoRemoteSearchQuery.fromJson(Map<String, dynamic> json) =>
      _$BookInfoRemoteSearchQueryFromJson(json);

  static const toJsonFactory = _$BookInfoRemoteSearchQueryToJson;
  Map<String, dynamic> toJson() => _$BookInfoRemoteSearchQueryToJson(this);

  @JsonKey(name: 'SearchInfo')
  final BookInfo? searchInfo;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'IncludeDisabledProviders')
  final bool? includeDisabledProviders;
  static const fromJsonFactory = _$BookInfoRemoteSearchQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BookInfoRemoteSearchQuery &&
            (identical(other.searchInfo, searchInfo) ||
                const DeepCollectionEquality()
                    .equals(other.searchInfo, searchInfo)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(
                    other.includeDisabledProviders, includeDisabledProviders) ||
                const DeepCollectionEquality().equals(
                    other.includeDisabledProviders, includeDisabledProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchInfo) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(includeDisabledProviders) ^
      runtimeType.hashCode;
}

extension $BookInfoRemoteSearchQueryExtension on BookInfoRemoteSearchQuery {
  BookInfoRemoteSearchQuery copyWith(
      {BookInfo? searchInfo,
      String? itemId,
      String? searchProviderName,
      bool? includeDisabledProviders}) {
    return BookInfoRemoteSearchQuery(
        searchInfo: searchInfo ?? this.searchInfo,
        itemId: itemId ?? this.itemId,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        includeDisabledProviders:
            includeDisabledProviders ?? this.includeDisabledProviders);
  }

  BookInfoRemoteSearchQuery copyWithWrapped(
      {Wrapped<BookInfo?>? searchInfo,
      Wrapped<String?>? itemId,
      Wrapped<String?>? searchProviderName,
      Wrapped<bool?>? includeDisabledProviders}) {
    return BookInfoRemoteSearchQuery(
        searchInfo: (searchInfo != null ? searchInfo.value : this.searchInfo),
        itemId: (itemId != null ? itemId.value : this.itemId),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        includeDisabledProviders: (includeDisabledProviders != null
            ? includeDisabledProviders.value
            : this.includeDisabledProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class BoxSetInfo {
  const BoxSetInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
  });

  factory BoxSetInfo.fromJson(Map<String, dynamic> json) =>
      _$BoxSetInfoFromJson(json);

  static const toJsonFactory = _$BoxSetInfoToJson;
  Map<String, dynamic> toJson() => _$BoxSetInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  static const fromJsonFactory = _$BoxSetInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BoxSetInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      runtimeType.hashCode;
}

extension $BoxSetInfoExtension on BoxSetInfo {
  BoxSetInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated}) {
    return BoxSetInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated);
  }

  BoxSetInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated}) {
    return BoxSetInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated));
  }
}

@JsonSerializable(explicitToJson: true)
class BoxSetInfoRemoteSearchQuery {
  const BoxSetInfoRemoteSearchQuery({
    this.searchInfo,
    this.itemId,
    this.searchProviderName,
    this.includeDisabledProviders,
  });

  factory BoxSetInfoRemoteSearchQuery.fromJson(Map<String, dynamic> json) =>
      _$BoxSetInfoRemoteSearchQueryFromJson(json);

  static const toJsonFactory = _$BoxSetInfoRemoteSearchQueryToJson;
  Map<String, dynamic> toJson() => _$BoxSetInfoRemoteSearchQueryToJson(this);

  @JsonKey(name: 'SearchInfo')
  final BoxSetInfo? searchInfo;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'IncludeDisabledProviders')
  final bool? includeDisabledProviders;
  static const fromJsonFactory = _$BoxSetInfoRemoteSearchQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BoxSetInfoRemoteSearchQuery &&
            (identical(other.searchInfo, searchInfo) ||
                const DeepCollectionEquality()
                    .equals(other.searchInfo, searchInfo)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(
                    other.includeDisabledProviders, includeDisabledProviders) ||
                const DeepCollectionEquality().equals(
                    other.includeDisabledProviders, includeDisabledProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchInfo) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(includeDisabledProviders) ^
      runtimeType.hashCode;
}

extension $BoxSetInfoRemoteSearchQueryExtension on BoxSetInfoRemoteSearchQuery {
  BoxSetInfoRemoteSearchQuery copyWith(
      {BoxSetInfo? searchInfo,
      String? itemId,
      String? searchProviderName,
      bool? includeDisabledProviders}) {
    return BoxSetInfoRemoteSearchQuery(
        searchInfo: searchInfo ?? this.searchInfo,
        itemId: itemId ?? this.itemId,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        includeDisabledProviders:
            includeDisabledProviders ?? this.includeDisabledProviders);
  }

  BoxSetInfoRemoteSearchQuery copyWithWrapped(
      {Wrapped<BoxSetInfo?>? searchInfo,
      Wrapped<String?>? itemId,
      Wrapped<String?>? searchProviderName,
      Wrapped<bool?>? includeDisabledProviders}) {
    return BoxSetInfoRemoteSearchQuery(
        searchInfo: (searchInfo != null ? searchInfo.value : this.searchInfo),
        itemId: (itemId != null ? itemId.value : this.itemId),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        includeDisabledProviders: (includeDisabledProviders != null
            ? includeDisabledProviders.value
            : this.includeDisabledProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class BrandingOptions {
  const BrandingOptions({
    this.loginDisclaimer,
    this.customCss,
    this.splashscreenEnabled,
  });

  factory BrandingOptions.fromJson(Map<String, dynamic> json) =>
      _$BrandingOptionsFromJson(json);

  static const toJsonFactory = _$BrandingOptionsToJson;
  Map<String, dynamic> toJson() => _$BrandingOptionsToJson(this);

  @JsonKey(name: 'LoginDisclaimer')
  final String? loginDisclaimer;
  @JsonKey(name: 'CustomCss')
  final String? customCss;
  @JsonKey(name: 'SplashscreenEnabled')
  final bool? splashscreenEnabled;
  static const fromJsonFactory = _$BrandingOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BrandingOptions &&
            (identical(other.loginDisclaimer, loginDisclaimer) ||
                const DeepCollectionEquality()
                    .equals(other.loginDisclaimer, loginDisclaimer)) &&
            (identical(other.customCss, customCss) ||
                const DeepCollectionEquality()
                    .equals(other.customCss, customCss)) &&
            (identical(other.splashscreenEnabled, splashscreenEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.splashscreenEnabled, splashscreenEnabled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(loginDisclaimer) ^
      const DeepCollectionEquality().hash(customCss) ^
      const DeepCollectionEquality().hash(splashscreenEnabled) ^
      runtimeType.hashCode;
}

extension $BrandingOptionsExtension on BrandingOptions {
  BrandingOptions copyWith(
      {String? loginDisclaimer, String? customCss, bool? splashscreenEnabled}) {
    return BrandingOptions(
        loginDisclaimer: loginDisclaimer ?? this.loginDisclaimer,
        customCss: customCss ?? this.customCss,
        splashscreenEnabled: splashscreenEnabled ?? this.splashscreenEnabled);
  }

  BrandingOptions copyWithWrapped(
      {Wrapped<String?>? loginDisclaimer,
      Wrapped<String?>? customCss,
      Wrapped<bool?>? splashscreenEnabled}) {
    return BrandingOptions(
        loginDisclaimer: (loginDisclaimer != null
            ? loginDisclaimer.value
            : this.loginDisclaimer),
        customCss: (customCss != null ? customCss.value : this.customCss),
        splashscreenEnabled: (splashscreenEnabled != null
            ? splashscreenEnabled.value
            : this.splashscreenEnabled));
  }
}

@JsonSerializable(explicitToJson: true)
class BufferRequestDto {
  const BufferRequestDto({
    this.when,
    this.positionTicks,
    this.isPlaying,
    this.playlistItemId,
  });

  factory BufferRequestDto.fromJson(Map<String, dynamic> json) =>
      _$BufferRequestDtoFromJson(json);

  static const toJsonFactory = _$BufferRequestDtoToJson;
  Map<String, dynamic> toJson() => _$BufferRequestDtoToJson(this);

  @JsonKey(name: 'When')
  final DateTime? when;
  @JsonKey(name: 'PositionTicks')
  final int? positionTicks;
  @JsonKey(name: 'IsPlaying')
  final bool? isPlaying;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  static const fromJsonFactory = _$BufferRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BufferRequestDto &&
            (identical(other.when, when) ||
                const DeepCollectionEquality().equals(other.when, when)) &&
            (identical(other.positionTicks, positionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.positionTicks, positionTicks)) &&
            (identical(other.isPlaying, isPlaying) ||
                const DeepCollectionEquality()
                    .equals(other.isPlaying, isPlaying)) &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(when) ^
      const DeepCollectionEquality().hash(positionTicks) ^
      const DeepCollectionEquality().hash(isPlaying) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      runtimeType.hashCode;
}

extension $BufferRequestDtoExtension on BufferRequestDto {
  BufferRequestDto copyWith(
      {DateTime? when,
      int? positionTicks,
      bool? isPlaying,
      String? playlistItemId}) {
    return BufferRequestDto(
        when: when ?? this.when,
        positionTicks: positionTicks ?? this.positionTicks,
        isPlaying: isPlaying ?? this.isPlaying,
        playlistItemId: playlistItemId ?? this.playlistItemId);
  }

  BufferRequestDto copyWithWrapped(
      {Wrapped<DateTime?>? when,
      Wrapped<int?>? positionTicks,
      Wrapped<bool?>? isPlaying,
      Wrapped<String?>? playlistItemId}) {
    return BufferRequestDto(
        when: (when != null ? when.value : this.when),
        positionTicks:
            (positionTicks != null ? positionTicks.value : this.positionTicks),
        isPlaying: (isPlaying != null ? isPlaying.value : this.isPlaying),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId));
  }
}

@JsonSerializable(explicitToJson: true)
class CastReceiverApplication {
  const CastReceiverApplication({
    this.id,
    this.name,
  });

  factory CastReceiverApplication.fromJson(Map<String, dynamic> json) =>
      _$CastReceiverApplicationFromJson(json);

  static const toJsonFactory = _$CastReceiverApplicationToJson;
  Map<String, dynamic> toJson() => _$CastReceiverApplicationToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Name')
  final String? name;
  static const fromJsonFactory = _$CastReceiverApplicationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CastReceiverApplication &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $CastReceiverApplicationExtension on CastReceiverApplication {
  CastReceiverApplication copyWith({String? id, String? name}) {
    return CastReceiverApplication(id: id ?? this.id, name: name ?? this.name);
  }

  CastReceiverApplication copyWithWrapped(
      {Wrapped<String?>? id, Wrapped<String?>? name}) {
    return CastReceiverApplication(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class ChannelFeatures {
  const ChannelFeatures({
    this.name,
    this.id,
    this.canSearch,
    this.mediaTypes,
    this.contentTypes,
    this.maxPageSize,
    this.autoRefreshLevels,
    this.defaultSortFields,
    this.supportsSortOrderToggle,
    this.supportsLatestMedia,
    this.canFilter,
    this.supportsContentDownloading,
  });

  factory ChannelFeatures.fromJson(Map<String, dynamic> json) =>
      _$ChannelFeaturesFromJson(json);

  static const toJsonFactory = _$ChannelFeaturesToJson;
  Map<String, dynamic> toJson() => _$ChannelFeaturesToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'CanSearch')
  final bool? canSearch;
  @JsonKey(
    name: 'MediaTypes',
    toJson: channelMediaTypeListToJson,
    fromJson: channelMediaTypeListFromJson,
  )
  final List<enums.ChannelMediaType>? mediaTypes;
  @JsonKey(
    name: 'ContentTypes',
    toJson: channelMediaContentTypeListToJson,
    fromJson: channelMediaContentTypeListFromJson,
  )
  final List<enums.ChannelMediaContentType>? contentTypes;
  @JsonKey(name: 'MaxPageSize')
  final int? maxPageSize;
  @JsonKey(name: 'AutoRefreshLevels')
  final int? autoRefreshLevels;
  @JsonKey(
    name: 'DefaultSortFields',
    toJson: channelItemSortFieldListToJson,
    fromJson: channelItemSortFieldListFromJson,
  )
  final List<enums.ChannelItemSortField>? defaultSortFields;
  @JsonKey(name: 'SupportsSortOrderToggle')
  final bool? supportsSortOrderToggle;
  @JsonKey(name: 'SupportsLatestMedia')
  final bool? supportsLatestMedia;
  @JsonKey(name: 'CanFilter')
  final bool? canFilter;
  @JsonKey(name: 'SupportsContentDownloading')
  final bool? supportsContentDownloading;
  static const fromJsonFactory = _$ChannelFeaturesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChannelFeatures &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.canSearch, canSearch) ||
                const DeepCollectionEquality()
                    .equals(other.canSearch, canSearch)) &&
            (identical(other.mediaTypes, mediaTypes) ||
                const DeepCollectionEquality()
                    .equals(other.mediaTypes, mediaTypes)) &&
            (identical(other.contentTypes, contentTypes) ||
                const DeepCollectionEquality()
                    .equals(other.contentTypes, contentTypes)) &&
            (identical(other.maxPageSize, maxPageSize) ||
                const DeepCollectionEquality()
                    .equals(other.maxPageSize, maxPageSize)) &&
            (identical(other.autoRefreshLevels, autoRefreshLevels) ||
                const DeepCollectionEquality()
                    .equals(other.autoRefreshLevels, autoRefreshLevels)) &&
            (identical(other.defaultSortFields, defaultSortFields) ||
                const DeepCollectionEquality()
                    .equals(other.defaultSortFields, defaultSortFields)) &&
            (identical(
                    other.supportsSortOrderToggle, supportsSortOrderToggle) ||
                const DeepCollectionEquality().equals(
                    other.supportsSortOrderToggle, supportsSortOrderToggle)) &&
            (identical(other.supportsLatestMedia, supportsLatestMedia) ||
                const DeepCollectionEquality()
                    .equals(other.supportsLatestMedia, supportsLatestMedia)) &&
            (identical(other.canFilter, canFilter) ||
                const DeepCollectionEquality()
                    .equals(other.canFilter, canFilter)) &&
            (identical(other.supportsContentDownloading,
                    supportsContentDownloading) ||
                const DeepCollectionEquality().equals(
                    other.supportsContentDownloading,
                    supportsContentDownloading)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(canSearch) ^
      const DeepCollectionEquality().hash(mediaTypes) ^
      const DeepCollectionEquality().hash(contentTypes) ^
      const DeepCollectionEquality().hash(maxPageSize) ^
      const DeepCollectionEquality().hash(autoRefreshLevels) ^
      const DeepCollectionEquality().hash(defaultSortFields) ^
      const DeepCollectionEquality().hash(supportsSortOrderToggle) ^
      const DeepCollectionEquality().hash(supportsLatestMedia) ^
      const DeepCollectionEquality().hash(canFilter) ^
      const DeepCollectionEquality().hash(supportsContentDownloading) ^
      runtimeType.hashCode;
}

extension $ChannelFeaturesExtension on ChannelFeatures {
  ChannelFeatures copyWith(
      {String? name,
      String? id,
      bool? canSearch,
      List<enums.ChannelMediaType>? mediaTypes,
      List<enums.ChannelMediaContentType>? contentTypes,
      int? maxPageSize,
      int? autoRefreshLevels,
      List<enums.ChannelItemSortField>? defaultSortFields,
      bool? supportsSortOrderToggle,
      bool? supportsLatestMedia,
      bool? canFilter,
      bool? supportsContentDownloading}) {
    return ChannelFeatures(
        name: name ?? this.name,
        id: id ?? this.id,
        canSearch: canSearch ?? this.canSearch,
        mediaTypes: mediaTypes ?? this.mediaTypes,
        contentTypes: contentTypes ?? this.contentTypes,
        maxPageSize: maxPageSize ?? this.maxPageSize,
        autoRefreshLevels: autoRefreshLevels ?? this.autoRefreshLevels,
        defaultSortFields: defaultSortFields ?? this.defaultSortFields,
        supportsSortOrderToggle:
            supportsSortOrderToggle ?? this.supportsSortOrderToggle,
        supportsLatestMedia: supportsLatestMedia ?? this.supportsLatestMedia,
        canFilter: canFilter ?? this.canFilter,
        supportsContentDownloading:
            supportsContentDownloading ?? this.supportsContentDownloading);
  }

  ChannelFeatures copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? id,
      Wrapped<bool?>? canSearch,
      Wrapped<List<enums.ChannelMediaType>?>? mediaTypes,
      Wrapped<List<enums.ChannelMediaContentType>?>? contentTypes,
      Wrapped<int?>? maxPageSize,
      Wrapped<int?>? autoRefreshLevels,
      Wrapped<List<enums.ChannelItemSortField>?>? defaultSortFields,
      Wrapped<bool?>? supportsSortOrderToggle,
      Wrapped<bool?>? supportsLatestMedia,
      Wrapped<bool?>? canFilter,
      Wrapped<bool?>? supportsContentDownloading}) {
    return ChannelFeatures(
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id),
        canSearch: (canSearch != null ? canSearch.value : this.canSearch),
        mediaTypes: (mediaTypes != null ? mediaTypes.value : this.mediaTypes),
        contentTypes:
            (contentTypes != null ? contentTypes.value : this.contentTypes),
        maxPageSize:
            (maxPageSize != null ? maxPageSize.value : this.maxPageSize),
        autoRefreshLevels: (autoRefreshLevels != null
            ? autoRefreshLevels.value
            : this.autoRefreshLevels),
        defaultSortFields: (defaultSortFields != null
            ? defaultSortFields.value
            : this.defaultSortFields),
        supportsSortOrderToggle: (supportsSortOrderToggle != null
            ? supportsSortOrderToggle.value
            : this.supportsSortOrderToggle),
        supportsLatestMedia: (supportsLatestMedia != null
            ? supportsLatestMedia.value
            : this.supportsLatestMedia),
        canFilter: (canFilter != null ? canFilter.value : this.canFilter),
        supportsContentDownloading: (supportsContentDownloading != null
            ? supportsContentDownloading.value
            : this.supportsContentDownloading));
  }
}

@JsonSerializable(explicitToJson: true)
class ChannelMappingOptionsDto {
  const ChannelMappingOptionsDto({
    this.tunerChannels,
    this.providerChannels,
    this.mappings,
    this.providerName,
  });

  factory ChannelMappingOptionsDto.fromJson(Map<String, dynamic> json) =>
      _$ChannelMappingOptionsDtoFromJson(json);

  static const toJsonFactory = _$ChannelMappingOptionsDtoToJson;
  Map<String, dynamic> toJson() => _$ChannelMappingOptionsDtoToJson(this);

  @JsonKey(name: 'TunerChannels', defaultValue: <TunerChannelMapping>[])
  final List<TunerChannelMapping>? tunerChannels;
  @JsonKey(name: 'ProviderChannels', defaultValue: <NameIdPair>[])
  final List<NameIdPair>? providerChannels;
  @JsonKey(name: 'Mappings', defaultValue: <NameValuePair>[])
  final List<NameValuePair>? mappings;
  @JsonKey(name: 'ProviderName')
  final String? providerName;
  static const fromJsonFactory = _$ChannelMappingOptionsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChannelMappingOptionsDto &&
            (identical(other.tunerChannels, tunerChannels) ||
                const DeepCollectionEquality()
                    .equals(other.tunerChannels, tunerChannels)) &&
            (identical(other.providerChannels, providerChannels) ||
                const DeepCollectionEquality()
                    .equals(other.providerChannels, providerChannels)) &&
            (identical(other.mappings, mappings) ||
                const DeepCollectionEquality()
                    .equals(other.mappings, mappings)) &&
            (identical(other.providerName, providerName) ||
                const DeepCollectionEquality()
                    .equals(other.providerName, providerName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tunerChannels) ^
      const DeepCollectionEquality().hash(providerChannels) ^
      const DeepCollectionEquality().hash(mappings) ^
      const DeepCollectionEquality().hash(providerName) ^
      runtimeType.hashCode;
}

extension $ChannelMappingOptionsDtoExtension on ChannelMappingOptionsDto {
  ChannelMappingOptionsDto copyWith(
      {List<TunerChannelMapping>? tunerChannels,
      List<NameIdPair>? providerChannels,
      List<NameValuePair>? mappings,
      String? providerName}) {
    return ChannelMappingOptionsDto(
        tunerChannels: tunerChannels ?? this.tunerChannels,
        providerChannels: providerChannels ?? this.providerChannels,
        mappings: mappings ?? this.mappings,
        providerName: providerName ?? this.providerName);
  }

  ChannelMappingOptionsDto copyWithWrapped(
      {Wrapped<List<TunerChannelMapping>?>? tunerChannels,
      Wrapped<List<NameIdPair>?>? providerChannels,
      Wrapped<List<NameValuePair>?>? mappings,
      Wrapped<String?>? providerName}) {
    return ChannelMappingOptionsDto(
        tunerChannels:
            (tunerChannels != null ? tunerChannels.value : this.tunerChannels),
        providerChannels: (providerChannels != null
            ? providerChannels.value
            : this.providerChannels),
        mappings: (mappings != null ? mappings.value : this.mappings),
        providerName:
            (providerName != null ? providerName.value : this.providerName));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterInfo {
  const ChapterInfo({
    this.startPositionTicks,
    this.name,
    this.imagePath,
    this.imageDateModified,
    this.imageTag,
  });

  factory ChapterInfo.fromJson(Map<String, dynamic> json) =>
      _$ChapterInfoFromJson(json);

  static const toJsonFactory = _$ChapterInfoToJson;
  Map<String, dynamic> toJson() => _$ChapterInfoToJson(this);

  @JsonKey(name: 'StartPositionTicks')
  final int? startPositionTicks;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'ImagePath')
  final String? imagePath;
  @JsonKey(name: 'ImageDateModified')
  final DateTime? imageDateModified;
  @JsonKey(name: 'ImageTag')
  final String? imageTag;
  static const fromJsonFactory = _$ChapterInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterInfo &&
            (identical(other.startPositionTicks, startPositionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.startPositionTicks, startPositionTicks)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.imagePath, imagePath) ||
                const DeepCollectionEquality()
                    .equals(other.imagePath, imagePath)) &&
            (identical(other.imageDateModified, imageDateModified) ||
                const DeepCollectionEquality()
                    .equals(other.imageDateModified, imageDateModified)) &&
            (identical(other.imageTag, imageTag) ||
                const DeepCollectionEquality()
                    .equals(other.imageTag, imageTag)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startPositionTicks) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(imagePath) ^
      const DeepCollectionEquality().hash(imageDateModified) ^
      const DeepCollectionEquality().hash(imageTag) ^
      runtimeType.hashCode;
}

extension $ChapterInfoExtension on ChapterInfo {
  ChapterInfo copyWith(
      {int? startPositionTicks,
      String? name,
      String? imagePath,
      DateTime? imageDateModified,
      String? imageTag}) {
    return ChapterInfo(
        startPositionTicks: startPositionTicks ?? this.startPositionTicks,
        name: name ?? this.name,
        imagePath: imagePath ?? this.imagePath,
        imageDateModified: imageDateModified ?? this.imageDateModified,
        imageTag: imageTag ?? this.imageTag);
  }

  ChapterInfo copyWithWrapped(
      {Wrapped<int?>? startPositionTicks,
      Wrapped<String?>? name,
      Wrapped<String?>? imagePath,
      Wrapped<DateTime?>? imageDateModified,
      Wrapped<String?>? imageTag}) {
    return ChapterInfo(
        startPositionTicks: (startPositionTicks != null
            ? startPositionTicks.value
            : this.startPositionTicks),
        name: (name != null ? name.value : this.name),
        imagePath: (imagePath != null ? imagePath.value : this.imagePath),
        imageDateModified: (imageDateModified != null
            ? imageDateModified.value
            : this.imageDateModified),
        imageTag: (imageTag != null ? imageTag.value : this.imageTag));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientCapabilitiesDto {
  const ClientCapabilitiesDto({
    this.playableMediaTypes,
    this.supportedCommands,
    this.supportsMediaControl,
    this.supportsPersistentIdentifier,
    this.deviceProfile,
    this.appStoreUrl,
    this.iconUrl,
  });

  factory ClientCapabilitiesDto.fromJson(Map<String, dynamic> json) =>
      _$ClientCapabilitiesDtoFromJson(json);

  static const toJsonFactory = _$ClientCapabilitiesDtoToJson;
  Map<String, dynamic> toJson() => _$ClientCapabilitiesDtoToJson(this);

  @JsonKey(
    name: 'PlayableMediaTypes',
    toJson: mediaTypeListToJson,
    fromJson: mediaTypeListFromJson,
  )
  final List<enums.MediaType>? playableMediaTypes;
  @JsonKey(
    name: 'SupportedCommands',
    toJson: generalCommandTypeListToJson,
    fromJson: generalCommandTypeListFromJson,
  )
  final List<enums.GeneralCommandType>? supportedCommands;
  @JsonKey(name: 'SupportsMediaControl')
  final bool? supportsMediaControl;
  @JsonKey(name: 'SupportsPersistentIdentifier')
  final bool? supportsPersistentIdentifier;
  @JsonKey(name: 'DeviceProfile')
  final DeviceProfile? deviceProfile;
  @JsonKey(name: 'AppStoreUrl')
  final String? appStoreUrl;
  @JsonKey(name: 'IconUrl')
  final String? iconUrl;
  static const fromJsonFactory = _$ClientCapabilitiesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientCapabilitiesDto &&
            (identical(other.playableMediaTypes, playableMediaTypes) ||
                const DeepCollectionEquality()
                    .equals(other.playableMediaTypes, playableMediaTypes)) &&
            (identical(other.supportedCommands, supportedCommands) ||
                const DeepCollectionEquality()
                    .equals(other.supportedCommands, supportedCommands)) &&
            (identical(other.supportsMediaControl, supportsMediaControl) ||
                const DeepCollectionEquality().equals(
                    other.supportsMediaControl, supportsMediaControl)) &&
            (identical(other.supportsPersistentIdentifier,
                    supportsPersistentIdentifier) ||
                const DeepCollectionEquality().equals(
                    other.supportsPersistentIdentifier,
                    supportsPersistentIdentifier)) &&
            (identical(other.deviceProfile, deviceProfile) ||
                const DeepCollectionEquality()
                    .equals(other.deviceProfile, deviceProfile)) &&
            (identical(other.appStoreUrl, appStoreUrl) ||
                const DeepCollectionEquality()
                    .equals(other.appStoreUrl, appStoreUrl)) &&
            (identical(other.iconUrl, iconUrl) ||
                const DeepCollectionEquality().equals(other.iconUrl, iconUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(playableMediaTypes) ^
      const DeepCollectionEquality().hash(supportedCommands) ^
      const DeepCollectionEquality().hash(supportsMediaControl) ^
      const DeepCollectionEquality().hash(supportsPersistentIdentifier) ^
      const DeepCollectionEquality().hash(deviceProfile) ^
      const DeepCollectionEquality().hash(appStoreUrl) ^
      const DeepCollectionEquality().hash(iconUrl) ^
      runtimeType.hashCode;
}

extension $ClientCapabilitiesDtoExtension on ClientCapabilitiesDto {
  ClientCapabilitiesDto copyWith(
      {List<enums.MediaType>? playableMediaTypes,
      List<enums.GeneralCommandType>? supportedCommands,
      bool? supportsMediaControl,
      bool? supportsPersistentIdentifier,
      DeviceProfile? deviceProfile,
      String? appStoreUrl,
      String? iconUrl}) {
    return ClientCapabilitiesDto(
        playableMediaTypes: playableMediaTypes ?? this.playableMediaTypes,
        supportedCommands: supportedCommands ?? this.supportedCommands,
        supportsMediaControl: supportsMediaControl ?? this.supportsMediaControl,
        supportsPersistentIdentifier:
            supportsPersistentIdentifier ?? this.supportsPersistentIdentifier,
        deviceProfile: deviceProfile ?? this.deviceProfile,
        appStoreUrl: appStoreUrl ?? this.appStoreUrl,
        iconUrl: iconUrl ?? this.iconUrl);
  }

  ClientCapabilitiesDto copyWithWrapped(
      {Wrapped<List<enums.MediaType>?>? playableMediaTypes,
      Wrapped<List<enums.GeneralCommandType>?>? supportedCommands,
      Wrapped<bool?>? supportsMediaControl,
      Wrapped<bool?>? supportsPersistentIdentifier,
      Wrapped<DeviceProfile?>? deviceProfile,
      Wrapped<String?>? appStoreUrl,
      Wrapped<String?>? iconUrl}) {
    return ClientCapabilitiesDto(
        playableMediaTypes: (playableMediaTypes != null
            ? playableMediaTypes.value
            : this.playableMediaTypes),
        supportedCommands: (supportedCommands != null
            ? supportedCommands.value
            : this.supportedCommands),
        supportsMediaControl: (supportsMediaControl != null
            ? supportsMediaControl.value
            : this.supportsMediaControl),
        supportsPersistentIdentifier: (supportsPersistentIdentifier != null
            ? supportsPersistentIdentifier.value
            : this.supportsPersistentIdentifier),
        deviceProfile:
            (deviceProfile != null ? deviceProfile.value : this.deviceProfile),
        appStoreUrl:
            (appStoreUrl != null ? appStoreUrl.value : this.appStoreUrl),
        iconUrl: (iconUrl != null ? iconUrl.value : this.iconUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientLogDocumentResponseDto {
  const ClientLogDocumentResponseDto({
    this.fileName,
  });

  factory ClientLogDocumentResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ClientLogDocumentResponseDtoFromJson(json);

  static const toJsonFactory = _$ClientLogDocumentResponseDtoToJson;
  Map<String, dynamic> toJson() => _$ClientLogDocumentResponseDtoToJson(this);

  @JsonKey(name: 'FileName')
  final String? fileName;
  static const fromJsonFactory = _$ClientLogDocumentResponseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientLogDocumentResponseDto &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fileName) ^ runtimeType.hashCode;
}

extension $ClientLogDocumentResponseDtoExtension
    on ClientLogDocumentResponseDto {
  ClientLogDocumentResponseDto copyWith({String? fileName}) {
    return ClientLogDocumentResponseDto(fileName: fileName ?? this.fileName);
  }

  ClientLogDocumentResponseDto copyWithWrapped({Wrapped<String?>? fileName}) {
    return ClientLogDocumentResponseDto(
        fileName: (fileName != null ? fileName.value : this.fileName));
  }
}

@JsonSerializable(explicitToJson: true)
class CodecProfile {
  const CodecProfile({
    this.type,
    this.conditions,
    this.applyConditions,
    this.codec,
    this.container,
    this.subContainer,
  });

  factory CodecProfile.fromJson(Map<String, dynamic> json) =>
      _$CodecProfileFromJson(json);

  static const toJsonFactory = _$CodecProfileToJson;
  Map<String, dynamic> toJson() => _$CodecProfileToJson(this);

  @JsonKey(
    name: 'Type',
    toJson: codecTypeNullableToJson,
    fromJson: codecTypeNullableFromJson,
  )
  final enums.CodecType? type;
  @JsonKey(name: 'Conditions', defaultValue: <ProfileCondition>[])
  final List<ProfileCondition>? conditions;
  @JsonKey(name: 'ApplyConditions', defaultValue: <ProfileCondition>[])
  final List<ProfileCondition>? applyConditions;
  @JsonKey(name: 'Codec')
  final String? codec;
  @JsonKey(name: 'Container')
  final String? container;
  @JsonKey(name: 'SubContainer')
  final String? subContainer;
  static const fromJsonFactory = _$CodecProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CodecProfile &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.applyConditions, applyConditions) ||
                const DeepCollectionEquality()
                    .equals(other.applyConditions, applyConditions)) &&
            (identical(other.codec, codec) ||
                const DeepCollectionEquality().equals(other.codec, codec)) &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)) &&
            (identical(other.subContainer, subContainer) ||
                const DeepCollectionEquality()
                    .equals(other.subContainer, subContainer)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(applyConditions) ^
      const DeepCollectionEquality().hash(codec) ^
      const DeepCollectionEquality().hash(container) ^
      const DeepCollectionEquality().hash(subContainer) ^
      runtimeType.hashCode;
}

extension $CodecProfileExtension on CodecProfile {
  CodecProfile copyWith(
      {enums.CodecType? type,
      List<ProfileCondition>? conditions,
      List<ProfileCondition>? applyConditions,
      String? codec,
      String? container,
      String? subContainer}) {
    return CodecProfile(
        type: type ?? this.type,
        conditions: conditions ?? this.conditions,
        applyConditions: applyConditions ?? this.applyConditions,
        codec: codec ?? this.codec,
        container: container ?? this.container,
        subContainer: subContainer ?? this.subContainer);
  }

  CodecProfile copyWithWrapped(
      {Wrapped<enums.CodecType?>? type,
      Wrapped<List<ProfileCondition>?>? conditions,
      Wrapped<List<ProfileCondition>?>? applyConditions,
      Wrapped<String?>? codec,
      Wrapped<String?>? container,
      Wrapped<String?>? subContainer}) {
    return CodecProfile(
        type: (type != null ? type.value : this.type),
        conditions: (conditions != null ? conditions.value : this.conditions),
        applyConditions: (applyConditions != null
            ? applyConditions.value
            : this.applyConditions),
        codec: (codec != null ? codec.value : this.codec),
        container: (container != null ? container.value : this.container),
        subContainer:
            (subContainer != null ? subContainer.value : this.subContainer));
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionCreationResult {
  const CollectionCreationResult({
    this.id,
  });

  factory CollectionCreationResult.fromJson(Map<String, dynamic> json) =>
      _$CollectionCreationResultFromJson(json);

  static const toJsonFactory = _$CollectionCreationResultToJson;
  Map<String, dynamic> toJson() => _$CollectionCreationResultToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  static const fromJsonFactory = _$CollectionCreationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionCreationResult &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ runtimeType.hashCode;
}

extension $CollectionCreationResultExtension on CollectionCreationResult {
  CollectionCreationResult copyWith({String? id}) {
    return CollectionCreationResult(id: id ?? this.id);
  }

  CollectionCreationResult copyWithWrapped({Wrapped<String?>? id}) {
    return CollectionCreationResult(id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class ConfigImageTypes {
  const ConfigImageTypes({
    this.backdropSizes,
    this.baseUrl,
    this.logoSizes,
    this.posterSizes,
    this.profileSizes,
    this.secureBaseUrl,
    this.stillSizes,
  });

  factory ConfigImageTypes.fromJson(Map<String, dynamic> json) =>
      _$ConfigImageTypesFromJson(json);

  static const toJsonFactory = _$ConfigImageTypesToJson;
  Map<String, dynamic> toJson() => _$ConfigImageTypesToJson(this);

  @JsonKey(name: 'BackdropSizes', defaultValue: <String>[])
  final List<String>? backdropSizes;
  @JsonKey(name: 'BaseUrl')
  final String? baseUrl;
  @JsonKey(name: 'LogoSizes', defaultValue: <String>[])
  final List<String>? logoSizes;
  @JsonKey(name: 'PosterSizes', defaultValue: <String>[])
  final List<String>? posterSizes;
  @JsonKey(name: 'ProfileSizes', defaultValue: <String>[])
  final List<String>? profileSizes;
  @JsonKey(name: 'SecureBaseUrl')
  final String? secureBaseUrl;
  @JsonKey(name: 'StillSizes', defaultValue: <String>[])
  final List<String>? stillSizes;
  static const fromJsonFactory = _$ConfigImageTypesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConfigImageTypes &&
            (identical(other.backdropSizes, backdropSizes) ||
                const DeepCollectionEquality()
                    .equals(other.backdropSizes, backdropSizes)) &&
            (identical(other.baseUrl, baseUrl) ||
                const DeepCollectionEquality()
                    .equals(other.baseUrl, baseUrl)) &&
            (identical(other.logoSizes, logoSizes) ||
                const DeepCollectionEquality()
                    .equals(other.logoSizes, logoSizes)) &&
            (identical(other.posterSizes, posterSizes) ||
                const DeepCollectionEquality()
                    .equals(other.posterSizes, posterSizes)) &&
            (identical(other.profileSizes, profileSizes) ||
                const DeepCollectionEquality()
                    .equals(other.profileSizes, profileSizes)) &&
            (identical(other.secureBaseUrl, secureBaseUrl) ||
                const DeepCollectionEquality()
                    .equals(other.secureBaseUrl, secureBaseUrl)) &&
            (identical(other.stillSizes, stillSizes) ||
                const DeepCollectionEquality()
                    .equals(other.stillSizes, stillSizes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(backdropSizes) ^
      const DeepCollectionEquality().hash(baseUrl) ^
      const DeepCollectionEquality().hash(logoSizes) ^
      const DeepCollectionEquality().hash(posterSizes) ^
      const DeepCollectionEquality().hash(profileSizes) ^
      const DeepCollectionEquality().hash(secureBaseUrl) ^
      const DeepCollectionEquality().hash(stillSizes) ^
      runtimeType.hashCode;
}

extension $ConfigImageTypesExtension on ConfigImageTypes {
  ConfigImageTypes copyWith(
      {List<String>? backdropSizes,
      String? baseUrl,
      List<String>? logoSizes,
      List<String>? posterSizes,
      List<String>? profileSizes,
      String? secureBaseUrl,
      List<String>? stillSizes}) {
    return ConfigImageTypes(
        backdropSizes: backdropSizes ?? this.backdropSizes,
        baseUrl: baseUrl ?? this.baseUrl,
        logoSizes: logoSizes ?? this.logoSizes,
        posterSizes: posterSizes ?? this.posterSizes,
        profileSizes: profileSizes ?? this.profileSizes,
        secureBaseUrl: secureBaseUrl ?? this.secureBaseUrl,
        stillSizes: stillSizes ?? this.stillSizes);
  }

  ConfigImageTypes copyWithWrapped(
      {Wrapped<List<String>?>? backdropSizes,
      Wrapped<String?>? baseUrl,
      Wrapped<List<String>?>? logoSizes,
      Wrapped<List<String>?>? posterSizes,
      Wrapped<List<String>?>? profileSizes,
      Wrapped<String?>? secureBaseUrl,
      Wrapped<List<String>?>? stillSizes}) {
    return ConfigImageTypes(
        backdropSizes:
            (backdropSizes != null ? backdropSizes.value : this.backdropSizes),
        baseUrl: (baseUrl != null ? baseUrl.value : this.baseUrl),
        logoSizes: (logoSizes != null ? logoSizes.value : this.logoSizes),
        posterSizes:
            (posterSizes != null ? posterSizes.value : this.posterSizes),
        profileSizes:
            (profileSizes != null ? profileSizes.value : this.profileSizes),
        secureBaseUrl:
            (secureBaseUrl != null ? secureBaseUrl.value : this.secureBaseUrl),
        stillSizes: (stillSizes != null ? stillSizes.value : this.stillSizes));
  }
}

@JsonSerializable(explicitToJson: true)
class ConfigurationPageInfo {
  const ConfigurationPageInfo({
    this.name,
    this.enableInMainMenu,
    this.menuSection,
    this.menuIcon,
    this.displayName,
    this.pluginId,
  });

  factory ConfigurationPageInfo.fromJson(Map<String, dynamic> json) =>
      _$ConfigurationPageInfoFromJson(json);

  static const toJsonFactory = _$ConfigurationPageInfoToJson;
  Map<String, dynamic> toJson() => _$ConfigurationPageInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'EnableInMainMenu')
  final bool? enableInMainMenu;
  @JsonKey(name: 'MenuSection')
  final String? menuSection;
  @JsonKey(name: 'MenuIcon')
  final String? menuIcon;
  @JsonKey(name: 'DisplayName')
  final String? displayName;
  @JsonKey(name: 'PluginId')
  final String? pluginId;
  static const fromJsonFactory = _$ConfigurationPageInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConfigurationPageInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.enableInMainMenu, enableInMainMenu) ||
                const DeepCollectionEquality()
                    .equals(other.enableInMainMenu, enableInMainMenu)) &&
            (identical(other.menuSection, menuSection) ||
                const DeepCollectionEquality()
                    .equals(other.menuSection, menuSection)) &&
            (identical(other.menuIcon, menuIcon) ||
                const DeepCollectionEquality()
                    .equals(other.menuIcon, menuIcon)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.pluginId, pluginId) ||
                const DeepCollectionEquality()
                    .equals(other.pluginId, pluginId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(enableInMainMenu) ^
      const DeepCollectionEquality().hash(menuSection) ^
      const DeepCollectionEquality().hash(menuIcon) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(pluginId) ^
      runtimeType.hashCode;
}

extension $ConfigurationPageInfoExtension on ConfigurationPageInfo {
  ConfigurationPageInfo copyWith(
      {String? name,
      bool? enableInMainMenu,
      String? menuSection,
      String? menuIcon,
      String? displayName,
      String? pluginId}) {
    return ConfigurationPageInfo(
        name: name ?? this.name,
        enableInMainMenu: enableInMainMenu ?? this.enableInMainMenu,
        menuSection: menuSection ?? this.menuSection,
        menuIcon: menuIcon ?? this.menuIcon,
        displayName: displayName ?? this.displayName,
        pluginId: pluginId ?? this.pluginId);
  }

  ConfigurationPageInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<bool?>? enableInMainMenu,
      Wrapped<String?>? menuSection,
      Wrapped<String?>? menuIcon,
      Wrapped<String?>? displayName,
      Wrapped<String?>? pluginId}) {
    return ConfigurationPageInfo(
        name: (name != null ? name.value : this.name),
        enableInMainMenu: (enableInMainMenu != null
            ? enableInMainMenu.value
            : this.enableInMainMenu),
        menuSection:
            (menuSection != null ? menuSection.value : this.menuSection),
        menuIcon: (menuIcon != null ? menuIcon.value : this.menuIcon),
        displayName:
            (displayName != null ? displayName.value : this.displayName),
        pluginId: (pluginId != null ? pluginId.value : this.pluginId));
  }
}

@JsonSerializable(explicitToJson: true)
class ContainerProfile {
  const ContainerProfile({
    this.type,
    this.conditions,
    this.container,
    this.subContainer,
  });

  factory ContainerProfile.fromJson(Map<String, dynamic> json) =>
      _$ContainerProfileFromJson(json);

  static const toJsonFactory = _$ContainerProfileToJson;
  Map<String, dynamic> toJson() => _$ContainerProfileToJson(this);

  @JsonKey(
    name: 'Type',
    toJson: dlnaProfileTypeNullableToJson,
    fromJson: dlnaProfileTypeNullableFromJson,
  )
  final enums.DlnaProfileType? type;
  @JsonKey(name: 'Conditions', defaultValue: <ProfileCondition>[])
  final List<ProfileCondition>? conditions;
  @JsonKey(name: 'Container')
  final String? container;
  @JsonKey(name: 'SubContainer')
  final String? subContainer;
  static const fromJsonFactory = _$ContainerProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ContainerProfile &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)) &&
            (identical(other.subContainer, subContainer) ||
                const DeepCollectionEquality()
                    .equals(other.subContainer, subContainer)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(container) ^
      const DeepCollectionEquality().hash(subContainer) ^
      runtimeType.hashCode;
}

extension $ContainerProfileExtension on ContainerProfile {
  ContainerProfile copyWith(
      {enums.DlnaProfileType? type,
      List<ProfileCondition>? conditions,
      String? container,
      String? subContainer}) {
    return ContainerProfile(
        type: type ?? this.type,
        conditions: conditions ?? this.conditions,
        container: container ?? this.container,
        subContainer: subContainer ?? this.subContainer);
  }

  ContainerProfile copyWithWrapped(
      {Wrapped<enums.DlnaProfileType?>? type,
      Wrapped<List<ProfileCondition>?>? conditions,
      Wrapped<String?>? container,
      Wrapped<String?>? subContainer}) {
    return ContainerProfile(
        type: (type != null ? type.value : this.type),
        conditions: (conditions != null ? conditions.value : this.conditions),
        container: (container != null ? container.value : this.container),
        subContainer:
            (subContainer != null ? subContainer.value : this.subContainer));
  }
}

@JsonSerializable(explicitToJson: true)
class CountryInfo {
  const CountryInfo({
    this.name,
    this.displayName,
    this.twoLetterISORegionName,
    this.threeLetterISORegionName,
  });

  factory CountryInfo.fromJson(Map<String, dynamic> json) =>
      _$CountryInfoFromJson(json);

  static const toJsonFactory = _$CountryInfoToJson;
  Map<String, dynamic> toJson() => _$CountryInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'DisplayName')
  final String? displayName;
  @JsonKey(name: 'TwoLetterISORegionName')
  final String? twoLetterISORegionName;
  @JsonKey(name: 'ThreeLetterISORegionName')
  final String? threeLetterISORegionName;
  static const fromJsonFactory = _$CountryInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CountryInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.twoLetterISORegionName, twoLetterISORegionName) ||
                const DeepCollectionEquality().equals(
                    other.twoLetterISORegionName, twoLetterISORegionName)) &&
            (identical(
                    other.threeLetterISORegionName, threeLetterISORegionName) ||
                const DeepCollectionEquality().equals(
                    other.threeLetterISORegionName, threeLetterISORegionName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(twoLetterISORegionName) ^
      const DeepCollectionEquality().hash(threeLetterISORegionName) ^
      runtimeType.hashCode;
}

extension $CountryInfoExtension on CountryInfo {
  CountryInfo copyWith(
      {String? name,
      String? displayName,
      String? twoLetterISORegionName,
      String? threeLetterISORegionName}) {
    return CountryInfo(
        name: name ?? this.name,
        displayName: displayName ?? this.displayName,
        twoLetterISORegionName:
            twoLetterISORegionName ?? this.twoLetterISORegionName,
        threeLetterISORegionName:
            threeLetterISORegionName ?? this.threeLetterISORegionName);
  }

  CountryInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? displayName,
      Wrapped<String?>? twoLetterISORegionName,
      Wrapped<String?>? threeLetterISORegionName}) {
    return CountryInfo(
        name: (name != null ? name.value : this.name),
        displayName:
            (displayName != null ? displayName.value : this.displayName),
        twoLetterISORegionName: (twoLetterISORegionName != null
            ? twoLetterISORegionName.value
            : this.twoLetterISORegionName),
        threeLetterISORegionName: (threeLetterISORegionName != null
            ? threeLetterISORegionName.value
            : this.threeLetterISORegionName));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePlaylistDto {
  const CreatePlaylistDto({
    this.name,
    this.ids,
    this.userId,
    this.mediaType,
    this.users,
    this.isPublic,
  });

  factory CreatePlaylistDto.fromJson(Map<String, dynamic> json) =>
      _$CreatePlaylistDtoFromJson(json);

  static const toJsonFactory = _$CreatePlaylistDtoToJson;
  Map<String, dynamic> toJson() => _$CreatePlaylistDtoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Ids', defaultValue: <String>[])
  final List<String>? ids;
  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(
    name: 'MediaType',
    toJson: mediaTypeNullableToJson,
    fromJson: mediaTypeNullableFromJson,
  )
  final enums.MediaType? mediaType;
  @JsonKey(name: 'Users', defaultValue: <PlaylistUserPermissions>[])
  final List<PlaylistUserPermissions>? users;
  @JsonKey(name: 'IsPublic')
  final bool? isPublic;
  static const fromJsonFactory = _$CreatePlaylistDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePlaylistDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.ids, ids) ||
                const DeepCollectionEquality().equals(other.ids, ids)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.mediaType, mediaType) ||
                const DeepCollectionEquality()
                    .equals(other.mediaType, mediaType)) &&
            (identical(other.users, users) ||
                const DeepCollectionEquality().equals(other.users, users)) &&
            (identical(other.isPublic, isPublic) ||
                const DeepCollectionEquality()
                    .equals(other.isPublic, isPublic)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(ids) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(mediaType) ^
      const DeepCollectionEquality().hash(users) ^
      const DeepCollectionEquality().hash(isPublic) ^
      runtimeType.hashCode;
}

extension $CreatePlaylistDtoExtension on CreatePlaylistDto {
  CreatePlaylistDto copyWith(
      {String? name,
      List<String>? ids,
      String? userId,
      enums.MediaType? mediaType,
      List<PlaylistUserPermissions>? users,
      bool? isPublic}) {
    return CreatePlaylistDto(
        name: name ?? this.name,
        ids: ids ?? this.ids,
        userId: userId ?? this.userId,
        mediaType: mediaType ?? this.mediaType,
        users: users ?? this.users,
        isPublic: isPublic ?? this.isPublic);
  }

  CreatePlaylistDto copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<List<String>?>? ids,
      Wrapped<String?>? userId,
      Wrapped<enums.MediaType?>? mediaType,
      Wrapped<List<PlaylistUserPermissions>?>? users,
      Wrapped<bool?>? isPublic}) {
    return CreatePlaylistDto(
        name: (name != null ? name.value : this.name),
        ids: (ids != null ? ids.value : this.ids),
        userId: (userId != null ? userId.value : this.userId),
        mediaType: (mediaType != null ? mediaType.value : this.mediaType),
        users: (users != null ? users.value : this.users),
        isPublic: (isPublic != null ? isPublic.value : this.isPublic));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateUserByName {
  const CreateUserByName({
    required this.name,
    this.password,
  });

  factory CreateUserByName.fromJson(Map<String, dynamic> json) =>
      _$CreateUserByNameFromJson(json);

  static const toJsonFactory = _$CreateUserByNameToJson;
  Map<String, dynamic> toJson() => _$CreateUserByNameToJson(this);

  @JsonKey(name: 'Name')
  final String name;
  @JsonKey(name: 'Password')
  final String? password;
  static const fromJsonFactory = _$CreateUserByNameFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateUserByName &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(password) ^
      runtimeType.hashCode;
}

extension $CreateUserByNameExtension on CreateUserByName {
  CreateUserByName copyWith({String? name, String? password}) {
    return CreateUserByName(
        name: name ?? this.name, password: password ?? this.password);
  }

  CreateUserByName copyWithWrapped(
      {Wrapped<String>? name, Wrapped<String?>? password}) {
    return CreateUserByName(
        name: (name != null ? name.value : this.name),
        password: (password != null ? password.value : this.password));
  }
}

@JsonSerializable(explicitToJson: true)
class CultureDto {
  const CultureDto({
    this.name,
    this.displayName,
    this.twoLetterISOLanguageName,
    this.threeLetterISOLanguageName,
    this.threeLetterISOLanguageNames,
  });

  factory CultureDto.fromJson(Map<String, dynamic> json) =>
      _$CultureDtoFromJson(json);

  static const toJsonFactory = _$CultureDtoToJson;
  Map<String, dynamic> toJson() => _$CultureDtoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'DisplayName')
  final String? displayName;
  @JsonKey(name: 'TwoLetterISOLanguageName')
  final String? twoLetterISOLanguageName;
  @JsonKey(name: 'ThreeLetterISOLanguageName')
  final String? threeLetterISOLanguageName;
  @JsonKey(name: 'ThreeLetterISOLanguageNames', defaultValue: <String>[])
  final List<String>? threeLetterISOLanguageNames;
  static const fromJsonFactory = _$CultureDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CultureDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(
                    other.twoLetterISOLanguageName, twoLetterISOLanguageName) ||
                const DeepCollectionEquality().equals(
                    other.twoLetterISOLanguageName,
                    twoLetterISOLanguageName)) &&
            (identical(other.threeLetterISOLanguageName,
                    threeLetterISOLanguageName) ||
                const DeepCollectionEquality().equals(
                    other.threeLetterISOLanguageName,
                    threeLetterISOLanguageName)) &&
            (identical(other.threeLetterISOLanguageNames,
                    threeLetterISOLanguageNames) ||
                const DeepCollectionEquality().equals(
                    other.threeLetterISOLanguageNames,
                    threeLetterISOLanguageNames)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(twoLetterISOLanguageName) ^
      const DeepCollectionEquality().hash(threeLetterISOLanguageName) ^
      const DeepCollectionEquality().hash(threeLetterISOLanguageNames) ^
      runtimeType.hashCode;
}

extension $CultureDtoExtension on CultureDto {
  CultureDto copyWith(
      {String? name,
      String? displayName,
      String? twoLetterISOLanguageName,
      String? threeLetterISOLanguageName,
      List<String>? threeLetterISOLanguageNames}) {
    return CultureDto(
        name: name ?? this.name,
        displayName: displayName ?? this.displayName,
        twoLetterISOLanguageName:
            twoLetterISOLanguageName ?? this.twoLetterISOLanguageName,
        threeLetterISOLanguageName:
            threeLetterISOLanguageName ?? this.threeLetterISOLanguageName,
        threeLetterISOLanguageNames:
            threeLetterISOLanguageNames ?? this.threeLetterISOLanguageNames);
  }

  CultureDto copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? displayName,
      Wrapped<String?>? twoLetterISOLanguageName,
      Wrapped<String?>? threeLetterISOLanguageName,
      Wrapped<List<String>?>? threeLetterISOLanguageNames}) {
    return CultureDto(
        name: (name != null ? name.value : this.name),
        displayName:
            (displayName != null ? displayName.value : this.displayName),
        twoLetterISOLanguageName: (twoLetterISOLanguageName != null
            ? twoLetterISOLanguageName.value
            : this.twoLetterISOLanguageName),
        threeLetterISOLanguageName: (threeLetterISOLanguageName != null
            ? threeLetterISOLanguageName.value
            : this.threeLetterISOLanguageName),
        threeLetterISOLanguageNames: (threeLetterISOLanguageNames != null
            ? threeLetterISOLanguageNames.value
            : this.threeLetterISOLanguageNames));
  }
}

@JsonSerializable(explicitToJson: true)
class DefaultDirectoryBrowserInfoDto {
  const DefaultDirectoryBrowserInfoDto({
    this.path,
  });

  factory DefaultDirectoryBrowserInfoDto.fromJson(Map<String, dynamic> json) =>
      _$DefaultDirectoryBrowserInfoDtoFromJson(json);

  static const toJsonFactory = _$DefaultDirectoryBrowserInfoDtoToJson;
  Map<String, dynamic> toJson() => _$DefaultDirectoryBrowserInfoDtoToJson(this);

  @JsonKey(name: 'Path')
  final String? path;
  static const fromJsonFactory = _$DefaultDirectoryBrowserInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DefaultDirectoryBrowserInfoDto &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(path) ^ runtimeType.hashCode;
}

extension $DefaultDirectoryBrowserInfoDtoExtension
    on DefaultDirectoryBrowserInfoDto {
  DefaultDirectoryBrowserInfoDto copyWith({String? path}) {
    return DefaultDirectoryBrowserInfoDto(path: path ?? this.path);
  }

  DefaultDirectoryBrowserInfoDto copyWithWrapped({Wrapped<String?>? path}) {
    return DefaultDirectoryBrowserInfoDto(
        path: (path != null ? path.value : this.path));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceInfoDto {
  const DeviceInfoDto({
    this.name,
    this.customName,
    this.accessToken,
    this.id,
    this.lastUserName,
    this.appName,
    this.appVersion,
    this.lastUserId,
    this.dateLastActivity,
    this.capabilities,
    this.iconUrl,
  });

  factory DeviceInfoDto.fromJson(Map<String, dynamic> json) =>
      _$DeviceInfoDtoFromJson(json);

  static const toJsonFactory = _$DeviceInfoDtoToJson;
  Map<String, dynamic> toJson() => _$DeviceInfoDtoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'CustomName')
  final String? customName;
  @JsonKey(name: 'AccessToken')
  final String? accessToken;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'LastUserName')
  final String? lastUserName;
  @JsonKey(name: 'AppName')
  final String? appName;
  @JsonKey(name: 'AppVersion')
  final String? appVersion;
  @JsonKey(name: 'LastUserId')
  final String? lastUserId;
  @JsonKey(name: 'DateLastActivity')
  final DateTime? dateLastActivity;
  @JsonKey(name: 'Capabilities')
  final ClientCapabilitiesDto? capabilities;
  @JsonKey(name: 'IconUrl')
  final String? iconUrl;
  static const fromJsonFactory = _$DeviceInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceInfoDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.customName, customName) ||
                const DeepCollectionEquality()
                    .equals(other.customName, customName)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.lastUserName, lastUserName) ||
                const DeepCollectionEquality()
                    .equals(other.lastUserName, lastUserName)) &&
            (identical(other.appName, appName) ||
                const DeepCollectionEquality()
                    .equals(other.appName, appName)) &&
            (identical(other.appVersion, appVersion) ||
                const DeepCollectionEquality()
                    .equals(other.appVersion, appVersion)) &&
            (identical(other.lastUserId, lastUserId) ||
                const DeepCollectionEquality()
                    .equals(other.lastUserId, lastUserId)) &&
            (identical(other.dateLastActivity, dateLastActivity) ||
                const DeepCollectionEquality()
                    .equals(other.dateLastActivity, dateLastActivity)) &&
            (identical(other.capabilities, capabilities) ||
                const DeepCollectionEquality()
                    .equals(other.capabilities, capabilities)) &&
            (identical(other.iconUrl, iconUrl) ||
                const DeepCollectionEquality().equals(other.iconUrl, iconUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(customName) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(lastUserName) ^
      const DeepCollectionEquality().hash(appName) ^
      const DeepCollectionEquality().hash(appVersion) ^
      const DeepCollectionEquality().hash(lastUserId) ^
      const DeepCollectionEquality().hash(dateLastActivity) ^
      const DeepCollectionEquality().hash(capabilities) ^
      const DeepCollectionEquality().hash(iconUrl) ^
      runtimeType.hashCode;
}

extension $DeviceInfoDtoExtension on DeviceInfoDto {
  DeviceInfoDto copyWith(
      {String? name,
      String? customName,
      String? accessToken,
      String? id,
      String? lastUserName,
      String? appName,
      String? appVersion,
      String? lastUserId,
      DateTime? dateLastActivity,
      ClientCapabilitiesDto? capabilities,
      String? iconUrl}) {
    return DeviceInfoDto(
        name: name ?? this.name,
        customName: customName ?? this.customName,
        accessToken: accessToken ?? this.accessToken,
        id: id ?? this.id,
        lastUserName: lastUserName ?? this.lastUserName,
        appName: appName ?? this.appName,
        appVersion: appVersion ?? this.appVersion,
        lastUserId: lastUserId ?? this.lastUserId,
        dateLastActivity: dateLastActivity ?? this.dateLastActivity,
        capabilities: capabilities ?? this.capabilities,
        iconUrl: iconUrl ?? this.iconUrl);
  }

  DeviceInfoDto copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? customName,
      Wrapped<String?>? accessToken,
      Wrapped<String?>? id,
      Wrapped<String?>? lastUserName,
      Wrapped<String?>? appName,
      Wrapped<String?>? appVersion,
      Wrapped<String?>? lastUserId,
      Wrapped<DateTime?>? dateLastActivity,
      Wrapped<ClientCapabilitiesDto?>? capabilities,
      Wrapped<String?>? iconUrl}) {
    return DeviceInfoDto(
        name: (name != null ? name.value : this.name),
        customName: (customName != null ? customName.value : this.customName),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        id: (id != null ? id.value : this.id),
        lastUserName:
            (lastUserName != null ? lastUserName.value : this.lastUserName),
        appName: (appName != null ? appName.value : this.appName),
        appVersion: (appVersion != null ? appVersion.value : this.appVersion),
        lastUserId: (lastUserId != null ? lastUserId.value : this.lastUserId),
        dateLastActivity: (dateLastActivity != null
            ? dateLastActivity.value
            : this.dateLastActivity),
        capabilities:
            (capabilities != null ? capabilities.value : this.capabilities),
        iconUrl: (iconUrl != null ? iconUrl.value : this.iconUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceInfoDtoQueryResult {
  const DeviceInfoDtoQueryResult({
    this.items,
    this.totalRecordCount,
    this.startIndex,
  });

  factory DeviceInfoDtoQueryResult.fromJson(Map<String, dynamic> json) =>
      _$DeviceInfoDtoQueryResultFromJson(json);

  static const toJsonFactory = _$DeviceInfoDtoQueryResultToJson;
  Map<String, dynamic> toJson() => _$DeviceInfoDtoQueryResultToJson(this);

  @JsonKey(name: 'Items', defaultValue: <DeviceInfoDto>[])
  final List<DeviceInfoDto>? items;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  static const fromJsonFactory = _$DeviceInfoDtoQueryResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceInfoDtoQueryResult &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      const DeepCollectionEquality().hash(startIndex) ^
      runtimeType.hashCode;
}

extension $DeviceInfoDtoQueryResultExtension on DeviceInfoDtoQueryResult {
  DeviceInfoDtoQueryResult copyWith(
      {List<DeviceInfoDto>? items, int? totalRecordCount, int? startIndex}) {
    return DeviceInfoDtoQueryResult(
        items: items ?? this.items,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount,
        startIndex: startIndex ?? this.startIndex);
  }

  DeviceInfoDtoQueryResult copyWithWrapped(
      {Wrapped<List<DeviceInfoDto>?>? items,
      Wrapped<int?>? totalRecordCount,
      Wrapped<int?>? startIndex}) {
    return DeviceInfoDtoQueryResult(
        items: (items != null ? items.value : this.items),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceOptionsDto {
  const DeviceOptionsDto({
    this.id,
    this.deviceId,
    this.customName,
  });

  factory DeviceOptionsDto.fromJson(Map<String, dynamic> json) =>
      _$DeviceOptionsDtoFromJson(json);

  static const toJsonFactory = _$DeviceOptionsDtoToJson;
  Map<String, dynamic> toJson() => _$DeviceOptionsDtoToJson(this);

  @JsonKey(name: 'Id')
  final int? id;
  @JsonKey(name: 'DeviceId')
  final String? deviceId;
  @JsonKey(name: 'CustomName')
  final String? customName;
  static const fromJsonFactory = _$DeviceOptionsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceOptionsDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.customName, customName) ||
                const DeepCollectionEquality()
                    .equals(other.customName, customName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(customName) ^
      runtimeType.hashCode;
}

extension $DeviceOptionsDtoExtension on DeviceOptionsDto {
  DeviceOptionsDto copyWith({int? id, String? deviceId, String? customName}) {
    return DeviceOptionsDto(
        id: id ?? this.id,
        deviceId: deviceId ?? this.deviceId,
        customName: customName ?? this.customName);
  }

  DeviceOptionsDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? deviceId,
      Wrapped<String?>? customName}) {
    return DeviceOptionsDto(
        id: (id != null ? id.value : this.id),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        customName: (customName != null ? customName.value : this.customName));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceProfile {
  const DeviceProfile({
    this.name,
    this.id,
    this.maxStreamingBitrate,
    this.maxStaticBitrate,
    this.musicStreamingTranscodingBitrate,
    this.maxStaticMusicBitrate,
    this.directPlayProfiles,
    this.transcodingProfiles,
    this.containerProfiles,
    this.codecProfiles,
    this.subtitleProfiles,
  });

  factory DeviceProfile.fromJson(Map<String, dynamic> json) =>
      _$DeviceProfileFromJson(json);

  static const toJsonFactory = _$DeviceProfileToJson;
  Map<String, dynamic> toJson() => _$DeviceProfileToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'MaxStreamingBitrate')
  final int? maxStreamingBitrate;
  @JsonKey(name: 'MaxStaticBitrate')
  final int? maxStaticBitrate;
  @JsonKey(name: 'MusicStreamingTranscodingBitrate')
  final int? musicStreamingTranscodingBitrate;
  @JsonKey(name: 'MaxStaticMusicBitrate')
  final int? maxStaticMusicBitrate;
  @JsonKey(name: 'DirectPlayProfiles', defaultValue: <DirectPlayProfile>[])
  final List<DirectPlayProfile>? directPlayProfiles;
  @JsonKey(name: 'TranscodingProfiles', defaultValue: <TranscodingProfile>[])
  final List<TranscodingProfile>? transcodingProfiles;
  @JsonKey(name: 'ContainerProfiles', defaultValue: <ContainerProfile>[])
  final List<ContainerProfile>? containerProfiles;
  @JsonKey(name: 'CodecProfiles', defaultValue: <CodecProfile>[])
  final List<CodecProfile>? codecProfiles;
  @JsonKey(name: 'SubtitleProfiles', defaultValue: <SubtitleProfile>[])
  final List<SubtitleProfile>? subtitleProfiles;
  static const fromJsonFactory = _$DeviceProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceProfile &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.maxStreamingBitrate, maxStreamingBitrate) ||
                const DeepCollectionEquality()
                    .equals(other.maxStreamingBitrate, maxStreamingBitrate)) &&
            (identical(other.maxStaticBitrate, maxStaticBitrate) ||
                const DeepCollectionEquality()
                    .equals(other.maxStaticBitrate, maxStaticBitrate)) &&
            (identical(other.musicStreamingTranscodingBitrate,
                    musicStreamingTranscodingBitrate) ||
                const DeepCollectionEquality().equals(
                    other.musicStreamingTranscodingBitrate,
                    musicStreamingTranscodingBitrate)) &&
            (identical(other.maxStaticMusicBitrate, maxStaticMusicBitrate) ||
                const DeepCollectionEquality().equals(
                    other.maxStaticMusicBitrate, maxStaticMusicBitrate)) &&
            (identical(other.directPlayProfiles, directPlayProfiles) ||
                const DeepCollectionEquality()
                    .equals(other.directPlayProfiles, directPlayProfiles)) &&
            (identical(other.transcodingProfiles, transcodingProfiles) ||
                const DeepCollectionEquality()
                    .equals(other.transcodingProfiles, transcodingProfiles)) &&
            (identical(other.containerProfiles, containerProfiles) ||
                const DeepCollectionEquality()
                    .equals(other.containerProfiles, containerProfiles)) &&
            (identical(other.codecProfiles, codecProfiles) ||
                const DeepCollectionEquality()
                    .equals(other.codecProfiles, codecProfiles)) &&
            (identical(other.subtitleProfiles, subtitleProfiles) ||
                const DeepCollectionEquality()
                    .equals(other.subtitleProfiles, subtitleProfiles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(maxStreamingBitrate) ^
      const DeepCollectionEquality().hash(maxStaticBitrate) ^
      const DeepCollectionEquality().hash(musicStreamingTranscodingBitrate) ^
      const DeepCollectionEquality().hash(maxStaticMusicBitrate) ^
      const DeepCollectionEquality().hash(directPlayProfiles) ^
      const DeepCollectionEquality().hash(transcodingProfiles) ^
      const DeepCollectionEquality().hash(containerProfiles) ^
      const DeepCollectionEquality().hash(codecProfiles) ^
      const DeepCollectionEquality().hash(subtitleProfiles) ^
      runtimeType.hashCode;
}

extension $DeviceProfileExtension on DeviceProfile {
  DeviceProfile copyWith(
      {String? name,
      String? id,
      int? maxStreamingBitrate,
      int? maxStaticBitrate,
      int? musicStreamingTranscodingBitrate,
      int? maxStaticMusicBitrate,
      List<DirectPlayProfile>? directPlayProfiles,
      List<TranscodingProfile>? transcodingProfiles,
      List<ContainerProfile>? containerProfiles,
      List<CodecProfile>? codecProfiles,
      List<SubtitleProfile>? subtitleProfiles}) {
    return DeviceProfile(
        name: name ?? this.name,
        id: id ?? this.id,
        maxStreamingBitrate: maxStreamingBitrate ?? this.maxStreamingBitrate,
        maxStaticBitrate: maxStaticBitrate ?? this.maxStaticBitrate,
        musicStreamingTranscodingBitrate: musicStreamingTranscodingBitrate ??
            this.musicStreamingTranscodingBitrate,
        maxStaticMusicBitrate:
            maxStaticMusicBitrate ?? this.maxStaticMusicBitrate,
        directPlayProfiles: directPlayProfiles ?? this.directPlayProfiles,
        transcodingProfiles: transcodingProfiles ?? this.transcodingProfiles,
        containerProfiles: containerProfiles ?? this.containerProfiles,
        codecProfiles: codecProfiles ?? this.codecProfiles,
        subtitleProfiles: subtitleProfiles ?? this.subtitleProfiles);
  }

  DeviceProfile copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? id,
      Wrapped<int?>? maxStreamingBitrate,
      Wrapped<int?>? maxStaticBitrate,
      Wrapped<int?>? musicStreamingTranscodingBitrate,
      Wrapped<int?>? maxStaticMusicBitrate,
      Wrapped<List<DirectPlayProfile>?>? directPlayProfiles,
      Wrapped<List<TranscodingProfile>?>? transcodingProfiles,
      Wrapped<List<ContainerProfile>?>? containerProfiles,
      Wrapped<List<CodecProfile>?>? codecProfiles,
      Wrapped<List<SubtitleProfile>?>? subtitleProfiles}) {
    return DeviceProfile(
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id),
        maxStreamingBitrate: (maxStreamingBitrate != null
            ? maxStreamingBitrate.value
            : this.maxStreamingBitrate),
        maxStaticBitrate: (maxStaticBitrate != null
            ? maxStaticBitrate.value
            : this.maxStaticBitrate),
        musicStreamingTranscodingBitrate:
            (musicStreamingTranscodingBitrate != null
                ? musicStreamingTranscodingBitrate.value
                : this.musicStreamingTranscodingBitrate),
        maxStaticMusicBitrate: (maxStaticMusicBitrate != null
            ? maxStaticMusicBitrate.value
            : this.maxStaticMusicBitrate),
        directPlayProfiles: (directPlayProfiles != null
            ? directPlayProfiles.value
            : this.directPlayProfiles),
        transcodingProfiles: (transcodingProfiles != null
            ? transcodingProfiles.value
            : this.transcodingProfiles),
        containerProfiles: (containerProfiles != null
            ? containerProfiles.value
            : this.containerProfiles),
        codecProfiles:
            (codecProfiles != null ? codecProfiles.value : this.codecProfiles),
        subtitleProfiles: (subtitleProfiles != null
            ? subtitleProfiles.value
            : this.subtitleProfiles));
  }
}

@JsonSerializable(explicitToJson: true)
class DirectPlayProfile {
  const DirectPlayProfile({
    this.container,
    this.audioCodec,
    this.videoCodec,
    this.type,
  });

  factory DirectPlayProfile.fromJson(Map<String, dynamic> json) =>
      _$DirectPlayProfileFromJson(json);

  static const toJsonFactory = _$DirectPlayProfileToJson;
  Map<String, dynamic> toJson() => _$DirectPlayProfileToJson(this);

  @JsonKey(name: 'Container')
  final String? container;
  @JsonKey(name: 'AudioCodec')
  final String? audioCodec;
  @JsonKey(name: 'VideoCodec')
  final String? videoCodec;
  @JsonKey(
    name: 'Type',
    toJson: dlnaProfileTypeNullableToJson,
    fromJson: dlnaProfileTypeNullableFromJson,
  )
  final enums.DlnaProfileType? type;
  static const fromJsonFactory = _$DirectPlayProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DirectPlayProfile &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)) &&
            (identical(other.audioCodec, audioCodec) ||
                const DeepCollectionEquality()
                    .equals(other.audioCodec, audioCodec)) &&
            (identical(other.videoCodec, videoCodec) ||
                const DeepCollectionEquality()
                    .equals(other.videoCodec, videoCodec)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(container) ^
      const DeepCollectionEquality().hash(audioCodec) ^
      const DeepCollectionEquality().hash(videoCodec) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $DirectPlayProfileExtension on DirectPlayProfile {
  DirectPlayProfile copyWith(
      {String? container,
      String? audioCodec,
      String? videoCodec,
      enums.DlnaProfileType? type}) {
    return DirectPlayProfile(
        container: container ?? this.container,
        audioCodec: audioCodec ?? this.audioCodec,
        videoCodec: videoCodec ?? this.videoCodec,
        type: type ?? this.type);
  }

  DirectPlayProfile copyWithWrapped(
      {Wrapped<String?>? container,
      Wrapped<String?>? audioCodec,
      Wrapped<String?>? videoCodec,
      Wrapped<enums.DlnaProfileType?>? type}) {
    return DirectPlayProfile(
        container: (container != null ? container.value : this.container),
        audioCodec: (audioCodec != null ? audioCodec.value : this.audioCodec),
        videoCodec: (videoCodec != null ? videoCodec.value : this.videoCodec),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class DisplayPreferencesDto {
  const DisplayPreferencesDto({
    this.id,
    this.viewType,
    this.sortBy,
    this.indexBy,
    this.rememberIndexing,
    this.primaryImageHeight,
    this.primaryImageWidth,
    this.customPrefs,
    this.scrollDirection,
    this.showBackdrop,
    this.rememberSorting,
    this.sortOrder,
    this.showSidebar,
    this.$Client,
  });

  factory DisplayPreferencesDto.fromJson(Map<String, dynamic> json) =>
      _$DisplayPreferencesDtoFromJson(json);

  static const toJsonFactory = _$DisplayPreferencesDtoToJson;
  Map<String, dynamic> toJson() => _$DisplayPreferencesDtoToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'ViewType')
  final String? viewType;
  @JsonKey(name: 'SortBy')
  final String? sortBy;
  @JsonKey(name: 'IndexBy')
  final String? indexBy;
  @JsonKey(name: 'RememberIndexing')
  final bool? rememberIndexing;
  @JsonKey(name: 'PrimaryImageHeight')
  final int? primaryImageHeight;
  @JsonKey(name: 'PrimaryImageWidth')
  final int? primaryImageWidth;
  @JsonKey(name: 'CustomPrefs')
  final Map<String, dynamic>? customPrefs;
  @JsonKey(
    name: 'ScrollDirection',
    toJson: scrollDirectionNullableToJson,
    fromJson: scrollDirectionNullableFromJson,
  )
  final enums.ScrollDirection? scrollDirection;
  @JsonKey(name: 'ShowBackdrop')
  final bool? showBackdrop;
  @JsonKey(name: 'RememberSorting')
  final bool? rememberSorting;
  @JsonKey(
    name: 'SortOrder',
    toJson: sortOrderNullableToJson,
    fromJson: sortOrderNullableFromJson,
  )
  final enums.SortOrder? sortOrder;
  @JsonKey(name: 'ShowSidebar')
  final bool? showSidebar;
  @JsonKey(name: 'Client')
  final String? $Client;
  static const fromJsonFactory = _$DisplayPreferencesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DisplayPreferencesDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.viewType, viewType) ||
                const DeepCollectionEquality()
                    .equals(other.viewType, viewType)) &&
            (identical(other.sortBy, sortBy) ||
                const DeepCollectionEquality().equals(other.sortBy, sortBy)) &&
            (identical(other.indexBy, indexBy) ||
                const DeepCollectionEquality()
                    .equals(other.indexBy, indexBy)) &&
            (identical(other.rememberIndexing, rememberIndexing) ||
                const DeepCollectionEquality()
                    .equals(other.rememberIndexing, rememberIndexing)) &&
            (identical(other.primaryImageHeight, primaryImageHeight) ||
                const DeepCollectionEquality()
                    .equals(other.primaryImageHeight, primaryImageHeight)) &&
            (identical(other.primaryImageWidth, primaryImageWidth) ||
                const DeepCollectionEquality()
                    .equals(other.primaryImageWidth, primaryImageWidth)) &&
            (identical(other.customPrefs, customPrefs) ||
                const DeepCollectionEquality()
                    .equals(other.customPrefs, customPrefs)) &&
            (identical(other.scrollDirection, scrollDirection) ||
                const DeepCollectionEquality()
                    .equals(other.scrollDirection, scrollDirection)) &&
            (identical(other.showBackdrop, showBackdrop) ||
                const DeepCollectionEquality()
                    .equals(other.showBackdrop, showBackdrop)) &&
            (identical(other.rememberSorting, rememberSorting) ||
                const DeepCollectionEquality()
                    .equals(other.rememberSorting, rememberSorting)) &&
            (identical(other.sortOrder, sortOrder) ||
                const DeepCollectionEquality()
                    .equals(other.sortOrder, sortOrder)) &&
            (identical(other.showSidebar, showSidebar) ||
                const DeepCollectionEquality()
                    .equals(other.showSidebar, showSidebar)) &&
            (identical(other.$Client, $Client) ||
                const DeepCollectionEquality().equals(other.$Client, $Client)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(viewType) ^
      const DeepCollectionEquality().hash(sortBy) ^
      const DeepCollectionEquality().hash(indexBy) ^
      const DeepCollectionEquality().hash(rememberIndexing) ^
      const DeepCollectionEquality().hash(primaryImageHeight) ^
      const DeepCollectionEquality().hash(primaryImageWidth) ^
      const DeepCollectionEquality().hash(customPrefs) ^
      const DeepCollectionEquality().hash(scrollDirection) ^
      const DeepCollectionEquality().hash(showBackdrop) ^
      const DeepCollectionEquality().hash(rememberSorting) ^
      const DeepCollectionEquality().hash(sortOrder) ^
      const DeepCollectionEquality().hash(showSidebar) ^
      const DeepCollectionEquality().hash($Client) ^
      runtimeType.hashCode;
}

extension $DisplayPreferencesDtoExtension on DisplayPreferencesDto {
  DisplayPreferencesDto copyWith(
      {String? id,
      String? viewType,
      String? sortBy,
      String? indexBy,
      bool? rememberIndexing,
      int? primaryImageHeight,
      int? primaryImageWidth,
      Map<String, dynamic>? customPrefs,
      enums.ScrollDirection? scrollDirection,
      bool? showBackdrop,
      bool? rememberSorting,
      enums.SortOrder? sortOrder,
      bool? showSidebar,
      String? $Client}) {
    return DisplayPreferencesDto(
        id: id ?? this.id,
        viewType: viewType ?? this.viewType,
        sortBy: sortBy ?? this.sortBy,
        indexBy: indexBy ?? this.indexBy,
        rememberIndexing: rememberIndexing ?? this.rememberIndexing,
        primaryImageHeight: primaryImageHeight ?? this.primaryImageHeight,
        primaryImageWidth: primaryImageWidth ?? this.primaryImageWidth,
        customPrefs: customPrefs ?? this.customPrefs,
        scrollDirection: scrollDirection ?? this.scrollDirection,
        showBackdrop: showBackdrop ?? this.showBackdrop,
        rememberSorting: rememberSorting ?? this.rememberSorting,
        sortOrder: sortOrder ?? this.sortOrder,
        showSidebar: showSidebar ?? this.showSidebar,
        $Client: $Client ?? this.$Client);
  }

  DisplayPreferencesDto copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? viewType,
      Wrapped<String?>? sortBy,
      Wrapped<String?>? indexBy,
      Wrapped<bool?>? rememberIndexing,
      Wrapped<int?>? primaryImageHeight,
      Wrapped<int?>? primaryImageWidth,
      Wrapped<Map<String, dynamic>?>? customPrefs,
      Wrapped<enums.ScrollDirection?>? scrollDirection,
      Wrapped<bool?>? showBackdrop,
      Wrapped<bool?>? rememberSorting,
      Wrapped<enums.SortOrder?>? sortOrder,
      Wrapped<bool?>? showSidebar,
      Wrapped<String?>? $Client}) {
    return DisplayPreferencesDto(
        id: (id != null ? id.value : this.id),
        viewType: (viewType != null ? viewType.value : this.viewType),
        sortBy: (sortBy != null ? sortBy.value : this.sortBy),
        indexBy: (indexBy != null ? indexBy.value : this.indexBy),
        rememberIndexing: (rememberIndexing != null
            ? rememberIndexing.value
            : this.rememberIndexing),
        primaryImageHeight: (primaryImageHeight != null
            ? primaryImageHeight.value
            : this.primaryImageHeight),
        primaryImageWidth: (primaryImageWidth != null
            ? primaryImageWidth.value
            : this.primaryImageWidth),
        customPrefs:
            (customPrefs != null ? customPrefs.value : this.customPrefs),
        scrollDirection: (scrollDirection != null
            ? scrollDirection.value
            : this.scrollDirection),
        showBackdrop:
            (showBackdrop != null ? showBackdrop.value : this.showBackdrop),
        rememberSorting: (rememberSorting != null
            ? rememberSorting.value
            : this.rememberSorting),
        sortOrder: (sortOrder != null ? sortOrder.value : this.sortOrder),
        showSidebar:
            (showSidebar != null ? showSidebar.value : this.showSidebar),
        $Client: ($Client != null ? $Client.value : this.$Client));
  }
}

@JsonSerializable(explicitToJson: true)
class EncodingOptions {
  const EncodingOptions({
    this.encodingThreadCount,
    this.transcodingTempPath,
    this.fallbackFontPath,
    this.enableFallbackFont,
    this.enableAudioVbr,
    this.downMixAudioBoost,
    this.downMixStereoAlgorithm,
    this.maxMuxingQueueSize,
    this.enableThrottling,
    this.throttleDelaySeconds,
    this.enableSegmentDeletion,
    this.segmentKeepSeconds,
    this.hardwareAccelerationType,
    this.encoderAppPath,
    this.encoderAppPathDisplay,
    this.vaapiDevice,
    this.qsvDevice,
    this.enableTonemapping,
    this.enableVppTonemapping,
    this.enableVideoToolboxTonemapping,
    this.tonemappingAlgorithm,
    this.tonemappingMode,
    this.tonemappingRange,
    this.tonemappingDesat,
    this.tonemappingPeak,
    this.tonemappingParam,
    this.vppTonemappingBrightness,
    this.vppTonemappingContrast,
    this.h264Crf,
    this.h265Crf,
    this.encoderPreset,
    this.deinterlaceDoubleRate,
    this.deinterlaceMethod,
    this.enableDecodingColorDepth10Hevc,
    this.enableDecodingColorDepth10Vp9,
    this.enableDecodingColorDepth10HevcRext,
    this.enableDecodingColorDepth12HevcRext,
    this.enableEnhancedNvdecDecoder,
    this.preferSystemNativeHwDecoder,
    this.enableIntelLowPowerH264HwEncoder,
    this.enableIntelLowPowerHevcHwEncoder,
    this.enableHardwareEncoding,
    this.allowHevcEncoding,
    this.allowAv1Encoding,
    this.enableSubtitleExtraction,
    this.hardwareDecodingCodecs,
    this.allowOnDemandMetadataBasedKeyframeExtractionForExtensions,
  });

  factory EncodingOptions.fromJson(Map<String, dynamic> json) =>
      _$EncodingOptionsFromJson(json);

  static const toJsonFactory = _$EncodingOptionsToJson;
  Map<String, dynamic> toJson() => _$EncodingOptionsToJson(this);

  @JsonKey(name: 'EncodingThreadCount')
  final int? encodingThreadCount;
  @JsonKey(name: 'TranscodingTempPath')
  final String? transcodingTempPath;
  @JsonKey(name: 'FallbackFontPath')
  final String? fallbackFontPath;
  @JsonKey(name: 'EnableFallbackFont')
  final bool? enableFallbackFont;
  @JsonKey(name: 'EnableAudioVbr')
  final bool? enableAudioVbr;
  @JsonKey(name: 'DownMixAudioBoost')
  final double? downMixAudioBoost;
  @JsonKey(
    name: 'DownMixStereoAlgorithm',
    toJson: downMixStereoAlgorithmsNullableToJson,
    fromJson: downMixStereoAlgorithmsNullableFromJson,
  )
  final enums.DownMixStereoAlgorithms? downMixStereoAlgorithm;
  @JsonKey(name: 'MaxMuxingQueueSize')
  final int? maxMuxingQueueSize;
  @JsonKey(name: 'EnableThrottling')
  final bool? enableThrottling;
  @JsonKey(name: 'ThrottleDelaySeconds')
  final int? throttleDelaySeconds;
  @JsonKey(name: 'EnableSegmentDeletion')
  final bool? enableSegmentDeletion;
  @JsonKey(name: 'SegmentKeepSeconds')
  final int? segmentKeepSeconds;
  @JsonKey(
    name: 'HardwareAccelerationType',
    toJson: hardwareAccelerationTypeNullableToJson,
    fromJson: hardwareAccelerationTypeNullableFromJson,
  )
  final enums.HardwareAccelerationType? hardwareAccelerationType;
  @JsonKey(name: 'EncoderAppPath')
  final String? encoderAppPath;
  @JsonKey(name: 'EncoderAppPathDisplay')
  final String? encoderAppPathDisplay;
  @JsonKey(name: 'VaapiDevice')
  final String? vaapiDevice;
  @JsonKey(name: 'QsvDevice')
  final String? qsvDevice;
  @JsonKey(name: 'EnableTonemapping')
  final bool? enableTonemapping;
  @JsonKey(name: 'EnableVppTonemapping')
  final bool? enableVppTonemapping;
  @JsonKey(name: 'EnableVideoToolboxTonemapping')
  final bool? enableVideoToolboxTonemapping;
  @JsonKey(
    name: 'TonemappingAlgorithm',
    toJson: tonemappingAlgorithmNullableToJson,
    fromJson: tonemappingAlgorithmNullableFromJson,
  )
  final enums.TonemappingAlgorithm? tonemappingAlgorithm;
  @JsonKey(
    name: 'TonemappingMode',
    toJson: tonemappingModeNullableToJson,
    fromJson: tonemappingModeNullableFromJson,
  )
  final enums.TonemappingMode? tonemappingMode;
  @JsonKey(
    name: 'TonemappingRange',
    toJson: tonemappingRangeNullableToJson,
    fromJson: tonemappingRangeNullableFromJson,
  )
  final enums.TonemappingRange? tonemappingRange;
  @JsonKey(name: 'TonemappingDesat')
  final double? tonemappingDesat;
  @JsonKey(name: 'TonemappingPeak')
  final double? tonemappingPeak;
  @JsonKey(name: 'TonemappingParam')
  final double? tonemappingParam;
  @JsonKey(name: 'VppTonemappingBrightness')
  final double? vppTonemappingBrightness;
  @JsonKey(name: 'VppTonemappingContrast')
  final double? vppTonemappingContrast;
  @JsonKey(name: 'H264Crf')
  final int? h264Crf;
  @JsonKey(name: 'H265Crf')
  final int? h265Crf;
  @JsonKey(
    name: 'EncoderPreset',
    toJson: encoderPresetNullableToJson,
    fromJson: encoderPresetNullableFromJson,
  )
  final enums.EncoderPreset? encoderPreset;
  @JsonKey(name: 'DeinterlaceDoubleRate')
  final bool? deinterlaceDoubleRate;
  @JsonKey(
    name: 'DeinterlaceMethod',
    toJson: deinterlaceMethodNullableToJson,
    fromJson: deinterlaceMethodNullableFromJson,
  )
  final enums.DeinterlaceMethod? deinterlaceMethod;
  @JsonKey(name: 'EnableDecodingColorDepth10Hevc')
  final bool? enableDecodingColorDepth10Hevc;
  @JsonKey(name: 'EnableDecodingColorDepth10Vp9')
  final bool? enableDecodingColorDepth10Vp9;
  @JsonKey(name: 'EnableDecodingColorDepth10HevcRext')
  final bool? enableDecodingColorDepth10HevcRext;
  @JsonKey(name: 'EnableDecodingColorDepth12HevcRext')
  final bool? enableDecodingColorDepth12HevcRext;
  @JsonKey(name: 'EnableEnhancedNvdecDecoder')
  final bool? enableEnhancedNvdecDecoder;
  @JsonKey(name: 'PreferSystemNativeHwDecoder')
  final bool? preferSystemNativeHwDecoder;
  @JsonKey(name: 'EnableIntelLowPowerH264HwEncoder')
  final bool? enableIntelLowPowerH264HwEncoder;
  @JsonKey(name: 'EnableIntelLowPowerHevcHwEncoder')
  final bool? enableIntelLowPowerHevcHwEncoder;
  @JsonKey(name: 'EnableHardwareEncoding')
  final bool? enableHardwareEncoding;
  @JsonKey(name: 'AllowHevcEncoding')
  final bool? allowHevcEncoding;
  @JsonKey(name: 'AllowAv1Encoding')
  final bool? allowAv1Encoding;
  @JsonKey(name: 'EnableSubtitleExtraction')
  final bool? enableSubtitleExtraction;
  @JsonKey(name: 'HardwareDecodingCodecs', defaultValue: <String>[])
  final List<String>? hardwareDecodingCodecs;
  @JsonKey(
      name: 'AllowOnDemandMetadataBasedKeyframeExtractionForExtensions',
      defaultValue: <String>[])
  final List<String>? allowOnDemandMetadataBasedKeyframeExtractionForExtensions;
  static const fromJsonFactory = _$EncodingOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EncodingOptions &&
            (identical(other.encodingThreadCount, encodingThreadCount) ||
                const DeepCollectionEquality()
                    .equals(other.encodingThreadCount, encodingThreadCount)) &&
            (identical(other.transcodingTempPath, transcodingTempPath) ||
                const DeepCollectionEquality()
                    .equals(other.transcodingTempPath, transcodingTempPath)) &&
            (identical(other.fallbackFontPath, fallbackFontPath) ||
                const DeepCollectionEquality()
                    .equals(other.fallbackFontPath, fallbackFontPath)) &&
            (identical(other.enableFallbackFont, enableFallbackFont) ||
                const DeepCollectionEquality()
                    .equals(other.enableFallbackFont, enableFallbackFont)) &&
            (identical(other.enableAudioVbr, enableAudioVbr) ||
                const DeepCollectionEquality()
                    .equals(other.enableAudioVbr, enableAudioVbr)) &&
            (identical(other.downMixAudioBoost, downMixAudioBoost) ||
                const DeepCollectionEquality()
                    .equals(other.downMixAudioBoost, downMixAudioBoost)) &&
            (identical(other.downMixStereoAlgorithm, downMixStereoAlgorithm) ||
                const DeepCollectionEquality().equals(
                    other.downMixStereoAlgorithm, downMixStereoAlgorithm)) &&
            (identical(other.maxMuxingQueueSize, maxMuxingQueueSize) ||
                const DeepCollectionEquality()
                    .equals(other.maxMuxingQueueSize, maxMuxingQueueSize)) &&
            (identical(other.enableThrottling, enableThrottling) ||
                const DeepCollectionEquality()
                    .equals(other.enableThrottling, enableThrottling)) &&
            (identical(other.throttleDelaySeconds, throttleDelaySeconds) ||
                const DeepCollectionEquality().equals(
                    other.throttleDelaySeconds, throttleDelaySeconds)) &&
            (identical(other.enableSegmentDeletion, enableSegmentDeletion) ||
                const DeepCollectionEquality().equals(
                    other.enableSegmentDeletion, enableSegmentDeletion)) &&
            (identical(other.segmentKeepSeconds, segmentKeepSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.segmentKeepSeconds, segmentKeepSeconds)) &&
            (identical(other.hardwareAccelerationType, hardwareAccelerationType) ||
                const DeepCollectionEquality().equals(
                    other.hardwareAccelerationType,
                    hardwareAccelerationType)) &&
            (identical(other.encoderAppPath, encoderAppPath) ||
                const DeepCollectionEquality()
                    .equals(other.encoderAppPath, encoderAppPath)) &&
            (identical(other.encoderAppPathDisplay, encoderAppPathDisplay) ||
                const DeepCollectionEquality().equals(
                    other.encoderAppPathDisplay, encoderAppPathDisplay)) &&
            (identical(other.vaapiDevice, vaapiDevice) ||
                const DeepCollectionEquality()
                    .equals(other.vaapiDevice, vaapiDevice)) &&
            (identical(other.qsvDevice, qsvDevice) ||
                const DeepCollectionEquality()
                    .equals(other.qsvDevice, qsvDevice)) &&
            (identical(other.enableTonemapping, enableTonemapping) ||
                const DeepCollectionEquality()
                    .equals(other.enableTonemapping, enableTonemapping)) &&
            (identical(other.enableVppTonemapping, enableVppTonemapping) ||
                const DeepCollectionEquality().equals(
                    other.enableVppTonemapping, enableVppTonemapping)) &&
            (identical(other.enableVideoToolboxTonemapping, enableVideoToolboxTonemapping) || const DeepCollectionEquality().equals(other.enableVideoToolboxTonemapping, enableVideoToolboxTonemapping)) &&
            (identical(other.tonemappingAlgorithm, tonemappingAlgorithm) || const DeepCollectionEquality().equals(other.tonemappingAlgorithm, tonemappingAlgorithm)) &&
            (identical(other.tonemappingMode, tonemappingMode) || const DeepCollectionEquality().equals(other.tonemappingMode, tonemappingMode)) &&
            (identical(other.tonemappingRange, tonemappingRange) || const DeepCollectionEquality().equals(other.tonemappingRange, tonemappingRange)) &&
            (identical(other.tonemappingDesat, tonemappingDesat) || const DeepCollectionEquality().equals(other.tonemappingDesat, tonemappingDesat)) &&
            (identical(other.tonemappingPeak, tonemappingPeak) || const DeepCollectionEquality().equals(other.tonemappingPeak, tonemappingPeak)) &&
            (identical(other.tonemappingParam, tonemappingParam) || const DeepCollectionEquality().equals(other.tonemappingParam, tonemappingParam)) &&
            (identical(other.vppTonemappingBrightness, vppTonemappingBrightness) || const DeepCollectionEquality().equals(other.vppTonemappingBrightness, vppTonemappingBrightness)) &&
            (identical(other.vppTonemappingContrast, vppTonemappingContrast) || const DeepCollectionEquality().equals(other.vppTonemappingContrast, vppTonemappingContrast)) &&
            (identical(other.h264Crf, h264Crf) || const DeepCollectionEquality().equals(other.h264Crf, h264Crf)) &&
            (identical(other.h265Crf, h265Crf) || const DeepCollectionEquality().equals(other.h265Crf, h265Crf)) &&
            (identical(other.encoderPreset, encoderPreset) || const DeepCollectionEquality().equals(other.encoderPreset, encoderPreset)) &&
            (identical(other.deinterlaceDoubleRate, deinterlaceDoubleRate) || const DeepCollectionEquality().equals(other.deinterlaceDoubleRate, deinterlaceDoubleRate)) &&
            (identical(other.deinterlaceMethod, deinterlaceMethod) || const DeepCollectionEquality().equals(other.deinterlaceMethod, deinterlaceMethod)) &&
            (identical(other.enableDecodingColorDepth10Hevc, enableDecodingColorDepth10Hevc) || const DeepCollectionEquality().equals(other.enableDecodingColorDepth10Hevc, enableDecodingColorDepth10Hevc)) &&
            (identical(other.enableDecodingColorDepth10Vp9, enableDecodingColorDepth10Vp9) || const DeepCollectionEquality().equals(other.enableDecodingColorDepth10Vp9, enableDecodingColorDepth10Vp9)) &&
            (identical(other.enableDecodingColorDepth10HevcRext, enableDecodingColorDepth10HevcRext) || const DeepCollectionEquality().equals(other.enableDecodingColorDepth10HevcRext, enableDecodingColorDepth10HevcRext)) &&
            (identical(other.enableDecodingColorDepth12HevcRext, enableDecodingColorDepth12HevcRext) || const DeepCollectionEquality().equals(other.enableDecodingColorDepth12HevcRext, enableDecodingColorDepth12HevcRext)) &&
            (identical(other.enableEnhancedNvdecDecoder, enableEnhancedNvdecDecoder) || const DeepCollectionEquality().equals(other.enableEnhancedNvdecDecoder, enableEnhancedNvdecDecoder)) &&
            (identical(other.preferSystemNativeHwDecoder, preferSystemNativeHwDecoder) || const DeepCollectionEquality().equals(other.preferSystemNativeHwDecoder, preferSystemNativeHwDecoder)) &&
            (identical(other.enableIntelLowPowerH264HwEncoder, enableIntelLowPowerH264HwEncoder) || const DeepCollectionEquality().equals(other.enableIntelLowPowerH264HwEncoder, enableIntelLowPowerH264HwEncoder)) &&
            (identical(other.enableIntelLowPowerHevcHwEncoder, enableIntelLowPowerHevcHwEncoder) || const DeepCollectionEquality().equals(other.enableIntelLowPowerHevcHwEncoder, enableIntelLowPowerHevcHwEncoder)) &&
            (identical(other.enableHardwareEncoding, enableHardwareEncoding) || const DeepCollectionEquality().equals(other.enableHardwareEncoding, enableHardwareEncoding)) &&
            (identical(other.allowHevcEncoding, allowHevcEncoding) || const DeepCollectionEquality().equals(other.allowHevcEncoding, allowHevcEncoding)) &&
            (identical(other.allowAv1Encoding, allowAv1Encoding) || const DeepCollectionEquality().equals(other.allowAv1Encoding, allowAv1Encoding)) &&
            (identical(other.enableSubtitleExtraction, enableSubtitleExtraction) || const DeepCollectionEquality().equals(other.enableSubtitleExtraction, enableSubtitleExtraction)) &&
            (identical(other.hardwareDecodingCodecs, hardwareDecodingCodecs) || const DeepCollectionEquality().equals(other.hardwareDecodingCodecs, hardwareDecodingCodecs)) &&
            (identical(other.allowOnDemandMetadataBasedKeyframeExtractionForExtensions, allowOnDemandMetadataBasedKeyframeExtractionForExtensions) || const DeepCollectionEquality().equals(other.allowOnDemandMetadataBasedKeyframeExtractionForExtensions, allowOnDemandMetadataBasedKeyframeExtractionForExtensions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(encodingThreadCount) ^
      const DeepCollectionEquality().hash(transcodingTempPath) ^
      const DeepCollectionEquality().hash(fallbackFontPath) ^
      const DeepCollectionEquality().hash(enableFallbackFont) ^
      const DeepCollectionEquality().hash(enableAudioVbr) ^
      const DeepCollectionEquality().hash(downMixAudioBoost) ^
      const DeepCollectionEquality().hash(downMixStereoAlgorithm) ^
      const DeepCollectionEquality().hash(maxMuxingQueueSize) ^
      const DeepCollectionEquality().hash(enableThrottling) ^
      const DeepCollectionEquality().hash(throttleDelaySeconds) ^
      const DeepCollectionEquality().hash(enableSegmentDeletion) ^
      const DeepCollectionEquality().hash(segmentKeepSeconds) ^
      const DeepCollectionEquality().hash(hardwareAccelerationType) ^
      const DeepCollectionEquality().hash(encoderAppPath) ^
      const DeepCollectionEquality().hash(encoderAppPathDisplay) ^
      const DeepCollectionEquality().hash(vaapiDevice) ^
      const DeepCollectionEquality().hash(qsvDevice) ^
      const DeepCollectionEquality().hash(enableTonemapping) ^
      const DeepCollectionEquality().hash(enableVppTonemapping) ^
      const DeepCollectionEquality().hash(enableVideoToolboxTonemapping) ^
      const DeepCollectionEquality().hash(tonemappingAlgorithm) ^
      const DeepCollectionEquality().hash(tonemappingMode) ^
      const DeepCollectionEquality().hash(tonemappingRange) ^
      const DeepCollectionEquality().hash(tonemappingDesat) ^
      const DeepCollectionEquality().hash(tonemappingPeak) ^
      const DeepCollectionEquality().hash(tonemappingParam) ^
      const DeepCollectionEquality().hash(vppTonemappingBrightness) ^
      const DeepCollectionEquality().hash(vppTonemappingContrast) ^
      const DeepCollectionEquality().hash(h264Crf) ^
      const DeepCollectionEquality().hash(h265Crf) ^
      const DeepCollectionEquality().hash(encoderPreset) ^
      const DeepCollectionEquality().hash(deinterlaceDoubleRate) ^
      const DeepCollectionEquality().hash(deinterlaceMethod) ^
      const DeepCollectionEquality().hash(enableDecodingColorDepth10Hevc) ^
      const DeepCollectionEquality().hash(enableDecodingColorDepth10Vp9) ^
      const DeepCollectionEquality().hash(enableDecodingColorDepth10HevcRext) ^
      const DeepCollectionEquality().hash(enableDecodingColorDepth12HevcRext) ^
      const DeepCollectionEquality().hash(enableEnhancedNvdecDecoder) ^
      const DeepCollectionEquality().hash(preferSystemNativeHwDecoder) ^
      const DeepCollectionEquality().hash(enableIntelLowPowerH264HwEncoder) ^
      const DeepCollectionEquality().hash(enableIntelLowPowerHevcHwEncoder) ^
      const DeepCollectionEquality().hash(enableHardwareEncoding) ^
      const DeepCollectionEquality().hash(allowHevcEncoding) ^
      const DeepCollectionEquality().hash(allowAv1Encoding) ^
      const DeepCollectionEquality().hash(enableSubtitleExtraction) ^
      const DeepCollectionEquality().hash(hardwareDecodingCodecs) ^
      const DeepCollectionEquality()
          .hash(allowOnDemandMetadataBasedKeyframeExtractionForExtensions) ^
      runtimeType.hashCode;
}

extension $EncodingOptionsExtension on EncodingOptions {
  EncodingOptions copyWith(
      {int? encodingThreadCount,
      String? transcodingTempPath,
      String? fallbackFontPath,
      bool? enableFallbackFont,
      bool? enableAudioVbr,
      double? downMixAudioBoost,
      enums.DownMixStereoAlgorithms? downMixStereoAlgorithm,
      int? maxMuxingQueueSize,
      bool? enableThrottling,
      int? throttleDelaySeconds,
      bool? enableSegmentDeletion,
      int? segmentKeepSeconds,
      enums.HardwareAccelerationType? hardwareAccelerationType,
      String? encoderAppPath,
      String? encoderAppPathDisplay,
      String? vaapiDevice,
      String? qsvDevice,
      bool? enableTonemapping,
      bool? enableVppTonemapping,
      bool? enableVideoToolboxTonemapping,
      enums.TonemappingAlgorithm? tonemappingAlgorithm,
      enums.TonemappingMode? tonemappingMode,
      enums.TonemappingRange? tonemappingRange,
      double? tonemappingDesat,
      double? tonemappingPeak,
      double? tonemappingParam,
      double? vppTonemappingBrightness,
      double? vppTonemappingContrast,
      int? h264Crf,
      int? h265Crf,
      enums.EncoderPreset? encoderPreset,
      bool? deinterlaceDoubleRate,
      enums.DeinterlaceMethod? deinterlaceMethod,
      bool? enableDecodingColorDepth10Hevc,
      bool? enableDecodingColorDepth10Vp9,
      bool? enableDecodingColorDepth10HevcRext,
      bool? enableDecodingColorDepth12HevcRext,
      bool? enableEnhancedNvdecDecoder,
      bool? preferSystemNativeHwDecoder,
      bool? enableIntelLowPowerH264HwEncoder,
      bool? enableIntelLowPowerHevcHwEncoder,
      bool? enableHardwareEncoding,
      bool? allowHevcEncoding,
      bool? allowAv1Encoding,
      bool? enableSubtitleExtraction,
      List<String>? hardwareDecodingCodecs,
      List<String>?
          allowOnDemandMetadataBasedKeyframeExtractionForExtensions}) {
    return EncodingOptions(
        encodingThreadCount: encodingThreadCount ?? this.encodingThreadCount,
        transcodingTempPath: transcodingTempPath ?? this.transcodingTempPath,
        fallbackFontPath: fallbackFontPath ?? this.fallbackFontPath,
        enableFallbackFont: enableFallbackFont ?? this.enableFallbackFont,
        enableAudioVbr: enableAudioVbr ?? this.enableAudioVbr,
        downMixAudioBoost: downMixAudioBoost ?? this.downMixAudioBoost,
        downMixStereoAlgorithm:
            downMixStereoAlgorithm ?? this.downMixStereoAlgorithm,
        maxMuxingQueueSize: maxMuxingQueueSize ?? this.maxMuxingQueueSize,
        enableThrottling: enableThrottling ?? this.enableThrottling,
        throttleDelaySeconds: throttleDelaySeconds ?? this.throttleDelaySeconds,
        enableSegmentDeletion:
            enableSegmentDeletion ?? this.enableSegmentDeletion,
        segmentKeepSeconds: segmentKeepSeconds ?? this.segmentKeepSeconds,
        hardwareAccelerationType:
            hardwareAccelerationType ?? this.hardwareAccelerationType,
        encoderAppPath: encoderAppPath ?? this.encoderAppPath,
        encoderAppPathDisplay:
            encoderAppPathDisplay ?? this.encoderAppPathDisplay,
        vaapiDevice: vaapiDevice ?? this.vaapiDevice,
        qsvDevice: qsvDevice ?? this.qsvDevice,
        enableTonemapping: enableTonemapping ?? this.enableTonemapping,
        enableVppTonemapping: enableVppTonemapping ?? this.enableVppTonemapping,
        enableVideoToolboxTonemapping:
            enableVideoToolboxTonemapping ?? this.enableVideoToolboxTonemapping,
        tonemappingAlgorithm: tonemappingAlgorithm ?? this.tonemappingAlgorithm,
        tonemappingMode: tonemappingMode ?? this.tonemappingMode,
        tonemappingRange: tonemappingRange ?? this.tonemappingRange,
        tonemappingDesat: tonemappingDesat ?? this.tonemappingDesat,
        tonemappingPeak: tonemappingPeak ?? this.tonemappingPeak,
        tonemappingParam: tonemappingParam ?? this.tonemappingParam,
        vppTonemappingBrightness:
            vppTonemappingBrightness ?? this.vppTonemappingBrightness,
        vppTonemappingContrast:
            vppTonemappingContrast ?? this.vppTonemappingContrast,
        h264Crf: h264Crf ?? this.h264Crf,
        h265Crf: h265Crf ?? this.h265Crf,
        encoderPreset: encoderPreset ?? this.encoderPreset,
        deinterlaceDoubleRate:
            deinterlaceDoubleRate ?? this.deinterlaceDoubleRate,
        deinterlaceMethod: deinterlaceMethod ?? this.deinterlaceMethod,
        enableDecodingColorDepth10Hevc: enableDecodingColorDepth10Hevc ??
            this.enableDecodingColorDepth10Hevc,
        enableDecodingColorDepth10Vp9:
            enableDecodingColorDepth10Vp9 ?? this.enableDecodingColorDepth10Vp9,
        enableDecodingColorDepth10HevcRext:
            enableDecodingColorDepth10HevcRext ??
                this.enableDecodingColorDepth10HevcRext,
        enableDecodingColorDepth12HevcRext:
            enableDecodingColorDepth12HevcRext ??
                this.enableDecodingColorDepth12HevcRext,
        enableEnhancedNvdecDecoder:
            enableEnhancedNvdecDecoder ?? this.enableEnhancedNvdecDecoder,
        preferSystemNativeHwDecoder:
            preferSystemNativeHwDecoder ?? this.preferSystemNativeHwDecoder,
        enableIntelLowPowerH264HwEncoder: enableIntelLowPowerH264HwEncoder ??
            this.enableIntelLowPowerH264HwEncoder,
        enableIntelLowPowerHevcHwEncoder: enableIntelLowPowerHevcHwEncoder ??
            this.enableIntelLowPowerHevcHwEncoder,
        enableHardwareEncoding:
            enableHardwareEncoding ?? this.enableHardwareEncoding,
        allowHevcEncoding: allowHevcEncoding ?? this.allowHevcEncoding,
        allowAv1Encoding: allowAv1Encoding ?? this.allowAv1Encoding,
        enableSubtitleExtraction:
            enableSubtitleExtraction ?? this.enableSubtitleExtraction,
        hardwareDecodingCodecs:
            hardwareDecodingCodecs ?? this.hardwareDecodingCodecs,
        allowOnDemandMetadataBasedKeyframeExtractionForExtensions:
            allowOnDemandMetadataBasedKeyframeExtractionForExtensions ??
                this.allowOnDemandMetadataBasedKeyframeExtractionForExtensions);
  }

  EncodingOptions copyWithWrapped(
      {Wrapped<int?>? encodingThreadCount,
      Wrapped<String?>? transcodingTempPath,
      Wrapped<String?>? fallbackFontPath,
      Wrapped<bool?>? enableFallbackFont,
      Wrapped<bool?>? enableAudioVbr,
      Wrapped<double?>? downMixAudioBoost,
      Wrapped<enums.DownMixStereoAlgorithms?>? downMixStereoAlgorithm,
      Wrapped<int?>? maxMuxingQueueSize,
      Wrapped<bool?>? enableThrottling,
      Wrapped<int?>? throttleDelaySeconds,
      Wrapped<bool?>? enableSegmentDeletion,
      Wrapped<int?>? segmentKeepSeconds,
      Wrapped<enums.HardwareAccelerationType?>? hardwareAccelerationType,
      Wrapped<String?>? encoderAppPath,
      Wrapped<String?>? encoderAppPathDisplay,
      Wrapped<String?>? vaapiDevice,
      Wrapped<String?>? qsvDevice,
      Wrapped<bool?>? enableTonemapping,
      Wrapped<bool?>? enableVppTonemapping,
      Wrapped<bool?>? enableVideoToolboxTonemapping,
      Wrapped<enums.TonemappingAlgorithm?>? tonemappingAlgorithm,
      Wrapped<enums.TonemappingMode?>? tonemappingMode,
      Wrapped<enums.TonemappingRange?>? tonemappingRange,
      Wrapped<double?>? tonemappingDesat,
      Wrapped<double?>? tonemappingPeak,
      Wrapped<double?>? tonemappingParam,
      Wrapped<double?>? vppTonemappingBrightness,
      Wrapped<double?>? vppTonemappingContrast,
      Wrapped<int?>? h264Crf,
      Wrapped<int?>? h265Crf,
      Wrapped<enums.EncoderPreset?>? encoderPreset,
      Wrapped<bool?>? deinterlaceDoubleRate,
      Wrapped<enums.DeinterlaceMethod?>? deinterlaceMethod,
      Wrapped<bool?>? enableDecodingColorDepth10Hevc,
      Wrapped<bool?>? enableDecodingColorDepth10Vp9,
      Wrapped<bool?>? enableDecodingColorDepth10HevcRext,
      Wrapped<bool?>? enableDecodingColorDepth12HevcRext,
      Wrapped<bool?>? enableEnhancedNvdecDecoder,
      Wrapped<bool?>? preferSystemNativeHwDecoder,
      Wrapped<bool?>? enableIntelLowPowerH264HwEncoder,
      Wrapped<bool?>? enableIntelLowPowerHevcHwEncoder,
      Wrapped<bool?>? enableHardwareEncoding,
      Wrapped<bool?>? allowHevcEncoding,
      Wrapped<bool?>? allowAv1Encoding,
      Wrapped<bool?>? enableSubtitleExtraction,
      Wrapped<List<String>?>? hardwareDecodingCodecs,
      Wrapped<List<String>?>?
          allowOnDemandMetadataBasedKeyframeExtractionForExtensions}) {
    return EncodingOptions(
        encodingThreadCount: (encodingThreadCount != null
            ? encodingThreadCount.value
            : this.encodingThreadCount),
        transcodingTempPath: (transcodingTempPath != null
            ? transcodingTempPath.value
            : this.transcodingTempPath),
        fallbackFontPath: (fallbackFontPath != null
            ? fallbackFontPath.value
            : this.fallbackFontPath),
        enableFallbackFont: (enableFallbackFont != null
            ? enableFallbackFont.value
            : this.enableFallbackFont),
        enableAudioVbr: (enableAudioVbr != null
            ? enableAudioVbr.value
            : this.enableAudioVbr),
        downMixAudioBoost: (downMixAudioBoost != null
            ? downMixAudioBoost.value
            : this.downMixAudioBoost),
        downMixStereoAlgorithm: (downMixStereoAlgorithm != null
            ? downMixStereoAlgorithm.value
            : this.downMixStereoAlgorithm),
        maxMuxingQueueSize: (maxMuxingQueueSize != null
            ? maxMuxingQueueSize.value
            : this.maxMuxingQueueSize),
        enableThrottling: (enableThrottling != null
            ? enableThrottling.value
            : this.enableThrottling),
        throttleDelaySeconds: (throttleDelaySeconds != null
            ? throttleDelaySeconds.value
            : this.throttleDelaySeconds),
        enableSegmentDeletion: (enableSegmentDeletion != null
            ? enableSegmentDeletion.value
            : this.enableSegmentDeletion),
        segmentKeepSeconds: (segmentKeepSeconds != null
            ? segmentKeepSeconds.value
            : this.segmentKeepSeconds),
        hardwareAccelerationType: (hardwareAccelerationType != null
            ? hardwareAccelerationType.value
            : this.hardwareAccelerationType),
        encoderAppPath: (encoderAppPath != null
            ? encoderAppPath.value
            : this.encoderAppPath),
        encoderAppPathDisplay: (encoderAppPathDisplay != null
            ? encoderAppPathDisplay.value
            : this.encoderAppPathDisplay),
        vaapiDevice:
            (vaapiDevice != null ? vaapiDevice.value : this.vaapiDevice),
        qsvDevice: (qsvDevice != null ? qsvDevice.value : this.qsvDevice),
        enableTonemapping: (enableTonemapping != null
            ? enableTonemapping.value
            : this.enableTonemapping),
        enableVppTonemapping: (enableVppTonemapping != null
            ? enableVppTonemapping.value
            : this.enableVppTonemapping),
        enableVideoToolboxTonemapping: (enableVideoToolboxTonemapping != null
            ? enableVideoToolboxTonemapping.value
            : this.enableVideoToolboxTonemapping),
        tonemappingAlgorithm: (tonemappingAlgorithm != null
            ? tonemappingAlgorithm.value
            : this.tonemappingAlgorithm),
        tonemappingMode: (tonemappingMode != null
            ? tonemappingMode.value
            : this.tonemappingMode),
        tonemappingRange: (tonemappingRange != null
            ? tonemappingRange.value
            : this.tonemappingRange),
        tonemappingDesat: (tonemappingDesat != null
            ? tonemappingDesat.value
            : this.tonemappingDesat),
        tonemappingPeak: (tonemappingPeak != null
            ? tonemappingPeak.value
            : this.tonemappingPeak),
        tonemappingParam: (tonemappingParam != null
            ? tonemappingParam.value
            : this.tonemappingParam),
        vppTonemappingBrightness: (vppTonemappingBrightness != null
            ? vppTonemappingBrightness.value
            : this.vppTonemappingBrightness),
        vppTonemappingContrast: (vppTonemappingContrast != null
            ? vppTonemappingContrast.value
            : this.vppTonemappingContrast),
        h264Crf: (h264Crf != null ? h264Crf.value : this.h264Crf),
        h265Crf: (h265Crf != null ? h265Crf.value : this.h265Crf),
        encoderPreset:
            (encoderPreset != null ? encoderPreset.value : this.encoderPreset),
        deinterlaceDoubleRate: (deinterlaceDoubleRate != null
            ? deinterlaceDoubleRate.value
            : this.deinterlaceDoubleRate),
        deinterlaceMethod: (deinterlaceMethod != null
            ? deinterlaceMethod.value
            : this.deinterlaceMethod),
        enableDecodingColorDepth10Hevc: (enableDecodingColorDepth10Hevc != null
            ? enableDecodingColorDepth10Hevc.value
            : this.enableDecodingColorDepth10Hevc),
        enableDecodingColorDepth10Vp9: (enableDecodingColorDepth10Vp9 != null
            ? enableDecodingColorDepth10Vp9.value
            : this.enableDecodingColorDepth10Vp9),
        enableDecodingColorDepth10HevcRext: (enableDecodingColorDepth10HevcRext != null
            ? enableDecodingColorDepth10HevcRext.value
            : this.enableDecodingColorDepth10HevcRext),
        enableDecodingColorDepth12HevcRext:
            (enableDecodingColorDepth12HevcRext != null
                ? enableDecodingColorDepth12HevcRext.value
                : this.enableDecodingColorDepth12HevcRext),
        enableEnhancedNvdecDecoder: (enableEnhancedNvdecDecoder != null
            ? enableEnhancedNvdecDecoder.value
            : this.enableEnhancedNvdecDecoder),
        preferSystemNativeHwDecoder: (preferSystemNativeHwDecoder != null
            ? preferSystemNativeHwDecoder.value
            : this.preferSystemNativeHwDecoder),
        enableIntelLowPowerH264HwEncoder: (enableIntelLowPowerH264HwEncoder != null
            ? enableIntelLowPowerH264HwEncoder.value
            : this.enableIntelLowPowerH264HwEncoder),
        enableIntelLowPowerHevcHwEncoder: (enableIntelLowPowerHevcHwEncoder != null
            ? enableIntelLowPowerHevcHwEncoder.value
            : this.enableIntelLowPowerHevcHwEncoder),
        enableHardwareEncoding: (enableHardwareEncoding != null
            ? enableHardwareEncoding.value
            : this.enableHardwareEncoding),
        allowHevcEncoding: (allowHevcEncoding != null
            ? allowHevcEncoding.value
            : this.allowHevcEncoding),
        allowAv1Encoding: (allowAv1Encoding != null
            ? allowAv1Encoding.value
            : this.allowAv1Encoding),
        enableSubtitleExtraction: (enableSubtitleExtraction != null
            ? enableSubtitleExtraction.value
            : this.enableSubtitleExtraction),
        hardwareDecodingCodecs: (hardwareDecodingCodecs != null
            ? hardwareDecodingCodecs.value
            : this.hardwareDecodingCodecs),
        allowOnDemandMetadataBasedKeyframeExtractionForExtensions: (allowOnDemandMetadataBasedKeyframeExtractionForExtensions != null ? allowOnDemandMetadataBasedKeyframeExtractionForExtensions.value : this.allowOnDemandMetadataBasedKeyframeExtractionForExtensions));
  }
}

@JsonSerializable(explicitToJson: true)
class EndPointInfo {
  const EndPointInfo({
    this.isLocal,
    this.isInNetwork,
  });

  factory EndPointInfo.fromJson(Map<String, dynamic> json) =>
      _$EndPointInfoFromJson(json);

  static const toJsonFactory = _$EndPointInfoToJson;
  Map<String, dynamic> toJson() => _$EndPointInfoToJson(this);

  @JsonKey(name: 'IsLocal')
  final bool? isLocal;
  @JsonKey(name: 'IsInNetwork')
  final bool? isInNetwork;
  static const fromJsonFactory = _$EndPointInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EndPointInfo &&
            (identical(other.isLocal, isLocal) ||
                const DeepCollectionEquality()
                    .equals(other.isLocal, isLocal)) &&
            (identical(other.isInNetwork, isInNetwork) ||
                const DeepCollectionEquality()
                    .equals(other.isInNetwork, isInNetwork)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isLocal) ^
      const DeepCollectionEquality().hash(isInNetwork) ^
      runtimeType.hashCode;
}

extension $EndPointInfoExtension on EndPointInfo {
  EndPointInfo copyWith({bool? isLocal, bool? isInNetwork}) {
    return EndPointInfo(
        isLocal: isLocal ?? this.isLocal,
        isInNetwork: isInNetwork ?? this.isInNetwork);
  }

  EndPointInfo copyWithWrapped(
      {Wrapped<bool?>? isLocal, Wrapped<bool?>? isInNetwork}) {
    return EndPointInfo(
        isLocal: (isLocal != null ? isLocal.value : this.isLocal),
        isInNetwork:
            (isInNetwork != null ? isInNetwork.value : this.isInNetwork));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalIdInfo {
  const ExternalIdInfo({
    this.name,
    this.key,
    this.type,
    this.urlFormatString,
  });

  factory ExternalIdInfo.fromJson(Map<String, dynamic> json) =>
      _$ExternalIdInfoFromJson(json);

  static const toJsonFactory = _$ExternalIdInfoToJson;
  Map<String, dynamic> toJson() => _$ExternalIdInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Key')
  final String? key;
  @JsonKey(
    name: 'Type',
    toJson: externalIdMediaTypeNullableToJson,
    fromJson: externalIdMediaTypeNullableFromJson,
  )
  final enums.ExternalIdMediaType? type;
  @JsonKey(name: 'UrlFormatString')
  @deprecated
  final String? urlFormatString;
  static const fromJsonFactory = _$ExternalIdInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalIdInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.urlFormatString, urlFormatString) ||
                const DeepCollectionEquality()
                    .equals(other.urlFormatString, urlFormatString)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(urlFormatString) ^
      runtimeType.hashCode;
}

extension $ExternalIdInfoExtension on ExternalIdInfo {
  ExternalIdInfo copyWith(
      {String? name,
      String? key,
      enums.ExternalIdMediaType? type,
      String? urlFormatString}) {
    return ExternalIdInfo(
        name: name ?? this.name,
        key: key ?? this.key,
        type: type ?? this.type,
        urlFormatString: urlFormatString ?? this.urlFormatString);
  }

  ExternalIdInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? key,
      Wrapped<enums.ExternalIdMediaType?>? type,
      Wrapped<String?>? urlFormatString}) {
    return ExternalIdInfo(
        name: (name != null ? name.value : this.name),
        key: (key != null ? key.value : this.key),
        type: (type != null ? type.value : this.type),
        urlFormatString: (urlFormatString != null
            ? urlFormatString.value
            : this.urlFormatString));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalUrl {
  const ExternalUrl({
    this.name,
    this.url,
  });

  factory ExternalUrl.fromJson(Map<String, dynamic> json) =>
      _$ExternalUrlFromJson(json);

  static const toJsonFactory = _$ExternalUrlToJson;
  Map<String, dynamic> toJson() => _$ExternalUrlToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Url')
  final String? url;
  static const fromJsonFactory = _$ExternalUrlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalUrl &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $ExternalUrlExtension on ExternalUrl {
  ExternalUrl copyWith({String? name, String? url}) {
    return ExternalUrl(name: name ?? this.name, url: url ?? this.url);
  }

  ExternalUrl copyWithWrapped({Wrapped<String?>? name, Wrapped<String?>? url}) {
    return ExternalUrl(
        name: (name != null ? name.value : this.name),
        url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class FileSystemEntryInfo {
  const FileSystemEntryInfo({
    this.name,
    this.path,
    this.type,
  });

  factory FileSystemEntryInfo.fromJson(Map<String, dynamic> json) =>
      _$FileSystemEntryInfoFromJson(json);

  static const toJsonFactory = _$FileSystemEntryInfoToJson;
  Map<String, dynamic> toJson() => _$FileSystemEntryInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(
    name: 'Type',
    toJson: fileSystemEntryTypeNullableToJson,
    fromJson: fileSystemEntryTypeNullableFromJson,
  )
  final enums.FileSystemEntryType? type;
  static const fromJsonFactory = _$FileSystemEntryInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FileSystemEntryInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $FileSystemEntryInfoExtension on FileSystemEntryInfo {
  FileSystemEntryInfo copyWith(
      {String? name, String? path, enums.FileSystemEntryType? type}) {
    return FileSystemEntryInfo(
        name: name ?? this.name,
        path: path ?? this.path,
        type: type ?? this.type);
  }

  FileSystemEntryInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? path,
      Wrapped<enums.FileSystemEntryType?>? type}) {
    return FileSystemEntryInfo(
        name: (name != null ? name.value : this.name),
        path: (path != null ? path.value : this.path),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class FontFile {
  const FontFile({
    this.name,
    this.size,
    this.dateCreated,
    this.dateModified,
  });

  factory FontFile.fromJson(Map<String, dynamic> json) =>
      _$FontFileFromJson(json);

  static const toJsonFactory = _$FontFileToJson;
  Map<String, dynamic> toJson() => _$FontFileToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Size')
  final int? size;
  @JsonKey(name: 'DateCreated')
  final DateTime? dateCreated;
  @JsonKey(name: 'DateModified')
  final DateTime? dateModified;
  static const fromJsonFactory = _$FontFileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FontFile &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.dateCreated, dateCreated) ||
                const DeepCollectionEquality()
                    .equals(other.dateCreated, dateCreated)) &&
            (identical(other.dateModified, dateModified) ||
                const DeepCollectionEquality()
                    .equals(other.dateModified, dateModified)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(dateCreated) ^
      const DeepCollectionEquality().hash(dateModified) ^
      runtimeType.hashCode;
}

extension $FontFileExtension on FontFile {
  FontFile copyWith(
      {String? name,
      int? size,
      DateTime? dateCreated,
      DateTime? dateModified}) {
    return FontFile(
        name: name ?? this.name,
        size: size ?? this.size,
        dateCreated: dateCreated ?? this.dateCreated,
        dateModified: dateModified ?? this.dateModified);
  }

  FontFile copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<int?>? size,
      Wrapped<DateTime?>? dateCreated,
      Wrapped<DateTime?>? dateModified}) {
    return FontFile(
        name: (name != null ? name.value : this.name),
        size: (size != null ? size.value : this.size),
        dateCreated:
            (dateCreated != null ? dateCreated.value : this.dateCreated),
        dateModified:
            (dateModified != null ? dateModified.value : this.dateModified));
  }
}

@JsonSerializable(explicitToJson: true)
class ForceKeepAliveMessage {
  const ForceKeepAliveMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory ForceKeepAliveMessage.fromJson(Map<String, dynamic> json) =>
      _$ForceKeepAliveMessageFromJson(json);

  static const toJsonFactory = _$ForceKeepAliveMessageToJson;
  Map<String, dynamic> toJson() => _$ForceKeepAliveMessageToJson(this);

  @JsonKey(name: 'Data')
  final int? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.forcekeepalive);

  static const fromJsonFactory = _$ForceKeepAliveMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForceKeepAliveMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $ForceKeepAliveMessageExtension on ForceKeepAliveMessage {
  ForceKeepAliveMessage copyWith(
      {int? data, String? messageId, enums.SessionMessageType? messageType}) {
    return ForceKeepAliveMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  ForceKeepAliveMessage copyWithWrapped(
      {Wrapped<int?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return ForceKeepAliveMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class ForgotPasswordDto {
  const ForgotPasswordDto({
    required this.enteredUsername,
  });

  factory ForgotPasswordDto.fromJson(Map<String, dynamic> json) =>
      _$ForgotPasswordDtoFromJson(json);

  static const toJsonFactory = _$ForgotPasswordDtoToJson;
  Map<String, dynamic> toJson() => _$ForgotPasswordDtoToJson(this);

  @JsonKey(name: 'EnteredUsername')
  final String enteredUsername;
  static const fromJsonFactory = _$ForgotPasswordDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForgotPasswordDto &&
            (identical(other.enteredUsername, enteredUsername) ||
                const DeepCollectionEquality()
                    .equals(other.enteredUsername, enteredUsername)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enteredUsername) ^
      runtimeType.hashCode;
}

extension $ForgotPasswordDtoExtension on ForgotPasswordDto {
  ForgotPasswordDto copyWith({String? enteredUsername}) {
    return ForgotPasswordDto(
        enteredUsername: enteredUsername ?? this.enteredUsername);
  }

  ForgotPasswordDto copyWithWrapped({Wrapped<String>? enteredUsername}) {
    return ForgotPasswordDto(
        enteredUsername: (enteredUsername != null
            ? enteredUsername.value
            : this.enteredUsername));
  }
}

@JsonSerializable(explicitToJson: true)
class ForgotPasswordPinDto {
  const ForgotPasswordPinDto({
    required this.pin,
  });

  factory ForgotPasswordPinDto.fromJson(Map<String, dynamic> json) =>
      _$ForgotPasswordPinDtoFromJson(json);

  static const toJsonFactory = _$ForgotPasswordPinDtoToJson;
  Map<String, dynamic> toJson() => _$ForgotPasswordPinDtoToJson(this);

  @JsonKey(name: 'Pin')
  final String pin;
  static const fromJsonFactory = _$ForgotPasswordPinDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForgotPasswordPinDto &&
            (identical(other.pin, pin) ||
                const DeepCollectionEquality().equals(other.pin, pin)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pin) ^ runtimeType.hashCode;
}

extension $ForgotPasswordPinDtoExtension on ForgotPasswordPinDto {
  ForgotPasswordPinDto copyWith({String? pin}) {
    return ForgotPasswordPinDto(pin: pin ?? this.pin);
  }

  ForgotPasswordPinDto copyWithWrapped({Wrapped<String>? pin}) {
    return ForgotPasswordPinDto(pin: (pin != null ? pin.value : this.pin));
  }
}

@JsonSerializable(explicitToJson: true)
class ForgotPasswordResult {
  const ForgotPasswordResult({
    this.action,
    this.pinFile,
    this.pinExpirationDate,
  });

  factory ForgotPasswordResult.fromJson(Map<String, dynamic> json) =>
      _$ForgotPasswordResultFromJson(json);

  static const toJsonFactory = _$ForgotPasswordResultToJson;
  Map<String, dynamic> toJson() => _$ForgotPasswordResultToJson(this);

  @JsonKey(
    name: 'Action',
    toJson: forgotPasswordActionNullableToJson,
    fromJson: forgotPasswordActionNullableFromJson,
  )
  final enums.ForgotPasswordAction? action;
  @JsonKey(name: 'PinFile')
  final String? pinFile;
  @JsonKey(name: 'PinExpirationDate')
  final DateTime? pinExpirationDate;
  static const fromJsonFactory = _$ForgotPasswordResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForgotPasswordResult &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)) &&
            (identical(other.pinFile, pinFile) ||
                const DeepCollectionEquality()
                    .equals(other.pinFile, pinFile)) &&
            (identical(other.pinExpirationDate, pinExpirationDate) ||
                const DeepCollectionEquality()
                    .equals(other.pinExpirationDate, pinExpirationDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(action) ^
      const DeepCollectionEquality().hash(pinFile) ^
      const DeepCollectionEquality().hash(pinExpirationDate) ^
      runtimeType.hashCode;
}

extension $ForgotPasswordResultExtension on ForgotPasswordResult {
  ForgotPasswordResult copyWith(
      {enums.ForgotPasswordAction? action,
      String? pinFile,
      DateTime? pinExpirationDate}) {
    return ForgotPasswordResult(
        action: action ?? this.action,
        pinFile: pinFile ?? this.pinFile,
        pinExpirationDate: pinExpirationDate ?? this.pinExpirationDate);
  }

  ForgotPasswordResult copyWithWrapped(
      {Wrapped<enums.ForgotPasswordAction?>? action,
      Wrapped<String?>? pinFile,
      Wrapped<DateTime?>? pinExpirationDate}) {
    return ForgotPasswordResult(
        action: (action != null ? action.value : this.action),
        pinFile: (pinFile != null ? pinFile.value : this.pinFile),
        pinExpirationDate: (pinExpirationDate != null
            ? pinExpirationDate.value
            : this.pinExpirationDate));
  }
}

@JsonSerializable(explicitToJson: true)
class GeneralCommand {
  const GeneralCommand({
    this.name,
    this.controllingUserId,
    this.arguments,
  });

  factory GeneralCommand.fromJson(Map<String, dynamic> json) =>
      _$GeneralCommandFromJson(json);

  static const toJsonFactory = _$GeneralCommandToJson;
  Map<String, dynamic> toJson() => _$GeneralCommandToJson(this);

  @JsonKey(
    name: 'Name',
    toJson: generalCommandTypeNullableToJson,
    fromJson: generalCommandTypeNullableFromJson,
  )
  final enums.GeneralCommandType? name;
  @JsonKey(name: 'ControllingUserId')
  final String? controllingUserId;
  @JsonKey(name: 'Arguments')
  final Map<String, dynamic>? arguments;
  static const fromJsonFactory = _$GeneralCommandFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeneralCommand &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.controllingUserId, controllingUserId) ||
                const DeepCollectionEquality()
                    .equals(other.controllingUserId, controllingUserId)) &&
            (identical(other.arguments, arguments) ||
                const DeepCollectionEquality()
                    .equals(other.arguments, arguments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(controllingUserId) ^
      const DeepCollectionEquality().hash(arguments) ^
      runtimeType.hashCode;
}

extension $GeneralCommandExtension on GeneralCommand {
  GeneralCommand copyWith(
      {enums.GeneralCommandType? name,
      String? controllingUserId,
      Map<String, dynamic>? arguments}) {
    return GeneralCommand(
        name: name ?? this.name,
        controllingUserId: controllingUserId ?? this.controllingUserId,
        arguments: arguments ?? this.arguments);
  }

  GeneralCommand copyWithWrapped(
      {Wrapped<enums.GeneralCommandType?>? name,
      Wrapped<String?>? controllingUserId,
      Wrapped<Map<String, dynamic>?>? arguments}) {
    return GeneralCommand(
        name: (name != null ? name.value : this.name),
        controllingUserId: (controllingUserId != null
            ? controllingUserId.value
            : this.controllingUserId),
        arguments: (arguments != null ? arguments.value : this.arguments));
  }
}

@JsonSerializable(explicitToJson: true)
class GeneralCommandMessage {
  const GeneralCommandMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory GeneralCommandMessage.fromJson(Map<String, dynamic> json) =>
      _$GeneralCommandMessageFromJson(json);

  static const toJsonFactory = _$GeneralCommandMessageToJson;
  Map<String, dynamic> toJson() => _$GeneralCommandMessageToJson(this);

  @JsonKey(name: 'Data')
  final GeneralCommand? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.generalcommand);

  static const fromJsonFactory = _$GeneralCommandMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GeneralCommandMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $GeneralCommandMessageExtension on GeneralCommandMessage {
  GeneralCommandMessage copyWith(
      {GeneralCommand? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return GeneralCommandMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  GeneralCommandMessage copyWithWrapped(
      {Wrapped<GeneralCommand?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return GeneralCommandMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class GetProgramsDto {
  const GetProgramsDto({
    this.channelIds,
    this.userId,
    this.minStartDate,
    this.hasAired,
    this.isAiring,
    this.maxStartDate,
    this.minEndDate,
    this.maxEndDate,
    this.isMovie,
    this.isSeries,
    this.isNews,
    this.isKids,
    this.isSports,
    this.startIndex,
    this.limit,
    this.sortBy,
    this.sortOrder,
    this.genres,
    this.genreIds,
    this.enableImages,
    this.enableTotalRecordCount,
    this.imageTypeLimit,
    this.enableImageTypes,
    this.enableUserData,
    this.seriesTimerId,
    this.librarySeriesId,
    this.fields,
  });

  factory GetProgramsDto.fromJson(Map<String, dynamic> json) =>
      _$GetProgramsDtoFromJson(json);

  static const toJsonFactory = _$GetProgramsDtoToJson;
  Map<String, dynamic> toJson() => _$GetProgramsDtoToJson(this);

  @JsonKey(name: 'ChannelIds', defaultValue: <String>[])
  final List<String>? channelIds;
  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'MinStartDate')
  final DateTime? minStartDate;
  @JsonKey(name: 'HasAired')
  final bool? hasAired;
  @JsonKey(name: 'IsAiring')
  final bool? isAiring;
  @JsonKey(name: 'MaxStartDate')
  final DateTime? maxStartDate;
  @JsonKey(name: 'MinEndDate')
  final DateTime? minEndDate;
  @JsonKey(name: 'MaxEndDate')
  final DateTime? maxEndDate;
  @JsonKey(name: 'IsMovie')
  final bool? isMovie;
  @JsonKey(name: 'IsSeries')
  final bool? isSeries;
  @JsonKey(name: 'IsNews')
  final bool? isNews;
  @JsonKey(name: 'IsKids')
  final bool? isKids;
  @JsonKey(name: 'IsSports')
  final bool? isSports;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  @JsonKey(name: 'Limit')
  final int? limit;
  @JsonKey(
    name: 'SortBy',
    toJson: itemSortByListToJson,
    fromJson: itemSortByListFromJson,
  )
  final List<enums.ItemSortBy>? sortBy;
  @JsonKey(
    name: 'SortOrder',
    toJson: sortOrderListToJson,
    fromJson: sortOrderListFromJson,
  )
  final List<enums.SortOrder>? sortOrder;
  @JsonKey(name: 'Genres', defaultValue: <String>[])
  final List<String>? genres;
  @JsonKey(name: 'GenreIds', defaultValue: <String>[])
  final List<String>? genreIds;
  @JsonKey(name: 'EnableImages')
  final bool? enableImages;
  @JsonKey(name: 'EnableTotalRecordCount', defaultValue: true)
  final bool? enableTotalRecordCount;
  @JsonKey(name: 'ImageTypeLimit')
  final int? imageTypeLimit;
  @JsonKey(
    name: 'EnableImageTypes',
    toJson: imageTypeListToJson,
    fromJson: imageTypeListFromJson,
  )
  final List<enums.ImageType>? enableImageTypes;
  @JsonKey(name: 'EnableUserData')
  final bool? enableUserData;
  @JsonKey(name: 'SeriesTimerId')
  final String? seriesTimerId;
  @JsonKey(name: 'LibrarySeriesId')
  final String? librarySeriesId;
  @JsonKey(
    name: 'Fields',
    toJson: itemFieldsListToJson,
    fromJson: itemFieldsListFromJson,
  )
  final List<enums.ItemFields>? fields;
  static const fromJsonFactory = _$GetProgramsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetProgramsDto &&
            (identical(other.channelIds, channelIds) ||
                const DeepCollectionEquality()
                    .equals(other.channelIds, channelIds)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.minStartDate, minStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.minStartDate, minStartDate)) &&
            (identical(other.hasAired, hasAired) ||
                const DeepCollectionEquality()
                    .equals(other.hasAired, hasAired)) &&
            (identical(other.isAiring, isAiring) ||
                const DeepCollectionEquality()
                    .equals(other.isAiring, isAiring)) &&
            (identical(other.maxStartDate, maxStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.maxStartDate, maxStartDate)) &&
            (identical(other.minEndDate, minEndDate) ||
                const DeepCollectionEquality()
                    .equals(other.minEndDate, minEndDate)) &&
            (identical(other.maxEndDate, maxEndDate) ||
                const DeepCollectionEquality()
                    .equals(other.maxEndDate, maxEndDate)) &&
            (identical(other.isMovie, isMovie) ||
                const DeepCollectionEquality()
                    .equals(other.isMovie, isMovie)) &&
            (identical(other.isSeries, isSeries) ||
                const DeepCollectionEquality()
                    .equals(other.isSeries, isSeries)) &&
            (identical(other.isNews, isNews) ||
                const DeepCollectionEquality().equals(other.isNews, isNews)) &&
            (identical(other.isKids, isKids) ||
                const DeepCollectionEquality().equals(other.isKids, isKids)) &&
            (identical(other.isSports, isSports) ||
                const DeepCollectionEquality()
                    .equals(other.isSports, isSports)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)) &&
            (identical(other.limit, limit) ||
                const DeepCollectionEquality().equals(other.limit, limit)) &&
            (identical(other.sortBy, sortBy) ||
                const DeepCollectionEquality().equals(other.sortBy, sortBy)) &&
            (identical(other.sortOrder, sortOrder) ||
                const DeepCollectionEquality()
                    .equals(other.sortOrder, sortOrder)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.genreIds, genreIds) ||
                const DeepCollectionEquality()
                    .equals(other.genreIds, genreIds)) &&
            (identical(other.enableImages, enableImages) ||
                const DeepCollectionEquality()
                    .equals(other.enableImages, enableImages)) &&
            (identical(other.enableTotalRecordCount, enableTotalRecordCount) ||
                const DeepCollectionEquality().equals(
                    other.enableTotalRecordCount, enableTotalRecordCount)) &&
            (identical(other.imageTypeLimit, imageTypeLimit) ||
                const DeepCollectionEquality()
                    .equals(other.imageTypeLimit, imageTypeLimit)) &&
            (identical(other.enableImageTypes, enableImageTypes) ||
                const DeepCollectionEquality()
                    .equals(other.enableImageTypes, enableImageTypes)) &&
            (identical(other.enableUserData, enableUserData) ||
                const DeepCollectionEquality()
                    .equals(other.enableUserData, enableUserData)) &&
            (identical(other.seriesTimerId, seriesTimerId) ||
                const DeepCollectionEquality().equals(other.seriesTimerId, seriesTimerId)) &&
            (identical(other.librarySeriesId, librarySeriesId) || const DeepCollectionEquality().equals(other.librarySeriesId, librarySeriesId)) &&
            (identical(other.fields, fields) || const DeepCollectionEquality().equals(other.fields, fields)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(channelIds) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(minStartDate) ^
      const DeepCollectionEquality().hash(hasAired) ^
      const DeepCollectionEquality().hash(isAiring) ^
      const DeepCollectionEquality().hash(maxStartDate) ^
      const DeepCollectionEquality().hash(minEndDate) ^
      const DeepCollectionEquality().hash(maxEndDate) ^
      const DeepCollectionEquality().hash(isMovie) ^
      const DeepCollectionEquality().hash(isSeries) ^
      const DeepCollectionEquality().hash(isNews) ^
      const DeepCollectionEquality().hash(isKids) ^
      const DeepCollectionEquality().hash(isSports) ^
      const DeepCollectionEquality().hash(startIndex) ^
      const DeepCollectionEquality().hash(limit) ^
      const DeepCollectionEquality().hash(sortBy) ^
      const DeepCollectionEquality().hash(sortOrder) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(genreIds) ^
      const DeepCollectionEquality().hash(enableImages) ^
      const DeepCollectionEquality().hash(enableTotalRecordCount) ^
      const DeepCollectionEquality().hash(imageTypeLimit) ^
      const DeepCollectionEquality().hash(enableImageTypes) ^
      const DeepCollectionEquality().hash(enableUserData) ^
      const DeepCollectionEquality().hash(seriesTimerId) ^
      const DeepCollectionEquality().hash(librarySeriesId) ^
      const DeepCollectionEquality().hash(fields) ^
      runtimeType.hashCode;
}

extension $GetProgramsDtoExtension on GetProgramsDto {
  GetProgramsDto copyWith(
      {List<String>? channelIds,
      String? userId,
      DateTime? minStartDate,
      bool? hasAired,
      bool? isAiring,
      DateTime? maxStartDate,
      DateTime? minEndDate,
      DateTime? maxEndDate,
      bool? isMovie,
      bool? isSeries,
      bool? isNews,
      bool? isKids,
      bool? isSports,
      int? startIndex,
      int? limit,
      List<enums.ItemSortBy>? sortBy,
      List<enums.SortOrder>? sortOrder,
      List<String>? genres,
      List<String>? genreIds,
      bool? enableImages,
      bool? enableTotalRecordCount,
      int? imageTypeLimit,
      List<enums.ImageType>? enableImageTypes,
      bool? enableUserData,
      String? seriesTimerId,
      String? librarySeriesId,
      List<enums.ItemFields>? fields}) {
    return GetProgramsDto(
        channelIds: channelIds ?? this.channelIds,
        userId: userId ?? this.userId,
        minStartDate: minStartDate ?? this.minStartDate,
        hasAired: hasAired ?? this.hasAired,
        isAiring: isAiring ?? this.isAiring,
        maxStartDate: maxStartDate ?? this.maxStartDate,
        minEndDate: minEndDate ?? this.minEndDate,
        maxEndDate: maxEndDate ?? this.maxEndDate,
        isMovie: isMovie ?? this.isMovie,
        isSeries: isSeries ?? this.isSeries,
        isNews: isNews ?? this.isNews,
        isKids: isKids ?? this.isKids,
        isSports: isSports ?? this.isSports,
        startIndex: startIndex ?? this.startIndex,
        limit: limit ?? this.limit,
        sortBy: sortBy ?? this.sortBy,
        sortOrder: sortOrder ?? this.sortOrder,
        genres: genres ?? this.genres,
        genreIds: genreIds ?? this.genreIds,
        enableImages: enableImages ?? this.enableImages,
        enableTotalRecordCount:
            enableTotalRecordCount ?? this.enableTotalRecordCount,
        imageTypeLimit: imageTypeLimit ?? this.imageTypeLimit,
        enableImageTypes: enableImageTypes ?? this.enableImageTypes,
        enableUserData: enableUserData ?? this.enableUserData,
        seriesTimerId: seriesTimerId ?? this.seriesTimerId,
        librarySeriesId: librarySeriesId ?? this.librarySeriesId,
        fields: fields ?? this.fields);
  }

  GetProgramsDto copyWithWrapped(
      {Wrapped<List<String>?>? channelIds,
      Wrapped<String?>? userId,
      Wrapped<DateTime?>? minStartDate,
      Wrapped<bool?>? hasAired,
      Wrapped<bool?>? isAiring,
      Wrapped<DateTime?>? maxStartDate,
      Wrapped<DateTime?>? minEndDate,
      Wrapped<DateTime?>? maxEndDate,
      Wrapped<bool?>? isMovie,
      Wrapped<bool?>? isSeries,
      Wrapped<bool?>? isNews,
      Wrapped<bool?>? isKids,
      Wrapped<bool?>? isSports,
      Wrapped<int?>? startIndex,
      Wrapped<int?>? limit,
      Wrapped<List<enums.ItemSortBy>?>? sortBy,
      Wrapped<List<enums.SortOrder>?>? sortOrder,
      Wrapped<List<String>?>? genres,
      Wrapped<List<String>?>? genreIds,
      Wrapped<bool?>? enableImages,
      Wrapped<bool?>? enableTotalRecordCount,
      Wrapped<int?>? imageTypeLimit,
      Wrapped<List<enums.ImageType>?>? enableImageTypes,
      Wrapped<bool?>? enableUserData,
      Wrapped<String?>? seriesTimerId,
      Wrapped<String?>? librarySeriesId,
      Wrapped<List<enums.ItemFields>?>? fields}) {
    return GetProgramsDto(
        channelIds: (channelIds != null ? channelIds.value : this.channelIds),
        userId: (userId != null ? userId.value : this.userId),
        minStartDate:
            (minStartDate != null ? minStartDate.value : this.minStartDate),
        hasAired: (hasAired != null ? hasAired.value : this.hasAired),
        isAiring: (isAiring != null ? isAiring.value : this.isAiring),
        maxStartDate:
            (maxStartDate != null ? maxStartDate.value : this.maxStartDate),
        minEndDate: (minEndDate != null ? minEndDate.value : this.minEndDate),
        maxEndDate: (maxEndDate != null ? maxEndDate.value : this.maxEndDate),
        isMovie: (isMovie != null ? isMovie.value : this.isMovie),
        isSeries: (isSeries != null ? isSeries.value : this.isSeries),
        isNews: (isNews != null ? isNews.value : this.isNews),
        isKids: (isKids != null ? isKids.value : this.isKids),
        isSports: (isSports != null ? isSports.value : this.isSports),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex),
        limit: (limit != null ? limit.value : this.limit),
        sortBy: (sortBy != null ? sortBy.value : this.sortBy),
        sortOrder: (sortOrder != null ? sortOrder.value : this.sortOrder),
        genres: (genres != null ? genres.value : this.genres),
        genreIds: (genreIds != null ? genreIds.value : this.genreIds),
        enableImages:
            (enableImages != null ? enableImages.value : this.enableImages),
        enableTotalRecordCount: (enableTotalRecordCount != null
            ? enableTotalRecordCount.value
            : this.enableTotalRecordCount),
        imageTypeLimit: (imageTypeLimit != null
            ? imageTypeLimit.value
            : this.imageTypeLimit),
        enableImageTypes: (enableImageTypes != null
            ? enableImageTypes.value
            : this.enableImageTypes),
        enableUserData: (enableUserData != null
            ? enableUserData.value
            : this.enableUserData),
        seriesTimerId:
            (seriesTimerId != null ? seriesTimerId.value : this.seriesTimerId),
        librarySeriesId: (librarySeriesId != null
            ? librarySeriesId.value
            : this.librarySeriesId),
        fields: (fields != null ? fields.value : this.fields));
  }
}

@JsonSerializable(explicitToJson: true)
class GroupInfoDto {
  const GroupInfoDto({
    this.groupId,
    this.groupName,
    this.state,
    this.participants,
    this.lastUpdatedAt,
  });

  factory GroupInfoDto.fromJson(Map<String, dynamic> json) =>
      _$GroupInfoDtoFromJson(json);

  static const toJsonFactory = _$GroupInfoDtoToJson;
  Map<String, dynamic> toJson() => _$GroupInfoDtoToJson(this);

  @JsonKey(name: 'GroupId')
  final String? groupId;
  @JsonKey(name: 'GroupName')
  final String? groupName;
  @JsonKey(
    name: 'State',
    toJson: groupStateTypeNullableToJson,
    fromJson: groupStateTypeNullableFromJson,
  )
  final enums.GroupStateType? state;
  @JsonKey(name: 'Participants', defaultValue: <String>[])
  final List<String>? participants;
  @JsonKey(name: 'LastUpdatedAt')
  final DateTime? lastUpdatedAt;
  static const fromJsonFactory = _$GroupInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GroupInfoDto &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.groupName, groupName) ||
                const DeepCollectionEquality()
                    .equals(other.groupName, groupName)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.participants, participants) ||
                const DeepCollectionEquality()
                    .equals(other.participants, participants)) &&
            (identical(other.lastUpdatedAt, lastUpdatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.lastUpdatedAt, lastUpdatedAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(groupName) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(participants) ^
      const DeepCollectionEquality().hash(lastUpdatedAt) ^
      runtimeType.hashCode;
}

extension $GroupInfoDtoExtension on GroupInfoDto {
  GroupInfoDto copyWith(
      {String? groupId,
      String? groupName,
      enums.GroupStateType? state,
      List<String>? participants,
      DateTime? lastUpdatedAt}) {
    return GroupInfoDto(
        groupId: groupId ?? this.groupId,
        groupName: groupName ?? this.groupName,
        state: state ?? this.state,
        participants: participants ?? this.participants,
        lastUpdatedAt: lastUpdatedAt ?? this.lastUpdatedAt);
  }

  GroupInfoDto copyWithWrapped(
      {Wrapped<String?>? groupId,
      Wrapped<String?>? groupName,
      Wrapped<enums.GroupStateType?>? state,
      Wrapped<List<String>?>? participants,
      Wrapped<DateTime?>? lastUpdatedAt}) {
    return GroupInfoDto(
        groupId: (groupId != null ? groupId.value : this.groupId),
        groupName: (groupName != null ? groupName.value : this.groupName),
        state: (state != null ? state.value : this.state),
        participants:
            (participants != null ? participants.value : this.participants),
        lastUpdatedAt:
            (lastUpdatedAt != null ? lastUpdatedAt.value : this.lastUpdatedAt));
  }
}

@JsonSerializable(explicitToJson: true)
class GroupInfoDtoGroupUpdate {
  const GroupInfoDtoGroupUpdate({
    this.groupId,
    this.type,
    this.data,
  });

  factory GroupInfoDtoGroupUpdate.fromJson(Map<String, dynamic> json) =>
      _$GroupInfoDtoGroupUpdateFromJson(json);

  static const toJsonFactory = _$GroupInfoDtoGroupUpdateToJson;
  Map<String, dynamic> toJson() => _$GroupInfoDtoGroupUpdateToJson(this);

  @JsonKey(name: 'GroupId')
  final String? groupId;
  @JsonKey(
    name: 'Type',
    toJson: groupUpdateTypeNullableToJson,
    fromJson: groupUpdateTypeNullableFromJson,
  )
  final enums.GroupUpdateType? type;
  @JsonKey(name: 'Data')
  final GroupInfoDto? data;
  static const fromJsonFactory = _$GroupInfoDtoGroupUpdateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GroupInfoDtoGroupUpdate &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $GroupInfoDtoGroupUpdateExtension on GroupInfoDtoGroupUpdate {
  GroupInfoDtoGroupUpdate copyWith(
      {String? groupId, enums.GroupUpdateType? type, GroupInfoDto? data}) {
    return GroupInfoDtoGroupUpdate(
        groupId: groupId ?? this.groupId,
        type: type ?? this.type,
        data: data ?? this.data);
  }

  GroupInfoDtoGroupUpdate copyWithWrapped(
      {Wrapped<String?>? groupId,
      Wrapped<enums.GroupUpdateType?>? type,
      Wrapped<GroupInfoDto?>? data}) {
    return GroupInfoDtoGroupUpdate(
        groupId: (groupId != null ? groupId.value : this.groupId),
        type: (type != null ? type.value : this.type),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class GroupStateUpdate {
  const GroupStateUpdate({
    this.state,
    this.reason,
  });

  factory GroupStateUpdate.fromJson(Map<String, dynamic> json) =>
      _$GroupStateUpdateFromJson(json);

  static const toJsonFactory = _$GroupStateUpdateToJson;
  Map<String, dynamic> toJson() => _$GroupStateUpdateToJson(this);

  @JsonKey(
    name: 'State',
    toJson: groupStateTypeNullableToJson,
    fromJson: groupStateTypeNullableFromJson,
  )
  final enums.GroupStateType? state;
  @JsonKey(
    name: 'Reason',
    toJson: playbackRequestTypeNullableToJson,
    fromJson: playbackRequestTypeNullableFromJson,
  )
  final enums.PlaybackRequestType? reason;
  static const fromJsonFactory = _$GroupStateUpdateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GroupStateUpdate &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(reason) ^
      runtimeType.hashCode;
}

extension $GroupStateUpdateExtension on GroupStateUpdate {
  GroupStateUpdate copyWith(
      {enums.GroupStateType? state, enums.PlaybackRequestType? reason}) {
    return GroupStateUpdate(
        state: state ?? this.state, reason: reason ?? this.reason);
  }

  GroupStateUpdate copyWithWrapped(
      {Wrapped<enums.GroupStateType?>? state,
      Wrapped<enums.PlaybackRequestType?>? reason}) {
    return GroupStateUpdate(
        state: (state != null ? state.value : this.state),
        reason: (reason != null ? reason.value : this.reason));
  }
}

@JsonSerializable(explicitToJson: true)
class GroupStateUpdateGroupUpdate {
  const GroupStateUpdateGroupUpdate({
    this.groupId,
    this.type,
    this.data,
  });

  factory GroupStateUpdateGroupUpdate.fromJson(Map<String, dynamic> json) =>
      _$GroupStateUpdateGroupUpdateFromJson(json);

  static const toJsonFactory = _$GroupStateUpdateGroupUpdateToJson;
  Map<String, dynamic> toJson() => _$GroupStateUpdateGroupUpdateToJson(this);

  @JsonKey(name: 'GroupId')
  final String? groupId;
  @JsonKey(
    name: 'Type',
    toJson: groupUpdateTypeNullableToJson,
    fromJson: groupUpdateTypeNullableFromJson,
  )
  final enums.GroupUpdateType? type;
  @JsonKey(name: 'Data')
  final GroupStateUpdate? data;
  static const fromJsonFactory = _$GroupStateUpdateGroupUpdateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GroupStateUpdateGroupUpdate &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $GroupStateUpdateGroupUpdateExtension on GroupStateUpdateGroupUpdate {
  GroupStateUpdateGroupUpdate copyWith(
      {String? groupId, enums.GroupUpdateType? type, GroupStateUpdate? data}) {
    return GroupStateUpdateGroupUpdate(
        groupId: groupId ?? this.groupId,
        type: type ?? this.type,
        data: data ?? this.data);
  }

  GroupStateUpdateGroupUpdate copyWithWrapped(
      {Wrapped<String?>? groupId,
      Wrapped<enums.GroupUpdateType?>? type,
      Wrapped<GroupStateUpdate?>? data}) {
    return GroupStateUpdateGroupUpdate(
        groupId: (groupId != null ? groupId.value : this.groupId),
        type: (type != null ? type.value : this.type),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class GroupUpdate {
  const GroupUpdate({
    this.groupId,
    this.type,
  });

  factory GroupUpdate.fromJson(Map<String, dynamic> json) =>
      _$GroupUpdateFromJson(json);

  static const toJsonFactory = _$GroupUpdateToJson;
  Map<String, dynamic> toJson() => _$GroupUpdateToJson(this);

  @JsonKey(name: 'GroupId')
  final String? groupId;
  @JsonKey(
    name: 'Type',
    toJson: groupUpdateTypeNullableToJson,
    fromJson: groupUpdateTypeNullableFromJson,
  )
  final enums.GroupUpdateType? type;
  static const fromJsonFactory = _$GroupUpdateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GroupUpdate &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $GroupUpdateExtension on GroupUpdate {
  GroupUpdate copyWith({String? groupId, enums.GroupUpdateType? type}) {
    return GroupUpdate(
        groupId: groupId ?? this.groupId, type: type ?? this.type);
  }

  GroupUpdate copyWithWrapped(
      {Wrapped<String?>? groupId, Wrapped<enums.GroupUpdateType?>? type}) {
    return GroupUpdate(
        groupId: (groupId != null ? groupId.value : this.groupId),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class GuideInfo {
  const GuideInfo({
    this.startDate,
    this.endDate,
  });

  factory GuideInfo.fromJson(Map<String, dynamic> json) =>
      _$GuideInfoFromJson(json);

  static const toJsonFactory = _$GuideInfoToJson;
  Map<String, dynamic> toJson() => _$GuideInfoToJson(this);

  @JsonKey(name: 'StartDate')
  final DateTime? startDate;
  @JsonKey(name: 'EndDate')
  final DateTime? endDate;
  static const fromJsonFactory = _$GuideInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GuideInfo &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality().equals(other.endDate, endDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      runtimeType.hashCode;
}

extension $GuideInfoExtension on GuideInfo {
  GuideInfo copyWith({DateTime? startDate, DateTime? endDate}) {
    return GuideInfo(
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate);
  }

  GuideInfo copyWithWrapped(
      {Wrapped<DateTime?>? startDate, Wrapped<DateTime?>? endDate}) {
    return GuideInfo(
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate));
  }
}

@JsonSerializable(explicitToJson: true)
class IgnoreWaitRequestDto {
  const IgnoreWaitRequestDto({
    this.ignoreWait,
  });

  factory IgnoreWaitRequestDto.fromJson(Map<String, dynamic> json) =>
      _$IgnoreWaitRequestDtoFromJson(json);

  static const toJsonFactory = _$IgnoreWaitRequestDtoToJson;
  Map<String, dynamic> toJson() => _$IgnoreWaitRequestDtoToJson(this);

  @JsonKey(name: 'IgnoreWait')
  final bool? ignoreWait;
  static const fromJsonFactory = _$IgnoreWaitRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is IgnoreWaitRequestDto &&
            (identical(other.ignoreWait, ignoreWait) ||
                const DeepCollectionEquality()
                    .equals(other.ignoreWait, ignoreWait)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ignoreWait) ^ runtimeType.hashCode;
}

extension $IgnoreWaitRequestDtoExtension on IgnoreWaitRequestDto {
  IgnoreWaitRequestDto copyWith({bool? ignoreWait}) {
    return IgnoreWaitRequestDto(ignoreWait: ignoreWait ?? this.ignoreWait);
  }

  IgnoreWaitRequestDto copyWithWrapped({Wrapped<bool?>? ignoreWait}) {
    return IgnoreWaitRequestDto(
        ignoreWait: (ignoreWait != null ? ignoreWait.value : this.ignoreWait));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageInfo {
  const ImageInfo({
    this.imageType,
    this.imageIndex,
    this.imageTag,
    this.path,
    this.blurHash,
    this.height,
    this.width,
    this.size,
  });

  factory ImageInfo.fromJson(Map<String, dynamic> json) =>
      _$ImageInfoFromJson(json);

  static const toJsonFactory = _$ImageInfoToJson;
  Map<String, dynamic> toJson() => _$ImageInfoToJson(this);

  @JsonKey(
    name: 'ImageType',
    toJson: imageTypeNullableToJson,
    fromJson: imageTypeNullableFromJson,
  )
  final enums.ImageType? imageType;
  @JsonKey(name: 'ImageIndex')
  final int? imageIndex;
  @JsonKey(name: 'ImageTag')
  final String? imageTag;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'BlurHash')
  final String? blurHash;
  @JsonKey(name: 'Height')
  final int? height;
  @JsonKey(name: 'Width')
  final int? width;
  @JsonKey(name: 'Size')
  final int? size;
  static const fromJsonFactory = _$ImageInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageInfo &&
            (identical(other.imageType, imageType) ||
                const DeepCollectionEquality()
                    .equals(other.imageType, imageType)) &&
            (identical(other.imageIndex, imageIndex) ||
                const DeepCollectionEquality()
                    .equals(other.imageIndex, imageIndex)) &&
            (identical(other.imageTag, imageTag) ||
                const DeepCollectionEquality()
                    .equals(other.imageTag, imageTag)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.blurHash, blurHash) ||
                const DeepCollectionEquality()
                    .equals(other.blurHash, blurHash)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(imageType) ^
      const DeepCollectionEquality().hash(imageIndex) ^
      const DeepCollectionEquality().hash(imageTag) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(blurHash) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(size) ^
      runtimeType.hashCode;
}

extension $ImageInfoExtension on ImageInfo {
  ImageInfo copyWith(
      {enums.ImageType? imageType,
      int? imageIndex,
      String? imageTag,
      String? path,
      String? blurHash,
      int? height,
      int? width,
      int? size}) {
    return ImageInfo(
        imageType: imageType ?? this.imageType,
        imageIndex: imageIndex ?? this.imageIndex,
        imageTag: imageTag ?? this.imageTag,
        path: path ?? this.path,
        blurHash: blurHash ?? this.blurHash,
        height: height ?? this.height,
        width: width ?? this.width,
        size: size ?? this.size);
  }

  ImageInfo copyWithWrapped(
      {Wrapped<enums.ImageType?>? imageType,
      Wrapped<int?>? imageIndex,
      Wrapped<String?>? imageTag,
      Wrapped<String?>? path,
      Wrapped<String?>? blurHash,
      Wrapped<int?>? height,
      Wrapped<int?>? width,
      Wrapped<int?>? size}) {
    return ImageInfo(
        imageType: (imageType != null ? imageType.value : this.imageType),
        imageIndex: (imageIndex != null ? imageIndex.value : this.imageIndex),
        imageTag: (imageTag != null ? imageTag.value : this.imageTag),
        path: (path != null ? path.value : this.path),
        blurHash: (blurHash != null ? blurHash.value : this.blurHash),
        height: (height != null ? height.value : this.height),
        width: (width != null ? width.value : this.width),
        size: (size != null ? size.value : this.size));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageOption {
  const ImageOption({
    this.type,
    this.limit,
    this.minWidth,
  });

  factory ImageOption.fromJson(Map<String, dynamic> json) =>
      _$ImageOptionFromJson(json);

  static const toJsonFactory = _$ImageOptionToJson;
  Map<String, dynamic> toJson() => _$ImageOptionToJson(this);

  @JsonKey(
    name: 'Type',
    toJson: imageTypeNullableToJson,
    fromJson: imageTypeNullableFromJson,
  )
  final enums.ImageType? type;
  @JsonKey(name: 'Limit')
  final int? limit;
  @JsonKey(name: 'MinWidth')
  final int? minWidth;
  static const fromJsonFactory = _$ImageOptionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageOption &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.limit, limit) ||
                const DeepCollectionEquality().equals(other.limit, limit)) &&
            (identical(other.minWidth, minWidth) ||
                const DeepCollectionEquality()
                    .equals(other.minWidth, minWidth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(limit) ^
      const DeepCollectionEquality().hash(minWidth) ^
      runtimeType.hashCode;
}

extension $ImageOptionExtension on ImageOption {
  ImageOption copyWith({enums.ImageType? type, int? limit, int? minWidth}) {
    return ImageOption(
        type: type ?? this.type,
        limit: limit ?? this.limit,
        minWidth: minWidth ?? this.minWidth);
  }

  ImageOption copyWithWrapped(
      {Wrapped<enums.ImageType?>? type,
      Wrapped<int?>? limit,
      Wrapped<int?>? minWidth}) {
    return ImageOption(
        type: (type != null ? type.value : this.type),
        limit: (limit != null ? limit.value : this.limit),
        minWidth: (minWidth != null ? minWidth.value : this.minWidth));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageProviderInfo {
  const ImageProviderInfo({
    this.name,
    this.supportedImages,
  });

  factory ImageProviderInfo.fromJson(Map<String, dynamic> json) =>
      _$ImageProviderInfoFromJson(json);

  static const toJsonFactory = _$ImageProviderInfoToJson;
  Map<String, dynamic> toJson() => _$ImageProviderInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(
    name: 'SupportedImages',
    toJson: imageTypeListToJson,
    fromJson: imageTypeListFromJson,
  )
  final List<enums.ImageType>? supportedImages;
  static const fromJsonFactory = _$ImageProviderInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageProviderInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.supportedImages, supportedImages) ||
                const DeepCollectionEquality()
                    .equals(other.supportedImages, supportedImages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(supportedImages) ^
      runtimeType.hashCode;
}

extension $ImageProviderInfoExtension on ImageProviderInfo {
  ImageProviderInfo copyWith(
      {String? name, List<enums.ImageType>? supportedImages}) {
    return ImageProviderInfo(
        name: name ?? this.name,
        supportedImages: supportedImages ?? this.supportedImages);
  }

  ImageProviderInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<List<enums.ImageType>?>? supportedImages}) {
    return ImageProviderInfo(
        name: (name != null ? name.value : this.name),
        supportedImages: (supportedImages != null
            ? supportedImages.value
            : this.supportedImages));
  }
}

@JsonSerializable(explicitToJson: true)
class InboundKeepAliveMessage {
  const InboundKeepAliveMessage({
    this.messageType,
  });

  factory InboundKeepAliveMessage.fromJson(Map<String, dynamic> json) =>
      _$InboundKeepAliveMessageFromJson(json);

  static const toJsonFactory = _$InboundKeepAliveMessageToJson;
  Map<String, dynamic> toJson() => _$InboundKeepAliveMessageToJson(this);

  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.keepalive);

  static const fromJsonFactory = _$InboundKeepAliveMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InboundKeepAliveMessage &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(messageType) ^ runtimeType.hashCode;
}

extension $InboundKeepAliveMessageExtension on InboundKeepAliveMessage {
  InboundKeepAliveMessage copyWith({enums.SessionMessageType? messageType}) {
    return InboundKeepAliveMessage(
        messageType: messageType ?? this.messageType);
  }

  InboundKeepAliveMessage copyWithWrapped(
      {Wrapped<enums.SessionMessageType?>? messageType}) {
    return InboundKeepAliveMessage(
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class InboundWebSocketMessage {
  const InboundWebSocketMessage();

  factory InboundWebSocketMessage.fromJson(Map<String, dynamic> json) =>
      _$InboundWebSocketMessageFromJson(json);

  static const toJsonFactory = _$InboundWebSocketMessageToJson;
  Map<String, dynamic> toJson() => _$InboundWebSocketMessageToJson(this);

  static const fromJsonFactory = _$InboundWebSocketMessageFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class InstallationInfo {
  const InstallationInfo({
    this.guid,
    this.name,
    this.version,
    this.changelog,
    this.sourceUrl,
    this.checksum,
    this.packageInfo,
  });

  factory InstallationInfo.fromJson(Map<String, dynamic> json) =>
      _$InstallationInfoFromJson(json);

  static const toJsonFactory = _$InstallationInfoToJson;
  Map<String, dynamic> toJson() => _$InstallationInfoToJson(this);

  @JsonKey(name: 'Guid')
  final String? guid;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Version')
  final String? version;
  @JsonKey(name: 'Changelog')
  final String? changelog;
  @JsonKey(name: 'SourceUrl')
  final String? sourceUrl;
  @JsonKey(name: 'Checksum')
  final String? checksum;
  @JsonKey(name: 'PackageInfo')
  final PackageInfo? packageInfo;
  static const fromJsonFactory = _$InstallationInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InstallationInfo &&
            (identical(other.guid, guid) ||
                const DeepCollectionEquality().equals(other.guid, guid)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.changelog, changelog) ||
                const DeepCollectionEquality()
                    .equals(other.changelog, changelog)) &&
            (identical(other.sourceUrl, sourceUrl) ||
                const DeepCollectionEquality()
                    .equals(other.sourceUrl, sourceUrl)) &&
            (identical(other.checksum, checksum) ||
                const DeepCollectionEquality()
                    .equals(other.checksum, checksum)) &&
            (identical(other.packageInfo, packageInfo) ||
                const DeepCollectionEquality()
                    .equals(other.packageInfo, packageInfo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(guid) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(changelog) ^
      const DeepCollectionEquality().hash(sourceUrl) ^
      const DeepCollectionEquality().hash(checksum) ^
      const DeepCollectionEquality().hash(packageInfo) ^
      runtimeType.hashCode;
}

extension $InstallationInfoExtension on InstallationInfo {
  InstallationInfo copyWith(
      {String? guid,
      String? name,
      String? version,
      String? changelog,
      String? sourceUrl,
      String? checksum,
      PackageInfo? packageInfo}) {
    return InstallationInfo(
        guid: guid ?? this.guid,
        name: name ?? this.name,
        version: version ?? this.version,
        changelog: changelog ?? this.changelog,
        sourceUrl: sourceUrl ?? this.sourceUrl,
        checksum: checksum ?? this.checksum,
        packageInfo: packageInfo ?? this.packageInfo);
  }

  InstallationInfo copyWithWrapped(
      {Wrapped<String?>? guid,
      Wrapped<String?>? name,
      Wrapped<String?>? version,
      Wrapped<String?>? changelog,
      Wrapped<String?>? sourceUrl,
      Wrapped<String?>? checksum,
      Wrapped<PackageInfo?>? packageInfo}) {
    return InstallationInfo(
        guid: (guid != null ? guid.value : this.guid),
        name: (name != null ? name.value : this.name),
        version: (version != null ? version.value : this.version),
        changelog: (changelog != null ? changelog.value : this.changelog),
        sourceUrl: (sourceUrl != null ? sourceUrl.value : this.sourceUrl),
        checksum: (checksum != null ? checksum.value : this.checksum),
        packageInfo:
            (packageInfo != null ? packageInfo.value : this.packageInfo));
  }
}

@JsonSerializable(explicitToJson: true)
class IPlugin {
  const IPlugin({
    this.name,
    this.description,
    this.id,
    this.version,
    this.assemblyFilePath,
    this.canUninstall,
    this.dataFolderPath,
  });

  factory IPlugin.fromJson(Map<String, dynamic> json) =>
      _$IPluginFromJson(json);

  static const toJsonFactory = _$IPluginToJson;
  Map<String, dynamic> toJson() => _$IPluginToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Description')
  final String? description;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Version')
  final String? version;
  @JsonKey(name: 'AssemblyFilePath')
  final String? assemblyFilePath;
  @JsonKey(name: 'CanUninstall')
  final bool? canUninstall;
  @JsonKey(name: 'DataFolderPath')
  final String? dataFolderPath;
  static const fromJsonFactory = _$IPluginFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is IPlugin &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.assemblyFilePath, assemblyFilePath) ||
                const DeepCollectionEquality()
                    .equals(other.assemblyFilePath, assemblyFilePath)) &&
            (identical(other.canUninstall, canUninstall) ||
                const DeepCollectionEquality()
                    .equals(other.canUninstall, canUninstall)) &&
            (identical(other.dataFolderPath, dataFolderPath) ||
                const DeepCollectionEquality()
                    .equals(other.dataFolderPath, dataFolderPath)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(assemblyFilePath) ^
      const DeepCollectionEquality().hash(canUninstall) ^
      const DeepCollectionEquality().hash(dataFolderPath) ^
      runtimeType.hashCode;
}

extension $IPluginExtension on IPlugin {
  IPlugin copyWith(
      {String? name,
      String? description,
      String? id,
      String? version,
      String? assemblyFilePath,
      bool? canUninstall,
      String? dataFolderPath}) {
    return IPlugin(
        name: name ?? this.name,
        description: description ?? this.description,
        id: id ?? this.id,
        version: version ?? this.version,
        assemblyFilePath: assemblyFilePath ?? this.assemblyFilePath,
        canUninstall: canUninstall ?? this.canUninstall,
        dataFolderPath: dataFolderPath ?? this.dataFolderPath);
  }

  IPlugin copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? id,
      Wrapped<String?>? version,
      Wrapped<String?>? assemblyFilePath,
      Wrapped<bool?>? canUninstall,
      Wrapped<String?>? dataFolderPath}) {
    return IPlugin(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        id: (id != null ? id.value : this.id),
        version: (version != null ? version.value : this.version),
        assemblyFilePath: (assemblyFilePath != null
            ? assemblyFilePath.value
            : this.assemblyFilePath),
        canUninstall:
            (canUninstall != null ? canUninstall.value : this.canUninstall),
        dataFolderPath: (dataFolderPath != null
            ? dataFolderPath.value
            : this.dataFolderPath));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemCounts {
  const ItemCounts({
    this.movieCount,
    this.seriesCount,
    this.episodeCount,
    this.artistCount,
    this.programCount,
    this.trailerCount,
    this.songCount,
    this.albumCount,
    this.musicVideoCount,
    this.boxSetCount,
    this.bookCount,
    this.itemCount,
  });

  factory ItemCounts.fromJson(Map<String, dynamic> json) =>
      _$ItemCountsFromJson(json);

  static const toJsonFactory = _$ItemCountsToJson;
  Map<String, dynamic> toJson() => _$ItemCountsToJson(this);

  @JsonKey(name: 'MovieCount')
  final int? movieCount;
  @JsonKey(name: 'SeriesCount')
  final int? seriesCount;
  @JsonKey(name: 'EpisodeCount')
  final int? episodeCount;
  @JsonKey(name: 'ArtistCount')
  final int? artistCount;
  @JsonKey(name: 'ProgramCount')
  final int? programCount;
  @JsonKey(name: 'TrailerCount')
  final int? trailerCount;
  @JsonKey(name: 'SongCount')
  final int? songCount;
  @JsonKey(name: 'AlbumCount')
  final int? albumCount;
  @JsonKey(name: 'MusicVideoCount')
  final int? musicVideoCount;
  @JsonKey(name: 'BoxSetCount')
  final int? boxSetCount;
  @JsonKey(name: 'BookCount')
  final int? bookCount;
  @JsonKey(name: 'ItemCount')
  final int? itemCount;
  static const fromJsonFactory = _$ItemCountsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ItemCounts &&
            (identical(other.movieCount, movieCount) ||
                const DeepCollectionEquality()
                    .equals(other.movieCount, movieCount)) &&
            (identical(other.seriesCount, seriesCount) ||
                const DeepCollectionEquality()
                    .equals(other.seriesCount, seriesCount)) &&
            (identical(other.episodeCount, episodeCount) ||
                const DeepCollectionEquality()
                    .equals(other.episodeCount, episodeCount)) &&
            (identical(other.artistCount, artistCount) ||
                const DeepCollectionEquality()
                    .equals(other.artistCount, artistCount)) &&
            (identical(other.programCount, programCount) ||
                const DeepCollectionEquality()
                    .equals(other.programCount, programCount)) &&
            (identical(other.trailerCount, trailerCount) ||
                const DeepCollectionEquality()
                    .equals(other.trailerCount, trailerCount)) &&
            (identical(other.songCount, songCount) ||
                const DeepCollectionEquality()
                    .equals(other.songCount, songCount)) &&
            (identical(other.albumCount, albumCount) ||
                const DeepCollectionEquality()
                    .equals(other.albumCount, albumCount)) &&
            (identical(other.musicVideoCount, musicVideoCount) ||
                const DeepCollectionEquality()
                    .equals(other.musicVideoCount, musicVideoCount)) &&
            (identical(other.boxSetCount, boxSetCount) ||
                const DeepCollectionEquality()
                    .equals(other.boxSetCount, boxSetCount)) &&
            (identical(other.bookCount, bookCount) ||
                const DeepCollectionEquality()
                    .equals(other.bookCount, bookCount)) &&
            (identical(other.itemCount, itemCount) ||
                const DeepCollectionEquality()
                    .equals(other.itemCount, itemCount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(movieCount) ^
      const DeepCollectionEquality().hash(seriesCount) ^
      const DeepCollectionEquality().hash(episodeCount) ^
      const DeepCollectionEquality().hash(artistCount) ^
      const DeepCollectionEquality().hash(programCount) ^
      const DeepCollectionEquality().hash(trailerCount) ^
      const DeepCollectionEquality().hash(songCount) ^
      const DeepCollectionEquality().hash(albumCount) ^
      const DeepCollectionEquality().hash(musicVideoCount) ^
      const DeepCollectionEquality().hash(boxSetCount) ^
      const DeepCollectionEquality().hash(bookCount) ^
      const DeepCollectionEquality().hash(itemCount) ^
      runtimeType.hashCode;
}

extension $ItemCountsExtension on ItemCounts {
  ItemCounts copyWith(
      {int? movieCount,
      int? seriesCount,
      int? episodeCount,
      int? artistCount,
      int? programCount,
      int? trailerCount,
      int? songCount,
      int? albumCount,
      int? musicVideoCount,
      int? boxSetCount,
      int? bookCount,
      int? itemCount}) {
    return ItemCounts(
        movieCount: movieCount ?? this.movieCount,
        seriesCount: seriesCount ?? this.seriesCount,
        episodeCount: episodeCount ?? this.episodeCount,
        artistCount: artistCount ?? this.artistCount,
        programCount: programCount ?? this.programCount,
        trailerCount: trailerCount ?? this.trailerCount,
        songCount: songCount ?? this.songCount,
        albumCount: albumCount ?? this.albumCount,
        musicVideoCount: musicVideoCount ?? this.musicVideoCount,
        boxSetCount: boxSetCount ?? this.boxSetCount,
        bookCount: bookCount ?? this.bookCount,
        itemCount: itemCount ?? this.itemCount);
  }

  ItemCounts copyWithWrapped(
      {Wrapped<int?>? movieCount,
      Wrapped<int?>? seriesCount,
      Wrapped<int?>? episodeCount,
      Wrapped<int?>? artistCount,
      Wrapped<int?>? programCount,
      Wrapped<int?>? trailerCount,
      Wrapped<int?>? songCount,
      Wrapped<int?>? albumCount,
      Wrapped<int?>? musicVideoCount,
      Wrapped<int?>? boxSetCount,
      Wrapped<int?>? bookCount,
      Wrapped<int?>? itemCount}) {
    return ItemCounts(
        movieCount: (movieCount != null ? movieCount.value : this.movieCount),
        seriesCount:
            (seriesCount != null ? seriesCount.value : this.seriesCount),
        episodeCount:
            (episodeCount != null ? episodeCount.value : this.episodeCount),
        artistCount:
            (artistCount != null ? artistCount.value : this.artistCount),
        programCount:
            (programCount != null ? programCount.value : this.programCount),
        trailerCount:
            (trailerCount != null ? trailerCount.value : this.trailerCount),
        songCount: (songCount != null ? songCount.value : this.songCount),
        albumCount: (albumCount != null ? albumCount.value : this.albumCount),
        musicVideoCount: (musicVideoCount != null
            ? musicVideoCount.value
            : this.musicVideoCount),
        boxSetCount:
            (boxSetCount != null ? boxSetCount.value : this.boxSetCount),
        bookCount: (bookCount != null ? bookCount.value : this.bookCount),
        itemCount: (itemCount != null ? itemCount.value : this.itemCount));
  }
}

@JsonSerializable(explicitToJson: true)
class JoinGroupRequestDto {
  const JoinGroupRequestDto({
    this.groupId,
  });

  factory JoinGroupRequestDto.fromJson(Map<String, dynamic> json) =>
      _$JoinGroupRequestDtoFromJson(json);

  static const toJsonFactory = _$JoinGroupRequestDtoToJson;
  Map<String, dynamic> toJson() => _$JoinGroupRequestDtoToJson(this);

  @JsonKey(name: 'GroupId')
  final String? groupId;
  static const fromJsonFactory = _$JoinGroupRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is JoinGroupRequestDto &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality().equals(other.groupId, groupId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(groupId) ^ runtimeType.hashCode;
}

extension $JoinGroupRequestDtoExtension on JoinGroupRequestDto {
  JoinGroupRequestDto copyWith({String? groupId}) {
    return JoinGroupRequestDto(groupId: groupId ?? this.groupId);
  }

  JoinGroupRequestDto copyWithWrapped({Wrapped<String?>? groupId}) {
    return JoinGroupRequestDto(
        groupId: (groupId != null ? groupId.value : this.groupId));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryChangedMessage {
  const LibraryChangedMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory LibraryChangedMessage.fromJson(Map<String, dynamic> json) =>
      _$LibraryChangedMessageFromJson(json);

  static const toJsonFactory = _$LibraryChangedMessageToJson;
  Map<String, dynamic> toJson() => _$LibraryChangedMessageToJson(this);

  @JsonKey(name: 'Data')
  final LibraryUpdateInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.librarychanged);

  static const fromJsonFactory = _$LibraryChangedMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryChangedMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $LibraryChangedMessageExtension on LibraryChangedMessage {
  LibraryChangedMessage copyWith(
      {LibraryUpdateInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return LibraryChangedMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  LibraryChangedMessage copyWithWrapped(
      {Wrapped<LibraryUpdateInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return LibraryChangedMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryOptionInfoDto {
  const LibraryOptionInfoDto({
    this.name,
    this.defaultEnabled,
  });

  factory LibraryOptionInfoDto.fromJson(Map<String, dynamic> json) =>
      _$LibraryOptionInfoDtoFromJson(json);

  static const toJsonFactory = _$LibraryOptionInfoDtoToJson;
  Map<String, dynamic> toJson() => _$LibraryOptionInfoDtoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'DefaultEnabled')
  final bool? defaultEnabled;
  static const fromJsonFactory = _$LibraryOptionInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryOptionInfoDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.defaultEnabled, defaultEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.defaultEnabled, defaultEnabled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(defaultEnabled) ^
      runtimeType.hashCode;
}

extension $LibraryOptionInfoDtoExtension on LibraryOptionInfoDto {
  LibraryOptionInfoDto copyWith({String? name, bool? defaultEnabled}) {
    return LibraryOptionInfoDto(
        name: name ?? this.name,
        defaultEnabled: defaultEnabled ?? this.defaultEnabled);
  }

  LibraryOptionInfoDto copyWithWrapped(
      {Wrapped<String?>? name, Wrapped<bool?>? defaultEnabled}) {
    return LibraryOptionInfoDto(
        name: (name != null ? name.value : this.name),
        defaultEnabled: (defaultEnabled != null
            ? defaultEnabled.value
            : this.defaultEnabled));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryOptions {
  const LibraryOptions({
    this.enabled,
    this.enablePhotos,
    this.enableRealtimeMonitor,
    this.enableLUFSScan,
    this.enableChapterImageExtraction,
    this.extractChapterImagesDuringLibraryScan,
    this.enableTrickplayImageExtraction,
    this.extractTrickplayImagesDuringLibraryScan,
    this.pathInfos,
    this.saveLocalMetadata,
    this.enableInternetProviders,
    this.enableAutomaticSeriesGrouping,
    this.enableEmbeddedTitles,
    this.enableEmbeddedExtrasTitles,
    this.enableEmbeddedEpisodeInfos,
    this.automaticRefreshIntervalDays,
    this.preferredMetadataLanguage,
    this.metadataCountryCode,
    this.seasonZeroDisplayName,
    this.metadataSavers,
    this.disabledLocalMetadataReaders,
    this.localMetadataReaderOrder,
    this.disabledSubtitleFetchers,
    this.subtitleFetcherOrder,
    this.disabledMediaSegmentProviders,
    this.mediaSegmentProvideOrder,
    this.skipSubtitlesIfEmbeddedSubtitlesPresent,
    this.skipSubtitlesIfAudioTrackMatches,
    this.subtitleDownloadLanguages,
    this.requirePerfectSubtitleMatch,
    this.saveSubtitlesWithMedia,
    this.saveLyricsWithMedia,
    this.saveTrickplayWithMedia,
    this.disabledLyricFetchers,
    this.lyricFetcherOrder,
    this.preferNonstandardArtistsTag,
    this.useCustomTagDelimiters,
    this.customTagDelimiters,
    this.delimiterWhitelist,
    this.automaticallyAddToCollection,
    this.allowEmbeddedSubtitles,
    this.typeOptions,
  });

  factory LibraryOptions.fromJson(Map<String, dynamic> json) =>
      _$LibraryOptionsFromJson(json);

  static const toJsonFactory = _$LibraryOptionsToJson;
  Map<String, dynamic> toJson() => _$LibraryOptionsToJson(this);

  @JsonKey(name: 'Enabled')
  final bool? enabled;
  @JsonKey(name: 'EnablePhotos')
  final bool? enablePhotos;
  @JsonKey(name: 'EnableRealtimeMonitor')
  final bool? enableRealtimeMonitor;
  @JsonKey(name: 'EnableLUFSScan')
  final bool? enableLUFSScan;
  @JsonKey(name: 'EnableChapterImageExtraction')
  final bool? enableChapterImageExtraction;
  @JsonKey(name: 'ExtractChapterImagesDuringLibraryScan')
  final bool? extractChapterImagesDuringLibraryScan;
  @JsonKey(name: 'EnableTrickplayImageExtraction')
  final bool? enableTrickplayImageExtraction;
  @JsonKey(name: 'ExtractTrickplayImagesDuringLibraryScan')
  final bool? extractTrickplayImagesDuringLibraryScan;
  @JsonKey(name: 'PathInfos', defaultValue: <MediaPathInfo>[])
  final List<MediaPathInfo>? pathInfos;
  @JsonKey(name: 'SaveLocalMetadata')
  final bool? saveLocalMetadata;
  @JsonKey(name: 'EnableInternetProviders')
  @deprecated
  final bool? enableInternetProviders;
  @JsonKey(name: 'EnableAutomaticSeriesGrouping')
  final bool? enableAutomaticSeriesGrouping;
  @JsonKey(name: 'EnableEmbeddedTitles')
  final bool? enableEmbeddedTitles;
  @JsonKey(name: 'EnableEmbeddedExtrasTitles')
  final bool? enableEmbeddedExtrasTitles;
  @JsonKey(name: 'EnableEmbeddedEpisodeInfos')
  final bool? enableEmbeddedEpisodeInfos;
  @JsonKey(name: 'AutomaticRefreshIntervalDays')
  final int? automaticRefreshIntervalDays;
  @JsonKey(name: 'PreferredMetadataLanguage')
  final String? preferredMetadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'SeasonZeroDisplayName')
  final String? seasonZeroDisplayName;
  @JsonKey(name: 'MetadataSavers', defaultValue: <String>[])
  final List<String>? metadataSavers;
  @JsonKey(name: 'DisabledLocalMetadataReaders', defaultValue: <String>[])
  final List<String>? disabledLocalMetadataReaders;
  @JsonKey(name: 'LocalMetadataReaderOrder', defaultValue: <String>[])
  final List<String>? localMetadataReaderOrder;
  @JsonKey(name: 'DisabledSubtitleFetchers', defaultValue: <String>[])
  final List<String>? disabledSubtitleFetchers;
  @JsonKey(name: 'SubtitleFetcherOrder', defaultValue: <String>[])
  final List<String>? subtitleFetcherOrder;
  @JsonKey(name: 'DisabledMediaSegmentProviders', defaultValue: <String>[])
  final List<String>? disabledMediaSegmentProviders;
  @JsonKey(name: 'MediaSegmentProvideOrder', defaultValue: <String>[])
  final List<String>? mediaSegmentProvideOrder;
  @JsonKey(name: 'SkipSubtitlesIfEmbeddedSubtitlesPresent')
  final bool? skipSubtitlesIfEmbeddedSubtitlesPresent;
  @JsonKey(name: 'SkipSubtitlesIfAudioTrackMatches')
  final bool? skipSubtitlesIfAudioTrackMatches;
  @JsonKey(name: 'SubtitleDownloadLanguages', defaultValue: <String>[])
  final List<String>? subtitleDownloadLanguages;
  @JsonKey(name: 'RequirePerfectSubtitleMatch')
  final bool? requirePerfectSubtitleMatch;
  @JsonKey(name: 'SaveSubtitlesWithMedia')
  final bool? saveSubtitlesWithMedia;
  @JsonKey(name: 'SaveLyricsWithMedia', defaultValue: false)
  final bool? saveLyricsWithMedia;
  @JsonKey(name: 'SaveTrickplayWithMedia', defaultValue: false)
  final bool? saveTrickplayWithMedia;
  @JsonKey(name: 'DisabledLyricFetchers', defaultValue: <String>[])
  final List<String>? disabledLyricFetchers;
  @JsonKey(name: 'LyricFetcherOrder', defaultValue: <String>[])
  final List<String>? lyricFetcherOrder;
  @JsonKey(name: 'PreferNonstandardArtistsTag', defaultValue: false)
  final bool? preferNonstandardArtistsTag;
  @JsonKey(name: 'UseCustomTagDelimiters', defaultValue: false)
  final bool? useCustomTagDelimiters;
  @JsonKey(name: 'CustomTagDelimiters', defaultValue: <String>[])
  final List<String>? customTagDelimiters;
  @JsonKey(name: 'DelimiterWhitelist', defaultValue: <String>[])
  final List<String>? delimiterWhitelist;
  @JsonKey(name: 'AutomaticallyAddToCollection')
  final bool? automaticallyAddToCollection;
  @JsonKey(
    name: 'AllowEmbeddedSubtitles',
    toJson: embeddedSubtitleOptionsNullableToJson,
    fromJson: embeddedSubtitleOptionsNullableFromJson,
  )
  final enums.EmbeddedSubtitleOptions? allowEmbeddedSubtitles;
  @JsonKey(name: 'TypeOptions', defaultValue: <TypeOptions>[])
  final List<TypeOptions>? typeOptions;
  static const fromJsonFactory = _$LibraryOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryOptions &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality()
                    .equals(other.enabled, enabled)) &&
            (identical(other.enablePhotos, enablePhotos) ||
                const DeepCollectionEquality()
                    .equals(other.enablePhotos, enablePhotos)) &&
            (identical(other.enableRealtimeMonitor, enableRealtimeMonitor) ||
                const DeepCollectionEquality().equals(
                    other.enableRealtimeMonitor, enableRealtimeMonitor)) &&
            (identical(other.enableLUFSScan, enableLUFSScan) ||
                const DeepCollectionEquality()
                    .equals(other.enableLUFSScan, enableLUFSScan)) &&
            (identical(other.enableChapterImageExtraction, enableChapterImageExtraction) ||
                const DeepCollectionEquality().equals(
                    other.enableChapterImageExtraction,
                    enableChapterImageExtraction)) &&
            (identical(other.extractChapterImagesDuringLibraryScan, extractChapterImagesDuringLibraryScan) ||
                const DeepCollectionEquality().equals(
                    other.extractChapterImagesDuringLibraryScan,
                    extractChapterImagesDuringLibraryScan)) &&
            (identical(other.enableTrickplayImageExtraction, enableTrickplayImageExtraction) ||
                const DeepCollectionEquality().equals(
                    other.enableTrickplayImageExtraction,
                    enableTrickplayImageExtraction)) &&
            (identical(other.extractTrickplayImagesDuringLibraryScan, extractTrickplayImagesDuringLibraryScan) ||
                const DeepCollectionEquality().equals(
                    other.extractTrickplayImagesDuringLibraryScan,
                    extractTrickplayImagesDuringLibraryScan)) &&
            (identical(other.pathInfos, pathInfos) ||
                const DeepCollectionEquality()
                    .equals(other.pathInfos, pathInfos)) &&
            (identical(other.saveLocalMetadata, saveLocalMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.saveLocalMetadata, saveLocalMetadata)) &&
            (identical(other.enableInternetProviders, enableInternetProviders) ||
                const DeepCollectionEquality().equals(
                    other.enableInternetProviders, enableInternetProviders)) &&
            (identical(other.enableAutomaticSeriesGrouping, enableAutomaticSeriesGrouping) ||
                const DeepCollectionEquality()
                    .equals(other.enableAutomaticSeriesGrouping, enableAutomaticSeriesGrouping)) &&
            (identical(other.enableEmbeddedTitles, enableEmbeddedTitles) || const DeepCollectionEquality().equals(other.enableEmbeddedTitles, enableEmbeddedTitles)) &&
            (identical(other.enableEmbeddedExtrasTitles, enableEmbeddedExtrasTitles) || const DeepCollectionEquality().equals(other.enableEmbeddedExtrasTitles, enableEmbeddedExtrasTitles)) &&
            (identical(other.enableEmbeddedEpisodeInfos, enableEmbeddedEpisodeInfos) || const DeepCollectionEquality().equals(other.enableEmbeddedEpisodeInfos, enableEmbeddedEpisodeInfos)) &&
            (identical(other.automaticRefreshIntervalDays, automaticRefreshIntervalDays) || const DeepCollectionEquality().equals(other.automaticRefreshIntervalDays, automaticRefreshIntervalDays)) &&
            (identical(other.preferredMetadataLanguage, preferredMetadataLanguage) || const DeepCollectionEquality().equals(other.preferredMetadataLanguage, preferredMetadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) || const DeepCollectionEquality().equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.seasonZeroDisplayName, seasonZeroDisplayName) || const DeepCollectionEquality().equals(other.seasonZeroDisplayName, seasonZeroDisplayName)) &&
            (identical(other.metadataSavers, metadataSavers) || const DeepCollectionEquality().equals(other.metadataSavers, metadataSavers)) &&
            (identical(other.disabledLocalMetadataReaders, disabledLocalMetadataReaders) || const DeepCollectionEquality().equals(other.disabledLocalMetadataReaders, disabledLocalMetadataReaders)) &&
            (identical(other.localMetadataReaderOrder, localMetadataReaderOrder) || const DeepCollectionEquality().equals(other.localMetadataReaderOrder, localMetadataReaderOrder)) &&
            (identical(other.disabledSubtitleFetchers, disabledSubtitleFetchers) || const DeepCollectionEquality().equals(other.disabledSubtitleFetchers, disabledSubtitleFetchers)) &&
            (identical(other.subtitleFetcherOrder, subtitleFetcherOrder) || const DeepCollectionEquality().equals(other.subtitleFetcherOrder, subtitleFetcherOrder)) &&
            (identical(other.disabledMediaSegmentProviders, disabledMediaSegmentProviders) || const DeepCollectionEquality().equals(other.disabledMediaSegmentProviders, disabledMediaSegmentProviders)) &&
            (identical(other.mediaSegmentProvideOrder, mediaSegmentProvideOrder) || const DeepCollectionEquality().equals(other.mediaSegmentProvideOrder, mediaSegmentProvideOrder)) &&
            (identical(other.skipSubtitlesIfEmbeddedSubtitlesPresent, skipSubtitlesIfEmbeddedSubtitlesPresent) || const DeepCollectionEquality().equals(other.skipSubtitlesIfEmbeddedSubtitlesPresent, skipSubtitlesIfEmbeddedSubtitlesPresent)) &&
            (identical(other.skipSubtitlesIfAudioTrackMatches, skipSubtitlesIfAudioTrackMatches) || const DeepCollectionEquality().equals(other.skipSubtitlesIfAudioTrackMatches, skipSubtitlesIfAudioTrackMatches)) &&
            (identical(other.subtitleDownloadLanguages, subtitleDownloadLanguages) || const DeepCollectionEquality().equals(other.subtitleDownloadLanguages, subtitleDownloadLanguages)) &&
            (identical(other.requirePerfectSubtitleMatch, requirePerfectSubtitleMatch) || const DeepCollectionEquality().equals(other.requirePerfectSubtitleMatch, requirePerfectSubtitleMatch)) &&
            (identical(other.saveSubtitlesWithMedia, saveSubtitlesWithMedia) || const DeepCollectionEquality().equals(other.saveSubtitlesWithMedia, saveSubtitlesWithMedia)) &&
            (identical(other.saveLyricsWithMedia, saveLyricsWithMedia) || const DeepCollectionEquality().equals(other.saveLyricsWithMedia, saveLyricsWithMedia)) &&
            (identical(other.saveTrickplayWithMedia, saveTrickplayWithMedia) || const DeepCollectionEquality().equals(other.saveTrickplayWithMedia, saveTrickplayWithMedia)) &&
            (identical(other.disabledLyricFetchers, disabledLyricFetchers) || const DeepCollectionEquality().equals(other.disabledLyricFetchers, disabledLyricFetchers)) &&
            (identical(other.lyricFetcherOrder, lyricFetcherOrder) || const DeepCollectionEquality().equals(other.lyricFetcherOrder, lyricFetcherOrder)) &&
            (identical(other.preferNonstandardArtistsTag, preferNonstandardArtistsTag) || const DeepCollectionEquality().equals(other.preferNonstandardArtistsTag, preferNonstandardArtistsTag)) &&
            (identical(other.useCustomTagDelimiters, useCustomTagDelimiters) || const DeepCollectionEquality().equals(other.useCustomTagDelimiters, useCustomTagDelimiters)) &&
            (identical(other.customTagDelimiters, customTagDelimiters) || const DeepCollectionEquality().equals(other.customTagDelimiters, customTagDelimiters)) &&
            (identical(other.delimiterWhitelist, delimiterWhitelist) || const DeepCollectionEquality().equals(other.delimiterWhitelist, delimiterWhitelist)) &&
            (identical(other.automaticallyAddToCollection, automaticallyAddToCollection) || const DeepCollectionEquality().equals(other.automaticallyAddToCollection, automaticallyAddToCollection)) &&
            (identical(other.allowEmbeddedSubtitles, allowEmbeddedSubtitles) || const DeepCollectionEquality().equals(other.allowEmbeddedSubtitles, allowEmbeddedSubtitles)) &&
            (identical(other.typeOptions, typeOptions) || const DeepCollectionEquality().equals(other.typeOptions, typeOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enabled) ^
      const DeepCollectionEquality().hash(enablePhotos) ^
      const DeepCollectionEquality().hash(enableRealtimeMonitor) ^
      const DeepCollectionEquality().hash(enableLUFSScan) ^
      const DeepCollectionEquality().hash(enableChapterImageExtraction) ^
      const DeepCollectionEquality()
          .hash(extractChapterImagesDuringLibraryScan) ^
      const DeepCollectionEquality().hash(enableTrickplayImageExtraction) ^
      const DeepCollectionEquality()
          .hash(extractTrickplayImagesDuringLibraryScan) ^
      const DeepCollectionEquality().hash(pathInfos) ^
      const DeepCollectionEquality().hash(saveLocalMetadata) ^
      const DeepCollectionEquality().hash(enableInternetProviders) ^
      const DeepCollectionEquality().hash(enableAutomaticSeriesGrouping) ^
      const DeepCollectionEquality().hash(enableEmbeddedTitles) ^
      const DeepCollectionEquality().hash(enableEmbeddedExtrasTitles) ^
      const DeepCollectionEquality().hash(enableEmbeddedEpisodeInfos) ^
      const DeepCollectionEquality().hash(automaticRefreshIntervalDays) ^
      const DeepCollectionEquality().hash(preferredMetadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(seasonZeroDisplayName) ^
      const DeepCollectionEquality().hash(metadataSavers) ^
      const DeepCollectionEquality().hash(disabledLocalMetadataReaders) ^
      const DeepCollectionEquality().hash(localMetadataReaderOrder) ^
      const DeepCollectionEquality().hash(disabledSubtitleFetchers) ^
      const DeepCollectionEquality().hash(subtitleFetcherOrder) ^
      const DeepCollectionEquality().hash(disabledMediaSegmentProviders) ^
      const DeepCollectionEquality().hash(mediaSegmentProvideOrder) ^
      const DeepCollectionEquality()
          .hash(skipSubtitlesIfEmbeddedSubtitlesPresent) ^
      const DeepCollectionEquality().hash(skipSubtitlesIfAudioTrackMatches) ^
      const DeepCollectionEquality().hash(subtitleDownloadLanguages) ^
      const DeepCollectionEquality().hash(requirePerfectSubtitleMatch) ^
      const DeepCollectionEquality().hash(saveSubtitlesWithMedia) ^
      const DeepCollectionEquality().hash(saveLyricsWithMedia) ^
      const DeepCollectionEquality().hash(saveTrickplayWithMedia) ^
      const DeepCollectionEquality().hash(disabledLyricFetchers) ^
      const DeepCollectionEquality().hash(lyricFetcherOrder) ^
      const DeepCollectionEquality().hash(preferNonstandardArtistsTag) ^
      const DeepCollectionEquality().hash(useCustomTagDelimiters) ^
      const DeepCollectionEquality().hash(customTagDelimiters) ^
      const DeepCollectionEquality().hash(delimiterWhitelist) ^
      const DeepCollectionEquality().hash(automaticallyAddToCollection) ^
      const DeepCollectionEquality().hash(allowEmbeddedSubtitles) ^
      const DeepCollectionEquality().hash(typeOptions) ^
      runtimeType.hashCode;
}

extension $LibraryOptionsExtension on LibraryOptions {
  LibraryOptions copyWith(
      {bool? enabled,
      bool? enablePhotos,
      bool? enableRealtimeMonitor,
      bool? enableLUFSScan,
      bool? enableChapterImageExtraction,
      bool? extractChapterImagesDuringLibraryScan,
      bool? enableTrickplayImageExtraction,
      bool? extractTrickplayImagesDuringLibraryScan,
      List<MediaPathInfo>? pathInfos,
      bool? saveLocalMetadata,
      bool? enableInternetProviders,
      bool? enableAutomaticSeriesGrouping,
      bool? enableEmbeddedTitles,
      bool? enableEmbeddedExtrasTitles,
      bool? enableEmbeddedEpisodeInfos,
      int? automaticRefreshIntervalDays,
      String? preferredMetadataLanguage,
      String? metadataCountryCode,
      String? seasonZeroDisplayName,
      List<String>? metadataSavers,
      List<String>? disabledLocalMetadataReaders,
      List<String>? localMetadataReaderOrder,
      List<String>? disabledSubtitleFetchers,
      List<String>? subtitleFetcherOrder,
      List<String>? disabledMediaSegmentProviders,
      List<String>? mediaSegmentProvideOrder,
      bool? skipSubtitlesIfEmbeddedSubtitlesPresent,
      bool? skipSubtitlesIfAudioTrackMatches,
      List<String>? subtitleDownloadLanguages,
      bool? requirePerfectSubtitleMatch,
      bool? saveSubtitlesWithMedia,
      bool? saveLyricsWithMedia,
      bool? saveTrickplayWithMedia,
      List<String>? disabledLyricFetchers,
      List<String>? lyricFetcherOrder,
      bool? preferNonstandardArtistsTag,
      bool? useCustomTagDelimiters,
      List<String>? customTagDelimiters,
      List<String>? delimiterWhitelist,
      bool? automaticallyAddToCollection,
      enums.EmbeddedSubtitleOptions? allowEmbeddedSubtitles,
      List<TypeOptions>? typeOptions}) {
    return LibraryOptions(
        enabled: enabled ?? this.enabled,
        enablePhotos: enablePhotos ?? this.enablePhotos,
        enableRealtimeMonitor:
            enableRealtimeMonitor ?? this.enableRealtimeMonitor,
        enableLUFSScan: enableLUFSScan ?? this.enableLUFSScan,
        enableChapterImageExtraction:
            enableChapterImageExtraction ?? this.enableChapterImageExtraction,
        extractChapterImagesDuringLibraryScan:
            extractChapterImagesDuringLibraryScan ??
                this.extractChapterImagesDuringLibraryScan,
        enableTrickplayImageExtraction: enableTrickplayImageExtraction ??
            this.enableTrickplayImageExtraction,
        extractTrickplayImagesDuringLibraryScan:
            extractTrickplayImagesDuringLibraryScan ??
                this.extractTrickplayImagesDuringLibraryScan,
        pathInfos: pathInfos ?? this.pathInfos,
        saveLocalMetadata: saveLocalMetadata ?? this.saveLocalMetadata,
        enableInternetProviders:
            enableInternetProviders ?? this.enableInternetProviders,
        enableAutomaticSeriesGrouping:
            enableAutomaticSeriesGrouping ?? this.enableAutomaticSeriesGrouping,
        enableEmbeddedTitles: enableEmbeddedTitles ?? this.enableEmbeddedTitles,
        enableEmbeddedExtrasTitles:
            enableEmbeddedExtrasTitles ?? this.enableEmbeddedExtrasTitles,
        enableEmbeddedEpisodeInfos:
            enableEmbeddedEpisodeInfos ?? this.enableEmbeddedEpisodeInfos,
        automaticRefreshIntervalDays:
            automaticRefreshIntervalDays ?? this.automaticRefreshIntervalDays,
        preferredMetadataLanguage:
            preferredMetadataLanguage ?? this.preferredMetadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        seasonZeroDisplayName:
            seasonZeroDisplayName ?? this.seasonZeroDisplayName,
        metadataSavers: metadataSavers ?? this.metadataSavers,
        disabledLocalMetadataReaders:
            disabledLocalMetadataReaders ?? this.disabledLocalMetadataReaders,
        localMetadataReaderOrder:
            localMetadataReaderOrder ?? this.localMetadataReaderOrder,
        disabledSubtitleFetchers:
            disabledSubtitleFetchers ?? this.disabledSubtitleFetchers,
        subtitleFetcherOrder: subtitleFetcherOrder ?? this.subtitleFetcherOrder,
        disabledMediaSegmentProviders:
            disabledMediaSegmentProviders ?? this.disabledMediaSegmentProviders,
        mediaSegmentProvideOrder:
            mediaSegmentProvideOrder ?? this.mediaSegmentProvideOrder,
        skipSubtitlesIfEmbeddedSubtitlesPresent:
            skipSubtitlesIfEmbeddedSubtitlesPresent ??
                this.skipSubtitlesIfEmbeddedSubtitlesPresent,
        skipSubtitlesIfAudioTrackMatches: skipSubtitlesIfAudioTrackMatches ??
            this.skipSubtitlesIfAudioTrackMatches,
        subtitleDownloadLanguages:
            subtitleDownloadLanguages ?? this.subtitleDownloadLanguages,
        requirePerfectSubtitleMatch:
            requirePerfectSubtitleMatch ?? this.requirePerfectSubtitleMatch,
        saveSubtitlesWithMedia:
            saveSubtitlesWithMedia ?? this.saveSubtitlesWithMedia,
        saveLyricsWithMedia: saveLyricsWithMedia ?? this.saveLyricsWithMedia,
        saveTrickplayWithMedia:
            saveTrickplayWithMedia ?? this.saveTrickplayWithMedia,
        disabledLyricFetchers:
            disabledLyricFetchers ?? this.disabledLyricFetchers,
        lyricFetcherOrder: lyricFetcherOrder ?? this.lyricFetcherOrder,
        preferNonstandardArtistsTag:
            preferNonstandardArtistsTag ?? this.preferNonstandardArtistsTag,
        useCustomTagDelimiters:
            useCustomTagDelimiters ?? this.useCustomTagDelimiters,
        customTagDelimiters: customTagDelimiters ?? this.customTagDelimiters,
        delimiterWhitelist: delimiterWhitelist ?? this.delimiterWhitelist,
        automaticallyAddToCollection:
            automaticallyAddToCollection ?? this.automaticallyAddToCollection,
        allowEmbeddedSubtitles:
            allowEmbeddedSubtitles ?? this.allowEmbeddedSubtitles,
        typeOptions: typeOptions ?? this.typeOptions);
  }

  LibraryOptions copyWithWrapped(
      {Wrapped<bool?>? enabled,
      Wrapped<bool?>? enablePhotos,
      Wrapped<bool?>? enableRealtimeMonitor,
      Wrapped<bool?>? enableLUFSScan,
      Wrapped<bool?>? enableChapterImageExtraction,
      Wrapped<bool?>? extractChapterImagesDuringLibraryScan,
      Wrapped<bool?>? enableTrickplayImageExtraction,
      Wrapped<bool?>? extractTrickplayImagesDuringLibraryScan,
      Wrapped<List<MediaPathInfo>?>? pathInfos,
      Wrapped<bool?>? saveLocalMetadata,
      Wrapped<bool?>? enableInternetProviders,
      Wrapped<bool?>? enableAutomaticSeriesGrouping,
      Wrapped<bool?>? enableEmbeddedTitles,
      Wrapped<bool?>? enableEmbeddedExtrasTitles,
      Wrapped<bool?>? enableEmbeddedEpisodeInfos,
      Wrapped<int?>? automaticRefreshIntervalDays,
      Wrapped<String?>? preferredMetadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<String?>? seasonZeroDisplayName,
      Wrapped<List<String>?>? metadataSavers,
      Wrapped<List<String>?>? disabledLocalMetadataReaders,
      Wrapped<List<String>?>? localMetadataReaderOrder,
      Wrapped<List<String>?>? disabledSubtitleFetchers,
      Wrapped<List<String>?>? subtitleFetcherOrder,
      Wrapped<List<String>?>? disabledMediaSegmentProviders,
      Wrapped<List<String>?>? mediaSegmentProvideOrder,
      Wrapped<bool?>? skipSubtitlesIfEmbeddedSubtitlesPresent,
      Wrapped<bool?>? skipSubtitlesIfAudioTrackMatches,
      Wrapped<List<String>?>? subtitleDownloadLanguages,
      Wrapped<bool?>? requirePerfectSubtitleMatch,
      Wrapped<bool?>? saveSubtitlesWithMedia,
      Wrapped<bool?>? saveLyricsWithMedia,
      Wrapped<bool?>? saveTrickplayWithMedia,
      Wrapped<List<String>?>? disabledLyricFetchers,
      Wrapped<List<String>?>? lyricFetcherOrder,
      Wrapped<bool?>? preferNonstandardArtistsTag,
      Wrapped<bool?>? useCustomTagDelimiters,
      Wrapped<List<String>?>? customTagDelimiters,
      Wrapped<List<String>?>? delimiterWhitelist,
      Wrapped<bool?>? automaticallyAddToCollection,
      Wrapped<enums.EmbeddedSubtitleOptions?>? allowEmbeddedSubtitles,
      Wrapped<List<TypeOptions>?>? typeOptions}) {
    return LibraryOptions(
        enabled: (enabled != null ? enabled.value : this.enabled),
        enablePhotos:
            (enablePhotos != null ? enablePhotos.value : this.enablePhotos),
        enableRealtimeMonitor: (enableRealtimeMonitor != null
            ? enableRealtimeMonitor.value
            : this.enableRealtimeMonitor),
        enableLUFSScan: (enableLUFSScan != null
            ? enableLUFSScan.value
            : this.enableLUFSScan),
        enableChapterImageExtraction: (enableChapterImageExtraction != null
            ? enableChapterImageExtraction.value
            : this.enableChapterImageExtraction),
        extractChapterImagesDuringLibraryScan: (extractChapterImagesDuringLibraryScan != null
            ? extractChapterImagesDuringLibraryScan.value
            : this.extractChapterImagesDuringLibraryScan),
        enableTrickplayImageExtraction: (enableTrickplayImageExtraction != null
            ? enableTrickplayImageExtraction.value
            : this.enableTrickplayImageExtraction),
        extractTrickplayImagesDuringLibraryScan:
            (extractTrickplayImagesDuringLibraryScan != null
                ? extractTrickplayImagesDuringLibraryScan.value
                : this.extractTrickplayImagesDuringLibraryScan),
        pathInfos: (pathInfos != null ? pathInfos.value : this.pathInfos),
        saveLocalMetadata: (saveLocalMetadata != null
            ? saveLocalMetadata.value
            : this.saveLocalMetadata),
        enableInternetProviders: (enableInternetProviders != null
            ? enableInternetProviders.value
            : this.enableInternetProviders),
        enableAutomaticSeriesGrouping: (enableAutomaticSeriesGrouping != null
            ? enableAutomaticSeriesGrouping.value
            : this.enableAutomaticSeriesGrouping),
        enableEmbeddedTitles: (enableEmbeddedTitles != null
            ? enableEmbeddedTitles.value
            : this.enableEmbeddedTitles),
        enableEmbeddedExtrasTitles: (enableEmbeddedExtrasTitles != null
            ? enableEmbeddedExtrasTitles.value
            : this.enableEmbeddedExtrasTitles),
        enableEmbeddedEpisodeInfos: (enableEmbeddedEpisodeInfos != null
            ? enableEmbeddedEpisodeInfos.value
            : this.enableEmbeddedEpisodeInfos),
        automaticRefreshIntervalDays: (automaticRefreshIntervalDays != null
            ? automaticRefreshIntervalDays.value
            : this.automaticRefreshIntervalDays),
        preferredMetadataLanguage: (preferredMetadataLanguage != null
            ? preferredMetadataLanguage.value
            : this.preferredMetadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        seasonZeroDisplayName: (seasonZeroDisplayName != null
            ? seasonZeroDisplayName.value
            : this.seasonZeroDisplayName),
        metadataSavers: (metadataSavers != null
            ? metadataSavers.value
            : this.metadataSavers),
        disabledLocalMetadataReaders: (disabledLocalMetadataReaders != null
            ? disabledLocalMetadataReaders.value
            : this.disabledLocalMetadataReaders),
        localMetadataReaderOrder: (localMetadataReaderOrder != null
            ? localMetadataReaderOrder.value
            : this.localMetadataReaderOrder),
        disabledSubtitleFetchers: (disabledSubtitleFetchers != null
            ? disabledSubtitleFetchers.value
            : this.disabledSubtitleFetchers),
        subtitleFetcherOrder: (subtitleFetcherOrder != null
            ? subtitleFetcherOrder.value
            : this.subtitleFetcherOrder),
        disabledMediaSegmentProviders: (disabledMediaSegmentProviders != null
            ? disabledMediaSegmentProviders.value
            : this.disabledMediaSegmentProviders),
        mediaSegmentProvideOrder: (mediaSegmentProvideOrder != null ? mediaSegmentProvideOrder.value : this.mediaSegmentProvideOrder),
        skipSubtitlesIfEmbeddedSubtitlesPresent: (skipSubtitlesIfEmbeddedSubtitlesPresent != null ? skipSubtitlesIfEmbeddedSubtitlesPresent.value : this.skipSubtitlesIfEmbeddedSubtitlesPresent),
        skipSubtitlesIfAudioTrackMatches: (skipSubtitlesIfAudioTrackMatches != null ? skipSubtitlesIfAudioTrackMatches.value : this.skipSubtitlesIfAudioTrackMatches),
        subtitleDownloadLanguages: (subtitleDownloadLanguages != null ? subtitleDownloadLanguages.value : this.subtitleDownloadLanguages),
        requirePerfectSubtitleMatch: (requirePerfectSubtitleMatch != null ? requirePerfectSubtitleMatch.value : this.requirePerfectSubtitleMatch),
        saveSubtitlesWithMedia: (saveSubtitlesWithMedia != null ? saveSubtitlesWithMedia.value : this.saveSubtitlesWithMedia),
        saveLyricsWithMedia: (saveLyricsWithMedia != null ? saveLyricsWithMedia.value : this.saveLyricsWithMedia),
        saveTrickplayWithMedia: (saveTrickplayWithMedia != null ? saveTrickplayWithMedia.value : this.saveTrickplayWithMedia),
        disabledLyricFetchers: (disabledLyricFetchers != null ? disabledLyricFetchers.value : this.disabledLyricFetchers),
        lyricFetcherOrder: (lyricFetcherOrder != null ? lyricFetcherOrder.value : this.lyricFetcherOrder),
        preferNonstandardArtistsTag: (preferNonstandardArtistsTag != null ? preferNonstandardArtistsTag.value : this.preferNonstandardArtistsTag),
        useCustomTagDelimiters: (useCustomTagDelimiters != null ? useCustomTagDelimiters.value : this.useCustomTagDelimiters),
        customTagDelimiters: (customTagDelimiters != null ? customTagDelimiters.value : this.customTagDelimiters),
        delimiterWhitelist: (delimiterWhitelist != null ? delimiterWhitelist.value : this.delimiterWhitelist),
        automaticallyAddToCollection: (automaticallyAddToCollection != null ? automaticallyAddToCollection.value : this.automaticallyAddToCollection),
        allowEmbeddedSubtitles: (allowEmbeddedSubtitles != null ? allowEmbeddedSubtitles.value : this.allowEmbeddedSubtitles),
        typeOptions: (typeOptions != null ? typeOptions.value : this.typeOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryOptionsResultDto {
  const LibraryOptionsResultDto({
    this.metadataSavers,
    this.metadataReaders,
    this.subtitleFetchers,
    this.lyricFetchers,
    this.typeOptions,
  });

  factory LibraryOptionsResultDto.fromJson(Map<String, dynamic> json) =>
      _$LibraryOptionsResultDtoFromJson(json);

  static const toJsonFactory = _$LibraryOptionsResultDtoToJson;
  Map<String, dynamic> toJson() => _$LibraryOptionsResultDtoToJson(this);

  @JsonKey(name: 'MetadataSavers', defaultValue: <LibraryOptionInfoDto>[])
  final List<LibraryOptionInfoDto>? metadataSavers;
  @JsonKey(name: 'MetadataReaders', defaultValue: <LibraryOptionInfoDto>[])
  final List<LibraryOptionInfoDto>? metadataReaders;
  @JsonKey(name: 'SubtitleFetchers', defaultValue: <LibraryOptionInfoDto>[])
  final List<LibraryOptionInfoDto>? subtitleFetchers;
  @JsonKey(name: 'LyricFetchers', defaultValue: <LibraryOptionInfoDto>[])
  final List<LibraryOptionInfoDto>? lyricFetchers;
  @JsonKey(name: 'TypeOptions', defaultValue: <LibraryTypeOptionsDto>[])
  final List<LibraryTypeOptionsDto>? typeOptions;
  static const fromJsonFactory = _$LibraryOptionsResultDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryOptionsResultDto &&
            (identical(other.metadataSavers, metadataSavers) ||
                const DeepCollectionEquality()
                    .equals(other.metadataSavers, metadataSavers)) &&
            (identical(other.metadataReaders, metadataReaders) ||
                const DeepCollectionEquality()
                    .equals(other.metadataReaders, metadataReaders)) &&
            (identical(other.subtitleFetchers, subtitleFetchers) ||
                const DeepCollectionEquality()
                    .equals(other.subtitleFetchers, subtitleFetchers)) &&
            (identical(other.lyricFetchers, lyricFetchers) ||
                const DeepCollectionEquality()
                    .equals(other.lyricFetchers, lyricFetchers)) &&
            (identical(other.typeOptions, typeOptions) ||
                const DeepCollectionEquality()
                    .equals(other.typeOptions, typeOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(metadataSavers) ^
      const DeepCollectionEquality().hash(metadataReaders) ^
      const DeepCollectionEquality().hash(subtitleFetchers) ^
      const DeepCollectionEquality().hash(lyricFetchers) ^
      const DeepCollectionEquality().hash(typeOptions) ^
      runtimeType.hashCode;
}

extension $LibraryOptionsResultDtoExtension on LibraryOptionsResultDto {
  LibraryOptionsResultDto copyWith(
      {List<LibraryOptionInfoDto>? metadataSavers,
      List<LibraryOptionInfoDto>? metadataReaders,
      List<LibraryOptionInfoDto>? subtitleFetchers,
      List<LibraryOptionInfoDto>? lyricFetchers,
      List<LibraryTypeOptionsDto>? typeOptions}) {
    return LibraryOptionsResultDto(
        metadataSavers: metadataSavers ?? this.metadataSavers,
        metadataReaders: metadataReaders ?? this.metadataReaders,
        subtitleFetchers: subtitleFetchers ?? this.subtitleFetchers,
        lyricFetchers: lyricFetchers ?? this.lyricFetchers,
        typeOptions: typeOptions ?? this.typeOptions);
  }

  LibraryOptionsResultDto copyWithWrapped(
      {Wrapped<List<LibraryOptionInfoDto>?>? metadataSavers,
      Wrapped<List<LibraryOptionInfoDto>?>? metadataReaders,
      Wrapped<List<LibraryOptionInfoDto>?>? subtitleFetchers,
      Wrapped<List<LibraryOptionInfoDto>?>? lyricFetchers,
      Wrapped<List<LibraryTypeOptionsDto>?>? typeOptions}) {
    return LibraryOptionsResultDto(
        metadataSavers: (metadataSavers != null
            ? metadataSavers.value
            : this.metadataSavers),
        metadataReaders: (metadataReaders != null
            ? metadataReaders.value
            : this.metadataReaders),
        subtitleFetchers: (subtitleFetchers != null
            ? subtitleFetchers.value
            : this.subtitleFetchers),
        lyricFetchers:
            (lyricFetchers != null ? lyricFetchers.value : this.lyricFetchers),
        typeOptions:
            (typeOptions != null ? typeOptions.value : this.typeOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryTypeOptionsDto {
  const LibraryTypeOptionsDto({
    this.type,
    this.metadataFetchers,
    this.imageFetchers,
    this.supportedImageTypes,
    this.defaultImageOptions,
  });

  factory LibraryTypeOptionsDto.fromJson(Map<String, dynamic> json) =>
      _$LibraryTypeOptionsDtoFromJson(json);

  static const toJsonFactory = _$LibraryTypeOptionsDtoToJson;
  Map<String, dynamic> toJson() => _$LibraryTypeOptionsDtoToJson(this);

  @JsonKey(name: 'Type')
  final String? type;
  @JsonKey(name: 'MetadataFetchers', defaultValue: <LibraryOptionInfoDto>[])
  final List<LibraryOptionInfoDto>? metadataFetchers;
  @JsonKey(name: 'ImageFetchers', defaultValue: <LibraryOptionInfoDto>[])
  final List<LibraryOptionInfoDto>? imageFetchers;
  @JsonKey(
    name: 'SupportedImageTypes',
    toJson: imageTypeListToJson,
    fromJson: imageTypeListFromJson,
  )
  final List<enums.ImageType>? supportedImageTypes;
  @JsonKey(name: 'DefaultImageOptions', defaultValue: <ImageOption>[])
  final List<ImageOption>? defaultImageOptions;
  static const fromJsonFactory = _$LibraryTypeOptionsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryTypeOptionsDto &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.metadataFetchers, metadataFetchers) ||
                const DeepCollectionEquality()
                    .equals(other.metadataFetchers, metadataFetchers)) &&
            (identical(other.imageFetchers, imageFetchers) ||
                const DeepCollectionEquality()
                    .equals(other.imageFetchers, imageFetchers)) &&
            (identical(other.supportedImageTypes, supportedImageTypes) ||
                const DeepCollectionEquality()
                    .equals(other.supportedImageTypes, supportedImageTypes)) &&
            (identical(other.defaultImageOptions, defaultImageOptions) ||
                const DeepCollectionEquality()
                    .equals(other.defaultImageOptions, defaultImageOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(metadataFetchers) ^
      const DeepCollectionEquality().hash(imageFetchers) ^
      const DeepCollectionEquality().hash(supportedImageTypes) ^
      const DeepCollectionEquality().hash(defaultImageOptions) ^
      runtimeType.hashCode;
}

extension $LibraryTypeOptionsDtoExtension on LibraryTypeOptionsDto {
  LibraryTypeOptionsDto copyWith(
      {String? type,
      List<LibraryOptionInfoDto>? metadataFetchers,
      List<LibraryOptionInfoDto>? imageFetchers,
      List<enums.ImageType>? supportedImageTypes,
      List<ImageOption>? defaultImageOptions}) {
    return LibraryTypeOptionsDto(
        type: type ?? this.type,
        metadataFetchers: metadataFetchers ?? this.metadataFetchers,
        imageFetchers: imageFetchers ?? this.imageFetchers,
        supportedImageTypes: supportedImageTypes ?? this.supportedImageTypes,
        defaultImageOptions: defaultImageOptions ?? this.defaultImageOptions);
  }

  LibraryTypeOptionsDto copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<List<LibraryOptionInfoDto>?>? metadataFetchers,
      Wrapped<List<LibraryOptionInfoDto>?>? imageFetchers,
      Wrapped<List<enums.ImageType>?>? supportedImageTypes,
      Wrapped<List<ImageOption>?>? defaultImageOptions}) {
    return LibraryTypeOptionsDto(
        type: (type != null ? type.value : this.type),
        metadataFetchers: (metadataFetchers != null
            ? metadataFetchers.value
            : this.metadataFetchers),
        imageFetchers:
            (imageFetchers != null ? imageFetchers.value : this.imageFetchers),
        supportedImageTypes: (supportedImageTypes != null
            ? supportedImageTypes.value
            : this.supportedImageTypes),
        defaultImageOptions: (defaultImageOptions != null
            ? defaultImageOptions.value
            : this.defaultImageOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryUpdateInfo {
  const LibraryUpdateInfo({
    this.foldersAddedTo,
    this.foldersRemovedFrom,
    this.itemsAdded,
    this.itemsRemoved,
    this.itemsUpdated,
    this.collectionFolders,
    this.isEmpty,
  });

  factory LibraryUpdateInfo.fromJson(Map<String, dynamic> json) =>
      _$LibraryUpdateInfoFromJson(json);

  static const toJsonFactory = _$LibraryUpdateInfoToJson;
  Map<String, dynamic> toJson() => _$LibraryUpdateInfoToJson(this);

  @JsonKey(name: 'FoldersAddedTo', defaultValue: <String>[])
  final List<String>? foldersAddedTo;
  @JsonKey(name: 'FoldersRemovedFrom', defaultValue: <String>[])
  final List<String>? foldersRemovedFrom;
  @JsonKey(name: 'ItemsAdded', defaultValue: <String>[])
  final List<String>? itemsAdded;
  @JsonKey(name: 'ItemsRemoved', defaultValue: <String>[])
  final List<String>? itemsRemoved;
  @JsonKey(name: 'ItemsUpdated', defaultValue: <String>[])
  final List<String>? itemsUpdated;
  @JsonKey(name: 'CollectionFolders', defaultValue: <String>[])
  final List<String>? collectionFolders;
  @JsonKey(name: 'IsEmpty')
  final bool? isEmpty;
  static const fromJsonFactory = _$LibraryUpdateInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryUpdateInfo &&
            (identical(other.foldersAddedTo, foldersAddedTo) ||
                const DeepCollectionEquality()
                    .equals(other.foldersAddedTo, foldersAddedTo)) &&
            (identical(other.foldersRemovedFrom, foldersRemovedFrom) ||
                const DeepCollectionEquality()
                    .equals(other.foldersRemovedFrom, foldersRemovedFrom)) &&
            (identical(other.itemsAdded, itemsAdded) ||
                const DeepCollectionEquality()
                    .equals(other.itemsAdded, itemsAdded)) &&
            (identical(other.itemsRemoved, itemsRemoved) ||
                const DeepCollectionEquality()
                    .equals(other.itemsRemoved, itemsRemoved)) &&
            (identical(other.itemsUpdated, itemsUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.itemsUpdated, itemsUpdated)) &&
            (identical(other.collectionFolders, collectionFolders) ||
                const DeepCollectionEquality()
                    .equals(other.collectionFolders, collectionFolders)) &&
            (identical(other.isEmpty, isEmpty) ||
                const DeepCollectionEquality().equals(other.isEmpty, isEmpty)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(foldersAddedTo) ^
      const DeepCollectionEquality().hash(foldersRemovedFrom) ^
      const DeepCollectionEquality().hash(itemsAdded) ^
      const DeepCollectionEquality().hash(itemsRemoved) ^
      const DeepCollectionEquality().hash(itemsUpdated) ^
      const DeepCollectionEquality().hash(collectionFolders) ^
      const DeepCollectionEquality().hash(isEmpty) ^
      runtimeType.hashCode;
}

extension $LibraryUpdateInfoExtension on LibraryUpdateInfo {
  LibraryUpdateInfo copyWith(
      {List<String>? foldersAddedTo,
      List<String>? foldersRemovedFrom,
      List<String>? itemsAdded,
      List<String>? itemsRemoved,
      List<String>? itemsUpdated,
      List<String>? collectionFolders,
      bool? isEmpty}) {
    return LibraryUpdateInfo(
        foldersAddedTo: foldersAddedTo ?? this.foldersAddedTo,
        foldersRemovedFrom: foldersRemovedFrom ?? this.foldersRemovedFrom,
        itemsAdded: itemsAdded ?? this.itemsAdded,
        itemsRemoved: itemsRemoved ?? this.itemsRemoved,
        itemsUpdated: itemsUpdated ?? this.itemsUpdated,
        collectionFolders: collectionFolders ?? this.collectionFolders,
        isEmpty: isEmpty ?? this.isEmpty);
  }

  LibraryUpdateInfo copyWithWrapped(
      {Wrapped<List<String>?>? foldersAddedTo,
      Wrapped<List<String>?>? foldersRemovedFrom,
      Wrapped<List<String>?>? itemsAdded,
      Wrapped<List<String>?>? itemsRemoved,
      Wrapped<List<String>?>? itemsUpdated,
      Wrapped<List<String>?>? collectionFolders,
      Wrapped<bool?>? isEmpty}) {
    return LibraryUpdateInfo(
        foldersAddedTo: (foldersAddedTo != null
            ? foldersAddedTo.value
            : this.foldersAddedTo),
        foldersRemovedFrom: (foldersRemovedFrom != null
            ? foldersRemovedFrom.value
            : this.foldersRemovedFrom),
        itemsAdded: (itemsAdded != null ? itemsAdded.value : this.itemsAdded),
        itemsRemoved:
            (itemsRemoved != null ? itemsRemoved.value : this.itemsRemoved),
        itemsUpdated:
            (itemsUpdated != null ? itemsUpdated.value : this.itemsUpdated),
        collectionFolders: (collectionFolders != null
            ? collectionFolders.value
            : this.collectionFolders),
        isEmpty: (isEmpty != null ? isEmpty.value : this.isEmpty));
  }
}

@JsonSerializable(explicitToJson: true)
class ListingsProviderInfo {
  const ListingsProviderInfo({
    this.id,
    this.type,
    this.username,
    this.password,
    this.listingsId,
    this.zipCode,
    this.country,
    this.path,
    this.enabledTuners,
    this.enableAllTuners,
    this.newsCategories,
    this.sportsCategories,
    this.kidsCategories,
    this.movieCategories,
    this.channelMappings,
    this.moviePrefix,
    this.preferredLanguage,
    this.userAgent,
  });

  factory ListingsProviderInfo.fromJson(Map<String, dynamic> json) =>
      _$ListingsProviderInfoFromJson(json);

  static const toJsonFactory = _$ListingsProviderInfoToJson;
  Map<String, dynamic> toJson() => _$ListingsProviderInfoToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Type')
  final String? type;
  @JsonKey(name: 'Username')
  final String? username;
  @JsonKey(name: 'Password')
  final String? password;
  @JsonKey(name: 'ListingsId')
  final String? listingsId;
  @JsonKey(name: 'ZipCode')
  final String? zipCode;
  @JsonKey(name: 'Country')
  final String? country;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'EnabledTuners', defaultValue: <String>[])
  final List<String>? enabledTuners;
  @JsonKey(name: 'EnableAllTuners')
  final bool? enableAllTuners;
  @JsonKey(name: 'NewsCategories', defaultValue: <String>[])
  final List<String>? newsCategories;
  @JsonKey(name: 'SportsCategories', defaultValue: <String>[])
  final List<String>? sportsCategories;
  @JsonKey(name: 'KidsCategories', defaultValue: <String>[])
  final List<String>? kidsCategories;
  @JsonKey(name: 'MovieCategories', defaultValue: <String>[])
  final List<String>? movieCategories;
  @JsonKey(name: 'ChannelMappings', defaultValue: <NameValuePair>[])
  final List<NameValuePair>? channelMappings;
  @JsonKey(name: 'MoviePrefix')
  final String? moviePrefix;
  @JsonKey(name: 'PreferredLanguage')
  final String? preferredLanguage;
  @JsonKey(name: 'UserAgent')
  final String? userAgent;
  static const fromJsonFactory = _$ListingsProviderInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ListingsProviderInfo &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)) &&
            (identical(other.listingsId, listingsId) ||
                const DeepCollectionEquality()
                    .equals(other.listingsId, listingsId)) &&
            (identical(other.zipCode, zipCode) ||
                const DeepCollectionEquality()
                    .equals(other.zipCode, zipCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.enabledTuners, enabledTuners) ||
                const DeepCollectionEquality()
                    .equals(other.enabledTuners, enabledTuners)) &&
            (identical(other.enableAllTuners, enableAllTuners) ||
                const DeepCollectionEquality()
                    .equals(other.enableAllTuners, enableAllTuners)) &&
            (identical(other.newsCategories, newsCategories) ||
                const DeepCollectionEquality()
                    .equals(other.newsCategories, newsCategories)) &&
            (identical(other.sportsCategories, sportsCategories) ||
                const DeepCollectionEquality()
                    .equals(other.sportsCategories, sportsCategories)) &&
            (identical(other.kidsCategories, kidsCategories) ||
                const DeepCollectionEquality()
                    .equals(other.kidsCategories, kidsCategories)) &&
            (identical(other.movieCategories, movieCategories) ||
                const DeepCollectionEquality()
                    .equals(other.movieCategories, movieCategories)) &&
            (identical(other.channelMappings, channelMappings) ||
                const DeepCollectionEquality()
                    .equals(other.channelMappings, channelMappings)) &&
            (identical(other.moviePrefix, moviePrefix) ||
                const DeepCollectionEquality()
                    .equals(other.moviePrefix, moviePrefix)) &&
            (identical(other.preferredLanguage, preferredLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.preferredLanguage, preferredLanguage)) &&
            (identical(other.userAgent, userAgent) ||
                const DeepCollectionEquality()
                    .equals(other.userAgent, userAgent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(listingsId) ^
      const DeepCollectionEquality().hash(zipCode) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(enabledTuners) ^
      const DeepCollectionEquality().hash(enableAllTuners) ^
      const DeepCollectionEquality().hash(newsCategories) ^
      const DeepCollectionEquality().hash(sportsCategories) ^
      const DeepCollectionEquality().hash(kidsCategories) ^
      const DeepCollectionEquality().hash(movieCategories) ^
      const DeepCollectionEquality().hash(channelMappings) ^
      const DeepCollectionEquality().hash(moviePrefix) ^
      const DeepCollectionEquality().hash(preferredLanguage) ^
      const DeepCollectionEquality().hash(userAgent) ^
      runtimeType.hashCode;
}

extension $ListingsProviderInfoExtension on ListingsProviderInfo {
  ListingsProviderInfo copyWith(
      {String? id,
      String? type,
      String? username,
      String? password,
      String? listingsId,
      String? zipCode,
      String? country,
      String? path,
      List<String>? enabledTuners,
      bool? enableAllTuners,
      List<String>? newsCategories,
      List<String>? sportsCategories,
      List<String>? kidsCategories,
      List<String>? movieCategories,
      List<NameValuePair>? channelMappings,
      String? moviePrefix,
      String? preferredLanguage,
      String? userAgent}) {
    return ListingsProviderInfo(
        id: id ?? this.id,
        type: type ?? this.type,
        username: username ?? this.username,
        password: password ?? this.password,
        listingsId: listingsId ?? this.listingsId,
        zipCode: zipCode ?? this.zipCode,
        country: country ?? this.country,
        path: path ?? this.path,
        enabledTuners: enabledTuners ?? this.enabledTuners,
        enableAllTuners: enableAllTuners ?? this.enableAllTuners,
        newsCategories: newsCategories ?? this.newsCategories,
        sportsCategories: sportsCategories ?? this.sportsCategories,
        kidsCategories: kidsCategories ?? this.kidsCategories,
        movieCategories: movieCategories ?? this.movieCategories,
        channelMappings: channelMappings ?? this.channelMappings,
        moviePrefix: moviePrefix ?? this.moviePrefix,
        preferredLanguage: preferredLanguage ?? this.preferredLanguage,
        userAgent: userAgent ?? this.userAgent);
  }

  ListingsProviderInfo copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? type,
      Wrapped<String?>? username,
      Wrapped<String?>? password,
      Wrapped<String?>? listingsId,
      Wrapped<String?>? zipCode,
      Wrapped<String?>? country,
      Wrapped<String?>? path,
      Wrapped<List<String>?>? enabledTuners,
      Wrapped<bool?>? enableAllTuners,
      Wrapped<List<String>?>? newsCategories,
      Wrapped<List<String>?>? sportsCategories,
      Wrapped<List<String>?>? kidsCategories,
      Wrapped<List<String>?>? movieCategories,
      Wrapped<List<NameValuePair>?>? channelMappings,
      Wrapped<String?>? moviePrefix,
      Wrapped<String?>? preferredLanguage,
      Wrapped<String?>? userAgent}) {
    return ListingsProviderInfo(
        id: (id != null ? id.value : this.id),
        type: (type != null ? type.value : this.type),
        username: (username != null ? username.value : this.username),
        password: (password != null ? password.value : this.password),
        listingsId: (listingsId != null ? listingsId.value : this.listingsId),
        zipCode: (zipCode != null ? zipCode.value : this.zipCode),
        country: (country != null ? country.value : this.country),
        path: (path != null ? path.value : this.path),
        enabledTuners:
            (enabledTuners != null ? enabledTuners.value : this.enabledTuners),
        enableAllTuners: (enableAllTuners != null
            ? enableAllTuners.value
            : this.enableAllTuners),
        newsCategories: (newsCategories != null
            ? newsCategories.value
            : this.newsCategories),
        sportsCategories: (sportsCategories != null
            ? sportsCategories.value
            : this.sportsCategories),
        kidsCategories: (kidsCategories != null
            ? kidsCategories.value
            : this.kidsCategories),
        movieCategories: (movieCategories != null
            ? movieCategories.value
            : this.movieCategories),
        channelMappings: (channelMappings != null
            ? channelMappings.value
            : this.channelMappings),
        moviePrefix:
            (moviePrefix != null ? moviePrefix.value : this.moviePrefix),
        preferredLanguage: (preferredLanguage != null
            ? preferredLanguage.value
            : this.preferredLanguage),
        userAgent: (userAgent != null ? userAgent.value : this.userAgent));
  }
}

@JsonSerializable(explicitToJson: true)
class LiveStreamResponse {
  const LiveStreamResponse({
    this.mediaSource,
  });

  factory LiveStreamResponse.fromJson(Map<String, dynamic> json) =>
      _$LiveStreamResponseFromJson(json);

  static const toJsonFactory = _$LiveStreamResponseToJson;
  Map<String, dynamic> toJson() => _$LiveStreamResponseToJson(this);

  @JsonKey(name: 'MediaSource')
  final MediaSourceInfo? mediaSource;
  static const fromJsonFactory = _$LiveStreamResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LiveStreamResponse &&
            (identical(other.mediaSource, mediaSource) ||
                const DeepCollectionEquality()
                    .equals(other.mediaSource, mediaSource)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(mediaSource) ^ runtimeType.hashCode;
}

extension $LiveStreamResponseExtension on LiveStreamResponse {
  LiveStreamResponse copyWith({MediaSourceInfo? mediaSource}) {
    return LiveStreamResponse(mediaSource: mediaSource ?? this.mediaSource);
  }

  LiveStreamResponse copyWithWrapped({Wrapped<MediaSourceInfo?>? mediaSource}) {
    return LiveStreamResponse(
        mediaSource:
            (mediaSource != null ? mediaSource.value : this.mediaSource));
  }
}

@JsonSerializable(explicitToJson: true)
class LiveTvInfo {
  const LiveTvInfo({
    this.services,
    this.isEnabled,
    this.enabledUsers,
  });

  factory LiveTvInfo.fromJson(Map<String, dynamic> json) =>
      _$LiveTvInfoFromJson(json);

  static const toJsonFactory = _$LiveTvInfoToJson;
  Map<String, dynamic> toJson() => _$LiveTvInfoToJson(this);

  @JsonKey(name: 'Services', defaultValue: <LiveTvServiceInfo>[])
  final List<LiveTvServiceInfo>? services;
  @JsonKey(name: 'IsEnabled')
  final bool? isEnabled;
  @JsonKey(name: 'EnabledUsers', defaultValue: <String>[])
  final List<String>? enabledUsers;
  static const fromJsonFactory = _$LiveTvInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LiveTvInfo &&
            (identical(other.services, services) ||
                const DeepCollectionEquality()
                    .equals(other.services, services)) &&
            (identical(other.isEnabled, isEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.isEnabled, isEnabled)) &&
            (identical(other.enabledUsers, enabledUsers) ||
                const DeepCollectionEquality()
                    .equals(other.enabledUsers, enabledUsers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(services) ^
      const DeepCollectionEquality().hash(isEnabled) ^
      const DeepCollectionEquality().hash(enabledUsers) ^
      runtimeType.hashCode;
}

extension $LiveTvInfoExtension on LiveTvInfo {
  LiveTvInfo copyWith(
      {List<LiveTvServiceInfo>? services,
      bool? isEnabled,
      List<String>? enabledUsers}) {
    return LiveTvInfo(
        services: services ?? this.services,
        isEnabled: isEnabled ?? this.isEnabled,
        enabledUsers: enabledUsers ?? this.enabledUsers);
  }

  LiveTvInfo copyWithWrapped(
      {Wrapped<List<LiveTvServiceInfo>?>? services,
      Wrapped<bool?>? isEnabled,
      Wrapped<List<String>?>? enabledUsers}) {
    return LiveTvInfo(
        services: (services != null ? services.value : this.services),
        isEnabled: (isEnabled != null ? isEnabled.value : this.isEnabled),
        enabledUsers:
            (enabledUsers != null ? enabledUsers.value : this.enabledUsers));
  }
}

@JsonSerializable(explicitToJson: true)
class LiveTvOptions {
  const LiveTvOptions({
    this.guideDays,
    this.recordingPath,
    this.movieRecordingPath,
    this.seriesRecordingPath,
    this.enableRecordingSubfolders,
    this.enableOriginalAudioWithEncodedRecordings,
    this.tunerHosts,
    this.listingProviders,
    this.prePaddingSeconds,
    this.postPaddingSeconds,
    this.mediaLocationsCreated,
    this.recordingPostProcessor,
    this.recordingPostProcessorArguments,
    this.saveRecordingNFO,
    this.saveRecordingImages,
  });

  factory LiveTvOptions.fromJson(Map<String, dynamic> json) =>
      _$LiveTvOptionsFromJson(json);

  static const toJsonFactory = _$LiveTvOptionsToJson;
  Map<String, dynamic> toJson() => _$LiveTvOptionsToJson(this);

  @JsonKey(name: 'GuideDays')
  final int? guideDays;
  @JsonKey(name: 'RecordingPath')
  final String? recordingPath;
  @JsonKey(name: 'MovieRecordingPath')
  final String? movieRecordingPath;
  @JsonKey(name: 'SeriesRecordingPath')
  final String? seriesRecordingPath;
  @JsonKey(name: 'EnableRecordingSubfolders')
  final bool? enableRecordingSubfolders;
  @JsonKey(name: 'EnableOriginalAudioWithEncodedRecordings')
  final bool? enableOriginalAudioWithEncodedRecordings;
  @JsonKey(name: 'TunerHosts', defaultValue: <TunerHostInfo>[])
  final List<TunerHostInfo>? tunerHosts;
  @JsonKey(name: 'ListingProviders', defaultValue: <ListingsProviderInfo>[])
  final List<ListingsProviderInfo>? listingProviders;
  @JsonKey(name: 'PrePaddingSeconds')
  final int? prePaddingSeconds;
  @JsonKey(name: 'PostPaddingSeconds')
  final int? postPaddingSeconds;
  @JsonKey(name: 'MediaLocationsCreated', defaultValue: <String>[])
  final List<String>? mediaLocationsCreated;
  @JsonKey(name: 'RecordingPostProcessor')
  final String? recordingPostProcessor;
  @JsonKey(name: 'RecordingPostProcessorArguments')
  final String? recordingPostProcessorArguments;
  @JsonKey(name: 'SaveRecordingNFO')
  final bool? saveRecordingNFO;
  @JsonKey(name: 'SaveRecordingImages')
  final bool? saveRecordingImages;
  static const fromJsonFactory = _$LiveTvOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LiveTvOptions &&
            (identical(other.guideDays, guideDays) ||
                const DeepCollectionEquality()
                    .equals(other.guideDays, guideDays)) &&
            (identical(other.recordingPath, recordingPath) ||
                const DeepCollectionEquality()
                    .equals(other.recordingPath, recordingPath)) &&
            (identical(other.movieRecordingPath, movieRecordingPath) ||
                const DeepCollectionEquality()
                    .equals(other.movieRecordingPath, movieRecordingPath)) &&
            (identical(other.seriesRecordingPath, seriesRecordingPath) ||
                const DeepCollectionEquality()
                    .equals(other.seriesRecordingPath, seriesRecordingPath)) &&
            (identical(other.enableRecordingSubfolders, enableRecordingSubfolders) ||
                const DeepCollectionEquality().equals(
                    other.enableRecordingSubfolders,
                    enableRecordingSubfolders)) &&
            (identical(other.enableOriginalAudioWithEncodedRecordings, enableOriginalAudioWithEncodedRecordings) ||
                const DeepCollectionEquality().equals(
                    other.enableOriginalAudioWithEncodedRecordings,
                    enableOriginalAudioWithEncodedRecordings)) &&
            (identical(other.tunerHosts, tunerHosts) ||
                const DeepCollectionEquality()
                    .equals(other.tunerHosts, tunerHosts)) &&
            (identical(other.listingProviders, listingProviders) ||
                const DeepCollectionEquality()
                    .equals(other.listingProviders, listingProviders)) &&
            (identical(other.prePaddingSeconds, prePaddingSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.prePaddingSeconds, prePaddingSeconds)) &&
            (identical(other.postPaddingSeconds, postPaddingSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.postPaddingSeconds, postPaddingSeconds)) &&
            (identical(other.mediaLocationsCreated, mediaLocationsCreated) ||
                const DeepCollectionEquality().equals(
                    other.mediaLocationsCreated, mediaLocationsCreated)) &&
            (identical(other.recordingPostProcessor, recordingPostProcessor) ||
                const DeepCollectionEquality().equals(
                    other.recordingPostProcessor, recordingPostProcessor)) &&
            (identical(other.recordingPostProcessorArguments, recordingPostProcessorArguments) ||
                const DeepCollectionEquality().equals(
                    other.recordingPostProcessorArguments,
                    recordingPostProcessorArguments)) &&
            (identical(other.saveRecordingNFO, saveRecordingNFO) || const DeepCollectionEquality().equals(other.saveRecordingNFO, saveRecordingNFO)) &&
            (identical(other.saveRecordingImages, saveRecordingImages) || const DeepCollectionEquality().equals(other.saveRecordingImages, saveRecordingImages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(guideDays) ^
      const DeepCollectionEquality().hash(recordingPath) ^
      const DeepCollectionEquality().hash(movieRecordingPath) ^
      const DeepCollectionEquality().hash(seriesRecordingPath) ^
      const DeepCollectionEquality().hash(enableRecordingSubfolders) ^
      const DeepCollectionEquality()
          .hash(enableOriginalAudioWithEncodedRecordings) ^
      const DeepCollectionEquality().hash(tunerHosts) ^
      const DeepCollectionEquality().hash(listingProviders) ^
      const DeepCollectionEquality().hash(prePaddingSeconds) ^
      const DeepCollectionEquality().hash(postPaddingSeconds) ^
      const DeepCollectionEquality().hash(mediaLocationsCreated) ^
      const DeepCollectionEquality().hash(recordingPostProcessor) ^
      const DeepCollectionEquality().hash(recordingPostProcessorArguments) ^
      const DeepCollectionEquality().hash(saveRecordingNFO) ^
      const DeepCollectionEquality().hash(saveRecordingImages) ^
      runtimeType.hashCode;
}

extension $LiveTvOptionsExtension on LiveTvOptions {
  LiveTvOptions copyWith(
      {int? guideDays,
      String? recordingPath,
      String? movieRecordingPath,
      String? seriesRecordingPath,
      bool? enableRecordingSubfolders,
      bool? enableOriginalAudioWithEncodedRecordings,
      List<TunerHostInfo>? tunerHosts,
      List<ListingsProviderInfo>? listingProviders,
      int? prePaddingSeconds,
      int? postPaddingSeconds,
      List<String>? mediaLocationsCreated,
      String? recordingPostProcessor,
      String? recordingPostProcessorArguments,
      bool? saveRecordingNFO,
      bool? saveRecordingImages}) {
    return LiveTvOptions(
        guideDays: guideDays ?? this.guideDays,
        recordingPath: recordingPath ?? this.recordingPath,
        movieRecordingPath: movieRecordingPath ?? this.movieRecordingPath,
        seriesRecordingPath: seriesRecordingPath ?? this.seriesRecordingPath,
        enableRecordingSubfolders:
            enableRecordingSubfolders ?? this.enableRecordingSubfolders,
        enableOriginalAudioWithEncodedRecordings:
            enableOriginalAudioWithEncodedRecordings ??
                this.enableOriginalAudioWithEncodedRecordings,
        tunerHosts: tunerHosts ?? this.tunerHosts,
        listingProviders: listingProviders ?? this.listingProviders,
        prePaddingSeconds: prePaddingSeconds ?? this.prePaddingSeconds,
        postPaddingSeconds: postPaddingSeconds ?? this.postPaddingSeconds,
        mediaLocationsCreated:
            mediaLocationsCreated ?? this.mediaLocationsCreated,
        recordingPostProcessor:
            recordingPostProcessor ?? this.recordingPostProcessor,
        recordingPostProcessorArguments: recordingPostProcessorArguments ??
            this.recordingPostProcessorArguments,
        saveRecordingNFO: saveRecordingNFO ?? this.saveRecordingNFO,
        saveRecordingImages: saveRecordingImages ?? this.saveRecordingImages);
  }

  LiveTvOptions copyWithWrapped(
      {Wrapped<int?>? guideDays,
      Wrapped<String?>? recordingPath,
      Wrapped<String?>? movieRecordingPath,
      Wrapped<String?>? seriesRecordingPath,
      Wrapped<bool?>? enableRecordingSubfolders,
      Wrapped<bool?>? enableOriginalAudioWithEncodedRecordings,
      Wrapped<List<TunerHostInfo>?>? tunerHosts,
      Wrapped<List<ListingsProviderInfo>?>? listingProviders,
      Wrapped<int?>? prePaddingSeconds,
      Wrapped<int?>? postPaddingSeconds,
      Wrapped<List<String>?>? mediaLocationsCreated,
      Wrapped<String?>? recordingPostProcessor,
      Wrapped<String?>? recordingPostProcessorArguments,
      Wrapped<bool?>? saveRecordingNFO,
      Wrapped<bool?>? saveRecordingImages}) {
    return LiveTvOptions(
        guideDays: (guideDays != null ? guideDays.value : this.guideDays),
        recordingPath:
            (recordingPath != null ? recordingPath.value : this.recordingPath),
        movieRecordingPath: (movieRecordingPath != null
            ? movieRecordingPath.value
            : this.movieRecordingPath),
        seriesRecordingPath: (seriesRecordingPath != null
            ? seriesRecordingPath.value
            : this.seriesRecordingPath),
        enableRecordingSubfolders: (enableRecordingSubfolders != null
            ? enableRecordingSubfolders.value
            : this.enableRecordingSubfolders),
        enableOriginalAudioWithEncodedRecordings:
            (enableOriginalAudioWithEncodedRecordings != null
                ? enableOriginalAudioWithEncodedRecordings.value
                : this.enableOriginalAudioWithEncodedRecordings),
        tunerHosts: (tunerHosts != null ? tunerHosts.value : this.tunerHosts),
        listingProviders: (listingProviders != null
            ? listingProviders.value
            : this.listingProviders),
        prePaddingSeconds: (prePaddingSeconds != null
            ? prePaddingSeconds.value
            : this.prePaddingSeconds),
        postPaddingSeconds: (postPaddingSeconds != null
            ? postPaddingSeconds.value
            : this.postPaddingSeconds),
        mediaLocationsCreated: (mediaLocationsCreated != null
            ? mediaLocationsCreated.value
            : this.mediaLocationsCreated),
        recordingPostProcessor: (recordingPostProcessor != null
            ? recordingPostProcessor.value
            : this.recordingPostProcessor),
        recordingPostProcessorArguments:
            (recordingPostProcessorArguments != null
                ? recordingPostProcessorArguments.value
                : this.recordingPostProcessorArguments),
        saveRecordingNFO: (saveRecordingNFO != null
            ? saveRecordingNFO.value
            : this.saveRecordingNFO),
        saveRecordingImages: (saveRecordingImages != null
            ? saveRecordingImages.value
            : this.saveRecordingImages));
  }
}

@JsonSerializable(explicitToJson: true)
class LiveTvServiceInfo {
  const LiveTvServiceInfo({
    this.name,
    this.homePageUrl,
    this.status,
    this.statusMessage,
    this.version,
    this.hasUpdateAvailable,
    this.isVisible,
    this.tuners,
  });

  factory LiveTvServiceInfo.fromJson(Map<String, dynamic> json) =>
      _$LiveTvServiceInfoFromJson(json);

  static const toJsonFactory = _$LiveTvServiceInfoToJson;
  Map<String, dynamic> toJson() => _$LiveTvServiceInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'HomePageUrl')
  final String? homePageUrl;
  @JsonKey(
    name: 'Status',
    toJson: liveTvServiceStatusNullableToJson,
    fromJson: liveTvServiceStatusNullableFromJson,
  )
  final enums.LiveTvServiceStatus? status;
  @JsonKey(name: 'StatusMessage')
  final String? statusMessage;
  @JsonKey(name: 'Version')
  final String? version;
  @JsonKey(name: 'HasUpdateAvailable')
  final bool? hasUpdateAvailable;
  @JsonKey(name: 'IsVisible')
  final bool? isVisible;
  @JsonKey(name: 'Tuners', defaultValue: <String>[])
  final List<String>? tuners;
  static const fromJsonFactory = _$LiveTvServiceInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LiveTvServiceInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.homePageUrl, homePageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.homePageUrl, homePageUrl)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.statusMessage, statusMessage) ||
                const DeepCollectionEquality()
                    .equals(other.statusMessage, statusMessage)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.hasUpdateAvailable, hasUpdateAvailable) ||
                const DeepCollectionEquality()
                    .equals(other.hasUpdateAvailable, hasUpdateAvailable)) &&
            (identical(other.isVisible, isVisible) ||
                const DeepCollectionEquality()
                    .equals(other.isVisible, isVisible)) &&
            (identical(other.tuners, tuners) ||
                const DeepCollectionEquality().equals(other.tuners, tuners)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(homePageUrl) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(statusMessage) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(hasUpdateAvailable) ^
      const DeepCollectionEquality().hash(isVisible) ^
      const DeepCollectionEquality().hash(tuners) ^
      runtimeType.hashCode;
}

extension $LiveTvServiceInfoExtension on LiveTvServiceInfo {
  LiveTvServiceInfo copyWith(
      {String? name,
      String? homePageUrl,
      enums.LiveTvServiceStatus? status,
      String? statusMessage,
      String? version,
      bool? hasUpdateAvailable,
      bool? isVisible,
      List<String>? tuners}) {
    return LiveTvServiceInfo(
        name: name ?? this.name,
        homePageUrl: homePageUrl ?? this.homePageUrl,
        status: status ?? this.status,
        statusMessage: statusMessage ?? this.statusMessage,
        version: version ?? this.version,
        hasUpdateAvailable: hasUpdateAvailable ?? this.hasUpdateAvailable,
        isVisible: isVisible ?? this.isVisible,
        tuners: tuners ?? this.tuners);
  }

  LiveTvServiceInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? homePageUrl,
      Wrapped<enums.LiveTvServiceStatus?>? status,
      Wrapped<String?>? statusMessage,
      Wrapped<String?>? version,
      Wrapped<bool?>? hasUpdateAvailable,
      Wrapped<bool?>? isVisible,
      Wrapped<List<String>?>? tuners}) {
    return LiveTvServiceInfo(
        name: (name != null ? name.value : this.name),
        homePageUrl:
            (homePageUrl != null ? homePageUrl.value : this.homePageUrl),
        status: (status != null ? status.value : this.status),
        statusMessage:
            (statusMessage != null ? statusMessage.value : this.statusMessage),
        version: (version != null ? version.value : this.version),
        hasUpdateAvailable: (hasUpdateAvailable != null
            ? hasUpdateAvailable.value
            : this.hasUpdateAvailable),
        isVisible: (isVisible != null ? isVisible.value : this.isVisible),
        tuners: (tuners != null ? tuners.value : this.tuners));
  }
}

@JsonSerializable(explicitToJson: true)
class LocalizationOption {
  const LocalizationOption({
    this.name,
    this.$Value,
  });

  factory LocalizationOption.fromJson(Map<String, dynamic> json) =>
      _$LocalizationOptionFromJson(json);

  static const toJsonFactory = _$LocalizationOptionToJson;
  Map<String, dynamic> toJson() => _$LocalizationOptionToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Value')
  final String? $Value;
  static const fromJsonFactory = _$LocalizationOptionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LocalizationOption &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$Value, $Value) ||
                const DeepCollectionEquality().equals(other.$Value, $Value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($Value) ^
      runtimeType.hashCode;
}

extension $LocalizationOptionExtension on LocalizationOption {
  LocalizationOption copyWith({String? name, String? $Value}) {
    return LocalizationOption(
        name: name ?? this.name, $Value: $Value ?? this.$Value);
  }

  LocalizationOption copyWithWrapped(
      {Wrapped<String?>? name, Wrapped<String?>? $Value}) {
    return LocalizationOption(
        name: (name != null ? name.value : this.name),
        $Value: ($Value != null ? $Value.value : this.$Value));
  }
}

@JsonSerializable(explicitToJson: true)
class LogFile {
  const LogFile({
    this.dateCreated,
    this.dateModified,
    this.size,
    this.name,
  });

  factory LogFile.fromJson(Map<String, dynamic> json) =>
      _$LogFileFromJson(json);

  static const toJsonFactory = _$LogFileToJson;
  Map<String, dynamic> toJson() => _$LogFileToJson(this);

  @JsonKey(name: 'DateCreated')
  final DateTime? dateCreated;
  @JsonKey(name: 'DateModified')
  final DateTime? dateModified;
  @JsonKey(name: 'Size')
  final int? size;
  @JsonKey(name: 'Name')
  final String? name;
  static const fromJsonFactory = _$LogFileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LogFile &&
            (identical(other.dateCreated, dateCreated) ||
                const DeepCollectionEquality()
                    .equals(other.dateCreated, dateCreated)) &&
            (identical(other.dateModified, dateModified) ||
                const DeepCollectionEquality()
                    .equals(other.dateModified, dateModified)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dateCreated) ^
      const DeepCollectionEquality().hash(dateModified) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $LogFileExtension on LogFile {
  LogFile copyWith(
      {DateTime? dateCreated,
      DateTime? dateModified,
      int? size,
      String? name}) {
    return LogFile(
        dateCreated: dateCreated ?? this.dateCreated,
        dateModified: dateModified ?? this.dateModified,
        size: size ?? this.size,
        name: name ?? this.name);
  }

  LogFile copyWithWrapped(
      {Wrapped<DateTime?>? dateCreated,
      Wrapped<DateTime?>? dateModified,
      Wrapped<int?>? size,
      Wrapped<String?>? name}) {
    return LogFile(
        dateCreated:
            (dateCreated != null ? dateCreated.value : this.dateCreated),
        dateModified:
            (dateModified != null ? dateModified.value : this.dateModified),
        size: (size != null ? size.value : this.size),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class LyricDto {
  const LyricDto({
    this.metadata,
    this.lyrics,
  });

  factory LyricDto.fromJson(Map<String, dynamic> json) =>
      _$LyricDtoFromJson(json);

  static const toJsonFactory = _$LyricDtoToJson;
  Map<String, dynamic> toJson() => _$LyricDtoToJson(this);

  @JsonKey(name: 'Metadata')
  final LyricMetadata? metadata;
  @JsonKey(name: 'Lyrics', defaultValue: <LyricLine>[])
  final List<LyricLine>? lyrics;
  static const fromJsonFactory = _$LyricDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LyricDto &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.lyrics, lyrics) ||
                const DeepCollectionEquality().equals(other.lyrics, lyrics)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(lyrics) ^
      runtimeType.hashCode;
}

extension $LyricDtoExtension on LyricDto {
  LyricDto copyWith({LyricMetadata? metadata, List<LyricLine>? lyrics}) {
    return LyricDto(
        metadata: metadata ?? this.metadata, lyrics: lyrics ?? this.lyrics);
  }

  LyricDto copyWithWrapped(
      {Wrapped<LyricMetadata?>? metadata, Wrapped<List<LyricLine>?>? lyrics}) {
    return LyricDto(
        metadata: (metadata != null ? metadata.value : this.metadata),
        lyrics: (lyrics != null ? lyrics.value : this.lyrics));
  }
}

@JsonSerializable(explicitToJson: true)
class LyricLine {
  const LyricLine({
    this.text,
    this.start,
  });

  factory LyricLine.fromJson(Map<String, dynamic> json) =>
      _$LyricLineFromJson(json);

  static const toJsonFactory = _$LyricLineToJson;
  Map<String, dynamic> toJson() => _$LyricLineToJson(this);

  @JsonKey(name: 'Text')
  final String? text;
  @JsonKey(name: 'Start')
  final int? start;
  static const fromJsonFactory = _$LyricLineFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LyricLine &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.start, start) ||
                const DeepCollectionEquality().equals(other.start, start)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(start) ^
      runtimeType.hashCode;
}

extension $LyricLineExtension on LyricLine {
  LyricLine copyWith({String? text, int? start}) {
    return LyricLine(text: text ?? this.text, start: start ?? this.start);
  }

  LyricLine copyWithWrapped({Wrapped<String?>? text, Wrapped<int?>? start}) {
    return LyricLine(
        text: (text != null ? text.value : this.text),
        start: (start != null ? start.value : this.start));
  }
}

@JsonSerializable(explicitToJson: true)
class LyricMetadata {
  const LyricMetadata({
    this.artist,
    this.album,
    this.title,
    this.author,
    this.length,
    this.by,
    this.offset,
    this.creator,
    this.version,
    this.isSynced,
  });

  factory LyricMetadata.fromJson(Map<String, dynamic> json) =>
      _$LyricMetadataFromJson(json);

  static const toJsonFactory = _$LyricMetadataToJson;
  Map<String, dynamic> toJson() => _$LyricMetadataToJson(this);

  @JsonKey(name: 'Artist')
  final String? artist;
  @JsonKey(name: 'Album')
  final String? album;
  @JsonKey(name: 'Title')
  final String? title;
  @JsonKey(name: 'Author')
  final String? author;
  @JsonKey(name: 'Length')
  final int? length;
  @JsonKey(name: 'By')
  final String? by;
  @JsonKey(name: 'Offset')
  final int? offset;
  @JsonKey(name: 'Creator')
  final String? creator;
  @JsonKey(name: 'Version')
  final String? version;
  @JsonKey(name: 'IsSynced')
  final bool? isSynced;
  static const fromJsonFactory = _$LyricMetadataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LyricMetadata &&
            (identical(other.artist, artist) ||
                const DeepCollectionEquality().equals(other.artist, artist)) &&
            (identical(other.album, album) ||
                const DeepCollectionEquality().equals(other.album, album)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.length, length) ||
                const DeepCollectionEquality().equals(other.length, length)) &&
            (identical(other.by, by) ||
                const DeepCollectionEquality().equals(other.by, by)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.creator, creator) ||
                const DeepCollectionEquality()
                    .equals(other.creator, creator)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.isSynced, isSynced) ||
                const DeepCollectionEquality()
                    .equals(other.isSynced, isSynced)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(artist) ^
      const DeepCollectionEquality().hash(album) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(length) ^
      const DeepCollectionEquality().hash(by) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(creator) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(isSynced) ^
      runtimeType.hashCode;
}

extension $LyricMetadataExtension on LyricMetadata {
  LyricMetadata copyWith(
      {String? artist,
      String? album,
      String? title,
      String? author,
      int? length,
      String? by,
      int? offset,
      String? creator,
      String? version,
      bool? isSynced}) {
    return LyricMetadata(
        artist: artist ?? this.artist,
        album: album ?? this.album,
        title: title ?? this.title,
        author: author ?? this.author,
        length: length ?? this.length,
        by: by ?? this.by,
        offset: offset ?? this.offset,
        creator: creator ?? this.creator,
        version: version ?? this.version,
        isSynced: isSynced ?? this.isSynced);
  }

  LyricMetadata copyWithWrapped(
      {Wrapped<String?>? artist,
      Wrapped<String?>? album,
      Wrapped<String?>? title,
      Wrapped<String?>? author,
      Wrapped<int?>? length,
      Wrapped<String?>? by,
      Wrapped<int?>? offset,
      Wrapped<String?>? creator,
      Wrapped<String?>? version,
      Wrapped<bool?>? isSynced}) {
    return LyricMetadata(
        artist: (artist != null ? artist.value : this.artist),
        album: (album != null ? album.value : this.album),
        title: (title != null ? title.value : this.title),
        author: (author != null ? author.value : this.author),
        length: (length != null ? length.value : this.length),
        by: (by != null ? by.value : this.by),
        offset: (offset != null ? offset.value : this.offset),
        creator: (creator != null ? creator.value : this.creator),
        version: (version != null ? version.value : this.version),
        isSynced: (isSynced != null ? isSynced.value : this.isSynced));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaAttachment {
  const MediaAttachment({
    this.codec,
    this.codecTag,
    this.comment,
    this.index,
    this.fileName,
    this.mimeType,
    this.deliveryUrl,
  });

  factory MediaAttachment.fromJson(Map<String, dynamic> json) =>
      _$MediaAttachmentFromJson(json);

  static const toJsonFactory = _$MediaAttachmentToJson;
  Map<String, dynamic> toJson() => _$MediaAttachmentToJson(this);

  @JsonKey(name: 'Codec')
  final String? codec;
  @JsonKey(name: 'CodecTag')
  final String? codecTag;
  @JsonKey(name: 'Comment')
  final String? comment;
  @JsonKey(name: 'Index')
  final int? index;
  @JsonKey(name: 'FileName')
  final String? fileName;
  @JsonKey(name: 'MimeType')
  final String? mimeType;
  @JsonKey(name: 'DeliveryUrl')
  final String? deliveryUrl;
  static const fromJsonFactory = _$MediaAttachmentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaAttachment &&
            (identical(other.codec, codec) ||
                const DeepCollectionEquality().equals(other.codec, codec)) &&
            (identical(other.codecTag, codecTag) ||
                const DeepCollectionEquality()
                    .equals(other.codecTag, codecTag)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.index, index) ||
                const DeepCollectionEquality().equals(other.index, index)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.mimeType, mimeType) ||
                const DeepCollectionEquality()
                    .equals(other.mimeType, mimeType)) &&
            (identical(other.deliveryUrl, deliveryUrl) ||
                const DeepCollectionEquality()
                    .equals(other.deliveryUrl, deliveryUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(codec) ^
      const DeepCollectionEquality().hash(codecTag) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(index) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(mimeType) ^
      const DeepCollectionEquality().hash(deliveryUrl) ^
      runtimeType.hashCode;
}

extension $MediaAttachmentExtension on MediaAttachment {
  MediaAttachment copyWith(
      {String? codec,
      String? codecTag,
      String? comment,
      int? index,
      String? fileName,
      String? mimeType,
      String? deliveryUrl}) {
    return MediaAttachment(
        codec: codec ?? this.codec,
        codecTag: codecTag ?? this.codecTag,
        comment: comment ?? this.comment,
        index: index ?? this.index,
        fileName: fileName ?? this.fileName,
        mimeType: mimeType ?? this.mimeType,
        deliveryUrl: deliveryUrl ?? this.deliveryUrl);
  }

  MediaAttachment copyWithWrapped(
      {Wrapped<String?>? codec,
      Wrapped<String?>? codecTag,
      Wrapped<String?>? comment,
      Wrapped<int?>? index,
      Wrapped<String?>? fileName,
      Wrapped<String?>? mimeType,
      Wrapped<String?>? deliveryUrl}) {
    return MediaAttachment(
        codec: (codec != null ? codec.value : this.codec),
        codecTag: (codecTag != null ? codecTag.value : this.codecTag),
        comment: (comment != null ? comment.value : this.comment),
        index: (index != null ? index.value : this.index),
        fileName: (fileName != null ? fileName.value : this.fileName),
        mimeType: (mimeType != null ? mimeType.value : this.mimeType),
        deliveryUrl:
            (deliveryUrl != null ? deliveryUrl.value : this.deliveryUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaPathDto {
  const MediaPathDto({
    required this.name,
    this.path,
    this.pathInfo,
  });

  factory MediaPathDto.fromJson(Map<String, dynamic> json) =>
      _$MediaPathDtoFromJson(json);

  static const toJsonFactory = _$MediaPathDtoToJson;
  Map<String, dynamic> toJson() => _$MediaPathDtoToJson(this);

  @JsonKey(name: 'Name')
  final String name;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'PathInfo')
  final MediaPathInfo? pathInfo;
  static const fromJsonFactory = _$MediaPathDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaPathDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.pathInfo, pathInfo) ||
                const DeepCollectionEquality()
                    .equals(other.pathInfo, pathInfo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(pathInfo) ^
      runtimeType.hashCode;
}

extension $MediaPathDtoExtension on MediaPathDto {
  MediaPathDto copyWith({String? name, String? path, MediaPathInfo? pathInfo}) {
    return MediaPathDto(
        name: name ?? this.name,
        path: path ?? this.path,
        pathInfo: pathInfo ?? this.pathInfo);
  }

  MediaPathDto copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? path,
      Wrapped<MediaPathInfo?>? pathInfo}) {
    return MediaPathDto(
        name: (name != null ? name.value : this.name),
        path: (path != null ? path.value : this.path),
        pathInfo: (pathInfo != null ? pathInfo.value : this.pathInfo));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaPathInfo {
  const MediaPathInfo({
    this.path,
  });

  factory MediaPathInfo.fromJson(Map<String, dynamic> json) =>
      _$MediaPathInfoFromJson(json);

  static const toJsonFactory = _$MediaPathInfoToJson;
  Map<String, dynamic> toJson() => _$MediaPathInfoToJson(this);

  @JsonKey(name: 'Path')
  final String? path;
  static const fromJsonFactory = _$MediaPathInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaPathInfo &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(path) ^ runtimeType.hashCode;
}

extension $MediaPathInfoExtension on MediaPathInfo {
  MediaPathInfo copyWith({String? path}) {
    return MediaPathInfo(path: path ?? this.path);
  }

  MediaPathInfo copyWithWrapped({Wrapped<String?>? path}) {
    return MediaPathInfo(path: (path != null ? path.value : this.path));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaSegmentDto {
  const MediaSegmentDto({
    this.id,
    this.itemId,
    this.type,
    this.startTicks,
    this.endTicks,
  });

  factory MediaSegmentDto.fromJson(Map<String, dynamic> json) =>
      _$MediaSegmentDtoFromJson(json);

  static const toJsonFactory = _$MediaSegmentDtoToJson;
  Map<String, dynamic> toJson() => _$MediaSegmentDtoToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(
    name: 'Type',
    toJson: mediaSegmentTypeNullableToJson,
    fromJson: mediaSegmentTypeNullableFromJson,
  )
  final enums.MediaSegmentType? type;
  @JsonKey(name: 'StartTicks')
  final int? startTicks;
  @JsonKey(name: 'EndTicks')
  final int? endTicks;
  static const fromJsonFactory = _$MediaSegmentDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaSegmentDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.startTicks, startTicks) ||
                const DeepCollectionEquality()
                    .equals(other.startTicks, startTicks)) &&
            (identical(other.endTicks, endTicks) ||
                const DeepCollectionEquality()
                    .equals(other.endTicks, endTicks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(startTicks) ^
      const DeepCollectionEquality().hash(endTicks) ^
      runtimeType.hashCode;
}

extension $MediaSegmentDtoExtension on MediaSegmentDto {
  MediaSegmentDto copyWith(
      {String? id,
      String? itemId,
      enums.MediaSegmentType? type,
      int? startTicks,
      int? endTicks}) {
    return MediaSegmentDto(
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        type: type ?? this.type,
        startTicks: startTicks ?? this.startTicks,
        endTicks: endTicks ?? this.endTicks);
  }

  MediaSegmentDto copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? itemId,
      Wrapped<enums.MediaSegmentType?>? type,
      Wrapped<int?>? startTicks,
      Wrapped<int?>? endTicks}) {
    return MediaSegmentDto(
        id: (id != null ? id.value : this.id),
        itemId: (itemId != null ? itemId.value : this.itemId),
        type: (type != null ? type.value : this.type),
        startTicks: (startTicks != null ? startTicks.value : this.startTicks),
        endTicks: (endTicks != null ? endTicks.value : this.endTicks));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaSegmentDtoQueryResult {
  const MediaSegmentDtoQueryResult({
    this.items,
    this.totalRecordCount,
    this.startIndex,
  });

  factory MediaSegmentDtoQueryResult.fromJson(Map<String, dynamic> json) =>
      _$MediaSegmentDtoQueryResultFromJson(json);

  static const toJsonFactory = _$MediaSegmentDtoQueryResultToJson;
  Map<String, dynamic> toJson() => _$MediaSegmentDtoQueryResultToJson(this);

  @JsonKey(name: 'Items', defaultValue: <MediaSegmentDto>[])
  final List<MediaSegmentDto>? items;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  static const fromJsonFactory = _$MediaSegmentDtoQueryResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaSegmentDtoQueryResult &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      const DeepCollectionEquality().hash(startIndex) ^
      runtimeType.hashCode;
}

extension $MediaSegmentDtoQueryResultExtension on MediaSegmentDtoQueryResult {
  MediaSegmentDtoQueryResult copyWith(
      {List<MediaSegmentDto>? items, int? totalRecordCount, int? startIndex}) {
    return MediaSegmentDtoQueryResult(
        items: items ?? this.items,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount,
        startIndex: startIndex ?? this.startIndex);
  }

  MediaSegmentDtoQueryResult copyWithWrapped(
      {Wrapped<List<MediaSegmentDto>?>? items,
      Wrapped<int?>? totalRecordCount,
      Wrapped<int?>? startIndex}) {
    return MediaSegmentDtoQueryResult(
        items: (items != null ? items.value : this.items),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaSourceInfo {
  const MediaSourceInfo({
    this.protocol,
    this.id,
    this.path,
    this.encoderPath,
    this.encoderProtocol,
    this.type,
    this.container,
    this.size,
    this.name,
    this.isRemote,
    this.eTag,
    this.runTimeTicks,
    this.readAtNativeFramerate,
    this.ignoreDts,
    this.ignoreIndex,
    this.genPtsInput,
    this.supportsTranscoding,
    this.supportsDirectStream,
    this.supportsDirectPlay,
    this.isInfiniteStream,
    this.useMostCompatibleTranscodingProfile,
    this.requiresOpening,
    this.openToken,
    this.requiresClosing,
    this.liveStreamId,
    this.bufferMs,
    this.requiresLooping,
    this.supportsProbing,
    this.videoType,
    this.isoType,
    this.video3DFormat,
    this.mediaStreams,
    this.mediaAttachments,
    this.formats,
    this.bitrate,
    this.fallbackMaxStreamingBitrate,
    this.timestamp,
    this.requiredHttpHeaders,
    this.transcodingUrl,
    this.transcodingSubProtocol,
    this.transcodingContainer,
    this.analyzeDurationMs,
    this.defaultAudioStreamIndex,
    this.defaultSubtitleStreamIndex,
    this.hasSegments,
  });

  factory MediaSourceInfo.fromJson(Map<String, dynamic> json) =>
      _$MediaSourceInfoFromJson(json);

  static const toJsonFactory = _$MediaSourceInfoToJson;
  Map<String, dynamic> toJson() => _$MediaSourceInfoToJson(this);

  @JsonKey(
    name: 'Protocol',
    toJson: mediaProtocolNullableToJson,
    fromJson: mediaProtocolNullableFromJson,
  )
  final enums.MediaProtocol? protocol;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'EncoderPath')
  final String? encoderPath;
  @JsonKey(
    name: 'EncoderProtocol',
    toJson: mediaProtocolNullableToJson,
    fromJson: mediaProtocolNullableFromJson,
  )
  final enums.MediaProtocol? encoderProtocol;
  @JsonKey(
    name: 'Type',
    toJson: mediaSourceTypeNullableToJson,
    fromJson: mediaSourceTypeNullableFromJson,
  )
  final enums.MediaSourceType? type;
  @JsonKey(name: 'Container')
  final String? container;
  @JsonKey(name: 'Size')
  final int? size;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'IsRemote')
  final bool? isRemote;
  @JsonKey(name: 'ETag')
  final String? eTag;
  @JsonKey(name: 'RunTimeTicks')
  final int? runTimeTicks;
  @JsonKey(name: 'ReadAtNativeFramerate')
  final bool? readAtNativeFramerate;
  @JsonKey(name: 'IgnoreDts')
  final bool? ignoreDts;
  @JsonKey(name: 'IgnoreIndex')
  final bool? ignoreIndex;
  @JsonKey(name: 'GenPtsInput')
  final bool? genPtsInput;
  @JsonKey(name: 'SupportsTranscoding')
  final bool? supportsTranscoding;
  @JsonKey(name: 'SupportsDirectStream')
  final bool? supportsDirectStream;
  @JsonKey(name: 'SupportsDirectPlay')
  final bool? supportsDirectPlay;
  @JsonKey(name: 'IsInfiniteStream')
  final bool? isInfiniteStream;
  @JsonKey(name: 'UseMostCompatibleTranscodingProfile', defaultValue: false)
  final bool? useMostCompatibleTranscodingProfile;
  @JsonKey(name: 'RequiresOpening')
  final bool? requiresOpening;
  @JsonKey(name: 'OpenToken')
  final String? openToken;
  @JsonKey(name: 'RequiresClosing')
  final bool? requiresClosing;
  @JsonKey(name: 'LiveStreamId')
  final String? liveStreamId;
  @JsonKey(name: 'BufferMs')
  final int? bufferMs;
  @JsonKey(name: 'RequiresLooping')
  final bool? requiresLooping;
  @JsonKey(name: 'SupportsProbing')
  final bool? supportsProbing;
  @JsonKey(
    name: 'VideoType',
    toJson: videoTypeNullableToJson,
    fromJson: videoTypeNullableFromJson,
  )
  final enums.VideoType? videoType;
  @JsonKey(
    name: 'IsoType',
    toJson: isoTypeNullableToJson,
    fromJson: isoTypeNullableFromJson,
  )
  final enums.IsoType? isoType;
  @JsonKey(
    name: 'Video3DFormat',
    toJson: video3DFormatNullableToJson,
    fromJson: video3DFormatNullableFromJson,
  )
  final enums.Video3DFormat? video3DFormat;
  @JsonKey(name: 'MediaStreams', defaultValue: <MediaStream>[])
  final List<MediaStream>? mediaStreams;
  @JsonKey(name: 'MediaAttachments', defaultValue: <MediaAttachment>[])
  final List<MediaAttachment>? mediaAttachments;
  @JsonKey(name: 'Formats', defaultValue: <String>[])
  final List<String>? formats;
  @JsonKey(name: 'Bitrate')
  final int? bitrate;
  @JsonKey(name: 'FallbackMaxStreamingBitrate')
  final int? fallbackMaxStreamingBitrate;
  @JsonKey(
    name: 'Timestamp',
    toJson: transportStreamTimestampNullableToJson,
    fromJson: transportStreamTimestampNullableFromJson,
  )
  final enums.TransportStreamTimestamp? timestamp;
  @JsonKey(name: 'RequiredHttpHeaders')
  final Map<String, dynamic>? requiredHttpHeaders;
  @JsonKey(name: 'TranscodingUrl')
  final String? transcodingUrl;
  @JsonKey(
    name: 'TranscodingSubProtocol',
    toJson: mediaStreamProtocolNullableToJson,
    fromJson: mediaStreamProtocolNullableFromJson,
  )
  final enums.MediaStreamProtocol? transcodingSubProtocol;
  @JsonKey(name: 'TranscodingContainer')
  final String? transcodingContainer;
  @JsonKey(name: 'AnalyzeDurationMs')
  final int? analyzeDurationMs;
  @JsonKey(name: 'DefaultAudioStreamIndex')
  final int? defaultAudioStreamIndex;
  @JsonKey(name: 'DefaultSubtitleStreamIndex')
  final int? defaultSubtitleStreamIndex;
  @JsonKey(name: 'HasSegments')
  final bool? hasSegments;
  static const fromJsonFactory = _$MediaSourceInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaSourceInfo &&
            (identical(other.protocol, protocol) ||
                const DeepCollectionEquality()
                    .equals(other.protocol, protocol)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.encoderPath, encoderPath) ||
                const DeepCollectionEquality()
                    .equals(other.encoderPath, encoderPath)) &&
            (identical(other.encoderProtocol, encoderProtocol) ||
                const DeepCollectionEquality()
                    .equals(other.encoderProtocol, encoderProtocol)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isRemote, isRemote) ||
                const DeepCollectionEquality()
                    .equals(other.isRemote, isRemote)) &&
            (identical(other.eTag, eTag) ||
                const DeepCollectionEquality().equals(other.eTag, eTag)) &&
            (identical(other.runTimeTicks, runTimeTicks) ||
                const DeepCollectionEquality()
                    .equals(other.runTimeTicks, runTimeTicks)) &&
            (identical(other.readAtNativeFramerate, readAtNativeFramerate) ||
                const DeepCollectionEquality().equals(
                    other.readAtNativeFramerate, readAtNativeFramerate)) &&
            (identical(other.ignoreDts, ignoreDts) ||
                const DeepCollectionEquality()
                    .equals(other.ignoreDts, ignoreDts)) &&
            (identical(other.ignoreIndex, ignoreIndex) ||
                const DeepCollectionEquality()
                    .equals(other.ignoreIndex, ignoreIndex)) &&
            (identical(other.genPtsInput, genPtsInput) ||
                const DeepCollectionEquality()
                    .equals(other.genPtsInput, genPtsInput)) &&
            (identical(other.supportsTranscoding, supportsTranscoding) ||
                const DeepCollectionEquality()
                    .equals(other.supportsTranscoding, supportsTranscoding)) &&
            (identical(other.supportsDirectStream, supportsDirectStream) ||
                const DeepCollectionEquality().equals(
                    other.supportsDirectStream, supportsDirectStream)) &&
            (identical(other.supportsDirectPlay, supportsDirectPlay) ||
                const DeepCollectionEquality()
                    .equals(other.supportsDirectPlay, supportsDirectPlay)) &&
            (identical(other.isInfiniteStream, isInfiniteStream) ||
                const DeepCollectionEquality()
                    .equals(other.isInfiniteStream, isInfiniteStream)) &&
            (identical(other.useMostCompatibleTranscodingProfile, useMostCompatibleTranscodingProfile) ||
                const DeepCollectionEquality().equals(
                    other.useMostCompatibleTranscodingProfile,
                    useMostCompatibleTranscodingProfile)) &&
            (identical(other.requiresOpening, requiresOpening) ||
                const DeepCollectionEquality()
                    .equals(other.requiresOpening, requiresOpening)) &&
            (identical(other.openToken, openToken) ||
                const DeepCollectionEquality()
                    .equals(other.openToken, openToken)) &&
            (identical(other.requiresClosing, requiresClosing) ||
                const DeepCollectionEquality().equals(other.requiresClosing, requiresClosing)) &&
            (identical(other.liveStreamId, liveStreamId) || const DeepCollectionEquality().equals(other.liveStreamId, liveStreamId)) &&
            (identical(other.bufferMs, bufferMs) || const DeepCollectionEquality().equals(other.bufferMs, bufferMs)) &&
            (identical(other.requiresLooping, requiresLooping) || const DeepCollectionEquality().equals(other.requiresLooping, requiresLooping)) &&
            (identical(other.supportsProbing, supportsProbing) || const DeepCollectionEquality().equals(other.supportsProbing, supportsProbing)) &&
            (identical(other.videoType, videoType) || const DeepCollectionEquality().equals(other.videoType, videoType)) &&
            (identical(other.isoType, isoType) || const DeepCollectionEquality().equals(other.isoType, isoType)) &&
            (identical(other.video3DFormat, video3DFormat) || const DeepCollectionEquality().equals(other.video3DFormat, video3DFormat)) &&
            (identical(other.mediaStreams, mediaStreams) || const DeepCollectionEquality().equals(other.mediaStreams, mediaStreams)) &&
            (identical(other.mediaAttachments, mediaAttachments) || const DeepCollectionEquality().equals(other.mediaAttachments, mediaAttachments)) &&
            (identical(other.formats, formats) || const DeepCollectionEquality().equals(other.formats, formats)) &&
            (identical(other.bitrate, bitrate) || const DeepCollectionEquality().equals(other.bitrate, bitrate)) &&
            (identical(other.fallbackMaxStreamingBitrate, fallbackMaxStreamingBitrate) || const DeepCollectionEquality().equals(other.fallbackMaxStreamingBitrate, fallbackMaxStreamingBitrate)) &&
            (identical(other.timestamp, timestamp) || const DeepCollectionEquality().equals(other.timestamp, timestamp)) &&
            (identical(other.requiredHttpHeaders, requiredHttpHeaders) || const DeepCollectionEquality().equals(other.requiredHttpHeaders, requiredHttpHeaders)) &&
            (identical(other.transcodingUrl, transcodingUrl) || const DeepCollectionEquality().equals(other.transcodingUrl, transcodingUrl)) &&
            (identical(other.transcodingSubProtocol, transcodingSubProtocol) || const DeepCollectionEquality().equals(other.transcodingSubProtocol, transcodingSubProtocol)) &&
            (identical(other.transcodingContainer, transcodingContainer) || const DeepCollectionEquality().equals(other.transcodingContainer, transcodingContainer)) &&
            (identical(other.analyzeDurationMs, analyzeDurationMs) || const DeepCollectionEquality().equals(other.analyzeDurationMs, analyzeDurationMs)) &&
            (identical(other.defaultAudioStreamIndex, defaultAudioStreamIndex) || const DeepCollectionEquality().equals(other.defaultAudioStreamIndex, defaultAudioStreamIndex)) &&
            (identical(other.defaultSubtitleStreamIndex, defaultSubtitleStreamIndex) || const DeepCollectionEquality().equals(other.defaultSubtitleStreamIndex, defaultSubtitleStreamIndex)) &&
            (identical(other.hasSegments, hasSegments) || const DeepCollectionEquality().equals(other.hasSegments, hasSegments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(protocol) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(encoderPath) ^
      const DeepCollectionEquality().hash(encoderProtocol) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(container) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isRemote) ^
      const DeepCollectionEquality().hash(eTag) ^
      const DeepCollectionEquality().hash(runTimeTicks) ^
      const DeepCollectionEquality().hash(readAtNativeFramerate) ^
      const DeepCollectionEquality().hash(ignoreDts) ^
      const DeepCollectionEquality().hash(ignoreIndex) ^
      const DeepCollectionEquality().hash(genPtsInput) ^
      const DeepCollectionEquality().hash(supportsTranscoding) ^
      const DeepCollectionEquality().hash(supportsDirectStream) ^
      const DeepCollectionEquality().hash(supportsDirectPlay) ^
      const DeepCollectionEquality().hash(isInfiniteStream) ^
      const DeepCollectionEquality().hash(useMostCompatibleTranscodingProfile) ^
      const DeepCollectionEquality().hash(requiresOpening) ^
      const DeepCollectionEquality().hash(openToken) ^
      const DeepCollectionEquality().hash(requiresClosing) ^
      const DeepCollectionEquality().hash(liveStreamId) ^
      const DeepCollectionEquality().hash(bufferMs) ^
      const DeepCollectionEquality().hash(requiresLooping) ^
      const DeepCollectionEquality().hash(supportsProbing) ^
      const DeepCollectionEquality().hash(videoType) ^
      const DeepCollectionEquality().hash(isoType) ^
      const DeepCollectionEquality().hash(video3DFormat) ^
      const DeepCollectionEquality().hash(mediaStreams) ^
      const DeepCollectionEquality().hash(mediaAttachments) ^
      const DeepCollectionEquality().hash(formats) ^
      const DeepCollectionEquality().hash(bitrate) ^
      const DeepCollectionEquality().hash(fallbackMaxStreamingBitrate) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(requiredHttpHeaders) ^
      const DeepCollectionEquality().hash(transcodingUrl) ^
      const DeepCollectionEquality().hash(transcodingSubProtocol) ^
      const DeepCollectionEquality().hash(transcodingContainer) ^
      const DeepCollectionEquality().hash(analyzeDurationMs) ^
      const DeepCollectionEquality().hash(defaultAudioStreamIndex) ^
      const DeepCollectionEquality().hash(defaultSubtitleStreamIndex) ^
      const DeepCollectionEquality().hash(hasSegments) ^
      runtimeType.hashCode;
}

extension $MediaSourceInfoExtension on MediaSourceInfo {
  MediaSourceInfo copyWith(
      {enums.MediaProtocol? protocol,
      String? id,
      String? path,
      String? encoderPath,
      enums.MediaProtocol? encoderProtocol,
      enums.MediaSourceType? type,
      String? container,
      int? size,
      String? name,
      bool? isRemote,
      String? eTag,
      int? runTimeTicks,
      bool? readAtNativeFramerate,
      bool? ignoreDts,
      bool? ignoreIndex,
      bool? genPtsInput,
      bool? supportsTranscoding,
      bool? supportsDirectStream,
      bool? supportsDirectPlay,
      bool? isInfiniteStream,
      bool? useMostCompatibleTranscodingProfile,
      bool? requiresOpening,
      String? openToken,
      bool? requiresClosing,
      String? liveStreamId,
      int? bufferMs,
      bool? requiresLooping,
      bool? supportsProbing,
      enums.VideoType? videoType,
      enums.IsoType? isoType,
      enums.Video3DFormat? video3DFormat,
      List<MediaStream>? mediaStreams,
      List<MediaAttachment>? mediaAttachments,
      List<String>? formats,
      int? bitrate,
      int? fallbackMaxStreamingBitrate,
      enums.TransportStreamTimestamp? timestamp,
      Map<String, dynamic>? requiredHttpHeaders,
      String? transcodingUrl,
      enums.MediaStreamProtocol? transcodingSubProtocol,
      String? transcodingContainer,
      int? analyzeDurationMs,
      int? defaultAudioStreamIndex,
      int? defaultSubtitleStreamIndex,
      bool? hasSegments}) {
    return MediaSourceInfo(
        protocol: protocol ?? this.protocol,
        id: id ?? this.id,
        path: path ?? this.path,
        encoderPath: encoderPath ?? this.encoderPath,
        encoderProtocol: encoderProtocol ?? this.encoderProtocol,
        type: type ?? this.type,
        container: container ?? this.container,
        size: size ?? this.size,
        name: name ?? this.name,
        isRemote: isRemote ?? this.isRemote,
        eTag: eTag ?? this.eTag,
        runTimeTicks: runTimeTicks ?? this.runTimeTicks,
        readAtNativeFramerate:
            readAtNativeFramerate ?? this.readAtNativeFramerate,
        ignoreDts: ignoreDts ?? this.ignoreDts,
        ignoreIndex: ignoreIndex ?? this.ignoreIndex,
        genPtsInput: genPtsInput ?? this.genPtsInput,
        supportsTranscoding: supportsTranscoding ?? this.supportsTranscoding,
        supportsDirectStream: supportsDirectStream ?? this.supportsDirectStream,
        supportsDirectPlay: supportsDirectPlay ?? this.supportsDirectPlay,
        isInfiniteStream: isInfiniteStream ?? this.isInfiniteStream,
        useMostCompatibleTranscodingProfile:
            useMostCompatibleTranscodingProfile ??
                this.useMostCompatibleTranscodingProfile,
        requiresOpening: requiresOpening ?? this.requiresOpening,
        openToken: openToken ?? this.openToken,
        requiresClosing: requiresClosing ?? this.requiresClosing,
        liveStreamId: liveStreamId ?? this.liveStreamId,
        bufferMs: bufferMs ?? this.bufferMs,
        requiresLooping: requiresLooping ?? this.requiresLooping,
        supportsProbing: supportsProbing ?? this.supportsProbing,
        videoType: videoType ?? this.videoType,
        isoType: isoType ?? this.isoType,
        video3DFormat: video3DFormat ?? this.video3DFormat,
        mediaStreams: mediaStreams ?? this.mediaStreams,
        mediaAttachments: mediaAttachments ?? this.mediaAttachments,
        formats: formats ?? this.formats,
        bitrate: bitrate ?? this.bitrate,
        fallbackMaxStreamingBitrate:
            fallbackMaxStreamingBitrate ?? this.fallbackMaxStreamingBitrate,
        timestamp: timestamp ?? this.timestamp,
        requiredHttpHeaders: requiredHttpHeaders ?? this.requiredHttpHeaders,
        transcodingUrl: transcodingUrl ?? this.transcodingUrl,
        transcodingSubProtocol:
            transcodingSubProtocol ?? this.transcodingSubProtocol,
        transcodingContainer: transcodingContainer ?? this.transcodingContainer,
        analyzeDurationMs: analyzeDurationMs ?? this.analyzeDurationMs,
        defaultAudioStreamIndex:
            defaultAudioStreamIndex ?? this.defaultAudioStreamIndex,
        defaultSubtitleStreamIndex:
            defaultSubtitleStreamIndex ?? this.defaultSubtitleStreamIndex,
        hasSegments: hasSegments ?? this.hasSegments);
  }

  MediaSourceInfo copyWithWrapped(
      {Wrapped<enums.MediaProtocol?>? protocol,
      Wrapped<String?>? id,
      Wrapped<String?>? path,
      Wrapped<String?>? encoderPath,
      Wrapped<enums.MediaProtocol?>? encoderProtocol,
      Wrapped<enums.MediaSourceType?>? type,
      Wrapped<String?>? container,
      Wrapped<int?>? size,
      Wrapped<String?>? name,
      Wrapped<bool?>? isRemote,
      Wrapped<String?>? eTag,
      Wrapped<int?>? runTimeTicks,
      Wrapped<bool?>? readAtNativeFramerate,
      Wrapped<bool?>? ignoreDts,
      Wrapped<bool?>? ignoreIndex,
      Wrapped<bool?>? genPtsInput,
      Wrapped<bool?>? supportsTranscoding,
      Wrapped<bool?>? supportsDirectStream,
      Wrapped<bool?>? supportsDirectPlay,
      Wrapped<bool?>? isInfiniteStream,
      Wrapped<bool?>? useMostCompatibleTranscodingProfile,
      Wrapped<bool?>? requiresOpening,
      Wrapped<String?>? openToken,
      Wrapped<bool?>? requiresClosing,
      Wrapped<String?>? liveStreamId,
      Wrapped<int?>? bufferMs,
      Wrapped<bool?>? requiresLooping,
      Wrapped<bool?>? supportsProbing,
      Wrapped<enums.VideoType?>? videoType,
      Wrapped<enums.IsoType?>? isoType,
      Wrapped<enums.Video3DFormat?>? video3DFormat,
      Wrapped<List<MediaStream>?>? mediaStreams,
      Wrapped<List<MediaAttachment>?>? mediaAttachments,
      Wrapped<List<String>?>? formats,
      Wrapped<int?>? bitrate,
      Wrapped<int?>? fallbackMaxStreamingBitrate,
      Wrapped<enums.TransportStreamTimestamp?>? timestamp,
      Wrapped<Map<String, dynamic>?>? requiredHttpHeaders,
      Wrapped<String?>? transcodingUrl,
      Wrapped<enums.MediaStreamProtocol?>? transcodingSubProtocol,
      Wrapped<String?>? transcodingContainer,
      Wrapped<int?>? analyzeDurationMs,
      Wrapped<int?>? defaultAudioStreamIndex,
      Wrapped<int?>? defaultSubtitleStreamIndex,
      Wrapped<bool?>? hasSegments}) {
    return MediaSourceInfo(
        protocol: (protocol != null ? protocol.value : this.protocol),
        id: (id != null ? id.value : this.id),
        path: (path != null ? path.value : this.path),
        encoderPath:
            (encoderPath != null ? encoderPath.value : this.encoderPath),
        encoderProtocol: (encoderProtocol != null
            ? encoderProtocol.value
            : this.encoderProtocol),
        type: (type != null ? type.value : this.type),
        container: (container != null ? container.value : this.container),
        size: (size != null ? size.value : this.size),
        name: (name != null ? name.value : this.name),
        isRemote: (isRemote != null ? isRemote.value : this.isRemote),
        eTag: (eTag != null ? eTag.value : this.eTag),
        runTimeTicks:
            (runTimeTicks != null ? runTimeTicks.value : this.runTimeTicks),
        readAtNativeFramerate: (readAtNativeFramerate != null
            ? readAtNativeFramerate.value
            : this.readAtNativeFramerate),
        ignoreDts: (ignoreDts != null ? ignoreDts.value : this.ignoreDts),
        ignoreIndex:
            (ignoreIndex != null ? ignoreIndex.value : this.ignoreIndex),
        genPtsInput:
            (genPtsInput != null ? genPtsInput.value : this.genPtsInput),
        supportsTranscoding: (supportsTranscoding != null
            ? supportsTranscoding.value
            : this.supportsTranscoding),
        supportsDirectStream: (supportsDirectStream != null
            ? supportsDirectStream.value
            : this.supportsDirectStream),
        supportsDirectPlay: (supportsDirectPlay != null
            ? supportsDirectPlay.value
            : this.supportsDirectPlay),
        isInfiniteStream: (isInfiniteStream != null
            ? isInfiniteStream.value
            : this.isInfiniteStream),
        useMostCompatibleTranscodingProfile:
            (useMostCompatibleTranscodingProfile != null
                ? useMostCompatibleTranscodingProfile.value
                : this.useMostCompatibleTranscodingProfile),
        requiresOpening: (requiresOpening != null
            ? requiresOpening.value
            : this.requiresOpening),
        openToken: (openToken != null ? openToken.value : this.openToken),
        requiresClosing: (requiresClosing != null
            ? requiresClosing.value
            : this.requiresClosing),
        liveStreamId:
            (liveStreamId != null ? liveStreamId.value : this.liveStreamId),
        bufferMs: (bufferMs != null ? bufferMs.value : this.bufferMs),
        requiresLooping: (requiresLooping != null
            ? requiresLooping.value
            : this.requiresLooping),
        supportsProbing: (supportsProbing != null
            ? supportsProbing.value
            : this.supportsProbing),
        videoType: (videoType != null ? videoType.value : this.videoType),
        isoType: (isoType != null ? isoType.value : this.isoType),
        video3DFormat:
            (video3DFormat != null ? video3DFormat.value : this.video3DFormat),
        mediaStreams:
            (mediaStreams != null ? mediaStreams.value : this.mediaStreams),
        mediaAttachments: (mediaAttachments != null
            ? mediaAttachments.value
            : this.mediaAttachments),
        formats: (formats != null ? formats.value : this.formats),
        bitrate: (bitrate != null ? bitrate.value : this.bitrate),
        fallbackMaxStreamingBitrate: (fallbackMaxStreamingBitrate != null
            ? fallbackMaxStreamingBitrate.value
            : this.fallbackMaxStreamingBitrate),
        timestamp: (timestamp != null ? timestamp.value : this.timestamp),
        requiredHttpHeaders: (requiredHttpHeaders != null
            ? requiredHttpHeaders.value
            : this.requiredHttpHeaders),
        transcodingUrl: (transcodingUrl != null
            ? transcodingUrl.value
            : this.transcodingUrl),
        transcodingSubProtocol: (transcodingSubProtocol != null
            ? transcodingSubProtocol.value
            : this.transcodingSubProtocol),
        transcodingContainer: (transcodingContainer != null
            ? transcodingContainer.value
            : this.transcodingContainer),
        analyzeDurationMs: (analyzeDurationMs != null
            ? analyzeDurationMs.value
            : this.analyzeDurationMs),
        defaultAudioStreamIndex: (defaultAudioStreamIndex != null
            ? defaultAudioStreamIndex.value
            : this.defaultAudioStreamIndex),
        defaultSubtitleStreamIndex: (defaultSubtitleStreamIndex != null
            ? defaultSubtitleStreamIndex.value
            : this.defaultSubtitleStreamIndex),
        hasSegments:
            (hasSegments != null ? hasSegments.value : this.hasSegments));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaStream {
  const MediaStream({
    this.codec,
    this.codecTag,
    this.language,
    this.colorRange,
    this.colorSpace,
    this.colorTransfer,
    this.colorPrimaries,
    this.dvVersionMajor,
    this.dvVersionMinor,
    this.dvProfile,
    this.dvLevel,
    this.rpuPresentFlag,
    this.elPresentFlag,
    this.blPresentFlag,
    this.dvBlSignalCompatibilityId,
    this.rotation,
    this.comment,
    this.timeBase,
    this.codecTimeBase,
    this.title,
    this.videoRange,
    this.videoRangeType,
    this.videoDoViTitle,
    this.audioSpatialFormat,
    this.localizedUndefined,
    this.localizedDefault,
    this.localizedForced,
    this.localizedExternal,
    this.localizedHearingImpaired,
    this.displayTitle,
    this.nalLengthSize,
    this.isInterlaced,
    this.isAVC,
    this.channelLayout,
    this.bitRate,
    this.bitDepth,
    this.refFrames,
    this.packetLength,
    this.channels,
    this.sampleRate,
    this.isDefault,
    this.isForced,
    this.isHearingImpaired,
    this.height,
    this.width,
    this.averageFrameRate,
    this.realFrameRate,
    this.referenceFrameRate,
    this.profile,
    this.type,
    this.aspectRatio,
    this.index,
    this.score,
    this.isExternal,
    this.deliveryMethod,
    this.deliveryUrl,
    this.isExternalUrl,
    this.isTextSubtitleStream,
    this.supportsExternalStream,
    this.path,
    this.pixelFormat,
    this.level,
    this.isAnamorphic,
  });

  factory MediaStream.fromJson(Map<String, dynamic> json) =>
      _$MediaStreamFromJson(json);

  static const toJsonFactory = _$MediaStreamToJson;
  Map<String, dynamic> toJson() => _$MediaStreamToJson(this);

  @JsonKey(name: 'Codec')
  final String? codec;
  @JsonKey(name: 'CodecTag')
  final String? codecTag;
  @JsonKey(name: 'Language')
  final String? language;
  @JsonKey(name: 'ColorRange')
  final String? colorRange;
  @JsonKey(name: 'ColorSpace')
  final String? colorSpace;
  @JsonKey(name: 'ColorTransfer')
  final String? colorTransfer;
  @JsonKey(name: 'ColorPrimaries')
  final String? colorPrimaries;
  @JsonKey(name: 'DvVersionMajor')
  final int? dvVersionMajor;
  @JsonKey(name: 'DvVersionMinor')
  final int? dvVersionMinor;
  @JsonKey(name: 'DvProfile')
  final int? dvProfile;
  @JsonKey(name: 'DvLevel')
  final int? dvLevel;
  @JsonKey(name: 'RpuPresentFlag')
  final int? rpuPresentFlag;
  @JsonKey(name: 'ElPresentFlag')
  final int? elPresentFlag;
  @JsonKey(name: 'BlPresentFlag')
  final int? blPresentFlag;
  @JsonKey(name: 'DvBlSignalCompatibilityId')
  final int? dvBlSignalCompatibilityId;
  @JsonKey(name: 'Rotation')
  final int? rotation;
  @JsonKey(name: 'Comment')
  final String? comment;
  @JsonKey(name: 'TimeBase')
  final String? timeBase;
  @JsonKey(name: 'CodecTimeBase')
  final String? codecTimeBase;
  @JsonKey(name: 'Title')
  final String? title;
  @JsonKey(
    name: 'VideoRange',
    toJson: videoRangeNullableToJson,
    fromJson: videoRangeNullableFromJson,
  )
  final enums.VideoRange? videoRange;
  @JsonKey(
    name: 'VideoRangeType',
    toJson: videoRangeTypeNullableToJson,
    fromJson: videoRangeTypeNullableFromJson,
  )
  final enums.VideoRangeType? videoRangeType;
  @JsonKey(name: 'VideoDoViTitle')
  final String? videoDoViTitle;
  @JsonKey(
    name: 'AudioSpatialFormat',
    toJson: audioSpatialFormatNullableToJson,
    fromJson: audioSpatialFormatAudioSpatialFormatNullableFromJson,
  )
  final enums.AudioSpatialFormat? audioSpatialFormat;
  static enums.AudioSpatialFormat?
      audioSpatialFormatAudioSpatialFormatNullableFromJson(Object? value) =>
          audioSpatialFormatNullableFromJson(
              value, enums.AudioSpatialFormat.none);

  @JsonKey(name: 'LocalizedUndefined')
  final String? localizedUndefined;
  @JsonKey(name: 'LocalizedDefault')
  final String? localizedDefault;
  @JsonKey(name: 'LocalizedForced')
  final String? localizedForced;
  @JsonKey(name: 'LocalizedExternal')
  final String? localizedExternal;
  @JsonKey(name: 'LocalizedHearingImpaired')
  final String? localizedHearingImpaired;
  @JsonKey(name: 'DisplayTitle')
  final String? displayTitle;
  @JsonKey(name: 'NalLengthSize')
  final String? nalLengthSize;
  @JsonKey(name: 'IsInterlaced')
  final bool? isInterlaced;
  @JsonKey(name: 'IsAVC')
  final bool? isAVC;
  @JsonKey(name: 'ChannelLayout')
  final String? channelLayout;
  @JsonKey(name: 'BitRate')
  final int? bitRate;
  @JsonKey(name: 'BitDepth')
  final int? bitDepth;
  @JsonKey(name: 'RefFrames')
  final int? refFrames;
  @JsonKey(name: 'PacketLength')
  final int? packetLength;
  @JsonKey(name: 'Channels')
  final int? channels;
  @JsonKey(name: 'SampleRate')
  final int? sampleRate;
  @JsonKey(name: 'IsDefault')
  final bool? isDefault;
  @JsonKey(name: 'IsForced')
  final bool? isForced;
  @JsonKey(name: 'IsHearingImpaired')
  final bool? isHearingImpaired;
  @JsonKey(name: 'Height')
  final int? height;
  @JsonKey(name: 'Width')
  final int? width;
  @JsonKey(name: 'AverageFrameRate')
  final double? averageFrameRate;
  @JsonKey(name: 'RealFrameRate')
  final double? realFrameRate;
  @JsonKey(name: 'ReferenceFrameRate')
  final double? referenceFrameRate;
  @JsonKey(name: 'Profile')
  final String? profile;
  @JsonKey(
    name: 'Type',
    toJson: mediaStreamTypeNullableToJson,
    fromJson: mediaStreamTypeNullableFromJson,
  )
  final enums.MediaStreamType? type;
  @JsonKey(name: 'AspectRatio')
  final String? aspectRatio;
  @JsonKey(name: 'Index')
  final int? index;
  @JsonKey(name: 'Score')
  final int? score;
  @JsonKey(name: 'IsExternal')
  final bool? isExternal;
  @JsonKey(
    name: 'DeliveryMethod',
    toJson: subtitleDeliveryMethodNullableToJson,
    fromJson: subtitleDeliveryMethodNullableFromJson,
  )
  final enums.SubtitleDeliveryMethod? deliveryMethod;
  @JsonKey(name: 'DeliveryUrl')
  final String? deliveryUrl;
  @JsonKey(name: 'IsExternalUrl')
  final bool? isExternalUrl;
  @JsonKey(name: 'IsTextSubtitleStream')
  final bool? isTextSubtitleStream;
  @JsonKey(name: 'SupportsExternalStream')
  final bool? supportsExternalStream;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'PixelFormat')
  final String? pixelFormat;
  @JsonKey(name: 'Level')
  final double? level;
  @JsonKey(name: 'IsAnamorphic')
  final bool? isAnamorphic;
  static const fromJsonFactory = _$MediaStreamFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaStream &&
            (identical(other.codec, codec) ||
                const DeepCollectionEquality().equals(other.codec, codec)) &&
            (identical(other.codecTag, codecTag) ||
                const DeepCollectionEquality()
                    .equals(other.codecTag, codecTag)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.colorRange, colorRange) ||
                const DeepCollectionEquality()
                    .equals(other.colorRange, colorRange)) &&
            (identical(other.colorSpace, colorSpace) ||
                const DeepCollectionEquality()
                    .equals(other.colorSpace, colorSpace)) &&
            (identical(other.colorTransfer, colorTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.colorTransfer, colorTransfer)) &&
            (identical(other.colorPrimaries, colorPrimaries) ||
                const DeepCollectionEquality()
                    .equals(other.colorPrimaries, colorPrimaries)) &&
            (identical(other.dvVersionMajor, dvVersionMajor) ||
                const DeepCollectionEquality()
                    .equals(other.dvVersionMajor, dvVersionMajor)) &&
            (identical(other.dvVersionMinor, dvVersionMinor) ||
                const DeepCollectionEquality()
                    .equals(other.dvVersionMinor, dvVersionMinor)) &&
            (identical(other.dvProfile, dvProfile) ||
                const DeepCollectionEquality()
                    .equals(other.dvProfile, dvProfile)) &&
            (identical(other.dvLevel, dvLevel) ||
                const DeepCollectionEquality()
                    .equals(other.dvLevel, dvLevel)) &&
            (identical(other.rpuPresentFlag, rpuPresentFlag) ||
                const DeepCollectionEquality()
                    .equals(other.rpuPresentFlag, rpuPresentFlag)) &&
            (identical(other.elPresentFlag, elPresentFlag) ||
                const DeepCollectionEquality()
                    .equals(other.elPresentFlag, elPresentFlag)) &&
            (identical(other.blPresentFlag, blPresentFlag) ||
                const DeepCollectionEquality()
                    .equals(other.blPresentFlag, blPresentFlag)) &&
            (identical(other.dvBlSignalCompatibilityId, dvBlSignalCompatibilityId) ||
                const DeepCollectionEquality().equals(
                    other.dvBlSignalCompatibilityId,
                    dvBlSignalCompatibilityId)) &&
            (identical(other.rotation, rotation) ||
                const DeepCollectionEquality()
                    .equals(other.rotation, rotation)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.timeBase, timeBase) ||
                const DeepCollectionEquality()
                    .equals(other.timeBase, timeBase)) &&
            (identical(other.codecTimeBase, codecTimeBase) ||
                const DeepCollectionEquality()
                    .equals(other.codecTimeBase, codecTimeBase)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.videoRange, videoRange) ||
                const DeepCollectionEquality()
                    .equals(other.videoRange, videoRange)) &&
            (identical(other.videoRangeType, videoRangeType) || const DeepCollectionEquality().equals(other.videoRangeType, videoRangeType)) &&
            (identical(other.videoDoViTitle, videoDoViTitle) || const DeepCollectionEquality().equals(other.videoDoViTitle, videoDoViTitle)) &&
            (identical(other.audioSpatialFormat, audioSpatialFormat) || const DeepCollectionEquality().equals(other.audioSpatialFormat, audioSpatialFormat)) &&
            (identical(other.localizedUndefined, localizedUndefined) || const DeepCollectionEquality().equals(other.localizedUndefined, localizedUndefined)) &&
            (identical(other.localizedDefault, localizedDefault) || const DeepCollectionEquality().equals(other.localizedDefault, localizedDefault)) &&
            (identical(other.localizedForced, localizedForced) || const DeepCollectionEquality().equals(other.localizedForced, localizedForced)) &&
            (identical(other.localizedExternal, localizedExternal) || const DeepCollectionEquality().equals(other.localizedExternal, localizedExternal)) &&
            (identical(other.localizedHearingImpaired, localizedHearingImpaired) || const DeepCollectionEquality().equals(other.localizedHearingImpaired, localizedHearingImpaired)) &&
            (identical(other.displayTitle, displayTitle) || const DeepCollectionEquality().equals(other.displayTitle, displayTitle)) &&
            (identical(other.nalLengthSize, nalLengthSize) || const DeepCollectionEquality().equals(other.nalLengthSize, nalLengthSize)) &&
            (identical(other.isInterlaced, isInterlaced) || const DeepCollectionEquality().equals(other.isInterlaced, isInterlaced)) &&
            (identical(other.isAVC, isAVC) || const DeepCollectionEquality().equals(other.isAVC, isAVC)) &&
            (identical(other.channelLayout, channelLayout) || const DeepCollectionEquality().equals(other.channelLayout, channelLayout)) &&
            (identical(other.bitRate, bitRate) || const DeepCollectionEquality().equals(other.bitRate, bitRate)) &&
            (identical(other.bitDepth, bitDepth) || const DeepCollectionEquality().equals(other.bitDepth, bitDepth)) &&
            (identical(other.refFrames, refFrames) || const DeepCollectionEquality().equals(other.refFrames, refFrames)) &&
            (identical(other.packetLength, packetLength) || const DeepCollectionEquality().equals(other.packetLength, packetLength)) &&
            (identical(other.channels, channels) || const DeepCollectionEquality().equals(other.channels, channels)) &&
            (identical(other.sampleRate, sampleRate) || const DeepCollectionEquality().equals(other.sampleRate, sampleRate)) &&
            (identical(other.isDefault, isDefault) || const DeepCollectionEquality().equals(other.isDefault, isDefault)) &&
            (identical(other.isForced, isForced) || const DeepCollectionEquality().equals(other.isForced, isForced)) &&
            (identical(other.isHearingImpaired, isHearingImpaired) || const DeepCollectionEquality().equals(other.isHearingImpaired, isHearingImpaired)) &&
            (identical(other.height, height) || const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.width, width) || const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.averageFrameRate, averageFrameRate) || const DeepCollectionEquality().equals(other.averageFrameRate, averageFrameRate)) &&
            (identical(other.realFrameRate, realFrameRate) || const DeepCollectionEquality().equals(other.realFrameRate, realFrameRate)) &&
            (identical(other.referenceFrameRate, referenceFrameRate) || const DeepCollectionEquality().equals(other.referenceFrameRate, referenceFrameRate)) &&
            (identical(other.profile, profile) || const DeepCollectionEquality().equals(other.profile, profile)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.aspectRatio, aspectRatio) || const DeepCollectionEquality().equals(other.aspectRatio, aspectRatio)) &&
            (identical(other.index, index) || const DeepCollectionEquality().equals(other.index, index)) &&
            (identical(other.score, score) || const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.isExternal, isExternal) || const DeepCollectionEquality().equals(other.isExternal, isExternal)) &&
            (identical(other.deliveryMethod, deliveryMethod) || const DeepCollectionEquality().equals(other.deliveryMethod, deliveryMethod)) &&
            (identical(other.deliveryUrl, deliveryUrl) || const DeepCollectionEquality().equals(other.deliveryUrl, deliveryUrl)) &&
            (identical(other.isExternalUrl, isExternalUrl) || const DeepCollectionEquality().equals(other.isExternalUrl, isExternalUrl)) &&
            (identical(other.isTextSubtitleStream, isTextSubtitleStream) || const DeepCollectionEquality().equals(other.isTextSubtitleStream, isTextSubtitleStream)) &&
            (identical(other.supportsExternalStream, supportsExternalStream) || const DeepCollectionEquality().equals(other.supportsExternalStream, supportsExternalStream)) &&
            (identical(other.path, path) || const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.pixelFormat, pixelFormat) || const DeepCollectionEquality().equals(other.pixelFormat, pixelFormat)) &&
            (identical(other.level, level) || const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.isAnamorphic, isAnamorphic) || const DeepCollectionEquality().equals(other.isAnamorphic, isAnamorphic)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(codec) ^
      const DeepCollectionEquality().hash(codecTag) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(colorRange) ^
      const DeepCollectionEquality().hash(colorSpace) ^
      const DeepCollectionEquality().hash(colorTransfer) ^
      const DeepCollectionEquality().hash(colorPrimaries) ^
      const DeepCollectionEquality().hash(dvVersionMajor) ^
      const DeepCollectionEquality().hash(dvVersionMinor) ^
      const DeepCollectionEquality().hash(dvProfile) ^
      const DeepCollectionEquality().hash(dvLevel) ^
      const DeepCollectionEquality().hash(rpuPresentFlag) ^
      const DeepCollectionEquality().hash(elPresentFlag) ^
      const DeepCollectionEquality().hash(blPresentFlag) ^
      const DeepCollectionEquality().hash(dvBlSignalCompatibilityId) ^
      const DeepCollectionEquality().hash(rotation) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(timeBase) ^
      const DeepCollectionEquality().hash(codecTimeBase) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(videoRange) ^
      const DeepCollectionEquality().hash(videoRangeType) ^
      const DeepCollectionEquality().hash(videoDoViTitle) ^
      const DeepCollectionEquality().hash(audioSpatialFormat) ^
      const DeepCollectionEquality().hash(localizedUndefined) ^
      const DeepCollectionEquality().hash(localizedDefault) ^
      const DeepCollectionEquality().hash(localizedForced) ^
      const DeepCollectionEquality().hash(localizedExternal) ^
      const DeepCollectionEquality().hash(localizedHearingImpaired) ^
      const DeepCollectionEquality().hash(displayTitle) ^
      const DeepCollectionEquality().hash(nalLengthSize) ^
      const DeepCollectionEquality().hash(isInterlaced) ^
      const DeepCollectionEquality().hash(isAVC) ^
      const DeepCollectionEquality().hash(channelLayout) ^
      const DeepCollectionEquality().hash(bitRate) ^
      const DeepCollectionEquality().hash(bitDepth) ^
      const DeepCollectionEquality().hash(refFrames) ^
      const DeepCollectionEquality().hash(packetLength) ^
      const DeepCollectionEquality().hash(channels) ^
      const DeepCollectionEquality().hash(sampleRate) ^
      const DeepCollectionEquality().hash(isDefault) ^
      const DeepCollectionEquality().hash(isForced) ^
      const DeepCollectionEquality().hash(isHearingImpaired) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(averageFrameRate) ^
      const DeepCollectionEquality().hash(realFrameRate) ^
      const DeepCollectionEquality().hash(referenceFrameRate) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(aspectRatio) ^
      const DeepCollectionEquality().hash(index) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(isExternal) ^
      const DeepCollectionEquality().hash(deliveryMethod) ^
      const DeepCollectionEquality().hash(deliveryUrl) ^
      const DeepCollectionEquality().hash(isExternalUrl) ^
      const DeepCollectionEquality().hash(isTextSubtitleStream) ^
      const DeepCollectionEquality().hash(supportsExternalStream) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(pixelFormat) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(isAnamorphic) ^
      runtimeType.hashCode;
}

extension $MediaStreamExtension on MediaStream {
  MediaStream copyWith(
      {String? codec,
      String? codecTag,
      String? language,
      String? colorRange,
      String? colorSpace,
      String? colorTransfer,
      String? colorPrimaries,
      int? dvVersionMajor,
      int? dvVersionMinor,
      int? dvProfile,
      int? dvLevel,
      int? rpuPresentFlag,
      int? elPresentFlag,
      int? blPresentFlag,
      int? dvBlSignalCompatibilityId,
      int? rotation,
      String? comment,
      String? timeBase,
      String? codecTimeBase,
      String? title,
      enums.VideoRange? videoRange,
      enums.VideoRangeType? videoRangeType,
      String? videoDoViTitle,
      enums.AudioSpatialFormat? audioSpatialFormat,
      String? localizedUndefined,
      String? localizedDefault,
      String? localizedForced,
      String? localizedExternal,
      String? localizedHearingImpaired,
      String? displayTitle,
      String? nalLengthSize,
      bool? isInterlaced,
      bool? isAVC,
      String? channelLayout,
      int? bitRate,
      int? bitDepth,
      int? refFrames,
      int? packetLength,
      int? channels,
      int? sampleRate,
      bool? isDefault,
      bool? isForced,
      bool? isHearingImpaired,
      int? height,
      int? width,
      double? averageFrameRate,
      double? realFrameRate,
      double? referenceFrameRate,
      String? profile,
      enums.MediaStreamType? type,
      String? aspectRatio,
      int? index,
      int? score,
      bool? isExternal,
      enums.SubtitleDeliveryMethod? deliveryMethod,
      String? deliveryUrl,
      bool? isExternalUrl,
      bool? isTextSubtitleStream,
      bool? supportsExternalStream,
      String? path,
      String? pixelFormat,
      double? level,
      bool? isAnamorphic}) {
    return MediaStream(
        codec: codec ?? this.codec,
        codecTag: codecTag ?? this.codecTag,
        language: language ?? this.language,
        colorRange: colorRange ?? this.colorRange,
        colorSpace: colorSpace ?? this.colorSpace,
        colorTransfer: colorTransfer ?? this.colorTransfer,
        colorPrimaries: colorPrimaries ?? this.colorPrimaries,
        dvVersionMajor: dvVersionMajor ?? this.dvVersionMajor,
        dvVersionMinor: dvVersionMinor ?? this.dvVersionMinor,
        dvProfile: dvProfile ?? this.dvProfile,
        dvLevel: dvLevel ?? this.dvLevel,
        rpuPresentFlag: rpuPresentFlag ?? this.rpuPresentFlag,
        elPresentFlag: elPresentFlag ?? this.elPresentFlag,
        blPresentFlag: blPresentFlag ?? this.blPresentFlag,
        dvBlSignalCompatibilityId:
            dvBlSignalCompatibilityId ?? this.dvBlSignalCompatibilityId,
        rotation: rotation ?? this.rotation,
        comment: comment ?? this.comment,
        timeBase: timeBase ?? this.timeBase,
        codecTimeBase: codecTimeBase ?? this.codecTimeBase,
        title: title ?? this.title,
        videoRange: videoRange ?? this.videoRange,
        videoRangeType: videoRangeType ?? this.videoRangeType,
        videoDoViTitle: videoDoViTitle ?? this.videoDoViTitle,
        audioSpatialFormat: audioSpatialFormat ?? this.audioSpatialFormat,
        localizedUndefined: localizedUndefined ?? this.localizedUndefined,
        localizedDefault: localizedDefault ?? this.localizedDefault,
        localizedForced: localizedForced ?? this.localizedForced,
        localizedExternal: localizedExternal ?? this.localizedExternal,
        localizedHearingImpaired:
            localizedHearingImpaired ?? this.localizedHearingImpaired,
        displayTitle: displayTitle ?? this.displayTitle,
        nalLengthSize: nalLengthSize ?? this.nalLengthSize,
        isInterlaced: isInterlaced ?? this.isInterlaced,
        isAVC: isAVC ?? this.isAVC,
        channelLayout: channelLayout ?? this.channelLayout,
        bitRate: bitRate ?? this.bitRate,
        bitDepth: bitDepth ?? this.bitDepth,
        refFrames: refFrames ?? this.refFrames,
        packetLength: packetLength ?? this.packetLength,
        channels: channels ?? this.channels,
        sampleRate: sampleRate ?? this.sampleRate,
        isDefault: isDefault ?? this.isDefault,
        isForced: isForced ?? this.isForced,
        isHearingImpaired: isHearingImpaired ?? this.isHearingImpaired,
        height: height ?? this.height,
        width: width ?? this.width,
        averageFrameRate: averageFrameRate ?? this.averageFrameRate,
        realFrameRate: realFrameRate ?? this.realFrameRate,
        referenceFrameRate: referenceFrameRate ?? this.referenceFrameRate,
        profile: profile ?? this.profile,
        type: type ?? this.type,
        aspectRatio: aspectRatio ?? this.aspectRatio,
        index: index ?? this.index,
        score: score ?? this.score,
        isExternal: isExternal ?? this.isExternal,
        deliveryMethod: deliveryMethod ?? this.deliveryMethod,
        deliveryUrl: deliveryUrl ?? this.deliveryUrl,
        isExternalUrl: isExternalUrl ?? this.isExternalUrl,
        isTextSubtitleStream: isTextSubtitleStream ?? this.isTextSubtitleStream,
        supportsExternalStream:
            supportsExternalStream ?? this.supportsExternalStream,
        path: path ?? this.path,
        pixelFormat: pixelFormat ?? this.pixelFormat,
        level: level ?? this.level,
        isAnamorphic: isAnamorphic ?? this.isAnamorphic);
  }

  MediaStream copyWithWrapped(
      {Wrapped<String?>? codec,
      Wrapped<String?>? codecTag,
      Wrapped<String?>? language,
      Wrapped<String?>? colorRange,
      Wrapped<String?>? colorSpace,
      Wrapped<String?>? colorTransfer,
      Wrapped<String?>? colorPrimaries,
      Wrapped<int?>? dvVersionMajor,
      Wrapped<int?>? dvVersionMinor,
      Wrapped<int?>? dvProfile,
      Wrapped<int?>? dvLevel,
      Wrapped<int?>? rpuPresentFlag,
      Wrapped<int?>? elPresentFlag,
      Wrapped<int?>? blPresentFlag,
      Wrapped<int?>? dvBlSignalCompatibilityId,
      Wrapped<int?>? rotation,
      Wrapped<String?>? comment,
      Wrapped<String?>? timeBase,
      Wrapped<String?>? codecTimeBase,
      Wrapped<String?>? title,
      Wrapped<enums.VideoRange?>? videoRange,
      Wrapped<enums.VideoRangeType?>? videoRangeType,
      Wrapped<String?>? videoDoViTitle,
      Wrapped<enums.AudioSpatialFormat?>? audioSpatialFormat,
      Wrapped<String?>? localizedUndefined,
      Wrapped<String?>? localizedDefault,
      Wrapped<String?>? localizedForced,
      Wrapped<String?>? localizedExternal,
      Wrapped<String?>? localizedHearingImpaired,
      Wrapped<String?>? displayTitle,
      Wrapped<String?>? nalLengthSize,
      Wrapped<bool?>? isInterlaced,
      Wrapped<bool?>? isAVC,
      Wrapped<String?>? channelLayout,
      Wrapped<int?>? bitRate,
      Wrapped<int?>? bitDepth,
      Wrapped<int?>? refFrames,
      Wrapped<int?>? packetLength,
      Wrapped<int?>? channels,
      Wrapped<int?>? sampleRate,
      Wrapped<bool?>? isDefault,
      Wrapped<bool?>? isForced,
      Wrapped<bool?>? isHearingImpaired,
      Wrapped<int?>? height,
      Wrapped<int?>? width,
      Wrapped<double?>? averageFrameRate,
      Wrapped<double?>? realFrameRate,
      Wrapped<double?>? referenceFrameRate,
      Wrapped<String?>? profile,
      Wrapped<enums.MediaStreamType?>? type,
      Wrapped<String?>? aspectRatio,
      Wrapped<int?>? index,
      Wrapped<int?>? score,
      Wrapped<bool?>? isExternal,
      Wrapped<enums.SubtitleDeliveryMethod?>? deliveryMethod,
      Wrapped<String?>? deliveryUrl,
      Wrapped<bool?>? isExternalUrl,
      Wrapped<bool?>? isTextSubtitleStream,
      Wrapped<bool?>? supportsExternalStream,
      Wrapped<String?>? path,
      Wrapped<String?>? pixelFormat,
      Wrapped<double?>? level,
      Wrapped<bool?>? isAnamorphic}) {
    return MediaStream(
        codec: (codec != null ? codec.value : this.codec),
        codecTag: (codecTag != null ? codecTag.value : this.codecTag),
        language: (language != null ? language.value : this.language),
        colorRange: (colorRange != null ? colorRange.value : this.colorRange),
        colorSpace: (colorSpace != null ? colorSpace.value : this.colorSpace),
        colorTransfer:
            (colorTransfer != null ? colorTransfer.value : this.colorTransfer),
        colorPrimaries: (colorPrimaries != null
            ? colorPrimaries.value
            : this.colorPrimaries),
        dvVersionMajor: (dvVersionMajor != null
            ? dvVersionMajor.value
            : this.dvVersionMajor),
        dvVersionMinor: (dvVersionMinor != null
            ? dvVersionMinor.value
            : this.dvVersionMinor),
        dvProfile: (dvProfile != null ? dvProfile.value : this.dvProfile),
        dvLevel: (dvLevel != null ? dvLevel.value : this.dvLevel),
        rpuPresentFlag: (rpuPresentFlag != null
            ? rpuPresentFlag.value
            : this.rpuPresentFlag),
        elPresentFlag:
            (elPresentFlag != null ? elPresentFlag.value : this.elPresentFlag),
        blPresentFlag:
            (blPresentFlag != null ? blPresentFlag.value : this.blPresentFlag),
        dvBlSignalCompatibilityId: (dvBlSignalCompatibilityId != null
            ? dvBlSignalCompatibilityId.value
            : this.dvBlSignalCompatibilityId),
        rotation: (rotation != null ? rotation.value : this.rotation),
        comment: (comment != null ? comment.value : this.comment),
        timeBase: (timeBase != null ? timeBase.value : this.timeBase),
        codecTimeBase:
            (codecTimeBase != null ? codecTimeBase.value : this.codecTimeBase),
        title: (title != null ? title.value : this.title),
        videoRange: (videoRange != null ? videoRange.value : this.videoRange),
        videoRangeType: (videoRangeType != null
            ? videoRangeType.value
            : this.videoRangeType),
        videoDoViTitle: (videoDoViTitle != null
            ? videoDoViTitle.value
            : this.videoDoViTitle),
        audioSpatialFormat: (audioSpatialFormat != null
            ? audioSpatialFormat.value
            : this.audioSpatialFormat),
        localizedUndefined: (localizedUndefined != null
            ? localizedUndefined.value
            : this.localizedUndefined),
        localizedDefault: (localizedDefault != null
            ? localizedDefault.value
            : this.localizedDefault),
        localizedForced: (localizedForced != null
            ? localizedForced.value
            : this.localizedForced),
        localizedExternal: (localizedExternal != null
            ? localizedExternal.value
            : this.localizedExternal),
        localizedHearingImpaired: (localizedHearingImpaired != null
            ? localizedHearingImpaired.value
            : this.localizedHearingImpaired),
        displayTitle:
            (displayTitle != null ? displayTitle.value : this.displayTitle),
        nalLengthSize:
            (nalLengthSize != null ? nalLengthSize.value : this.nalLengthSize),
        isInterlaced:
            (isInterlaced != null ? isInterlaced.value : this.isInterlaced),
        isAVC: (isAVC != null ? isAVC.value : this.isAVC),
        channelLayout:
            (channelLayout != null ? channelLayout.value : this.channelLayout),
        bitRate: (bitRate != null ? bitRate.value : this.bitRate),
        bitDepth: (bitDepth != null ? bitDepth.value : this.bitDepth),
        refFrames: (refFrames != null ? refFrames.value : this.refFrames),
        packetLength:
            (packetLength != null ? packetLength.value : this.packetLength),
        channels: (channels != null ? channels.value : this.channels),
        sampleRate: (sampleRate != null ? sampleRate.value : this.sampleRate),
        isDefault: (isDefault != null ? isDefault.value : this.isDefault),
        isForced: (isForced != null ? isForced.value : this.isForced),
        isHearingImpaired: (isHearingImpaired != null
            ? isHearingImpaired.value
            : this.isHearingImpaired),
        height: (height != null ? height.value : this.height),
        width: (width != null ? width.value : this.width),
        averageFrameRate: (averageFrameRate != null
            ? averageFrameRate.value
            : this.averageFrameRate),
        realFrameRate:
            (realFrameRate != null ? realFrameRate.value : this.realFrameRate),
        referenceFrameRate: (referenceFrameRate != null
            ? referenceFrameRate.value
            : this.referenceFrameRate),
        profile: (profile != null ? profile.value : this.profile),
        type: (type != null ? type.value : this.type),
        aspectRatio:
            (aspectRatio != null ? aspectRatio.value : this.aspectRatio),
        index: (index != null ? index.value : this.index),
        score: (score != null ? score.value : this.score),
        isExternal: (isExternal != null ? isExternal.value : this.isExternal),
        deliveryMethod: (deliveryMethod != null
            ? deliveryMethod.value
            : this.deliveryMethod),
        deliveryUrl:
            (deliveryUrl != null ? deliveryUrl.value : this.deliveryUrl),
        isExternalUrl:
            (isExternalUrl != null ? isExternalUrl.value : this.isExternalUrl),
        isTextSubtitleStream: (isTextSubtitleStream != null
            ? isTextSubtitleStream.value
            : this.isTextSubtitleStream),
        supportsExternalStream: (supportsExternalStream != null
            ? supportsExternalStream.value
            : this.supportsExternalStream),
        path: (path != null ? path.value : this.path),
        pixelFormat:
            (pixelFormat != null ? pixelFormat.value : this.pixelFormat),
        level: (level != null ? level.value : this.level),
        isAnamorphic:
            (isAnamorphic != null ? isAnamorphic.value : this.isAnamorphic));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaUpdateInfoDto {
  const MediaUpdateInfoDto({
    this.updates,
  });

  factory MediaUpdateInfoDto.fromJson(Map<String, dynamic> json) =>
      _$MediaUpdateInfoDtoFromJson(json);

  static const toJsonFactory = _$MediaUpdateInfoDtoToJson;
  Map<String, dynamic> toJson() => _$MediaUpdateInfoDtoToJson(this);

  @JsonKey(name: 'Updates', defaultValue: <MediaUpdateInfoPathDto>[])
  final List<MediaUpdateInfoPathDto>? updates;
  static const fromJsonFactory = _$MediaUpdateInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaUpdateInfoDto &&
            (identical(other.updates, updates) ||
                const DeepCollectionEquality().equals(other.updates, updates)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(updates) ^ runtimeType.hashCode;
}

extension $MediaUpdateInfoDtoExtension on MediaUpdateInfoDto {
  MediaUpdateInfoDto copyWith({List<MediaUpdateInfoPathDto>? updates}) {
    return MediaUpdateInfoDto(updates: updates ?? this.updates);
  }

  MediaUpdateInfoDto copyWithWrapped(
      {Wrapped<List<MediaUpdateInfoPathDto>?>? updates}) {
    return MediaUpdateInfoDto(
        updates: (updates != null ? updates.value : this.updates));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaUpdateInfoPathDto {
  const MediaUpdateInfoPathDto({
    this.path,
    this.updateType,
  });

  factory MediaUpdateInfoPathDto.fromJson(Map<String, dynamic> json) =>
      _$MediaUpdateInfoPathDtoFromJson(json);

  static const toJsonFactory = _$MediaUpdateInfoPathDtoToJson;
  Map<String, dynamic> toJson() => _$MediaUpdateInfoPathDtoToJson(this);

  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'UpdateType')
  final String? updateType;
  static const fromJsonFactory = _$MediaUpdateInfoPathDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaUpdateInfoPathDto &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.updateType, updateType) ||
                const DeepCollectionEquality()
                    .equals(other.updateType, updateType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(updateType) ^
      runtimeType.hashCode;
}

extension $MediaUpdateInfoPathDtoExtension on MediaUpdateInfoPathDto {
  MediaUpdateInfoPathDto copyWith({String? path, String? updateType}) {
    return MediaUpdateInfoPathDto(
        path: path ?? this.path, updateType: updateType ?? this.updateType);
  }

  MediaUpdateInfoPathDto copyWithWrapped(
      {Wrapped<String?>? path, Wrapped<String?>? updateType}) {
    return MediaUpdateInfoPathDto(
        path: (path != null ? path.value : this.path),
        updateType: (updateType != null ? updateType.value : this.updateType));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaUrl {
  const MediaUrl({
    this.url,
    this.name,
  });

  factory MediaUrl.fromJson(Map<String, dynamic> json) =>
      _$MediaUrlFromJson(json);

  static const toJsonFactory = _$MediaUrlToJson;
  Map<String, dynamic> toJson() => _$MediaUrlToJson(this);

  @JsonKey(name: 'Url')
  final String? url;
  @JsonKey(name: 'Name')
  final String? name;
  static const fromJsonFactory = _$MediaUrlFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaUrl &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $MediaUrlExtension on MediaUrl {
  MediaUrl copyWith({String? url, String? name}) {
    return MediaUrl(url: url ?? this.url, name: name ?? this.name);
  }

  MediaUrl copyWithWrapped({Wrapped<String?>? url, Wrapped<String?>? name}) {
    return MediaUrl(
        url: (url != null ? url.value : this.url),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class MessageCommand {
  const MessageCommand({
    this.header,
    required this.text,
    this.timeoutMs,
  });

  factory MessageCommand.fromJson(Map<String, dynamic> json) =>
      _$MessageCommandFromJson(json);

  static const toJsonFactory = _$MessageCommandToJson;
  Map<String, dynamic> toJson() => _$MessageCommandToJson(this);

  @JsonKey(name: 'Header')
  final String? header;
  @JsonKey(name: 'Text')
  final String text;
  @JsonKey(name: 'TimeoutMs')
  final int? timeoutMs;
  static const fromJsonFactory = _$MessageCommandFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MessageCommand &&
            (identical(other.header, header) ||
                const DeepCollectionEquality().equals(other.header, header)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.timeoutMs, timeoutMs) ||
                const DeepCollectionEquality()
                    .equals(other.timeoutMs, timeoutMs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(header) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(timeoutMs) ^
      runtimeType.hashCode;
}

extension $MessageCommandExtension on MessageCommand {
  MessageCommand copyWith({String? header, String? text, int? timeoutMs}) {
    return MessageCommand(
        header: header ?? this.header,
        text: text ?? this.text,
        timeoutMs: timeoutMs ?? this.timeoutMs);
  }

  MessageCommand copyWithWrapped(
      {Wrapped<String?>? header,
      Wrapped<String>? text,
      Wrapped<int?>? timeoutMs}) {
    return MessageCommand(
        header: (header != null ? header.value : this.header),
        text: (text != null ? text.value : this.text),
        timeoutMs: (timeoutMs != null ? timeoutMs.value : this.timeoutMs));
  }
}

@JsonSerializable(explicitToJson: true)
class MetadataConfiguration {
  const MetadataConfiguration({
    this.useFileCreationTimeForDateAdded,
  });

  factory MetadataConfiguration.fromJson(Map<String, dynamic> json) =>
      _$MetadataConfigurationFromJson(json);

  static const toJsonFactory = _$MetadataConfigurationToJson;
  Map<String, dynamic> toJson() => _$MetadataConfigurationToJson(this);

  @JsonKey(name: 'UseFileCreationTimeForDateAdded')
  final bool? useFileCreationTimeForDateAdded;
  static const fromJsonFactory = _$MetadataConfigurationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MetadataConfiguration &&
            (identical(other.useFileCreationTimeForDateAdded,
                    useFileCreationTimeForDateAdded) ||
                const DeepCollectionEquality().equals(
                    other.useFileCreationTimeForDateAdded,
                    useFileCreationTimeForDateAdded)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(useFileCreationTimeForDateAdded) ^
      runtimeType.hashCode;
}

extension $MetadataConfigurationExtension on MetadataConfiguration {
  MetadataConfiguration copyWith({bool? useFileCreationTimeForDateAdded}) {
    return MetadataConfiguration(
        useFileCreationTimeForDateAdded: useFileCreationTimeForDateAdded ??
            this.useFileCreationTimeForDateAdded);
  }

  MetadataConfiguration copyWithWrapped(
      {Wrapped<bool?>? useFileCreationTimeForDateAdded}) {
    return MetadataConfiguration(
        useFileCreationTimeForDateAdded:
            (useFileCreationTimeForDateAdded != null
                ? useFileCreationTimeForDateAdded.value
                : this.useFileCreationTimeForDateAdded));
  }
}

@JsonSerializable(explicitToJson: true)
class MetadataEditorInfo {
  const MetadataEditorInfo({
    this.parentalRatingOptions,
    this.countries,
    this.cultures,
    this.externalIdInfos,
    this.contentType,
    this.contentTypeOptions,
  });

  factory MetadataEditorInfo.fromJson(Map<String, dynamic> json) =>
      _$MetadataEditorInfoFromJson(json);

  static const toJsonFactory = _$MetadataEditorInfoToJson;
  Map<String, dynamic> toJson() => _$MetadataEditorInfoToJson(this);

  @JsonKey(name: 'ParentalRatingOptions', defaultValue: <ParentalRating>[])
  final List<ParentalRating>? parentalRatingOptions;
  @JsonKey(name: 'Countries', defaultValue: <CountryInfo>[])
  final List<CountryInfo>? countries;
  @JsonKey(name: 'Cultures', defaultValue: <CultureDto>[])
  final List<CultureDto>? cultures;
  @JsonKey(name: 'ExternalIdInfos', defaultValue: <ExternalIdInfo>[])
  final List<ExternalIdInfo>? externalIdInfos;
  @JsonKey(
    name: 'ContentType',
    toJson: collectionTypeNullableToJson,
    fromJson: collectionTypeNullableFromJson,
  )
  final enums.CollectionType? contentType;
  @JsonKey(name: 'ContentTypeOptions', defaultValue: <NameValuePair>[])
  final List<NameValuePair>? contentTypeOptions;
  static const fromJsonFactory = _$MetadataEditorInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MetadataEditorInfo &&
            (identical(other.parentalRatingOptions, parentalRatingOptions) ||
                const DeepCollectionEquality().equals(
                    other.parentalRatingOptions, parentalRatingOptions)) &&
            (identical(other.countries, countries) ||
                const DeepCollectionEquality()
                    .equals(other.countries, countries)) &&
            (identical(other.cultures, cultures) ||
                const DeepCollectionEquality()
                    .equals(other.cultures, cultures)) &&
            (identical(other.externalIdInfos, externalIdInfos) ||
                const DeepCollectionEquality()
                    .equals(other.externalIdInfos, externalIdInfos)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.contentTypeOptions, contentTypeOptions) ||
                const DeepCollectionEquality()
                    .equals(other.contentTypeOptions, contentTypeOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(parentalRatingOptions) ^
      const DeepCollectionEquality().hash(countries) ^
      const DeepCollectionEquality().hash(cultures) ^
      const DeepCollectionEquality().hash(externalIdInfos) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(contentTypeOptions) ^
      runtimeType.hashCode;
}

extension $MetadataEditorInfoExtension on MetadataEditorInfo {
  MetadataEditorInfo copyWith(
      {List<ParentalRating>? parentalRatingOptions,
      List<CountryInfo>? countries,
      List<CultureDto>? cultures,
      List<ExternalIdInfo>? externalIdInfos,
      enums.CollectionType? contentType,
      List<NameValuePair>? contentTypeOptions}) {
    return MetadataEditorInfo(
        parentalRatingOptions:
            parentalRatingOptions ?? this.parentalRatingOptions,
        countries: countries ?? this.countries,
        cultures: cultures ?? this.cultures,
        externalIdInfos: externalIdInfos ?? this.externalIdInfos,
        contentType: contentType ?? this.contentType,
        contentTypeOptions: contentTypeOptions ?? this.contentTypeOptions);
  }

  MetadataEditorInfo copyWithWrapped(
      {Wrapped<List<ParentalRating>?>? parentalRatingOptions,
      Wrapped<List<CountryInfo>?>? countries,
      Wrapped<List<CultureDto>?>? cultures,
      Wrapped<List<ExternalIdInfo>?>? externalIdInfos,
      Wrapped<enums.CollectionType?>? contentType,
      Wrapped<List<NameValuePair>?>? contentTypeOptions}) {
    return MetadataEditorInfo(
        parentalRatingOptions: (parentalRatingOptions != null
            ? parentalRatingOptions.value
            : this.parentalRatingOptions),
        countries: (countries != null ? countries.value : this.countries),
        cultures: (cultures != null ? cultures.value : this.cultures),
        externalIdInfos: (externalIdInfos != null
            ? externalIdInfos.value
            : this.externalIdInfos),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        contentTypeOptions: (contentTypeOptions != null
            ? contentTypeOptions.value
            : this.contentTypeOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class MetadataOptions {
  const MetadataOptions({
    this.itemType,
    this.disabledMetadataSavers,
    this.localMetadataReaderOrder,
    this.disabledMetadataFetchers,
    this.metadataFetcherOrder,
    this.disabledImageFetchers,
    this.imageFetcherOrder,
  });

  factory MetadataOptions.fromJson(Map<String, dynamic> json) =>
      _$MetadataOptionsFromJson(json);

  static const toJsonFactory = _$MetadataOptionsToJson;
  Map<String, dynamic> toJson() => _$MetadataOptionsToJson(this);

  @JsonKey(name: 'ItemType')
  final String? itemType;
  @JsonKey(name: 'DisabledMetadataSavers', defaultValue: <String>[])
  final List<String>? disabledMetadataSavers;
  @JsonKey(name: 'LocalMetadataReaderOrder', defaultValue: <String>[])
  final List<String>? localMetadataReaderOrder;
  @JsonKey(name: 'DisabledMetadataFetchers', defaultValue: <String>[])
  final List<String>? disabledMetadataFetchers;
  @JsonKey(name: 'MetadataFetcherOrder', defaultValue: <String>[])
  final List<String>? metadataFetcherOrder;
  @JsonKey(name: 'DisabledImageFetchers', defaultValue: <String>[])
  final List<String>? disabledImageFetchers;
  @JsonKey(name: 'ImageFetcherOrder', defaultValue: <String>[])
  final List<String>? imageFetcherOrder;
  static const fromJsonFactory = _$MetadataOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MetadataOptions &&
            (identical(other.itemType, itemType) ||
                const DeepCollectionEquality()
                    .equals(other.itemType, itemType)) &&
            (identical(other.disabledMetadataSavers, disabledMetadataSavers) ||
                const DeepCollectionEquality().equals(
                    other.disabledMetadataSavers, disabledMetadataSavers)) &&
            (identical(
                    other.localMetadataReaderOrder, localMetadataReaderOrder) ||
                const DeepCollectionEquality().equals(
                    other.localMetadataReaderOrder,
                    localMetadataReaderOrder)) &&
            (identical(
                    other.disabledMetadataFetchers, disabledMetadataFetchers) ||
                const DeepCollectionEquality().equals(
                    other.disabledMetadataFetchers,
                    disabledMetadataFetchers)) &&
            (identical(other.metadataFetcherOrder, metadataFetcherOrder) ||
                const DeepCollectionEquality().equals(
                    other.metadataFetcherOrder, metadataFetcherOrder)) &&
            (identical(other.disabledImageFetchers, disabledImageFetchers) ||
                const DeepCollectionEquality().equals(
                    other.disabledImageFetchers, disabledImageFetchers)) &&
            (identical(other.imageFetcherOrder, imageFetcherOrder) ||
                const DeepCollectionEquality()
                    .equals(other.imageFetcherOrder, imageFetcherOrder)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemType) ^
      const DeepCollectionEquality().hash(disabledMetadataSavers) ^
      const DeepCollectionEquality().hash(localMetadataReaderOrder) ^
      const DeepCollectionEquality().hash(disabledMetadataFetchers) ^
      const DeepCollectionEquality().hash(metadataFetcherOrder) ^
      const DeepCollectionEquality().hash(disabledImageFetchers) ^
      const DeepCollectionEquality().hash(imageFetcherOrder) ^
      runtimeType.hashCode;
}

extension $MetadataOptionsExtension on MetadataOptions {
  MetadataOptions copyWith(
      {String? itemType,
      List<String>? disabledMetadataSavers,
      List<String>? localMetadataReaderOrder,
      List<String>? disabledMetadataFetchers,
      List<String>? metadataFetcherOrder,
      List<String>? disabledImageFetchers,
      List<String>? imageFetcherOrder}) {
    return MetadataOptions(
        itemType: itemType ?? this.itemType,
        disabledMetadataSavers:
            disabledMetadataSavers ?? this.disabledMetadataSavers,
        localMetadataReaderOrder:
            localMetadataReaderOrder ?? this.localMetadataReaderOrder,
        disabledMetadataFetchers:
            disabledMetadataFetchers ?? this.disabledMetadataFetchers,
        metadataFetcherOrder: metadataFetcherOrder ?? this.metadataFetcherOrder,
        disabledImageFetchers:
            disabledImageFetchers ?? this.disabledImageFetchers,
        imageFetcherOrder: imageFetcherOrder ?? this.imageFetcherOrder);
  }

  MetadataOptions copyWithWrapped(
      {Wrapped<String?>? itemType,
      Wrapped<List<String>?>? disabledMetadataSavers,
      Wrapped<List<String>?>? localMetadataReaderOrder,
      Wrapped<List<String>?>? disabledMetadataFetchers,
      Wrapped<List<String>?>? metadataFetcherOrder,
      Wrapped<List<String>?>? disabledImageFetchers,
      Wrapped<List<String>?>? imageFetcherOrder}) {
    return MetadataOptions(
        itemType: (itemType != null ? itemType.value : this.itemType),
        disabledMetadataSavers: (disabledMetadataSavers != null
            ? disabledMetadataSavers.value
            : this.disabledMetadataSavers),
        localMetadataReaderOrder: (localMetadataReaderOrder != null
            ? localMetadataReaderOrder.value
            : this.localMetadataReaderOrder),
        disabledMetadataFetchers: (disabledMetadataFetchers != null
            ? disabledMetadataFetchers.value
            : this.disabledMetadataFetchers),
        metadataFetcherOrder: (metadataFetcherOrder != null
            ? metadataFetcherOrder.value
            : this.metadataFetcherOrder),
        disabledImageFetchers: (disabledImageFetchers != null
            ? disabledImageFetchers.value
            : this.disabledImageFetchers),
        imageFetcherOrder: (imageFetcherOrder != null
            ? imageFetcherOrder.value
            : this.imageFetcherOrder));
  }
}

@JsonSerializable(explicitToJson: true)
class MovePlaylistItemRequestDto {
  const MovePlaylistItemRequestDto({
    this.playlistItemId,
    this.newIndex,
  });

  factory MovePlaylistItemRequestDto.fromJson(Map<String, dynamic> json) =>
      _$MovePlaylistItemRequestDtoFromJson(json);

  static const toJsonFactory = _$MovePlaylistItemRequestDtoToJson;
  Map<String, dynamic> toJson() => _$MovePlaylistItemRequestDtoToJson(this);

  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  @JsonKey(name: 'NewIndex')
  final int? newIndex;
  static const fromJsonFactory = _$MovePlaylistItemRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MovePlaylistItemRequestDto &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)) &&
            (identical(other.newIndex, newIndex) ||
                const DeepCollectionEquality()
                    .equals(other.newIndex, newIndex)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(playlistItemId) ^
      const DeepCollectionEquality().hash(newIndex) ^
      runtimeType.hashCode;
}

extension $MovePlaylistItemRequestDtoExtension on MovePlaylistItemRequestDto {
  MovePlaylistItemRequestDto copyWith({String? playlistItemId, int? newIndex}) {
    return MovePlaylistItemRequestDto(
        playlistItemId: playlistItemId ?? this.playlistItemId,
        newIndex: newIndex ?? this.newIndex);
  }

  MovePlaylistItemRequestDto copyWithWrapped(
      {Wrapped<String?>? playlistItemId, Wrapped<int?>? newIndex}) {
    return MovePlaylistItemRequestDto(
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId),
        newIndex: (newIndex != null ? newIndex.value : this.newIndex));
  }
}

@JsonSerializable(explicitToJson: true)
class MovieInfo {
  const MovieInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
  });

  factory MovieInfo.fromJson(Map<String, dynamic> json) =>
      _$MovieInfoFromJson(json);

  static const toJsonFactory = _$MovieInfoToJson;
  Map<String, dynamic> toJson() => _$MovieInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  static const fromJsonFactory = _$MovieInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MovieInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      runtimeType.hashCode;
}

extension $MovieInfoExtension on MovieInfo {
  MovieInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated}) {
    return MovieInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated);
  }

  MovieInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated}) {
    return MovieInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated));
  }
}

@JsonSerializable(explicitToJson: true)
class MovieInfoRemoteSearchQuery {
  const MovieInfoRemoteSearchQuery({
    this.searchInfo,
    this.itemId,
    this.searchProviderName,
    this.includeDisabledProviders,
  });

  factory MovieInfoRemoteSearchQuery.fromJson(Map<String, dynamic> json) =>
      _$MovieInfoRemoteSearchQueryFromJson(json);

  static const toJsonFactory = _$MovieInfoRemoteSearchQueryToJson;
  Map<String, dynamic> toJson() => _$MovieInfoRemoteSearchQueryToJson(this);

  @JsonKey(name: 'SearchInfo')
  final MovieInfo? searchInfo;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'IncludeDisabledProviders')
  final bool? includeDisabledProviders;
  static const fromJsonFactory = _$MovieInfoRemoteSearchQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MovieInfoRemoteSearchQuery &&
            (identical(other.searchInfo, searchInfo) ||
                const DeepCollectionEquality()
                    .equals(other.searchInfo, searchInfo)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(
                    other.includeDisabledProviders, includeDisabledProviders) ||
                const DeepCollectionEquality().equals(
                    other.includeDisabledProviders, includeDisabledProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchInfo) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(includeDisabledProviders) ^
      runtimeType.hashCode;
}

extension $MovieInfoRemoteSearchQueryExtension on MovieInfoRemoteSearchQuery {
  MovieInfoRemoteSearchQuery copyWith(
      {MovieInfo? searchInfo,
      String? itemId,
      String? searchProviderName,
      bool? includeDisabledProviders}) {
    return MovieInfoRemoteSearchQuery(
        searchInfo: searchInfo ?? this.searchInfo,
        itemId: itemId ?? this.itemId,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        includeDisabledProviders:
            includeDisabledProviders ?? this.includeDisabledProviders);
  }

  MovieInfoRemoteSearchQuery copyWithWrapped(
      {Wrapped<MovieInfo?>? searchInfo,
      Wrapped<String?>? itemId,
      Wrapped<String?>? searchProviderName,
      Wrapped<bool?>? includeDisabledProviders}) {
    return MovieInfoRemoteSearchQuery(
        searchInfo: (searchInfo != null ? searchInfo.value : this.searchInfo),
        itemId: (itemId != null ? itemId.value : this.itemId),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        includeDisabledProviders: (includeDisabledProviders != null
            ? includeDisabledProviders.value
            : this.includeDisabledProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class MusicVideoInfo {
  const MusicVideoInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
    this.artists,
  });

  factory MusicVideoInfo.fromJson(Map<String, dynamic> json) =>
      _$MusicVideoInfoFromJson(json);

  static const toJsonFactory = _$MusicVideoInfoToJson;
  Map<String, dynamic> toJson() => _$MusicVideoInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  @JsonKey(name: 'Artists', defaultValue: <String>[])
  final List<String>? artists;
  static const fromJsonFactory = _$MusicVideoInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MusicVideoInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)) &&
            (identical(other.artists, artists) ||
                const DeepCollectionEquality().equals(other.artists, artists)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      const DeepCollectionEquality().hash(artists) ^
      runtimeType.hashCode;
}

extension $MusicVideoInfoExtension on MusicVideoInfo {
  MusicVideoInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated,
      List<String>? artists}) {
    return MusicVideoInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated,
        artists: artists ?? this.artists);
  }

  MusicVideoInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated,
      Wrapped<List<String>?>? artists}) {
    return MusicVideoInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated),
        artists: (artists != null ? artists.value : this.artists));
  }
}

@JsonSerializable(explicitToJson: true)
class MusicVideoInfoRemoteSearchQuery {
  const MusicVideoInfoRemoteSearchQuery({
    this.searchInfo,
    this.itemId,
    this.searchProviderName,
    this.includeDisabledProviders,
  });

  factory MusicVideoInfoRemoteSearchQuery.fromJson(Map<String, dynamic> json) =>
      _$MusicVideoInfoRemoteSearchQueryFromJson(json);

  static const toJsonFactory = _$MusicVideoInfoRemoteSearchQueryToJson;
  Map<String, dynamic> toJson() =>
      _$MusicVideoInfoRemoteSearchQueryToJson(this);

  @JsonKey(name: 'SearchInfo')
  final MusicVideoInfo? searchInfo;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'IncludeDisabledProviders')
  final bool? includeDisabledProviders;
  static const fromJsonFactory = _$MusicVideoInfoRemoteSearchQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MusicVideoInfoRemoteSearchQuery &&
            (identical(other.searchInfo, searchInfo) ||
                const DeepCollectionEquality()
                    .equals(other.searchInfo, searchInfo)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(
                    other.includeDisabledProviders, includeDisabledProviders) ||
                const DeepCollectionEquality().equals(
                    other.includeDisabledProviders, includeDisabledProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchInfo) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(includeDisabledProviders) ^
      runtimeType.hashCode;
}

extension $MusicVideoInfoRemoteSearchQueryExtension
    on MusicVideoInfoRemoteSearchQuery {
  MusicVideoInfoRemoteSearchQuery copyWith(
      {MusicVideoInfo? searchInfo,
      String? itemId,
      String? searchProviderName,
      bool? includeDisabledProviders}) {
    return MusicVideoInfoRemoteSearchQuery(
        searchInfo: searchInfo ?? this.searchInfo,
        itemId: itemId ?? this.itemId,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        includeDisabledProviders:
            includeDisabledProviders ?? this.includeDisabledProviders);
  }

  MusicVideoInfoRemoteSearchQuery copyWithWrapped(
      {Wrapped<MusicVideoInfo?>? searchInfo,
      Wrapped<String?>? itemId,
      Wrapped<String?>? searchProviderName,
      Wrapped<bool?>? includeDisabledProviders}) {
    return MusicVideoInfoRemoteSearchQuery(
        searchInfo: (searchInfo != null ? searchInfo.value : this.searchInfo),
        itemId: (itemId != null ? itemId.value : this.itemId),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        includeDisabledProviders: (includeDisabledProviders != null
            ? includeDisabledProviders.value
            : this.includeDisabledProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class NameGuidPair {
  const NameGuidPair({
    this.name,
    this.id,
  });

  factory NameGuidPair.fromJson(Map<String, dynamic> json) =>
      _$NameGuidPairFromJson(json);

  static const toJsonFactory = _$NameGuidPairToJson;
  Map<String, dynamic> toJson() => _$NameGuidPairToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Id')
  final String? id;
  static const fromJsonFactory = _$NameGuidPairFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NameGuidPair &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $NameGuidPairExtension on NameGuidPair {
  NameGuidPair copyWith({String? name, String? id}) {
    return NameGuidPair(name: name ?? this.name, id: id ?? this.id);
  }

  NameGuidPair copyWithWrapped({Wrapped<String?>? name, Wrapped<String?>? id}) {
    return NameGuidPair(
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class NameIdPair {
  const NameIdPair({
    this.name,
    this.id,
  });

  factory NameIdPair.fromJson(Map<String, dynamic> json) =>
      _$NameIdPairFromJson(json);

  static const toJsonFactory = _$NameIdPairToJson;
  Map<String, dynamic> toJson() => _$NameIdPairToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Id')
  final String? id;
  static const fromJsonFactory = _$NameIdPairFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NameIdPair &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $NameIdPairExtension on NameIdPair {
  NameIdPair copyWith({String? name, String? id}) {
    return NameIdPair(name: name ?? this.name, id: id ?? this.id);
  }

  NameIdPair copyWithWrapped({Wrapped<String?>? name, Wrapped<String?>? id}) {
    return NameIdPair(
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class NameValuePair {
  const NameValuePair({
    this.name,
    this.$Value,
  });

  factory NameValuePair.fromJson(Map<String, dynamic> json) =>
      _$NameValuePairFromJson(json);

  static const toJsonFactory = _$NameValuePairToJson;
  Map<String, dynamic> toJson() => _$NameValuePairToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Value')
  final String? $Value;
  static const fromJsonFactory = _$NameValuePairFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NameValuePair &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$Value, $Value) ||
                const DeepCollectionEquality().equals(other.$Value, $Value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($Value) ^
      runtimeType.hashCode;
}

extension $NameValuePairExtension on NameValuePair {
  NameValuePair copyWith({String? name, String? $Value}) {
    return NameValuePair(
        name: name ?? this.name, $Value: $Value ?? this.$Value);
  }

  NameValuePair copyWithWrapped(
      {Wrapped<String?>? name, Wrapped<String?>? $Value}) {
    return NameValuePair(
        name: (name != null ? name.value : this.name),
        $Value: ($Value != null ? $Value.value : this.$Value));
  }
}

@JsonSerializable(explicitToJson: true)
class NetworkConfiguration {
  const NetworkConfiguration({
    this.baseUrl,
    this.enableHttps,
    this.requireHttps,
    this.certificatePath,
    this.certificatePassword,
    this.internalHttpPort,
    this.internalHttpsPort,
    this.publicHttpPort,
    this.publicHttpsPort,
    this.autoDiscovery,
    this.enableUPnP,
    this.enableIPv4,
    this.enableIPv6,
    this.enableRemoteAccess,
    this.localNetworkSubnets,
    this.localNetworkAddresses,
    this.knownProxies,
    this.ignoreVirtualInterfaces,
    this.virtualInterfaceNames,
    this.enablePublishedServerUriByRequest,
    this.publishedServerUriBySubnet,
    this.remoteIPFilter,
    this.isRemoteIPFilterBlacklist,
  });

  factory NetworkConfiguration.fromJson(Map<String, dynamic> json) =>
      _$NetworkConfigurationFromJson(json);

  static const toJsonFactory = _$NetworkConfigurationToJson;
  Map<String, dynamic> toJson() => _$NetworkConfigurationToJson(this);

  @JsonKey(name: 'BaseUrl')
  final String? baseUrl;
  @JsonKey(name: 'EnableHttps')
  final bool? enableHttps;
  @JsonKey(name: 'RequireHttps')
  final bool? requireHttps;
  @JsonKey(name: 'CertificatePath')
  final String? certificatePath;
  @JsonKey(name: 'CertificatePassword')
  final String? certificatePassword;
  @JsonKey(name: 'InternalHttpPort')
  final int? internalHttpPort;
  @JsonKey(name: 'InternalHttpsPort')
  final int? internalHttpsPort;
  @JsonKey(name: 'PublicHttpPort')
  final int? publicHttpPort;
  @JsonKey(name: 'PublicHttpsPort')
  final int? publicHttpsPort;
  @JsonKey(name: 'AutoDiscovery')
  final bool? autoDiscovery;
  @JsonKey(name: 'EnableUPnP')
  final bool? enableUPnP;
  @JsonKey(name: 'EnableIPv4')
  final bool? enableIPv4;
  @JsonKey(name: 'EnableIPv6')
  final bool? enableIPv6;
  @JsonKey(name: 'EnableRemoteAccess')
  final bool? enableRemoteAccess;
  @JsonKey(name: 'LocalNetworkSubnets', defaultValue: <String>[])
  final List<String>? localNetworkSubnets;
  @JsonKey(name: 'LocalNetworkAddresses', defaultValue: <String>[])
  final List<String>? localNetworkAddresses;
  @JsonKey(name: 'KnownProxies', defaultValue: <String>[])
  final List<String>? knownProxies;
  @JsonKey(name: 'IgnoreVirtualInterfaces')
  final bool? ignoreVirtualInterfaces;
  @JsonKey(name: 'VirtualInterfaceNames', defaultValue: <String>[])
  final List<String>? virtualInterfaceNames;
  @JsonKey(name: 'EnablePublishedServerUriByRequest')
  final bool? enablePublishedServerUriByRequest;
  @JsonKey(name: 'PublishedServerUriBySubnet', defaultValue: <String>[])
  final List<String>? publishedServerUriBySubnet;
  @JsonKey(name: 'RemoteIPFilter', defaultValue: <String>[])
  final List<String>? remoteIPFilter;
  @JsonKey(name: 'IsRemoteIPFilterBlacklist')
  final bool? isRemoteIPFilterBlacklist;
  static const fromJsonFactory = _$NetworkConfigurationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NetworkConfiguration &&
            (identical(other.baseUrl, baseUrl) ||
                const DeepCollectionEquality()
                    .equals(other.baseUrl, baseUrl)) &&
            (identical(other.enableHttps, enableHttps) ||
                const DeepCollectionEquality()
                    .equals(other.enableHttps, enableHttps)) &&
            (identical(other.requireHttps, requireHttps) ||
                const DeepCollectionEquality()
                    .equals(other.requireHttps, requireHttps)) &&
            (identical(other.certificatePath, certificatePath) ||
                const DeepCollectionEquality()
                    .equals(other.certificatePath, certificatePath)) &&
            (identical(other.certificatePassword, certificatePassword) ||
                const DeepCollectionEquality()
                    .equals(other.certificatePassword, certificatePassword)) &&
            (identical(other.internalHttpPort, internalHttpPort) ||
                const DeepCollectionEquality()
                    .equals(other.internalHttpPort, internalHttpPort)) &&
            (identical(other.internalHttpsPort, internalHttpsPort) ||
                const DeepCollectionEquality()
                    .equals(other.internalHttpsPort, internalHttpsPort)) &&
            (identical(other.publicHttpPort, publicHttpPort) ||
                const DeepCollectionEquality()
                    .equals(other.publicHttpPort, publicHttpPort)) &&
            (identical(other.publicHttpsPort, publicHttpsPort) ||
                const DeepCollectionEquality()
                    .equals(other.publicHttpsPort, publicHttpsPort)) &&
            (identical(other.autoDiscovery, autoDiscovery) ||
                const DeepCollectionEquality()
                    .equals(other.autoDiscovery, autoDiscovery)) &&
            (identical(other.enableUPnP, enableUPnP) ||
                const DeepCollectionEquality()
                    .equals(other.enableUPnP, enableUPnP)) &&
            (identical(other.enableIPv4, enableIPv4) ||
                const DeepCollectionEquality()
                    .equals(other.enableIPv4, enableIPv4)) &&
            (identical(other.enableIPv6, enableIPv6) ||
                const DeepCollectionEquality()
                    .equals(other.enableIPv6, enableIPv6)) &&
            (identical(other.enableRemoteAccess, enableRemoteAccess) ||
                const DeepCollectionEquality()
                    .equals(other.enableRemoteAccess, enableRemoteAccess)) &&
            (identical(other.localNetworkSubnets, localNetworkSubnets) ||
                const DeepCollectionEquality()
                    .equals(other.localNetworkSubnets, localNetworkSubnets)) &&
            (identical(other.localNetworkAddresses, localNetworkAddresses) ||
                const DeepCollectionEquality().equals(
                    other.localNetworkAddresses, localNetworkAddresses)) &&
            (identical(other.knownProxies, knownProxies) ||
                const DeepCollectionEquality()
                    .equals(other.knownProxies, knownProxies)) &&
            (identical(other.ignoreVirtualInterfaces, ignoreVirtualInterfaces) ||
                const DeepCollectionEquality().equals(
                    other.ignoreVirtualInterfaces, ignoreVirtualInterfaces)) &&
            (identical(other.virtualInterfaceNames, virtualInterfaceNames) ||
                const DeepCollectionEquality().equals(
                    other.virtualInterfaceNames, virtualInterfaceNames)) &&
            (identical(other.enablePublishedServerUriByRequest, enablePublishedServerUriByRequest) ||
                const DeepCollectionEquality().equals(
                    other.enablePublishedServerUriByRequest,
                    enablePublishedServerUriByRequest)) &&
            (identical(other.publishedServerUriBySubnet, publishedServerUriBySubnet) || const DeepCollectionEquality().equals(other.publishedServerUriBySubnet, publishedServerUriBySubnet)) &&
            (identical(other.remoteIPFilter, remoteIPFilter) || const DeepCollectionEquality().equals(other.remoteIPFilter, remoteIPFilter)) &&
            (identical(other.isRemoteIPFilterBlacklist, isRemoteIPFilterBlacklist) || const DeepCollectionEquality().equals(other.isRemoteIPFilterBlacklist, isRemoteIPFilterBlacklist)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(baseUrl) ^
      const DeepCollectionEquality().hash(enableHttps) ^
      const DeepCollectionEquality().hash(requireHttps) ^
      const DeepCollectionEquality().hash(certificatePath) ^
      const DeepCollectionEquality().hash(certificatePassword) ^
      const DeepCollectionEquality().hash(internalHttpPort) ^
      const DeepCollectionEquality().hash(internalHttpsPort) ^
      const DeepCollectionEquality().hash(publicHttpPort) ^
      const DeepCollectionEquality().hash(publicHttpsPort) ^
      const DeepCollectionEquality().hash(autoDiscovery) ^
      const DeepCollectionEquality().hash(enableUPnP) ^
      const DeepCollectionEquality().hash(enableIPv4) ^
      const DeepCollectionEquality().hash(enableIPv6) ^
      const DeepCollectionEquality().hash(enableRemoteAccess) ^
      const DeepCollectionEquality().hash(localNetworkSubnets) ^
      const DeepCollectionEquality().hash(localNetworkAddresses) ^
      const DeepCollectionEquality().hash(knownProxies) ^
      const DeepCollectionEquality().hash(ignoreVirtualInterfaces) ^
      const DeepCollectionEquality().hash(virtualInterfaceNames) ^
      const DeepCollectionEquality().hash(enablePublishedServerUriByRequest) ^
      const DeepCollectionEquality().hash(publishedServerUriBySubnet) ^
      const DeepCollectionEquality().hash(remoteIPFilter) ^
      const DeepCollectionEquality().hash(isRemoteIPFilterBlacklist) ^
      runtimeType.hashCode;
}

extension $NetworkConfigurationExtension on NetworkConfiguration {
  NetworkConfiguration copyWith(
      {String? baseUrl,
      bool? enableHttps,
      bool? requireHttps,
      String? certificatePath,
      String? certificatePassword,
      int? internalHttpPort,
      int? internalHttpsPort,
      int? publicHttpPort,
      int? publicHttpsPort,
      bool? autoDiscovery,
      bool? enableUPnP,
      bool? enableIPv4,
      bool? enableIPv6,
      bool? enableRemoteAccess,
      List<String>? localNetworkSubnets,
      List<String>? localNetworkAddresses,
      List<String>? knownProxies,
      bool? ignoreVirtualInterfaces,
      List<String>? virtualInterfaceNames,
      bool? enablePublishedServerUriByRequest,
      List<String>? publishedServerUriBySubnet,
      List<String>? remoteIPFilter,
      bool? isRemoteIPFilterBlacklist}) {
    return NetworkConfiguration(
        baseUrl: baseUrl ?? this.baseUrl,
        enableHttps: enableHttps ?? this.enableHttps,
        requireHttps: requireHttps ?? this.requireHttps,
        certificatePath: certificatePath ?? this.certificatePath,
        certificatePassword: certificatePassword ?? this.certificatePassword,
        internalHttpPort: internalHttpPort ?? this.internalHttpPort,
        internalHttpsPort: internalHttpsPort ?? this.internalHttpsPort,
        publicHttpPort: publicHttpPort ?? this.publicHttpPort,
        publicHttpsPort: publicHttpsPort ?? this.publicHttpsPort,
        autoDiscovery: autoDiscovery ?? this.autoDiscovery,
        enableUPnP: enableUPnP ?? this.enableUPnP,
        enableIPv4: enableIPv4 ?? this.enableIPv4,
        enableIPv6: enableIPv6 ?? this.enableIPv6,
        enableRemoteAccess: enableRemoteAccess ?? this.enableRemoteAccess,
        localNetworkSubnets: localNetworkSubnets ?? this.localNetworkSubnets,
        localNetworkAddresses:
            localNetworkAddresses ?? this.localNetworkAddresses,
        knownProxies: knownProxies ?? this.knownProxies,
        ignoreVirtualInterfaces:
            ignoreVirtualInterfaces ?? this.ignoreVirtualInterfaces,
        virtualInterfaceNames:
            virtualInterfaceNames ?? this.virtualInterfaceNames,
        enablePublishedServerUriByRequest: enablePublishedServerUriByRequest ??
            this.enablePublishedServerUriByRequest,
        publishedServerUriBySubnet:
            publishedServerUriBySubnet ?? this.publishedServerUriBySubnet,
        remoteIPFilter: remoteIPFilter ?? this.remoteIPFilter,
        isRemoteIPFilterBlacklist:
            isRemoteIPFilterBlacklist ?? this.isRemoteIPFilterBlacklist);
  }

  NetworkConfiguration copyWithWrapped(
      {Wrapped<String?>? baseUrl,
      Wrapped<bool?>? enableHttps,
      Wrapped<bool?>? requireHttps,
      Wrapped<String?>? certificatePath,
      Wrapped<String?>? certificatePassword,
      Wrapped<int?>? internalHttpPort,
      Wrapped<int?>? internalHttpsPort,
      Wrapped<int?>? publicHttpPort,
      Wrapped<int?>? publicHttpsPort,
      Wrapped<bool?>? autoDiscovery,
      Wrapped<bool?>? enableUPnP,
      Wrapped<bool?>? enableIPv4,
      Wrapped<bool?>? enableIPv6,
      Wrapped<bool?>? enableRemoteAccess,
      Wrapped<List<String>?>? localNetworkSubnets,
      Wrapped<List<String>?>? localNetworkAddresses,
      Wrapped<List<String>?>? knownProxies,
      Wrapped<bool?>? ignoreVirtualInterfaces,
      Wrapped<List<String>?>? virtualInterfaceNames,
      Wrapped<bool?>? enablePublishedServerUriByRequest,
      Wrapped<List<String>?>? publishedServerUriBySubnet,
      Wrapped<List<String>?>? remoteIPFilter,
      Wrapped<bool?>? isRemoteIPFilterBlacklist}) {
    return NetworkConfiguration(
        baseUrl: (baseUrl != null ? baseUrl.value : this.baseUrl),
        enableHttps:
            (enableHttps != null ? enableHttps.value : this.enableHttps),
        requireHttps:
            (requireHttps != null ? requireHttps.value : this.requireHttps),
        certificatePath: (certificatePath != null
            ? certificatePath.value
            : this.certificatePath),
        certificatePassword: (certificatePassword != null
            ? certificatePassword.value
            : this.certificatePassword),
        internalHttpPort: (internalHttpPort != null
            ? internalHttpPort.value
            : this.internalHttpPort),
        internalHttpsPort: (internalHttpsPort != null
            ? internalHttpsPort.value
            : this.internalHttpsPort),
        publicHttpPort: (publicHttpPort != null
            ? publicHttpPort.value
            : this.publicHttpPort),
        publicHttpsPort: (publicHttpsPort != null
            ? publicHttpsPort.value
            : this.publicHttpsPort),
        autoDiscovery:
            (autoDiscovery != null ? autoDiscovery.value : this.autoDiscovery),
        enableUPnP: (enableUPnP != null ? enableUPnP.value : this.enableUPnP),
        enableIPv4: (enableIPv4 != null ? enableIPv4.value : this.enableIPv4),
        enableIPv6: (enableIPv6 != null ? enableIPv6.value : this.enableIPv6),
        enableRemoteAccess: (enableRemoteAccess != null
            ? enableRemoteAccess.value
            : this.enableRemoteAccess),
        localNetworkSubnets: (localNetworkSubnets != null
            ? localNetworkSubnets.value
            : this.localNetworkSubnets),
        localNetworkAddresses: (localNetworkAddresses != null
            ? localNetworkAddresses.value
            : this.localNetworkAddresses),
        knownProxies:
            (knownProxies != null ? knownProxies.value : this.knownProxies),
        ignoreVirtualInterfaces: (ignoreVirtualInterfaces != null
            ? ignoreVirtualInterfaces.value
            : this.ignoreVirtualInterfaces),
        virtualInterfaceNames: (virtualInterfaceNames != null
            ? virtualInterfaceNames.value
            : this.virtualInterfaceNames),
        enablePublishedServerUriByRequest:
            (enablePublishedServerUriByRequest != null
                ? enablePublishedServerUriByRequest.value
                : this.enablePublishedServerUriByRequest),
        publishedServerUriBySubnet: (publishedServerUriBySubnet != null
            ? publishedServerUriBySubnet.value
            : this.publishedServerUriBySubnet),
        remoteIPFilter: (remoteIPFilter != null
            ? remoteIPFilter.value
            : this.remoteIPFilter),
        isRemoteIPFilterBlacklist: (isRemoteIPFilterBlacklist != null
            ? isRemoteIPFilterBlacklist.value
            : this.isRemoteIPFilterBlacklist));
  }
}

@JsonSerializable(explicitToJson: true)
class NewGroupRequestDto {
  const NewGroupRequestDto({
    this.groupName,
  });

  factory NewGroupRequestDto.fromJson(Map<String, dynamic> json) =>
      _$NewGroupRequestDtoFromJson(json);

  static const toJsonFactory = _$NewGroupRequestDtoToJson;
  Map<String, dynamic> toJson() => _$NewGroupRequestDtoToJson(this);

  @JsonKey(name: 'GroupName')
  final String? groupName;
  static const fromJsonFactory = _$NewGroupRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NewGroupRequestDto &&
            (identical(other.groupName, groupName) ||
                const DeepCollectionEquality()
                    .equals(other.groupName, groupName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(groupName) ^ runtimeType.hashCode;
}

extension $NewGroupRequestDtoExtension on NewGroupRequestDto {
  NewGroupRequestDto copyWith({String? groupName}) {
    return NewGroupRequestDto(groupName: groupName ?? this.groupName);
  }

  NewGroupRequestDto copyWithWrapped({Wrapped<String?>? groupName}) {
    return NewGroupRequestDto(
        groupName: (groupName != null ? groupName.value : this.groupName));
  }
}

@JsonSerializable(explicitToJson: true)
class NextItemRequestDto {
  const NextItemRequestDto({
    this.playlistItemId,
  });

  factory NextItemRequestDto.fromJson(Map<String, dynamic> json) =>
      _$NextItemRequestDtoFromJson(json);

  static const toJsonFactory = _$NextItemRequestDtoToJson;
  Map<String, dynamic> toJson() => _$NextItemRequestDtoToJson(this);

  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  static const fromJsonFactory = _$NextItemRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NextItemRequestDto &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(playlistItemId) ^
      runtimeType.hashCode;
}

extension $NextItemRequestDtoExtension on NextItemRequestDto {
  NextItemRequestDto copyWith({String? playlistItemId}) {
    return NextItemRequestDto(
        playlistItemId: playlistItemId ?? this.playlistItemId);
  }

  NextItemRequestDto copyWithWrapped({Wrapped<String?>? playlistItemId}) {
    return NextItemRequestDto(
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId));
  }
}

@JsonSerializable(explicitToJson: true)
class OpenLiveStreamDto {
  const OpenLiveStreamDto({
    this.openToken,
    this.userId,
    this.playSessionId,
    this.maxStreamingBitrate,
    this.startTimeTicks,
    this.audioStreamIndex,
    this.subtitleStreamIndex,
    this.maxAudioChannels,
    this.itemId,
    this.enableDirectPlay,
    this.enableDirectStream,
    this.alwaysBurnInSubtitleWhenTranscoding,
    this.deviceProfile,
    this.directPlayProtocols,
  });

  factory OpenLiveStreamDto.fromJson(Map<String, dynamic> json) =>
      _$OpenLiveStreamDtoFromJson(json);

  static const toJsonFactory = _$OpenLiveStreamDtoToJson;
  Map<String, dynamic> toJson() => _$OpenLiveStreamDtoToJson(this);

  @JsonKey(name: 'OpenToken')
  final String? openToken;
  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'PlaySessionId')
  final String? playSessionId;
  @JsonKey(name: 'MaxStreamingBitrate')
  final int? maxStreamingBitrate;
  @JsonKey(name: 'StartTimeTicks')
  final int? startTimeTicks;
  @JsonKey(name: 'AudioStreamIndex')
  final int? audioStreamIndex;
  @JsonKey(name: 'SubtitleStreamIndex')
  final int? subtitleStreamIndex;
  @JsonKey(name: 'MaxAudioChannels')
  final int? maxAudioChannels;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'EnableDirectPlay')
  final bool? enableDirectPlay;
  @JsonKey(name: 'EnableDirectStream')
  final bool? enableDirectStream;
  @JsonKey(name: 'AlwaysBurnInSubtitleWhenTranscoding')
  final bool? alwaysBurnInSubtitleWhenTranscoding;
  @JsonKey(name: 'DeviceProfile')
  final DeviceProfile? deviceProfile;
  @JsonKey(
    name: 'DirectPlayProtocols',
    toJson: mediaProtocolListToJson,
    fromJson: mediaProtocolListFromJson,
  )
  final List<enums.MediaProtocol>? directPlayProtocols;
  static const fromJsonFactory = _$OpenLiveStreamDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OpenLiveStreamDto &&
            (identical(other.openToken, openToken) ||
                const DeepCollectionEquality()
                    .equals(other.openToken, openToken)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.playSessionId, playSessionId) ||
                const DeepCollectionEquality()
                    .equals(other.playSessionId, playSessionId)) &&
            (identical(other.maxStreamingBitrate, maxStreamingBitrate) ||
                const DeepCollectionEquality()
                    .equals(other.maxStreamingBitrate, maxStreamingBitrate)) &&
            (identical(other.startTimeTicks, startTimeTicks) ||
                const DeepCollectionEquality()
                    .equals(other.startTimeTicks, startTimeTicks)) &&
            (identical(other.audioStreamIndex, audioStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.audioStreamIndex, audioStreamIndex)) &&
            (identical(other.subtitleStreamIndex, subtitleStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.subtitleStreamIndex, subtitleStreamIndex)) &&
            (identical(other.maxAudioChannels, maxAudioChannels) ||
                const DeepCollectionEquality()
                    .equals(other.maxAudioChannels, maxAudioChannels)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.enableDirectPlay, enableDirectPlay) ||
                const DeepCollectionEquality()
                    .equals(other.enableDirectPlay, enableDirectPlay)) &&
            (identical(other.enableDirectStream, enableDirectStream) ||
                const DeepCollectionEquality()
                    .equals(other.enableDirectStream, enableDirectStream)) &&
            (identical(other.alwaysBurnInSubtitleWhenTranscoding,
                    alwaysBurnInSubtitleWhenTranscoding) ||
                const DeepCollectionEquality().equals(
                    other.alwaysBurnInSubtitleWhenTranscoding,
                    alwaysBurnInSubtitleWhenTranscoding)) &&
            (identical(other.deviceProfile, deviceProfile) ||
                const DeepCollectionEquality()
                    .equals(other.deviceProfile, deviceProfile)) &&
            (identical(other.directPlayProtocols, directPlayProtocols) ||
                const DeepCollectionEquality()
                    .equals(other.directPlayProtocols, directPlayProtocols)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(openToken) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(playSessionId) ^
      const DeepCollectionEquality().hash(maxStreamingBitrate) ^
      const DeepCollectionEquality().hash(startTimeTicks) ^
      const DeepCollectionEquality().hash(audioStreamIndex) ^
      const DeepCollectionEquality().hash(subtitleStreamIndex) ^
      const DeepCollectionEquality().hash(maxAudioChannels) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(enableDirectPlay) ^
      const DeepCollectionEquality().hash(enableDirectStream) ^
      const DeepCollectionEquality().hash(alwaysBurnInSubtitleWhenTranscoding) ^
      const DeepCollectionEquality().hash(deviceProfile) ^
      const DeepCollectionEquality().hash(directPlayProtocols) ^
      runtimeType.hashCode;
}

extension $OpenLiveStreamDtoExtension on OpenLiveStreamDto {
  OpenLiveStreamDto copyWith(
      {String? openToken,
      String? userId,
      String? playSessionId,
      int? maxStreamingBitrate,
      int? startTimeTicks,
      int? audioStreamIndex,
      int? subtitleStreamIndex,
      int? maxAudioChannels,
      String? itemId,
      bool? enableDirectPlay,
      bool? enableDirectStream,
      bool? alwaysBurnInSubtitleWhenTranscoding,
      DeviceProfile? deviceProfile,
      List<enums.MediaProtocol>? directPlayProtocols}) {
    return OpenLiveStreamDto(
        openToken: openToken ?? this.openToken,
        userId: userId ?? this.userId,
        playSessionId: playSessionId ?? this.playSessionId,
        maxStreamingBitrate: maxStreamingBitrate ?? this.maxStreamingBitrate,
        startTimeTicks: startTimeTicks ?? this.startTimeTicks,
        audioStreamIndex: audioStreamIndex ?? this.audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex ?? this.subtitleStreamIndex,
        maxAudioChannels: maxAudioChannels ?? this.maxAudioChannels,
        itemId: itemId ?? this.itemId,
        enableDirectPlay: enableDirectPlay ?? this.enableDirectPlay,
        enableDirectStream: enableDirectStream ?? this.enableDirectStream,
        alwaysBurnInSubtitleWhenTranscoding:
            alwaysBurnInSubtitleWhenTranscoding ??
                this.alwaysBurnInSubtitleWhenTranscoding,
        deviceProfile: deviceProfile ?? this.deviceProfile,
        directPlayProtocols: directPlayProtocols ?? this.directPlayProtocols);
  }

  OpenLiveStreamDto copyWithWrapped(
      {Wrapped<String?>? openToken,
      Wrapped<String?>? userId,
      Wrapped<String?>? playSessionId,
      Wrapped<int?>? maxStreamingBitrate,
      Wrapped<int?>? startTimeTicks,
      Wrapped<int?>? audioStreamIndex,
      Wrapped<int?>? subtitleStreamIndex,
      Wrapped<int?>? maxAudioChannels,
      Wrapped<String?>? itemId,
      Wrapped<bool?>? enableDirectPlay,
      Wrapped<bool?>? enableDirectStream,
      Wrapped<bool?>? alwaysBurnInSubtitleWhenTranscoding,
      Wrapped<DeviceProfile?>? deviceProfile,
      Wrapped<List<enums.MediaProtocol>?>? directPlayProtocols}) {
    return OpenLiveStreamDto(
        openToken: (openToken != null ? openToken.value : this.openToken),
        userId: (userId != null ? userId.value : this.userId),
        playSessionId:
            (playSessionId != null ? playSessionId.value : this.playSessionId),
        maxStreamingBitrate: (maxStreamingBitrate != null
            ? maxStreamingBitrate.value
            : this.maxStreamingBitrate),
        startTimeTicks: (startTimeTicks != null
            ? startTimeTicks.value
            : this.startTimeTicks),
        audioStreamIndex: (audioStreamIndex != null
            ? audioStreamIndex.value
            : this.audioStreamIndex),
        subtitleStreamIndex: (subtitleStreamIndex != null
            ? subtitleStreamIndex.value
            : this.subtitleStreamIndex),
        maxAudioChannels: (maxAudioChannels != null
            ? maxAudioChannels.value
            : this.maxAudioChannels),
        itemId: (itemId != null ? itemId.value : this.itemId),
        enableDirectPlay: (enableDirectPlay != null
            ? enableDirectPlay.value
            : this.enableDirectPlay),
        enableDirectStream: (enableDirectStream != null
            ? enableDirectStream.value
            : this.enableDirectStream),
        alwaysBurnInSubtitleWhenTranscoding:
            (alwaysBurnInSubtitleWhenTranscoding != null
                ? alwaysBurnInSubtitleWhenTranscoding.value
                : this.alwaysBurnInSubtitleWhenTranscoding),
        deviceProfile:
            (deviceProfile != null ? deviceProfile.value : this.deviceProfile),
        directPlayProtocols: (directPlayProtocols != null
            ? directPlayProtocols.value
            : this.directPlayProtocols));
  }
}

@JsonSerializable(explicitToJson: true)
class OutboundKeepAliveMessage {
  const OutboundKeepAliveMessage({
    this.messageId,
    this.messageType,
  });

  factory OutboundKeepAliveMessage.fromJson(Map<String, dynamic> json) =>
      _$OutboundKeepAliveMessageFromJson(json);

  static const toJsonFactory = _$OutboundKeepAliveMessageToJson;
  Map<String, dynamic> toJson() => _$OutboundKeepAliveMessageToJson(this);

  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.keepalive);

  static const fromJsonFactory = _$OutboundKeepAliveMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OutboundKeepAliveMessage &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $OutboundKeepAliveMessageExtension on OutboundKeepAliveMessage {
  OutboundKeepAliveMessage copyWith(
      {String? messageId, enums.SessionMessageType? messageType}) {
    return OutboundKeepAliveMessage(
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  OutboundKeepAliveMessage copyWithWrapped(
      {Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return OutboundKeepAliveMessage(
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class OutboundWebSocketMessage {
  const OutboundWebSocketMessage();

  factory OutboundWebSocketMessage.fromJson(Map<String, dynamic> json) =>
      _$OutboundWebSocketMessageFromJson(json);

  static const toJsonFactory = _$OutboundWebSocketMessageToJson;
  Map<String, dynamic> toJson() => _$OutboundWebSocketMessageToJson(this);

  static const fromJsonFactory = _$OutboundWebSocketMessageFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class PackageInfo {
  const PackageInfo({
    this.name,
    this.description,
    this.overview,
    this.owner,
    this.category,
    this.guid,
    this.versions,
    this.imageUrl,
  });

  factory PackageInfo.fromJson(Map<String, dynamic> json) =>
      _$PackageInfoFromJson(json);

  static const toJsonFactory = _$PackageInfoToJson;
  Map<String, dynamic> toJson() => _$PackageInfoToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'overview')
  final String? overview;
  @JsonKey(name: 'owner')
  final String? owner;
  @JsonKey(name: 'category')
  final String? category;
  @JsonKey(name: 'guid')
  final String? guid;
  @JsonKey(name: 'versions', defaultValue: <VersionInfo>[])
  final List<VersionInfo>? versions;
  @JsonKey(name: 'imageUrl')
  final String? imageUrl;
  static const fromJsonFactory = _$PackageInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PackageInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.overview, overview) ||
                const DeepCollectionEquality()
                    .equals(other.overview, overview)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.guid, guid) ||
                const DeepCollectionEquality().equals(other.guid, guid)) &&
            (identical(other.versions, versions) ||
                const DeepCollectionEquality()
                    .equals(other.versions, versions)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(overview) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(guid) ^
      const DeepCollectionEquality().hash(versions) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      runtimeType.hashCode;
}

extension $PackageInfoExtension on PackageInfo {
  PackageInfo copyWith(
      {String? name,
      String? description,
      String? overview,
      String? owner,
      String? category,
      String? guid,
      List<VersionInfo>? versions,
      String? imageUrl}) {
    return PackageInfo(
        name: name ?? this.name,
        description: description ?? this.description,
        overview: overview ?? this.overview,
        owner: owner ?? this.owner,
        category: category ?? this.category,
        guid: guid ?? this.guid,
        versions: versions ?? this.versions,
        imageUrl: imageUrl ?? this.imageUrl);
  }

  PackageInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? description,
      Wrapped<String?>? overview,
      Wrapped<String?>? owner,
      Wrapped<String?>? category,
      Wrapped<String?>? guid,
      Wrapped<List<VersionInfo>?>? versions,
      Wrapped<String?>? imageUrl}) {
    return PackageInfo(
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        overview: (overview != null ? overview.value : this.overview),
        owner: (owner != null ? owner.value : this.owner),
        category: (category != null ? category.value : this.category),
        guid: (guid != null ? guid.value : this.guid),
        versions: (versions != null ? versions.value : this.versions),
        imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class ParentalRating {
  const ParentalRating({
    this.name,
    this.$Value,
  });

  factory ParentalRating.fromJson(Map<String, dynamic> json) =>
      _$ParentalRatingFromJson(json);

  static const toJsonFactory = _$ParentalRatingToJson;
  Map<String, dynamic> toJson() => _$ParentalRatingToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Value')
  final int? $Value;
  static const fromJsonFactory = _$ParentalRatingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ParentalRating &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$Value, $Value) ||
                const DeepCollectionEquality().equals(other.$Value, $Value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($Value) ^
      runtimeType.hashCode;
}

extension $ParentalRatingExtension on ParentalRating {
  ParentalRating copyWith({String? name, int? $Value}) {
    return ParentalRating(
        name: name ?? this.name, $Value: $Value ?? this.$Value);
  }

  ParentalRating copyWithWrapped(
      {Wrapped<String?>? name, Wrapped<int?>? $Value}) {
    return ParentalRating(
        name: (name != null ? name.value : this.name),
        $Value: ($Value != null ? $Value.value : this.$Value));
  }
}

@JsonSerializable(explicitToJson: true)
class PathSubstitution {
  const PathSubstitution({
    this.from,
    this.to,
  });

  factory PathSubstitution.fromJson(Map<String, dynamic> json) =>
      _$PathSubstitutionFromJson(json);

  static const toJsonFactory = _$PathSubstitutionToJson;
  Map<String, dynamic> toJson() => _$PathSubstitutionToJson(this);

  @JsonKey(name: 'From')
  final String? from;
  @JsonKey(name: 'To')
  final String? to;
  static const fromJsonFactory = _$PathSubstitutionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PathSubstitution &&
            (identical(other.from, from) ||
                const DeepCollectionEquality().equals(other.from, from)) &&
            (identical(other.to, to) ||
                const DeepCollectionEquality().equals(other.to, to)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(from) ^
      const DeepCollectionEquality().hash(to) ^
      runtimeType.hashCode;
}

extension $PathSubstitutionExtension on PathSubstitution {
  PathSubstitution copyWith({String? from, String? to}) {
    return PathSubstitution(from: from ?? this.from, to: to ?? this.to);
  }

  PathSubstitution copyWithWrapped(
      {Wrapped<String?>? from, Wrapped<String?>? to}) {
    return PathSubstitution(
        from: (from != null ? from.value : this.from),
        to: (to != null ? to.value : this.to));
  }
}

@JsonSerializable(explicitToJson: true)
class PersonLookupInfo {
  const PersonLookupInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
  });

  factory PersonLookupInfo.fromJson(Map<String, dynamic> json) =>
      _$PersonLookupInfoFromJson(json);

  static const toJsonFactory = _$PersonLookupInfoToJson;
  Map<String, dynamic> toJson() => _$PersonLookupInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  static const fromJsonFactory = _$PersonLookupInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonLookupInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      runtimeType.hashCode;
}

extension $PersonLookupInfoExtension on PersonLookupInfo {
  PersonLookupInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated}) {
    return PersonLookupInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated);
  }

  PersonLookupInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated}) {
    return PersonLookupInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated));
  }
}

@JsonSerializable(explicitToJson: true)
class PersonLookupInfoRemoteSearchQuery {
  const PersonLookupInfoRemoteSearchQuery({
    this.searchInfo,
    this.itemId,
    this.searchProviderName,
    this.includeDisabledProviders,
  });

  factory PersonLookupInfoRemoteSearchQuery.fromJson(
          Map<String, dynamic> json) =>
      _$PersonLookupInfoRemoteSearchQueryFromJson(json);

  static const toJsonFactory = _$PersonLookupInfoRemoteSearchQueryToJson;
  Map<String, dynamic> toJson() =>
      _$PersonLookupInfoRemoteSearchQueryToJson(this);

  @JsonKey(name: 'SearchInfo')
  final PersonLookupInfo? searchInfo;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'IncludeDisabledProviders')
  final bool? includeDisabledProviders;
  static const fromJsonFactory = _$PersonLookupInfoRemoteSearchQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonLookupInfoRemoteSearchQuery &&
            (identical(other.searchInfo, searchInfo) ||
                const DeepCollectionEquality()
                    .equals(other.searchInfo, searchInfo)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(
                    other.includeDisabledProviders, includeDisabledProviders) ||
                const DeepCollectionEquality().equals(
                    other.includeDisabledProviders, includeDisabledProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchInfo) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(includeDisabledProviders) ^
      runtimeType.hashCode;
}

extension $PersonLookupInfoRemoteSearchQueryExtension
    on PersonLookupInfoRemoteSearchQuery {
  PersonLookupInfoRemoteSearchQuery copyWith(
      {PersonLookupInfo? searchInfo,
      String? itemId,
      String? searchProviderName,
      bool? includeDisabledProviders}) {
    return PersonLookupInfoRemoteSearchQuery(
        searchInfo: searchInfo ?? this.searchInfo,
        itemId: itemId ?? this.itemId,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        includeDisabledProviders:
            includeDisabledProviders ?? this.includeDisabledProviders);
  }

  PersonLookupInfoRemoteSearchQuery copyWithWrapped(
      {Wrapped<PersonLookupInfo?>? searchInfo,
      Wrapped<String?>? itemId,
      Wrapped<String?>? searchProviderName,
      Wrapped<bool?>? includeDisabledProviders}) {
    return PersonLookupInfoRemoteSearchQuery(
        searchInfo: (searchInfo != null ? searchInfo.value : this.searchInfo),
        itemId: (itemId != null ? itemId.value : this.itemId),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        includeDisabledProviders: (includeDisabledProviders != null
            ? includeDisabledProviders.value
            : this.includeDisabledProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class PingRequestDto {
  const PingRequestDto({
    this.ping,
  });

  factory PingRequestDto.fromJson(Map<String, dynamic> json) =>
      _$PingRequestDtoFromJson(json);

  static const toJsonFactory = _$PingRequestDtoToJson;
  Map<String, dynamic> toJson() => _$PingRequestDtoToJson(this);

  @JsonKey(name: 'Ping')
  final int? ping;
  static const fromJsonFactory = _$PingRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PingRequestDto &&
            (identical(other.ping, ping) ||
                const DeepCollectionEquality().equals(other.ping, ping)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ping) ^ runtimeType.hashCode;
}

extension $PingRequestDtoExtension on PingRequestDto {
  PingRequestDto copyWith({int? ping}) {
    return PingRequestDto(ping: ping ?? this.ping);
  }

  PingRequestDto copyWithWrapped({Wrapped<int?>? ping}) {
    return PingRequestDto(ping: (ping != null ? ping.value : this.ping));
  }
}

@JsonSerializable(explicitToJson: true)
class PinRedeemResult {
  const PinRedeemResult({
    this.success,
    this.usersReset,
  });

  factory PinRedeemResult.fromJson(Map<String, dynamic> json) =>
      _$PinRedeemResultFromJson(json);

  static const toJsonFactory = _$PinRedeemResultToJson;
  Map<String, dynamic> toJson() => _$PinRedeemResultToJson(this);

  @JsonKey(name: 'Success')
  final bool? success;
  @JsonKey(name: 'UsersReset', defaultValue: <String>[])
  final List<String>? usersReset;
  static const fromJsonFactory = _$PinRedeemResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PinRedeemResult &&
            (identical(other.success, success) ||
                const DeepCollectionEquality()
                    .equals(other.success, success)) &&
            (identical(other.usersReset, usersReset) ||
                const DeepCollectionEquality()
                    .equals(other.usersReset, usersReset)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(usersReset) ^
      runtimeType.hashCode;
}

extension $PinRedeemResultExtension on PinRedeemResult {
  PinRedeemResult copyWith({bool? success, List<String>? usersReset}) {
    return PinRedeemResult(
        success: success ?? this.success,
        usersReset: usersReset ?? this.usersReset);
  }

  PinRedeemResult copyWithWrapped(
      {Wrapped<bool?>? success, Wrapped<List<String>?>? usersReset}) {
    return PinRedeemResult(
        success: (success != null ? success.value : this.success),
        usersReset: (usersReset != null ? usersReset.value : this.usersReset));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaybackInfoDto {
  const PlaybackInfoDto({
    this.userId,
    this.maxStreamingBitrate,
    this.startTimeTicks,
    this.audioStreamIndex,
    this.subtitleStreamIndex,
    this.maxAudioChannels,
    this.mediaSourceId,
    this.liveStreamId,
    this.deviceProfile,
    this.enableDirectPlay,
    this.enableDirectStream,
    this.enableTranscoding,
    this.allowVideoStreamCopy,
    this.allowAudioStreamCopy,
    this.autoOpenLiveStream,
    this.alwaysBurnInSubtitleWhenTranscoding,
  });

  factory PlaybackInfoDto.fromJson(Map<String, dynamic> json) =>
      _$PlaybackInfoDtoFromJson(json);

  static const toJsonFactory = _$PlaybackInfoDtoToJson;
  Map<String, dynamic> toJson() => _$PlaybackInfoDtoToJson(this);

  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'MaxStreamingBitrate')
  final int? maxStreamingBitrate;
  @JsonKey(name: 'StartTimeTicks')
  final int? startTimeTicks;
  @JsonKey(name: 'AudioStreamIndex')
  final int? audioStreamIndex;
  @JsonKey(name: 'SubtitleStreamIndex')
  final int? subtitleStreamIndex;
  @JsonKey(name: 'MaxAudioChannels')
  final int? maxAudioChannels;
  @JsonKey(name: 'MediaSourceId')
  final String? mediaSourceId;
  @JsonKey(name: 'LiveStreamId')
  final String? liveStreamId;
  @JsonKey(name: 'DeviceProfile')
  final DeviceProfile? deviceProfile;
  @JsonKey(name: 'EnableDirectPlay')
  final bool? enableDirectPlay;
  @JsonKey(name: 'EnableDirectStream')
  final bool? enableDirectStream;
  @JsonKey(name: 'EnableTranscoding')
  final bool? enableTranscoding;
  @JsonKey(name: 'AllowVideoStreamCopy')
  final bool? allowVideoStreamCopy;
  @JsonKey(name: 'AllowAudioStreamCopy')
  final bool? allowAudioStreamCopy;
  @JsonKey(name: 'AutoOpenLiveStream')
  final bool? autoOpenLiveStream;
  @JsonKey(name: 'AlwaysBurnInSubtitleWhenTranscoding')
  final bool? alwaysBurnInSubtitleWhenTranscoding;
  static const fromJsonFactory = _$PlaybackInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaybackInfoDto &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.maxStreamingBitrate, maxStreamingBitrate) ||
                const DeepCollectionEquality()
                    .equals(other.maxStreamingBitrate, maxStreamingBitrate)) &&
            (identical(other.startTimeTicks, startTimeTicks) ||
                const DeepCollectionEquality()
                    .equals(other.startTimeTicks, startTimeTicks)) &&
            (identical(other.audioStreamIndex, audioStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.audioStreamIndex, audioStreamIndex)) &&
            (identical(other.subtitleStreamIndex, subtitleStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.subtitleStreamIndex, subtitleStreamIndex)) &&
            (identical(other.maxAudioChannels, maxAudioChannels) ||
                const DeepCollectionEquality()
                    .equals(other.maxAudioChannels, maxAudioChannels)) &&
            (identical(other.mediaSourceId, mediaSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.mediaSourceId, mediaSourceId)) &&
            (identical(other.liveStreamId, liveStreamId) ||
                const DeepCollectionEquality()
                    .equals(other.liveStreamId, liveStreamId)) &&
            (identical(other.deviceProfile, deviceProfile) ||
                const DeepCollectionEquality()
                    .equals(other.deviceProfile, deviceProfile)) &&
            (identical(other.enableDirectPlay, enableDirectPlay) ||
                const DeepCollectionEquality()
                    .equals(other.enableDirectPlay, enableDirectPlay)) &&
            (identical(other.enableDirectStream, enableDirectStream) ||
                const DeepCollectionEquality()
                    .equals(other.enableDirectStream, enableDirectStream)) &&
            (identical(other.enableTranscoding, enableTranscoding) ||
                const DeepCollectionEquality()
                    .equals(other.enableTranscoding, enableTranscoding)) &&
            (identical(other.allowVideoStreamCopy, allowVideoStreamCopy) ||
                const DeepCollectionEquality().equals(
                    other.allowVideoStreamCopy, allowVideoStreamCopy)) &&
            (identical(other.allowAudioStreamCopy, allowAudioStreamCopy) ||
                const DeepCollectionEquality().equals(
                    other.allowAudioStreamCopy, allowAudioStreamCopy)) &&
            (identical(other.autoOpenLiveStream, autoOpenLiveStream) ||
                const DeepCollectionEquality()
                    .equals(other.autoOpenLiveStream, autoOpenLiveStream)) &&
            (identical(other.alwaysBurnInSubtitleWhenTranscoding,
                    alwaysBurnInSubtitleWhenTranscoding) ||
                const DeepCollectionEquality().equals(
                    other.alwaysBurnInSubtitleWhenTranscoding,
                    alwaysBurnInSubtitleWhenTranscoding)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(maxStreamingBitrate) ^
      const DeepCollectionEquality().hash(startTimeTicks) ^
      const DeepCollectionEquality().hash(audioStreamIndex) ^
      const DeepCollectionEquality().hash(subtitleStreamIndex) ^
      const DeepCollectionEquality().hash(maxAudioChannels) ^
      const DeepCollectionEquality().hash(mediaSourceId) ^
      const DeepCollectionEquality().hash(liveStreamId) ^
      const DeepCollectionEquality().hash(deviceProfile) ^
      const DeepCollectionEquality().hash(enableDirectPlay) ^
      const DeepCollectionEquality().hash(enableDirectStream) ^
      const DeepCollectionEquality().hash(enableTranscoding) ^
      const DeepCollectionEquality().hash(allowVideoStreamCopy) ^
      const DeepCollectionEquality().hash(allowAudioStreamCopy) ^
      const DeepCollectionEquality().hash(autoOpenLiveStream) ^
      const DeepCollectionEquality().hash(alwaysBurnInSubtitleWhenTranscoding) ^
      runtimeType.hashCode;
}

extension $PlaybackInfoDtoExtension on PlaybackInfoDto {
  PlaybackInfoDto copyWith(
      {String? userId,
      int? maxStreamingBitrate,
      int? startTimeTicks,
      int? audioStreamIndex,
      int? subtitleStreamIndex,
      int? maxAudioChannels,
      String? mediaSourceId,
      String? liveStreamId,
      DeviceProfile? deviceProfile,
      bool? enableDirectPlay,
      bool? enableDirectStream,
      bool? enableTranscoding,
      bool? allowVideoStreamCopy,
      bool? allowAudioStreamCopy,
      bool? autoOpenLiveStream,
      bool? alwaysBurnInSubtitleWhenTranscoding}) {
    return PlaybackInfoDto(
        userId: userId ?? this.userId,
        maxStreamingBitrate: maxStreamingBitrate ?? this.maxStreamingBitrate,
        startTimeTicks: startTimeTicks ?? this.startTimeTicks,
        audioStreamIndex: audioStreamIndex ?? this.audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex ?? this.subtitleStreamIndex,
        maxAudioChannels: maxAudioChannels ?? this.maxAudioChannels,
        mediaSourceId: mediaSourceId ?? this.mediaSourceId,
        liveStreamId: liveStreamId ?? this.liveStreamId,
        deviceProfile: deviceProfile ?? this.deviceProfile,
        enableDirectPlay: enableDirectPlay ?? this.enableDirectPlay,
        enableDirectStream: enableDirectStream ?? this.enableDirectStream,
        enableTranscoding: enableTranscoding ?? this.enableTranscoding,
        allowVideoStreamCopy: allowVideoStreamCopy ?? this.allowVideoStreamCopy,
        allowAudioStreamCopy: allowAudioStreamCopy ?? this.allowAudioStreamCopy,
        autoOpenLiveStream: autoOpenLiveStream ?? this.autoOpenLiveStream,
        alwaysBurnInSubtitleWhenTranscoding:
            alwaysBurnInSubtitleWhenTranscoding ??
                this.alwaysBurnInSubtitleWhenTranscoding);
  }

  PlaybackInfoDto copyWithWrapped(
      {Wrapped<String?>? userId,
      Wrapped<int?>? maxStreamingBitrate,
      Wrapped<int?>? startTimeTicks,
      Wrapped<int?>? audioStreamIndex,
      Wrapped<int?>? subtitleStreamIndex,
      Wrapped<int?>? maxAudioChannels,
      Wrapped<String?>? mediaSourceId,
      Wrapped<String?>? liveStreamId,
      Wrapped<DeviceProfile?>? deviceProfile,
      Wrapped<bool?>? enableDirectPlay,
      Wrapped<bool?>? enableDirectStream,
      Wrapped<bool?>? enableTranscoding,
      Wrapped<bool?>? allowVideoStreamCopy,
      Wrapped<bool?>? allowAudioStreamCopy,
      Wrapped<bool?>? autoOpenLiveStream,
      Wrapped<bool?>? alwaysBurnInSubtitleWhenTranscoding}) {
    return PlaybackInfoDto(
        userId: (userId != null ? userId.value : this.userId),
        maxStreamingBitrate: (maxStreamingBitrate != null
            ? maxStreamingBitrate.value
            : this.maxStreamingBitrate),
        startTimeTicks: (startTimeTicks != null
            ? startTimeTicks.value
            : this.startTimeTicks),
        audioStreamIndex: (audioStreamIndex != null
            ? audioStreamIndex.value
            : this.audioStreamIndex),
        subtitleStreamIndex: (subtitleStreamIndex != null
            ? subtitleStreamIndex.value
            : this.subtitleStreamIndex),
        maxAudioChannels: (maxAudioChannels != null
            ? maxAudioChannels.value
            : this.maxAudioChannels),
        mediaSourceId:
            (mediaSourceId != null ? mediaSourceId.value : this.mediaSourceId),
        liveStreamId:
            (liveStreamId != null ? liveStreamId.value : this.liveStreamId),
        deviceProfile:
            (deviceProfile != null ? deviceProfile.value : this.deviceProfile),
        enableDirectPlay: (enableDirectPlay != null
            ? enableDirectPlay.value
            : this.enableDirectPlay),
        enableDirectStream: (enableDirectStream != null
            ? enableDirectStream.value
            : this.enableDirectStream),
        enableTranscoding: (enableTranscoding != null
            ? enableTranscoding.value
            : this.enableTranscoding),
        allowVideoStreamCopy: (allowVideoStreamCopy != null
            ? allowVideoStreamCopy.value
            : this.allowVideoStreamCopy),
        allowAudioStreamCopy: (allowAudioStreamCopy != null
            ? allowAudioStreamCopy.value
            : this.allowAudioStreamCopy),
        autoOpenLiveStream: (autoOpenLiveStream != null
            ? autoOpenLiveStream.value
            : this.autoOpenLiveStream),
        alwaysBurnInSubtitleWhenTranscoding:
            (alwaysBurnInSubtitleWhenTranscoding != null
                ? alwaysBurnInSubtitleWhenTranscoding.value
                : this.alwaysBurnInSubtitleWhenTranscoding));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaybackInfoResponse {
  const PlaybackInfoResponse({
    this.mediaSources,
    this.playSessionId,
    this.errorCode,
  });

  factory PlaybackInfoResponse.fromJson(Map<String, dynamic> json) =>
      _$PlaybackInfoResponseFromJson(json);

  static const toJsonFactory = _$PlaybackInfoResponseToJson;
  Map<String, dynamic> toJson() => _$PlaybackInfoResponseToJson(this);

  @JsonKey(name: 'MediaSources', defaultValue: <MediaSourceInfo>[])
  final List<MediaSourceInfo>? mediaSources;
  @JsonKey(name: 'PlaySessionId')
  final String? playSessionId;
  @JsonKey(
    name: 'ErrorCode',
    toJson: playbackErrorCodeNullableToJson,
    fromJson: playbackErrorCodeNullableFromJson,
  )
  final enums.PlaybackErrorCode? errorCode;
  static const fromJsonFactory = _$PlaybackInfoResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaybackInfoResponse &&
            (identical(other.mediaSources, mediaSources) ||
                const DeepCollectionEquality()
                    .equals(other.mediaSources, mediaSources)) &&
            (identical(other.playSessionId, playSessionId) ||
                const DeepCollectionEquality()
                    .equals(other.playSessionId, playSessionId)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(mediaSources) ^
      const DeepCollectionEquality().hash(playSessionId) ^
      const DeepCollectionEquality().hash(errorCode) ^
      runtimeType.hashCode;
}

extension $PlaybackInfoResponseExtension on PlaybackInfoResponse {
  PlaybackInfoResponse copyWith(
      {List<MediaSourceInfo>? mediaSources,
      String? playSessionId,
      enums.PlaybackErrorCode? errorCode}) {
    return PlaybackInfoResponse(
        mediaSources: mediaSources ?? this.mediaSources,
        playSessionId: playSessionId ?? this.playSessionId,
        errorCode: errorCode ?? this.errorCode);
  }

  PlaybackInfoResponse copyWithWrapped(
      {Wrapped<List<MediaSourceInfo>?>? mediaSources,
      Wrapped<String?>? playSessionId,
      Wrapped<enums.PlaybackErrorCode?>? errorCode}) {
    return PlaybackInfoResponse(
        mediaSources:
            (mediaSources != null ? mediaSources.value : this.mediaSources),
        playSessionId:
            (playSessionId != null ? playSessionId.value : this.playSessionId),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaybackProgressInfo {
  const PlaybackProgressInfo({
    this.canSeek,
    this.item,
    this.itemId,
    this.sessionId,
    this.mediaSourceId,
    this.audioStreamIndex,
    this.subtitleStreamIndex,
    this.isPaused,
    this.isMuted,
    this.positionTicks,
    this.playbackStartTimeTicks,
    this.volumeLevel,
    this.brightness,
    this.aspectRatio,
    this.playMethod,
    this.liveStreamId,
    this.playSessionId,
    this.repeatMode,
    this.playbackOrder,
    this.nowPlayingQueue,
    this.playlistItemId,
  });

  factory PlaybackProgressInfo.fromJson(Map<String, dynamic> json) =>
      _$PlaybackProgressInfoFromJson(json);

  static const toJsonFactory = _$PlaybackProgressInfoToJson;
  Map<String, dynamic> toJson() => _$PlaybackProgressInfoToJson(this);

  @JsonKey(name: 'CanSeek')
  final bool? canSeek;
  @JsonKey(name: 'Item')
  final BaseItemDto? item;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SessionId')
  final String? sessionId;
  @JsonKey(name: 'MediaSourceId')
  final String? mediaSourceId;
  @JsonKey(name: 'AudioStreamIndex')
  final int? audioStreamIndex;
  @JsonKey(name: 'SubtitleStreamIndex')
  final int? subtitleStreamIndex;
  @JsonKey(name: 'IsPaused')
  final bool? isPaused;
  @JsonKey(name: 'IsMuted')
  final bool? isMuted;
  @JsonKey(name: 'PositionTicks')
  final int? positionTicks;
  @JsonKey(name: 'PlaybackStartTimeTicks')
  final int? playbackStartTimeTicks;
  @JsonKey(name: 'VolumeLevel')
  final int? volumeLevel;
  @JsonKey(name: 'Brightness')
  final int? brightness;
  @JsonKey(name: 'AspectRatio')
  final String? aspectRatio;
  @JsonKey(
    name: 'PlayMethod',
    toJson: playMethodNullableToJson,
    fromJson: playMethodNullableFromJson,
  )
  final enums.PlayMethod? playMethod;
  @JsonKey(name: 'LiveStreamId')
  final String? liveStreamId;
  @JsonKey(name: 'PlaySessionId')
  final String? playSessionId;
  @JsonKey(
    name: 'RepeatMode',
    toJson: repeatModeNullableToJson,
    fromJson: repeatModeNullableFromJson,
  )
  final enums.RepeatMode? repeatMode;
  @JsonKey(
    name: 'PlaybackOrder',
    toJson: playbackOrderNullableToJson,
    fromJson: playbackOrderNullableFromJson,
  )
  final enums.PlaybackOrder? playbackOrder;
  @JsonKey(name: 'NowPlayingQueue', defaultValue: <QueueItem>[])
  final List<QueueItem>? nowPlayingQueue;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  static const fromJsonFactory = _$PlaybackProgressInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaybackProgressInfo &&
            (identical(other.canSeek, canSeek) ||
                const DeepCollectionEquality()
                    .equals(other.canSeek, canSeek)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.sessionId, sessionId) ||
                const DeepCollectionEquality()
                    .equals(other.sessionId, sessionId)) &&
            (identical(other.mediaSourceId, mediaSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.mediaSourceId, mediaSourceId)) &&
            (identical(other.audioStreamIndex, audioStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.audioStreamIndex, audioStreamIndex)) &&
            (identical(other.subtitleStreamIndex, subtitleStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.subtitleStreamIndex, subtitleStreamIndex)) &&
            (identical(other.isPaused, isPaused) ||
                const DeepCollectionEquality()
                    .equals(other.isPaused, isPaused)) &&
            (identical(other.isMuted, isMuted) ||
                const DeepCollectionEquality()
                    .equals(other.isMuted, isMuted)) &&
            (identical(other.positionTicks, positionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.positionTicks, positionTicks)) &&
            (identical(other.playbackStartTimeTicks, playbackStartTimeTicks) ||
                const DeepCollectionEquality().equals(
                    other.playbackStartTimeTicks, playbackStartTimeTicks)) &&
            (identical(other.volumeLevel, volumeLevel) ||
                const DeepCollectionEquality()
                    .equals(other.volumeLevel, volumeLevel)) &&
            (identical(other.brightness, brightness) ||
                const DeepCollectionEquality()
                    .equals(other.brightness, brightness)) &&
            (identical(other.aspectRatio, aspectRatio) ||
                const DeepCollectionEquality()
                    .equals(other.aspectRatio, aspectRatio)) &&
            (identical(other.playMethod, playMethod) ||
                const DeepCollectionEquality()
                    .equals(other.playMethod, playMethod)) &&
            (identical(other.liveStreamId, liveStreamId) ||
                const DeepCollectionEquality()
                    .equals(other.liveStreamId, liveStreamId)) &&
            (identical(other.playSessionId, playSessionId) ||
                const DeepCollectionEquality()
                    .equals(other.playSessionId, playSessionId)) &&
            (identical(other.repeatMode, repeatMode) ||
                const DeepCollectionEquality()
                    .equals(other.repeatMode, repeatMode)) &&
            (identical(other.playbackOrder, playbackOrder) ||
                const DeepCollectionEquality()
                    .equals(other.playbackOrder, playbackOrder)) &&
            (identical(other.nowPlayingQueue, nowPlayingQueue) ||
                const DeepCollectionEquality()
                    .equals(other.nowPlayingQueue, nowPlayingQueue)) &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(canSeek) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(sessionId) ^
      const DeepCollectionEquality().hash(mediaSourceId) ^
      const DeepCollectionEquality().hash(audioStreamIndex) ^
      const DeepCollectionEquality().hash(subtitleStreamIndex) ^
      const DeepCollectionEquality().hash(isPaused) ^
      const DeepCollectionEquality().hash(isMuted) ^
      const DeepCollectionEquality().hash(positionTicks) ^
      const DeepCollectionEquality().hash(playbackStartTimeTicks) ^
      const DeepCollectionEquality().hash(volumeLevel) ^
      const DeepCollectionEquality().hash(brightness) ^
      const DeepCollectionEquality().hash(aspectRatio) ^
      const DeepCollectionEquality().hash(playMethod) ^
      const DeepCollectionEquality().hash(liveStreamId) ^
      const DeepCollectionEquality().hash(playSessionId) ^
      const DeepCollectionEquality().hash(repeatMode) ^
      const DeepCollectionEquality().hash(playbackOrder) ^
      const DeepCollectionEquality().hash(nowPlayingQueue) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      runtimeType.hashCode;
}

extension $PlaybackProgressInfoExtension on PlaybackProgressInfo {
  PlaybackProgressInfo copyWith(
      {bool? canSeek,
      BaseItemDto? item,
      String? itemId,
      String? sessionId,
      String? mediaSourceId,
      int? audioStreamIndex,
      int? subtitleStreamIndex,
      bool? isPaused,
      bool? isMuted,
      int? positionTicks,
      int? playbackStartTimeTicks,
      int? volumeLevel,
      int? brightness,
      String? aspectRatio,
      enums.PlayMethod? playMethod,
      String? liveStreamId,
      String? playSessionId,
      enums.RepeatMode? repeatMode,
      enums.PlaybackOrder? playbackOrder,
      List<QueueItem>? nowPlayingQueue,
      String? playlistItemId}) {
    return PlaybackProgressInfo(
        canSeek: canSeek ?? this.canSeek,
        item: item ?? this.item,
        itemId: itemId ?? this.itemId,
        sessionId: sessionId ?? this.sessionId,
        mediaSourceId: mediaSourceId ?? this.mediaSourceId,
        audioStreamIndex: audioStreamIndex ?? this.audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex ?? this.subtitleStreamIndex,
        isPaused: isPaused ?? this.isPaused,
        isMuted: isMuted ?? this.isMuted,
        positionTicks: positionTicks ?? this.positionTicks,
        playbackStartTimeTicks:
            playbackStartTimeTicks ?? this.playbackStartTimeTicks,
        volumeLevel: volumeLevel ?? this.volumeLevel,
        brightness: brightness ?? this.brightness,
        aspectRatio: aspectRatio ?? this.aspectRatio,
        playMethod: playMethod ?? this.playMethod,
        liveStreamId: liveStreamId ?? this.liveStreamId,
        playSessionId: playSessionId ?? this.playSessionId,
        repeatMode: repeatMode ?? this.repeatMode,
        playbackOrder: playbackOrder ?? this.playbackOrder,
        nowPlayingQueue: nowPlayingQueue ?? this.nowPlayingQueue,
        playlistItemId: playlistItemId ?? this.playlistItemId);
  }

  PlaybackProgressInfo copyWithWrapped(
      {Wrapped<bool?>? canSeek,
      Wrapped<BaseItemDto?>? item,
      Wrapped<String?>? itemId,
      Wrapped<String?>? sessionId,
      Wrapped<String?>? mediaSourceId,
      Wrapped<int?>? audioStreamIndex,
      Wrapped<int?>? subtitleStreamIndex,
      Wrapped<bool?>? isPaused,
      Wrapped<bool?>? isMuted,
      Wrapped<int?>? positionTicks,
      Wrapped<int?>? playbackStartTimeTicks,
      Wrapped<int?>? volumeLevel,
      Wrapped<int?>? brightness,
      Wrapped<String?>? aspectRatio,
      Wrapped<enums.PlayMethod?>? playMethod,
      Wrapped<String?>? liveStreamId,
      Wrapped<String?>? playSessionId,
      Wrapped<enums.RepeatMode?>? repeatMode,
      Wrapped<enums.PlaybackOrder?>? playbackOrder,
      Wrapped<List<QueueItem>?>? nowPlayingQueue,
      Wrapped<String?>? playlistItemId}) {
    return PlaybackProgressInfo(
        canSeek: (canSeek != null ? canSeek.value : this.canSeek),
        item: (item != null ? item.value : this.item),
        itemId: (itemId != null ? itemId.value : this.itemId),
        sessionId: (sessionId != null ? sessionId.value : this.sessionId),
        mediaSourceId:
            (mediaSourceId != null ? mediaSourceId.value : this.mediaSourceId),
        audioStreamIndex: (audioStreamIndex != null
            ? audioStreamIndex.value
            : this.audioStreamIndex),
        subtitleStreamIndex: (subtitleStreamIndex != null
            ? subtitleStreamIndex.value
            : this.subtitleStreamIndex),
        isPaused: (isPaused != null ? isPaused.value : this.isPaused),
        isMuted: (isMuted != null ? isMuted.value : this.isMuted),
        positionTicks:
            (positionTicks != null ? positionTicks.value : this.positionTicks),
        playbackStartTimeTicks: (playbackStartTimeTicks != null
            ? playbackStartTimeTicks.value
            : this.playbackStartTimeTicks),
        volumeLevel:
            (volumeLevel != null ? volumeLevel.value : this.volumeLevel),
        brightness: (brightness != null ? brightness.value : this.brightness),
        aspectRatio:
            (aspectRatio != null ? aspectRatio.value : this.aspectRatio),
        playMethod: (playMethod != null ? playMethod.value : this.playMethod),
        liveStreamId:
            (liveStreamId != null ? liveStreamId.value : this.liveStreamId),
        playSessionId:
            (playSessionId != null ? playSessionId.value : this.playSessionId),
        repeatMode: (repeatMode != null ? repeatMode.value : this.repeatMode),
        playbackOrder:
            (playbackOrder != null ? playbackOrder.value : this.playbackOrder),
        nowPlayingQueue: (nowPlayingQueue != null
            ? nowPlayingQueue.value
            : this.nowPlayingQueue),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaybackStartInfo {
  const PlaybackStartInfo({
    this.canSeek,
    this.item,
    this.itemId,
    this.sessionId,
    this.mediaSourceId,
    this.audioStreamIndex,
    this.subtitleStreamIndex,
    this.isPaused,
    this.isMuted,
    this.positionTicks,
    this.playbackStartTimeTicks,
    this.volumeLevel,
    this.brightness,
    this.aspectRatio,
    this.playMethod,
    this.liveStreamId,
    this.playSessionId,
    this.repeatMode,
    this.playbackOrder,
    this.nowPlayingQueue,
    this.playlistItemId,
  });

  factory PlaybackStartInfo.fromJson(Map<String, dynamic> json) =>
      _$PlaybackStartInfoFromJson(json);

  static const toJsonFactory = _$PlaybackStartInfoToJson;
  Map<String, dynamic> toJson() => _$PlaybackStartInfoToJson(this);

  @JsonKey(name: 'CanSeek')
  final bool? canSeek;
  @JsonKey(name: 'Item')
  final BaseItemDto? item;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SessionId')
  final String? sessionId;
  @JsonKey(name: 'MediaSourceId')
  final String? mediaSourceId;
  @JsonKey(name: 'AudioStreamIndex')
  final int? audioStreamIndex;
  @JsonKey(name: 'SubtitleStreamIndex')
  final int? subtitleStreamIndex;
  @JsonKey(name: 'IsPaused')
  final bool? isPaused;
  @JsonKey(name: 'IsMuted')
  final bool? isMuted;
  @JsonKey(name: 'PositionTicks')
  final int? positionTicks;
  @JsonKey(name: 'PlaybackStartTimeTicks')
  final int? playbackStartTimeTicks;
  @JsonKey(name: 'VolumeLevel')
  final int? volumeLevel;
  @JsonKey(name: 'Brightness')
  final int? brightness;
  @JsonKey(name: 'AspectRatio')
  final String? aspectRatio;
  @JsonKey(
    name: 'PlayMethod',
    toJson: playMethodNullableToJson,
    fromJson: playMethodNullableFromJson,
  )
  final enums.PlayMethod? playMethod;
  @JsonKey(name: 'LiveStreamId')
  final String? liveStreamId;
  @JsonKey(name: 'PlaySessionId')
  final String? playSessionId;
  @JsonKey(
    name: 'RepeatMode',
    toJson: repeatModeNullableToJson,
    fromJson: repeatModeNullableFromJson,
  )
  final enums.RepeatMode? repeatMode;
  @JsonKey(
    name: 'PlaybackOrder',
    toJson: playbackOrderNullableToJson,
    fromJson: playbackOrderNullableFromJson,
  )
  final enums.PlaybackOrder? playbackOrder;
  @JsonKey(name: 'NowPlayingQueue', defaultValue: <QueueItem>[])
  final List<QueueItem>? nowPlayingQueue;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  static const fromJsonFactory = _$PlaybackStartInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaybackStartInfo &&
            (identical(other.canSeek, canSeek) ||
                const DeepCollectionEquality()
                    .equals(other.canSeek, canSeek)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.sessionId, sessionId) ||
                const DeepCollectionEquality()
                    .equals(other.sessionId, sessionId)) &&
            (identical(other.mediaSourceId, mediaSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.mediaSourceId, mediaSourceId)) &&
            (identical(other.audioStreamIndex, audioStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.audioStreamIndex, audioStreamIndex)) &&
            (identical(other.subtitleStreamIndex, subtitleStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.subtitleStreamIndex, subtitleStreamIndex)) &&
            (identical(other.isPaused, isPaused) ||
                const DeepCollectionEquality()
                    .equals(other.isPaused, isPaused)) &&
            (identical(other.isMuted, isMuted) ||
                const DeepCollectionEquality()
                    .equals(other.isMuted, isMuted)) &&
            (identical(other.positionTicks, positionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.positionTicks, positionTicks)) &&
            (identical(other.playbackStartTimeTicks, playbackStartTimeTicks) ||
                const DeepCollectionEquality().equals(
                    other.playbackStartTimeTicks, playbackStartTimeTicks)) &&
            (identical(other.volumeLevel, volumeLevel) ||
                const DeepCollectionEquality()
                    .equals(other.volumeLevel, volumeLevel)) &&
            (identical(other.brightness, brightness) ||
                const DeepCollectionEquality()
                    .equals(other.brightness, brightness)) &&
            (identical(other.aspectRatio, aspectRatio) ||
                const DeepCollectionEquality()
                    .equals(other.aspectRatio, aspectRatio)) &&
            (identical(other.playMethod, playMethod) ||
                const DeepCollectionEquality()
                    .equals(other.playMethod, playMethod)) &&
            (identical(other.liveStreamId, liveStreamId) ||
                const DeepCollectionEquality()
                    .equals(other.liveStreamId, liveStreamId)) &&
            (identical(other.playSessionId, playSessionId) ||
                const DeepCollectionEquality()
                    .equals(other.playSessionId, playSessionId)) &&
            (identical(other.repeatMode, repeatMode) ||
                const DeepCollectionEquality()
                    .equals(other.repeatMode, repeatMode)) &&
            (identical(other.playbackOrder, playbackOrder) ||
                const DeepCollectionEquality()
                    .equals(other.playbackOrder, playbackOrder)) &&
            (identical(other.nowPlayingQueue, nowPlayingQueue) ||
                const DeepCollectionEquality()
                    .equals(other.nowPlayingQueue, nowPlayingQueue)) &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(canSeek) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(sessionId) ^
      const DeepCollectionEquality().hash(mediaSourceId) ^
      const DeepCollectionEquality().hash(audioStreamIndex) ^
      const DeepCollectionEquality().hash(subtitleStreamIndex) ^
      const DeepCollectionEquality().hash(isPaused) ^
      const DeepCollectionEquality().hash(isMuted) ^
      const DeepCollectionEquality().hash(positionTicks) ^
      const DeepCollectionEquality().hash(playbackStartTimeTicks) ^
      const DeepCollectionEquality().hash(volumeLevel) ^
      const DeepCollectionEquality().hash(brightness) ^
      const DeepCollectionEquality().hash(aspectRatio) ^
      const DeepCollectionEquality().hash(playMethod) ^
      const DeepCollectionEquality().hash(liveStreamId) ^
      const DeepCollectionEquality().hash(playSessionId) ^
      const DeepCollectionEquality().hash(repeatMode) ^
      const DeepCollectionEquality().hash(playbackOrder) ^
      const DeepCollectionEquality().hash(nowPlayingQueue) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      runtimeType.hashCode;
}

extension $PlaybackStartInfoExtension on PlaybackStartInfo {
  PlaybackStartInfo copyWith(
      {bool? canSeek,
      BaseItemDto? item,
      String? itemId,
      String? sessionId,
      String? mediaSourceId,
      int? audioStreamIndex,
      int? subtitleStreamIndex,
      bool? isPaused,
      bool? isMuted,
      int? positionTicks,
      int? playbackStartTimeTicks,
      int? volumeLevel,
      int? brightness,
      String? aspectRatio,
      enums.PlayMethod? playMethod,
      String? liveStreamId,
      String? playSessionId,
      enums.RepeatMode? repeatMode,
      enums.PlaybackOrder? playbackOrder,
      List<QueueItem>? nowPlayingQueue,
      String? playlistItemId}) {
    return PlaybackStartInfo(
        canSeek: canSeek ?? this.canSeek,
        item: item ?? this.item,
        itemId: itemId ?? this.itemId,
        sessionId: sessionId ?? this.sessionId,
        mediaSourceId: mediaSourceId ?? this.mediaSourceId,
        audioStreamIndex: audioStreamIndex ?? this.audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex ?? this.subtitleStreamIndex,
        isPaused: isPaused ?? this.isPaused,
        isMuted: isMuted ?? this.isMuted,
        positionTicks: positionTicks ?? this.positionTicks,
        playbackStartTimeTicks:
            playbackStartTimeTicks ?? this.playbackStartTimeTicks,
        volumeLevel: volumeLevel ?? this.volumeLevel,
        brightness: brightness ?? this.brightness,
        aspectRatio: aspectRatio ?? this.aspectRatio,
        playMethod: playMethod ?? this.playMethod,
        liveStreamId: liveStreamId ?? this.liveStreamId,
        playSessionId: playSessionId ?? this.playSessionId,
        repeatMode: repeatMode ?? this.repeatMode,
        playbackOrder: playbackOrder ?? this.playbackOrder,
        nowPlayingQueue: nowPlayingQueue ?? this.nowPlayingQueue,
        playlistItemId: playlistItemId ?? this.playlistItemId);
  }

  PlaybackStartInfo copyWithWrapped(
      {Wrapped<bool?>? canSeek,
      Wrapped<BaseItemDto?>? item,
      Wrapped<String?>? itemId,
      Wrapped<String?>? sessionId,
      Wrapped<String?>? mediaSourceId,
      Wrapped<int?>? audioStreamIndex,
      Wrapped<int?>? subtitleStreamIndex,
      Wrapped<bool?>? isPaused,
      Wrapped<bool?>? isMuted,
      Wrapped<int?>? positionTicks,
      Wrapped<int?>? playbackStartTimeTicks,
      Wrapped<int?>? volumeLevel,
      Wrapped<int?>? brightness,
      Wrapped<String?>? aspectRatio,
      Wrapped<enums.PlayMethod?>? playMethod,
      Wrapped<String?>? liveStreamId,
      Wrapped<String?>? playSessionId,
      Wrapped<enums.RepeatMode?>? repeatMode,
      Wrapped<enums.PlaybackOrder?>? playbackOrder,
      Wrapped<List<QueueItem>?>? nowPlayingQueue,
      Wrapped<String?>? playlistItemId}) {
    return PlaybackStartInfo(
        canSeek: (canSeek != null ? canSeek.value : this.canSeek),
        item: (item != null ? item.value : this.item),
        itemId: (itemId != null ? itemId.value : this.itemId),
        sessionId: (sessionId != null ? sessionId.value : this.sessionId),
        mediaSourceId:
            (mediaSourceId != null ? mediaSourceId.value : this.mediaSourceId),
        audioStreamIndex: (audioStreamIndex != null
            ? audioStreamIndex.value
            : this.audioStreamIndex),
        subtitleStreamIndex: (subtitleStreamIndex != null
            ? subtitleStreamIndex.value
            : this.subtitleStreamIndex),
        isPaused: (isPaused != null ? isPaused.value : this.isPaused),
        isMuted: (isMuted != null ? isMuted.value : this.isMuted),
        positionTicks:
            (positionTicks != null ? positionTicks.value : this.positionTicks),
        playbackStartTimeTicks: (playbackStartTimeTicks != null
            ? playbackStartTimeTicks.value
            : this.playbackStartTimeTicks),
        volumeLevel:
            (volumeLevel != null ? volumeLevel.value : this.volumeLevel),
        brightness: (brightness != null ? brightness.value : this.brightness),
        aspectRatio:
            (aspectRatio != null ? aspectRatio.value : this.aspectRatio),
        playMethod: (playMethod != null ? playMethod.value : this.playMethod),
        liveStreamId:
            (liveStreamId != null ? liveStreamId.value : this.liveStreamId),
        playSessionId:
            (playSessionId != null ? playSessionId.value : this.playSessionId),
        repeatMode: (repeatMode != null ? repeatMode.value : this.repeatMode),
        playbackOrder:
            (playbackOrder != null ? playbackOrder.value : this.playbackOrder),
        nowPlayingQueue: (nowPlayingQueue != null
            ? nowPlayingQueue.value
            : this.nowPlayingQueue),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaybackStopInfo {
  const PlaybackStopInfo({
    this.item,
    this.itemId,
    this.sessionId,
    this.mediaSourceId,
    this.positionTicks,
    this.liveStreamId,
    this.playSessionId,
    this.failed,
    this.nextMediaType,
    this.playlistItemId,
    this.nowPlayingQueue,
  });

  factory PlaybackStopInfo.fromJson(Map<String, dynamic> json) =>
      _$PlaybackStopInfoFromJson(json);

  static const toJsonFactory = _$PlaybackStopInfoToJson;
  Map<String, dynamic> toJson() => _$PlaybackStopInfoToJson(this);

  @JsonKey(name: 'Item')
  final BaseItemDto? item;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SessionId')
  final String? sessionId;
  @JsonKey(name: 'MediaSourceId')
  final String? mediaSourceId;
  @JsonKey(name: 'PositionTicks')
  final int? positionTicks;
  @JsonKey(name: 'LiveStreamId')
  final String? liveStreamId;
  @JsonKey(name: 'PlaySessionId')
  final String? playSessionId;
  @JsonKey(name: 'Failed')
  final bool? failed;
  @JsonKey(name: 'NextMediaType')
  final String? nextMediaType;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  @JsonKey(name: 'NowPlayingQueue', defaultValue: <QueueItem>[])
  final List<QueueItem>? nowPlayingQueue;
  static const fromJsonFactory = _$PlaybackStopInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaybackStopInfo &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.sessionId, sessionId) ||
                const DeepCollectionEquality()
                    .equals(other.sessionId, sessionId)) &&
            (identical(other.mediaSourceId, mediaSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.mediaSourceId, mediaSourceId)) &&
            (identical(other.positionTicks, positionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.positionTicks, positionTicks)) &&
            (identical(other.liveStreamId, liveStreamId) ||
                const DeepCollectionEquality()
                    .equals(other.liveStreamId, liveStreamId)) &&
            (identical(other.playSessionId, playSessionId) ||
                const DeepCollectionEquality()
                    .equals(other.playSessionId, playSessionId)) &&
            (identical(other.failed, failed) ||
                const DeepCollectionEquality().equals(other.failed, failed)) &&
            (identical(other.nextMediaType, nextMediaType) ||
                const DeepCollectionEquality()
                    .equals(other.nextMediaType, nextMediaType)) &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)) &&
            (identical(other.nowPlayingQueue, nowPlayingQueue) ||
                const DeepCollectionEquality()
                    .equals(other.nowPlayingQueue, nowPlayingQueue)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(sessionId) ^
      const DeepCollectionEquality().hash(mediaSourceId) ^
      const DeepCollectionEquality().hash(positionTicks) ^
      const DeepCollectionEquality().hash(liveStreamId) ^
      const DeepCollectionEquality().hash(playSessionId) ^
      const DeepCollectionEquality().hash(failed) ^
      const DeepCollectionEquality().hash(nextMediaType) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      const DeepCollectionEquality().hash(nowPlayingQueue) ^
      runtimeType.hashCode;
}

extension $PlaybackStopInfoExtension on PlaybackStopInfo {
  PlaybackStopInfo copyWith(
      {BaseItemDto? item,
      String? itemId,
      String? sessionId,
      String? mediaSourceId,
      int? positionTicks,
      String? liveStreamId,
      String? playSessionId,
      bool? failed,
      String? nextMediaType,
      String? playlistItemId,
      List<QueueItem>? nowPlayingQueue}) {
    return PlaybackStopInfo(
        item: item ?? this.item,
        itemId: itemId ?? this.itemId,
        sessionId: sessionId ?? this.sessionId,
        mediaSourceId: mediaSourceId ?? this.mediaSourceId,
        positionTicks: positionTicks ?? this.positionTicks,
        liveStreamId: liveStreamId ?? this.liveStreamId,
        playSessionId: playSessionId ?? this.playSessionId,
        failed: failed ?? this.failed,
        nextMediaType: nextMediaType ?? this.nextMediaType,
        playlistItemId: playlistItemId ?? this.playlistItemId,
        nowPlayingQueue: nowPlayingQueue ?? this.nowPlayingQueue);
  }

  PlaybackStopInfo copyWithWrapped(
      {Wrapped<BaseItemDto?>? item,
      Wrapped<String?>? itemId,
      Wrapped<String?>? sessionId,
      Wrapped<String?>? mediaSourceId,
      Wrapped<int?>? positionTicks,
      Wrapped<String?>? liveStreamId,
      Wrapped<String?>? playSessionId,
      Wrapped<bool?>? failed,
      Wrapped<String?>? nextMediaType,
      Wrapped<String?>? playlistItemId,
      Wrapped<List<QueueItem>?>? nowPlayingQueue}) {
    return PlaybackStopInfo(
        item: (item != null ? item.value : this.item),
        itemId: (itemId != null ? itemId.value : this.itemId),
        sessionId: (sessionId != null ? sessionId.value : this.sessionId),
        mediaSourceId:
            (mediaSourceId != null ? mediaSourceId.value : this.mediaSourceId),
        positionTicks:
            (positionTicks != null ? positionTicks.value : this.positionTicks),
        liveStreamId:
            (liveStreamId != null ? liveStreamId.value : this.liveStreamId),
        playSessionId:
            (playSessionId != null ? playSessionId.value : this.playSessionId),
        failed: (failed != null ? failed.value : this.failed),
        nextMediaType:
            (nextMediaType != null ? nextMediaType.value : this.nextMediaType),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId),
        nowPlayingQueue: (nowPlayingQueue != null
            ? nowPlayingQueue.value
            : this.nowPlayingQueue));
  }
}

@JsonSerializable(explicitToJson: true)
class PlayerStateInfo {
  const PlayerStateInfo({
    this.positionTicks,
    this.canSeek,
    this.isPaused,
    this.isMuted,
    this.volumeLevel,
    this.audioStreamIndex,
    this.subtitleStreamIndex,
    this.mediaSourceId,
    this.playMethod,
    this.repeatMode,
    this.playbackOrder,
    this.liveStreamId,
  });

  factory PlayerStateInfo.fromJson(Map<String, dynamic> json) =>
      _$PlayerStateInfoFromJson(json);

  static const toJsonFactory = _$PlayerStateInfoToJson;
  Map<String, dynamic> toJson() => _$PlayerStateInfoToJson(this);

  @JsonKey(name: 'PositionTicks')
  final int? positionTicks;
  @JsonKey(name: 'CanSeek')
  final bool? canSeek;
  @JsonKey(name: 'IsPaused')
  final bool? isPaused;
  @JsonKey(name: 'IsMuted')
  final bool? isMuted;
  @JsonKey(name: 'VolumeLevel')
  final int? volumeLevel;
  @JsonKey(name: 'AudioStreamIndex')
  final int? audioStreamIndex;
  @JsonKey(name: 'SubtitleStreamIndex')
  final int? subtitleStreamIndex;
  @JsonKey(name: 'MediaSourceId')
  final String? mediaSourceId;
  @JsonKey(
    name: 'PlayMethod',
    toJson: playMethodNullableToJson,
    fromJson: playMethodNullableFromJson,
  )
  final enums.PlayMethod? playMethod;
  @JsonKey(
    name: 'RepeatMode',
    toJson: repeatModeNullableToJson,
    fromJson: repeatModeNullableFromJson,
  )
  final enums.RepeatMode? repeatMode;
  @JsonKey(
    name: 'PlaybackOrder',
    toJson: playbackOrderNullableToJson,
    fromJson: playbackOrderNullableFromJson,
  )
  final enums.PlaybackOrder? playbackOrder;
  @JsonKey(name: 'LiveStreamId')
  final String? liveStreamId;
  static const fromJsonFactory = _$PlayerStateInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlayerStateInfo &&
            (identical(other.positionTicks, positionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.positionTicks, positionTicks)) &&
            (identical(other.canSeek, canSeek) ||
                const DeepCollectionEquality()
                    .equals(other.canSeek, canSeek)) &&
            (identical(other.isPaused, isPaused) ||
                const DeepCollectionEquality()
                    .equals(other.isPaused, isPaused)) &&
            (identical(other.isMuted, isMuted) ||
                const DeepCollectionEquality()
                    .equals(other.isMuted, isMuted)) &&
            (identical(other.volumeLevel, volumeLevel) ||
                const DeepCollectionEquality()
                    .equals(other.volumeLevel, volumeLevel)) &&
            (identical(other.audioStreamIndex, audioStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.audioStreamIndex, audioStreamIndex)) &&
            (identical(other.subtitleStreamIndex, subtitleStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.subtitleStreamIndex, subtitleStreamIndex)) &&
            (identical(other.mediaSourceId, mediaSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.mediaSourceId, mediaSourceId)) &&
            (identical(other.playMethod, playMethod) ||
                const DeepCollectionEquality()
                    .equals(other.playMethod, playMethod)) &&
            (identical(other.repeatMode, repeatMode) ||
                const DeepCollectionEquality()
                    .equals(other.repeatMode, repeatMode)) &&
            (identical(other.playbackOrder, playbackOrder) ||
                const DeepCollectionEquality()
                    .equals(other.playbackOrder, playbackOrder)) &&
            (identical(other.liveStreamId, liveStreamId) ||
                const DeepCollectionEquality()
                    .equals(other.liveStreamId, liveStreamId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(positionTicks) ^
      const DeepCollectionEquality().hash(canSeek) ^
      const DeepCollectionEquality().hash(isPaused) ^
      const DeepCollectionEquality().hash(isMuted) ^
      const DeepCollectionEquality().hash(volumeLevel) ^
      const DeepCollectionEquality().hash(audioStreamIndex) ^
      const DeepCollectionEquality().hash(subtitleStreamIndex) ^
      const DeepCollectionEquality().hash(mediaSourceId) ^
      const DeepCollectionEquality().hash(playMethod) ^
      const DeepCollectionEquality().hash(repeatMode) ^
      const DeepCollectionEquality().hash(playbackOrder) ^
      const DeepCollectionEquality().hash(liveStreamId) ^
      runtimeType.hashCode;
}

extension $PlayerStateInfoExtension on PlayerStateInfo {
  PlayerStateInfo copyWith(
      {int? positionTicks,
      bool? canSeek,
      bool? isPaused,
      bool? isMuted,
      int? volumeLevel,
      int? audioStreamIndex,
      int? subtitleStreamIndex,
      String? mediaSourceId,
      enums.PlayMethod? playMethod,
      enums.RepeatMode? repeatMode,
      enums.PlaybackOrder? playbackOrder,
      String? liveStreamId}) {
    return PlayerStateInfo(
        positionTicks: positionTicks ?? this.positionTicks,
        canSeek: canSeek ?? this.canSeek,
        isPaused: isPaused ?? this.isPaused,
        isMuted: isMuted ?? this.isMuted,
        volumeLevel: volumeLevel ?? this.volumeLevel,
        audioStreamIndex: audioStreamIndex ?? this.audioStreamIndex,
        subtitleStreamIndex: subtitleStreamIndex ?? this.subtitleStreamIndex,
        mediaSourceId: mediaSourceId ?? this.mediaSourceId,
        playMethod: playMethod ?? this.playMethod,
        repeatMode: repeatMode ?? this.repeatMode,
        playbackOrder: playbackOrder ?? this.playbackOrder,
        liveStreamId: liveStreamId ?? this.liveStreamId);
  }

  PlayerStateInfo copyWithWrapped(
      {Wrapped<int?>? positionTicks,
      Wrapped<bool?>? canSeek,
      Wrapped<bool?>? isPaused,
      Wrapped<bool?>? isMuted,
      Wrapped<int?>? volumeLevel,
      Wrapped<int?>? audioStreamIndex,
      Wrapped<int?>? subtitleStreamIndex,
      Wrapped<String?>? mediaSourceId,
      Wrapped<enums.PlayMethod?>? playMethod,
      Wrapped<enums.RepeatMode?>? repeatMode,
      Wrapped<enums.PlaybackOrder?>? playbackOrder,
      Wrapped<String?>? liveStreamId}) {
    return PlayerStateInfo(
        positionTicks:
            (positionTicks != null ? positionTicks.value : this.positionTicks),
        canSeek: (canSeek != null ? canSeek.value : this.canSeek),
        isPaused: (isPaused != null ? isPaused.value : this.isPaused),
        isMuted: (isMuted != null ? isMuted.value : this.isMuted),
        volumeLevel:
            (volumeLevel != null ? volumeLevel.value : this.volumeLevel),
        audioStreamIndex: (audioStreamIndex != null
            ? audioStreamIndex.value
            : this.audioStreamIndex),
        subtitleStreamIndex: (subtitleStreamIndex != null
            ? subtitleStreamIndex.value
            : this.subtitleStreamIndex),
        mediaSourceId:
            (mediaSourceId != null ? mediaSourceId.value : this.mediaSourceId),
        playMethod: (playMethod != null ? playMethod.value : this.playMethod),
        repeatMode: (repeatMode != null ? repeatMode.value : this.repeatMode),
        playbackOrder:
            (playbackOrder != null ? playbackOrder.value : this.playbackOrder),
        liveStreamId:
            (liveStreamId != null ? liveStreamId.value : this.liveStreamId));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaylistCreationResult {
  const PlaylistCreationResult({
    this.id,
  });

  factory PlaylistCreationResult.fromJson(Map<String, dynamic> json) =>
      _$PlaylistCreationResultFromJson(json);

  static const toJsonFactory = _$PlaylistCreationResultToJson;
  Map<String, dynamic> toJson() => _$PlaylistCreationResultToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  static const fromJsonFactory = _$PlaylistCreationResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaylistCreationResult &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ runtimeType.hashCode;
}

extension $PlaylistCreationResultExtension on PlaylistCreationResult {
  PlaylistCreationResult copyWith({String? id}) {
    return PlaylistCreationResult(id: id ?? this.id);
  }

  PlaylistCreationResult copyWithWrapped({Wrapped<String?>? id}) {
    return PlaylistCreationResult(id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaylistDto {
  const PlaylistDto({
    this.openAccess,
    this.shares,
    this.itemIds,
  });

  factory PlaylistDto.fromJson(Map<String, dynamic> json) =>
      _$PlaylistDtoFromJson(json);

  static const toJsonFactory = _$PlaylistDtoToJson;
  Map<String, dynamic> toJson() => _$PlaylistDtoToJson(this);

  @JsonKey(name: 'OpenAccess')
  final bool? openAccess;
  @JsonKey(name: 'Shares', defaultValue: <PlaylistUserPermissions>[])
  final List<PlaylistUserPermissions>? shares;
  @JsonKey(name: 'ItemIds', defaultValue: <String>[])
  final List<String>? itemIds;
  static const fromJsonFactory = _$PlaylistDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaylistDto &&
            (identical(other.openAccess, openAccess) ||
                const DeepCollectionEquality()
                    .equals(other.openAccess, openAccess)) &&
            (identical(other.shares, shares) ||
                const DeepCollectionEquality().equals(other.shares, shares)) &&
            (identical(other.itemIds, itemIds) ||
                const DeepCollectionEquality().equals(other.itemIds, itemIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(openAccess) ^
      const DeepCollectionEquality().hash(shares) ^
      const DeepCollectionEquality().hash(itemIds) ^
      runtimeType.hashCode;
}

extension $PlaylistDtoExtension on PlaylistDto {
  PlaylistDto copyWith(
      {bool? openAccess,
      List<PlaylistUserPermissions>? shares,
      List<String>? itemIds}) {
    return PlaylistDto(
        openAccess: openAccess ?? this.openAccess,
        shares: shares ?? this.shares,
        itemIds: itemIds ?? this.itemIds);
  }

  PlaylistDto copyWithWrapped(
      {Wrapped<bool?>? openAccess,
      Wrapped<List<PlaylistUserPermissions>?>? shares,
      Wrapped<List<String>?>? itemIds}) {
    return PlaylistDto(
        openAccess: (openAccess != null ? openAccess.value : this.openAccess),
        shares: (shares != null ? shares.value : this.shares),
        itemIds: (itemIds != null ? itemIds.value : this.itemIds));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaylistUserPermissions {
  const PlaylistUserPermissions({
    this.userId,
    this.canEdit,
  });

  factory PlaylistUserPermissions.fromJson(Map<String, dynamic> json) =>
      _$PlaylistUserPermissionsFromJson(json);

  static const toJsonFactory = _$PlaylistUserPermissionsToJson;
  Map<String, dynamic> toJson() => _$PlaylistUserPermissionsToJson(this);

  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'CanEdit')
  final bool? canEdit;
  static const fromJsonFactory = _$PlaylistUserPermissionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaylistUserPermissions &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.canEdit, canEdit) ||
                const DeepCollectionEquality().equals(other.canEdit, canEdit)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(canEdit) ^
      runtimeType.hashCode;
}

extension $PlaylistUserPermissionsExtension on PlaylistUserPermissions {
  PlaylistUserPermissions copyWith({String? userId, bool? canEdit}) {
    return PlaylistUserPermissions(
        userId: userId ?? this.userId, canEdit: canEdit ?? this.canEdit);
  }

  PlaylistUserPermissions copyWithWrapped(
      {Wrapped<String?>? userId, Wrapped<bool?>? canEdit}) {
    return PlaylistUserPermissions(
        userId: (userId != null ? userId.value : this.userId),
        canEdit: (canEdit != null ? canEdit.value : this.canEdit));
  }
}

@JsonSerializable(explicitToJson: true)
class PlayMessage {
  const PlayMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory PlayMessage.fromJson(Map<String, dynamic> json) =>
      _$PlayMessageFromJson(json);

  static const toJsonFactory = _$PlayMessageToJson;
  Map<String, dynamic> toJson() => _$PlayMessageToJson(this);

  @JsonKey(name: 'Data')
  final PlayRequest? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.play);

  static const fromJsonFactory = _$PlayMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlayMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $PlayMessageExtension on PlayMessage {
  PlayMessage copyWith(
      {PlayRequest? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return PlayMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  PlayMessage copyWithWrapped(
      {Wrapped<PlayRequest?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return PlayMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class PlayQueueUpdate {
  const PlayQueueUpdate({
    this.reason,
    this.lastUpdate,
    this.playlist,
    this.playingItemIndex,
    this.startPositionTicks,
    this.isPlaying,
    this.shuffleMode,
    this.repeatMode,
  });

  factory PlayQueueUpdate.fromJson(Map<String, dynamic> json) =>
      _$PlayQueueUpdateFromJson(json);

  static const toJsonFactory = _$PlayQueueUpdateToJson;
  Map<String, dynamic> toJson() => _$PlayQueueUpdateToJson(this);

  @JsonKey(
    name: 'Reason',
    toJson: playQueueUpdateReasonNullableToJson,
    fromJson: playQueueUpdateReasonNullableFromJson,
  )
  final enums.PlayQueueUpdateReason? reason;
  @JsonKey(name: 'LastUpdate')
  final DateTime? lastUpdate;
  @JsonKey(name: 'Playlist', defaultValue: <SyncPlayQueueItem>[])
  final List<SyncPlayQueueItem>? playlist;
  @JsonKey(name: 'PlayingItemIndex')
  final int? playingItemIndex;
  @JsonKey(name: 'StartPositionTicks')
  final int? startPositionTicks;
  @JsonKey(name: 'IsPlaying')
  final bool? isPlaying;
  @JsonKey(
    name: 'ShuffleMode',
    toJson: groupShuffleModeNullableToJson,
    fromJson: groupShuffleModeNullableFromJson,
  )
  final enums.GroupShuffleMode? shuffleMode;
  @JsonKey(
    name: 'RepeatMode',
    toJson: groupRepeatModeNullableToJson,
    fromJson: groupRepeatModeNullableFromJson,
  )
  final enums.GroupRepeatMode? repeatMode;
  static const fromJsonFactory = _$PlayQueueUpdateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlayQueueUpdate &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)) &&
            (identical(other.lastUpdate, lastUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastUpdate, lastUpdate)) &&
            (identical(other.playlist, playlist) ||
                const DeepCollectionEquality()
                    .equals(other.playlist, playlist)) &&
            (identical(other.playingItemIndex, playingItemIndex) ||
                const DeepCollectionEquality()
                    .equals(other.playingItemIndex, playingItemIndex)) &&
            (identical(other.startPositionTicks, startPositionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.startPositionTicks, startPositionTicks)) &&
            (identical(other.isPlaying, isPlaying) ||
                const DeepCollectionEquality()
                    .equals(other.isPlaying, isPlaying)) &&
            (identical(other.shuffleMode, shuffleMode) ||
                const DeepCollectionEquality()
                    .equals(other.shuffleMode, shuffleMode)) &&
            (identical(other.repeatMode, repeatMode) ||
                const DeepCollectionEquality()
                    .equals(other.repeatMode, repeatMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(reason) ^
      const DeepCollectionEquality().hash(lastUpdate) ^
      const DeepCollectionEquality().hash(playlist) ^
      const DeepCollectionEquality().hash(playingItemIndex) ^
      const DeepCollectionEquality().hash(startPositionTicks) ^
      const DeepCollectionEquality().hash(isPlaying) ^
      const DeepCollectionEquality().hash(shuffleMode) ^
      const DeepCollectionEquality().hash(repeatMode) ^
      runtimeType.hashCode;
}

extension $PlayQueueUpdateExtension on PlayQueueUpdate {
  PlayQueueUpdate copyWith(
      {enums.PlayQueueUpdateReason? reason,
      DateTime? lastUpdate,
      List<SyncPlayQueueItem>? playlist,
      int? playingItemIndex,
      int? startPositionTicks,
      bool? isPlaying,
      enums.GroupShuffleMode? shuffleMode,
      enums.GroupRepeatMode? repeatMode}) {
    return PlayQueueUpdate(
        reason: reason ?? this.reason,
        lastUpdate: lastUpdate ?? this.lastUpdate,
        playlist: playlist ?? this.playlist,
        playingItemIndex: playingItemIndex ?? this.playingItemIndex,
        startPositionTicks: startPositionTicks ?? this.startPositionTicks,
        isPlaying: isPlaying ?? this.isPlaying,
        shuffleMode: shuffleMode ?? this.shuffleMode,
        repeatMode: repeatMode ?? this.repeatMode);
  }

  PlayQueueUpdate copyWithWrapped(
      {Wrapped<enums.PlayQueueUpdateReason?>? reason,
      Wrapped<DateTime?>? lastUpdate,
      Wrapped<List<SyncPlayQueueItem>?>? playlist,
      Wrapped<int?>? playingItemIndex,
      Wrapped<int?>? startPositionTicks,
      Wrapped<bool?>? isPlaying,
      Wrapped<enums.GroupShuffleMode?>? shuffleMode,
      Wrapped<enums.GroupRepeatMode?>? repeatMode}) {
    return PlayQueueUpdate(
        reason: (reason != null ? reason.value : this.reason),
        lastUpdate: (lastUpdate != null ? lastUpdate.value : this.lastUpdate),
        playlist: (playlist != null ? playlist.value : this.playlist),
        playingItemIndex: (playingItemIndex != null
            ? playingItemIndex.value
            : this.playingItemIndex),
        startPositionTicks: (startPositionTicks != null
            ? startPositionTicks.value
            : this.startPositionTicks),
        isPlaying: (isPlaying != null ? isPlaying.value : this.isPlaying),
        shuffleMode:
            (shuffleMode != null ? shuffleMode.value : this.shuffleMode),
        repeatMode: (repeatMode != null ? repeatMode.value : this.repeatMode));
  }
}

@JsonSerializable(explicitToJson: true)
class PlayQueueUpdateGroupUpdate {
  const PlayQueueUpdateGroupUpdate({
    this.groupId,
    this.type,
    this.data,
  });

  factory PlayQueueUpdateGroupUpdate.fromJson(Map<String, dynamic> json) =>
      _$PlayQueueUpdateGroupUpdateFromJson(json);

  static const toJsonFactory = _$PlayQueueUpdateGroupUpdateToJson;
  Map<String, dynamic> toJson() => _$PlayQueueUpdateGroupUpdateToJson(this);

  @JsonKey(name: 'GroupId')
  final String? groupId;
  @JsonKey(
    name: 'Type',
    toJson: groupUpdateTypeNullableToJson,
    fromJson: groupUpdateTypeNullableFromJson,
  )
  final enums.GroupUpdateType? type;
  @JsonKey(name: 'Data')
  final PlayQueueUpdate? data;
  static const fromJsonFactory = _$PlayQueueUpdateGroupUpdateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlayQueueUpdateGroupUpdate &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $PlayQueueUpdateGroupUpdateExtension on PlayQueueUpdateGroupUpdate {
  PlayQueueUpdateGroupUpdate copyWith(
      {String? groupId, enums.GroupUpdateType? type, PlayQueueUpdate? data}) {
    return PlayQueueUpdateGroupUpdate(
        groupId: groupId ?? this.groupId,
        type: type ?? this.type,
        data: data ?? this.data);
  }

  PlayQueueUpdateGroupUpdate copyWithWrapped(
      {Wrapped<String?>? groupId,
      Wrapped<enums.GroupUpdateType?>? type,
      Wrapped<PlayQueueUpdate?>? data}) {
    return PlayQueueUpdateGroupUpdate(
        groupId: (groupId != null ? groupId.value : this.groupId),
        type: (type != null ? type.value : this.type),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class PlayRequest {
  const PlayRequest({
    this.itemIds,
    this.startPositionTicks,
    this.playCommand,
    this.controllingUserId,
    this.subtitleStreamIndex,
    this.audioStreamIndex,
    this.mediaSourceId,
    this.startIndex,
  });

  factory PlayRequest.fromJson(Map<String, dynamic> json) =>
      _$PlayRequestFromJson(json);

  static const toJsonFactory = _$PlayRequestToJson;
  Map<String, dynamic> toJson() => _$PlayRequestToJson(this);

  @JsonKey(name: 'ItemIds', defaultValue: <String>[])
  final List<String>? itemIds;
  @JsonKey(name: 'StartPositionTicks')
  final int? startPositionTicks;
  @JsonKey(
    name: 'PlayCommand',
    toJson: playCommandNullableToJson,
    fromJson: playCommandNullableFromJson,
  )
  final enums.PlayCommand? playCommand;
  @JsonKey(name: 'ControllingUserId')
  final String? controllingUserId;
  @JsonKey(name: 'SubtitleStreamIndex')
  final int? subtitleStreamIndex;
  @JsonKey(name: 'AudioStreamIndex')
  final int? audioStreamIndex;
  @JsonKey(name: 'MediaSourceId')
  final String? mediaSourceId;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  static const fromJsonFactory = _$PlayRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlayRequest &&
            (identical(other.itemIds, itemIds) ||
                const DeepCollectionEquality()
                    .equals(other.itemIds, itemIds)) &&
            (identical(other.startPositionTicks, startPositionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.startPositionTicks, startPositionTicks)) &&
            (identical(other.playCommand, playCommand) ||
                const DeepCollectionEquality()
                    .equals(other.playCommand, playCommand)) &&
            (identical(other.controllingUserId, controllingUserId) ||
                const DeepCollectionEquality()
                    .equals(other.controllingUserId, controllingUserId)) &&
            (identical(other.subtitleStreamIndex, subtitleStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.subtitleStreamIndex, subtitleStreamIndex)) &&
            (identical(other.audioStreamIndex, audioStreamIndex) ||
                const DeepCollectionEquality()
                    .equals(other.audioStreamIndex, audioStreamIndex)) &&
            (identical(other.mediaSourceId, mediaSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.mediaSourceId, mediaSourceId)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemIds) ^
      const DeepCollectionEquality().hash(startPositionTicks) ^
      const DeepCollectionEquality().hash(playCommand) ^
      const DeepCollectionEquality().hash(controllingUserId) ^
      const DeepCollectionEquality().hash(subtitleStreamIndex) ^
      const DeepCollectionEquality().hash(audioStreamIndex) ^
      const DeepCollectionEquality().hash(mediaSourceId) ^
      const DeepCollectionEquality().hash(startIndex) ^
      runtimeType.hashCode;
}

extension $PlayRequestExtension on PlayRequest {
  PlayRequest copyWith(
      {List<String>? itemIds,
      int? startPositionTicks,
      enums.PlayCommand? playCommand,
      String? controllingUserId,
      int? subtitleStreamIndex,
      int? audioStreamIndex,
      String? mediaSourceId,
      int? startIndex}) {
    return PlayRequest(
        itemIds: itemIds ?? this.itemIds,
        startPositionTicks: startPositionTicks ?? this.startPositionTicks,
        playCommand: playCommand ?? this.playCommand,
        controllingUserId: controllingUserId ?? this.controllingUserId,
        subtitleStreamIndex: subtitleStreamIndex ?? this.subtitleStreamIndex,
        audioStreamIndex: audioStreamIndex ?? this.audioStreamIndex,
        mediaSourceId: mediaSourceId ?? this.mediaSourceId,
        startIndex: startIndex ?? this.startIndex);
  }

  PlayRequest copyWithWrapped(
      {Wrapped<List<String>?>? itemIds,
      Wrapped<int?>? startPositionTicks,
      Wrapped<enums.PlayCommand?>? playCommand,
      Wrapped<String?>? controllingUserId,
      Wrapped<int?>? subtitleStreamIndex,
      Wrapped<int?>? audioStreamIndex,
      Wrapped<String?>? mediaSourceId,
      Wrapped<int?>? startIndex}) {
    return PlayRequest(
        itemIds: (itemIds != null ? itemIds.value : this.itemIds),
        startPositionTicks: (startPositionTicks != null
            ? startPositionTicks.value
            : this.startPositionTicks),
        playCommand:
            (playCommand != null ? playCommand.value : this.playCommand),
        controllingUserId: (controllingUserId != null
            ? controllingUserId.value
            : this.controllingUserId),
        subtitleStreamIndex: (subtitleStreamIndex != null
            ? subtitleStreamIndex.value
            : this.subtitleStreamIndex),
        audioStreamIndex: (audioStreamIndex != null
            ? audioStreamIndex.value
            : this.audioStreamIndex),
        mediaSourceId:
            (mediaSourceId != null ? mediaSourceId.value : this.mediaSourceId),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex));
  }
}

@JsonSerializable(explicitToJson: true)
class PlayRequestDto {
  const PlayRequestDto({
    this.playingQueue,
    this.playingItemPosition,
    this.startPositionTicks,
  });

  factory PlayRequestDto.fromJson(Map<String, dynamic> json) =>
      _$PlayRequestDtoFromJson(json);

  static const toJsonFactory = _$PlayRequestDtoToJson;
  Map<String, dynamic> toJson() => _$PlayRequestDtoToJson(this);

  @JsonKey(name: 'PlayingQueue', defaultValue: <String>[])
  final List<String>? playingQueue;
  @JsonKey(name: 'PlayingItemPosition')
  final int? playingItemPosition;
  @JsonKey(name: 'StartPositionTicks')
  final int? startPositionTicks;
  static const fromJsonFactory = _$PlayRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlayRequestDto &&
            (identical(other.playingQueue, playingQueue) ||
                const DeepCollectionEquality()
                    .equals(other.playingQueue, playingQueue)) &&
            (identical(other.playingItemPosition, playingItemPosition) ||
                const DeepCollectionEquality()
                    .equals(other.playingItemPosition, playingItemPosition)) &&
            (identical(other.startPositionTicks, startPositionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.startPositionTicks, startPositionTicks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(playingQueue) ^
      const DeepCollectionEquality().hash(playingItemPosition) ^
      const DeepCollectionEquality().hash(startPositionTicks) ^
      runtimeType.hashCode;
}

extension $PlayRequestDtoExtension on PlayRequestDto {
  PlayRequestDto copyWith(
      {List<String>? playingQueue,
      int? playingItemPosition,
      int? startPositionTicks}) {
    return PlayRequestDto(
        playingQueue: playingQueue ?? this.playingQueue,
        playingItemPosition: playingItemPosition ?? this.playingItemPosition,
        startPositionTicks: startPositionTicks ?? this.startPositionTicks);
  }

  PlayRequestDto copyWithWrapped(
      {Wrapped<List<String>?>? playingQueue,
      Wrapped<int?>? playingItemPosition,
      Wrapped<int?>? startPositionTicks}) {
    return PlayRequestDto(
        playingQueue:
            (playingQueue != null ? playingQueue.value : this.playingQueue),
        playingItemPosition: (playingItemPosition != null
            ? playingItemPosition.value
            : this.playingItemPosition),
        startPositionTicks: (startPositionTicks != null
            ? startPositionTicks.value
            : this.startPositionTicks));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaystateMessage {
  const PlaystateMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory PlaystateMessage.fromJson(Map<String, dynamic> json) =>
      _$PlaystateMessageFromJson(json);

  static const toJsonFactory = _$PlaystateMessageToJson;
  Map<String, dynamic> toJson() => _$PlaystateMessageToJson(this);

  @JsonKey(name: 'Data')
  final PlaystateRequest? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.playstate);

  static const fromJsonFactory = _$PlaystateMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaystateMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $PlaystateMessageExtension on PlaystateMessage {
  PlaystateMessage copyWith(
      {PlaystateRequest? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return PlaystateMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  PlaystateMessage copyWithWrapped(
      {Wrapped<PlaystateRequest?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return PlaystateMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaystateRequest {
  const PlaystateRequest({
    this.command,
    this.seekPositionTicks,
    this.controllingUserId,
  });

  factory PlaystateRequest.fromJson(Map<String, dynamic> json) =>
      _$PlaystateRequestFromJson(json);

  static const toJsonFactory = _$PlaystateRequestToJson;
  Map<String, dynamic> toJson() => _$PlaystateRequestToJson(this);

  @JsonKey(
    name: 'Command',
    toJson: playstateCommandNullableToJson,
    fromJson: playstateCommandNullableFromJson,
  )
  final enums.PlaystateCommand? command;
  @JsonKey(name: 'SeekPositionTicks')
  final int? seekPositionTicks;
  @JsonKey(name: 'ControllingUserId')
  final String? controllingUserId;
  static const fromJsonFactory = _$PlaystateRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PlaystateRequest &&
            (identical(other.command, command) ||
                const DeepCollectionEquality()
                    .equals(other.command, command)) &&
            (identical(other.seekPositionTicks, seekPositionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.seekPositionTicks, seekPositionTicks)) &&
            (identical(other.controllingUserId, controllingUserId) ||
                const DeepCollectionEquality()
                    .equals(other.controllingUserId, controllingUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(command) ^
      const DeepCollectionEquality().hash(seekPositionTicks) ^
      const DeepCollectionEquality().hash(controllingUserId) ^
      runtimeType.hashCode;
}

extension $PlaystateRequestExtension on PlaystateRequest {
  PlaystateRequest copyWith(
      {enums.PlaystateCommand? command,
      int? seekPositionTicks,
      String? controllingUserId}) {
    return PlaystateRequest(
        command: command ?? this.command,
        seekPositionTicks: seekPositionTicks ?? this.seekPositionTicks,
        controllingUserId: controllingUserId ?? this.controllingUserId);
  }

  PlaystateRequest copyWithWrapped(
      {Wrapped<enums.PlaystateCommand?>? command,
      Wrapped<int?>? seekPositionTicks,
      Wrapped<String?>? controllingUserId}) {
    return PlaystateRequest(
        command: (command != null ? command.value : this.command),
        seekPositionTicks: (seekPositionTicks != null
            ? seekPositionTicks.value
            : this.seekPositionTicks),
        controllingUserId: (controllingUserId != null
            ? controllingUserId.value
            : this.controllingUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class PluginInfo {
  const PluginInfo({
    this.name,
    this.version,
    this.configurationFileName,
    this.description,
    this.id,
    this.canUninstall,
    this.hasImage,
    this.status,
  });

  factory PluginInfo.fromJson(Map<String, dynamic> json) =>
      _$PluginInfoFromJson(json);

  static const toJsonFactory = _$PluginInfoToJson;
  Map<String, dynamic> toJson() => _$PluginInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Version')
  final String? version;
  @JsonKey(name: 'ConfigurationFileName')
  final String? configurationFileName;
  @JsonKey(name: 'Description')
  final String? description;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'CanUninstall')
  final bool? canUninstall;
  @JsonKey(name: 'HasImage')
  final bool? hasImage;
  @JsonKey(
    name: 'Status',
    toJson: pluginStatusNullableToJson,
    fromJson: pluginStatusNullableFromJson,
  )
  final enums.PluginStatus? status;
  static const fromJsonFactory = _$PluginInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PluginInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.configurationFileName, configurationFileName) ||
                const DeepCollectionEquality().equals(
                    other.configurationFileName, configurationFileName)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.canUninstall, canUninstall) ||
                const DeepCollectionEquality()
                    .equals(other.canUninstall, canUninstall)) &&
            (identical(other.hasImage, hasImage) ||
                const DeepCollectionEquality()
                    .equals(other.hasImage, hasImage)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(configurationFileName) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(canUninstall) ^
      const DeepCollectionEquality().hash(hasImage) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $PluginInfoExtension on PluginInfo {
  PluginInfo copyWith(
      {String? name,
      String? version,
      String? configurationFileName,
      String? description,
      String? id,
      bool? canUninstall,
      bool? hasImage,
      enums.PluginStatus? status}) {
    return PluginInfo(
        name: name ?? this.name,
        version: version ?? this.version,
        configurationFileName:
            configurationFileName ?? this.configurationFileName,
        description: description ?? this.description,
        id: id ?? this.id,
        canUninstall: canUninstall ?? this.canUninstall,
        hasImage: hasImage ?? this.hasImage,
        status: status ?? this.status);
  }

  PluginInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? version,
      Wrapped<String?>? configurationFileName,
      Wrapped<String?>? description,
      Wrapped<String?>? id,
      Wrapped<bool?>? canUninstall,
      Wrapped<bool?>? hasImage,
      Wrapped<enums.PluginStatus?>? status}) {
    return PluginInfo(
        name: (name != null ? name.value : this.name),
        version: (version != null ? version.value : this.version),
        configurationFileName: (configurationFileName != null
            ? configurationFileName.value
            : this.configurationFileName),
        description:
            (description != null ? description.value : this.description),
        id: (id != null ? id.value : this.id),
        canUninstall:
            (canUninstall != null ? canUninstall.value : this.canUninstall),
        hasImage: (hasImage != null ? hasImage.value : this.hasImage),
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class PluginInstallationCancelledMessage {
  const PluginInstallationCancelledMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory PluginInstallationCancelledMessage.fromJson(
          Map<String, dynamic> json) =>
      _$PluginInstallationCancelledMessageFromJson(json);

  static const toJsonFactory = _$PluginInstallationCancelledMessageToJson;
  Map<String, dynamic> toJson() =>
      _$PluginInstallationCancelledMessageToJson(this);

  @JsonKey(name: 'Data')
  final InstallationInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.packageinstallationcancelled);

  static const fromJsonFactory = _$PluginInstallationCancelledMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PluginInstallationCancelledMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $PluginInstallationCancelledMessageExtension
    on PluginInstallationCancelledMessage {
  PluginInstallationCancelledMessage copyWith(
      {InstallationInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return PluginInstallationCancelledMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  PluginInstallationCancelledMessage copyWithWrapped(
      {Wrapped<InstallationInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return PluginInstallationCancelledMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class PluginInstallationCompletedMessage {
  const PluginInstallationCompletedMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory PluginInstallationCompletedMessage.fromJson(
          Map<String, dynamic> json) =>
      _$PluginInstallationCompletedMessageFromJson(json);

  static const toJsonFactory = _$PluginInstallationCompletedMessageToJson;
  Map<String, dynamic> toJson() =>
      _$PluginInstallationCompletedMessageToJson(this);

  @JsonKey(name: 'Data')
  final InstallationInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.packageinstallationcompleted);

  static const fromJsonFactory = _$PluginInstallationCompletedMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PluginInstallationCompletedMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $PluginInstallationCompletedMessageExtension
    on PluginInstallationCompletedMessage {
  PluginInstallationCompletedMessage copyWith(
      {InstallationInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return PluginInstallationCompletedMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  PluginInstallationCompletedMessage copyWithWrapped(
      {Wrapped<InstallationInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return PluginInstallationCompletedMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class PluginInstallationFailedMessage {
  const PluginInstallationFailedMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory PluginInstallationFailedMessage.fromJson(Map<String, dynamic> json) =>
      _$PluginInstallationFailedMessageFromJson(json);

  static const toJsonFactory = _$PluginInstallationFailedMessageToJson;
  Map<String, dynamic> toJson() =>
      _$PluginInstallationFailedMessageToJson(this);

  @JsonKey(name: 'Data')
  final InstallationInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.packageinstallationfailed);

  static const fromJsonFactory = _$PluginInstallationFailedMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PluginInstallationFailedMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $PluginInstallationFailedMessageExtension
    on PluginInstallationFailedMessage {
  PluginInstallationFailedMessage copyWith(
      {InstallationInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return PluginInstallationFailedMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  PluginInstallationFailedMessage copyWithWrapped(
      {Wrapped<InstallationInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return PluginInstallationFailedMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class PluginInstallingMessage {
  const PluginInstallingMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory PluginInstallingMessage.fromJson(Map<String, dynamic> json) =>
      _$PluginInstallingMessageFromJson(json);

  static const toJsonFactory = _$PluginInstallingMessageToJson;
  Map<String, dynamic> toJson() => _$PluginInstallingMessageToJson(this);

  @JsonKey(name: 'Data')
  final InstallationInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.packageinstalling);

  static const fromJsonFactory = _$PluginInstallingMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PluginInstallingMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $PluginInstallingMessageExtension on PluginInstallingMessage {
  PluginInstallingMessage copyWith(
      {InstallationInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return PluginInstallingMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  PluginInstallingMessage copyWithWrapped(
      {Wrapped<InstallationInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return PluginInstallingMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class PluginUninstalledMessage {
  const PluginUninstalledMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory PluginUninstalledMessage.fromJson(Map<String, dynamic> json) =>
      _$PluginUninstalledMessageFromJson(json);

  static const toJsonFactory = _$PluginUninstalledMessageToJson;
  Map<String, dynamic> toJson() => _$PluginUninstalledMessageToJson(this);

  @JsonKey(name: 'Data')
  final PluginInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.packageuninstalled);

  static const fromJsonFactory = _$PluginUninstalledMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PluginUninstalledMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $PluginUninstalledMessageExtension on PluginUninstalledMessage {
  PluginUninstalledMessage copyWith(
      {PluginInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return PluginUninstalledMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  PluginUninstalledMessage copyWithWrapped(
      {Wrapped<PluginInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return PluginUninstalledMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class PreviousItemRequestDto {
  const PreviousItemRequestDto({
    this.playlistItemId,
  });

  factory PreviousItemRequestDto.fromJson(Map<String, dynamic> json) =>
      _$PreviousItemRequestDtoFromJson(json);

  static const toJsonFactory = _$PreviousItemRequestDtoToJson;
  Map<String, dynamic> toJson() => _$PreviousItemRequestDtoToJson(this);

  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  static const fromJsonFactory = _$PreviousItemRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PreviousItemRequestDto &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(playlistItemId) ^
      runtimeType.hashCode;
}

extension $PreviousItemRequestDtoExtension on PreviousItemRequestDto {
  PreviousItemRequestDto copyWith({String? playlistItemId}) {
    return PreviousItemRequestDto(
        playlistItemId: playlistItemId ?? this.playlistItemId);
  }

  PreviousItemRequestDto copyWithWrapped({Wrapped<String?>? playlistItemId}) {
    return PreviousItemRequestDto(
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProblemDetails {
  const ProblemDetails({
    this.type,
    this.title,
    this.status,
    this.detail,
    this.instance,
  });

  factory ProblemDetails.fromJson(Map<String, dynamic> json) =>
      _$ProblemDetailsFromJson(json);

  static const toJsonFactory = _$ProblemDetailsToJson;
  Map<String, dynamic> toJson() => _$ProblemDetailsToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'status')
  final int? status;
  @JsonKey(name: 'detail')
  final String? detail;
  @JsonKey(name: 'instance')
  final String? instance;
  static const fromJsonFactory = _$ProblemDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProblemDetails &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.detail, detail) ||
                const DeepCollectionEquality().equals(other.detail, detail)) &&
            (identical(other.instance, instance) ||
                const DeepCollectionEquality()
                    .equals(other.instance, instance)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(detail) ^
      const DeepCollectionEquality().hash(instance) ^
      runtimeType.hashCode;
}

extension $ProblemDetailsExtension on ProblemDetails {
  ProblemDetails copyWith(
      {String? type,
      String? title,
      int? status,
      String? detail,
      String? instance}) {
    return ProblemDetails(
        type: type ?? this.type,
        title: title ?? this.title,
        status: status ?? this.status,
        detail: detail ?? this.detail,
        instance: instance ?? this.instance);
  }

  ProblemDetails copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<String?>? title,
      Wrapped<int?>? status,
      Wrapped<String?>? detail,
      Wrapped<String?>? instance}) {
    return ProblemDetails(
        type: (type != null ? type.value : this.type),
        title: (title != null ? title.value : this.title),
        status: (status != null ? status.value : this.status),
        detail: (detail != null ? detail.value : this.detail),
        instance: (instance != null ? instance.value : this.instance));
  }
}

@JsonSerializable(explicitToJson: true)
class ProfileCondition {
  const ProfileCondition({
    this.condition,
    this.property,
    this.$Value,
    this.isRequired,
  });

  factory ProfileCondition.fromJson(Map<String, dynamic> json) =>
      _$ProfileConditionFromJson(json);

  static const toJsonFactory = _$ProfileConditionToJson;
  Map<String, dynamic> toJson() => _$ProfileConditionToJson(this);

  @JsonKey(
    name: 'Condition',
    toJson: profileConditionTypeNullableToJson,
    fromJson: profileConditionTypeNullableFromJson,
  )
  final enums.ProfileConditionType? condition;
  @JsonKey(
    name: 'Property',
    toJson: profileConditionValueNullableToJson,
    fromJson: profileConditionValueNullableFromJson,
  )
  final enums.ProfileConditionValue? property;
  @JsonKey(name: 'Value')
  final String? $Value;
  @JsonKey(name: 'IsRequired')
  final bool? isRequired;
  static const fromJsonFactory = _$ProfileConditionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProfileCondition &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality()
                    .equals(other.property, property)) &&
            (identical(other.$Value, $Value) ||
                const DeepCollectionEquality().equals(other.$Value, $Value)) &&
            (identical(other.isRequired, isRequired) ||
                const DeepCollectionEquality()
                    .equals(other.isRequired, isRequired)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash($Value) ^
      const DeepCollectionEquality().hash(isRequired) ^
      runtimeType.hashCode;
}

extension $ProfileConditionExtension on ProfileCondition {
  ProfileCondition copyWith(
      {enums.ProfileConditionType? condition,
      enums.ProfileConditionValue? property,
      String? $Value,
      bool? isRequired}) {
    return ProfileCondition(
        condition: condition ?? this.condition,
        property: property ?? this.property,
        $Value: $Value ?? this.$Value,
        isRequired: isRequired ?? this.isRequired);
  }

  ProfileCondition copyWithWrapped(
      {Wrapped<enums.ProfileConditionType?>? condition,
      Wrapped<enums.ProfileConditionValue?>? property,
      Wrapped<String?>? $Value,
      Wrapped<bool?>? isRequired}) {
    return ProfileCondition(
        condition: (condition != null ? condition.value : this.condition),
        property: (property != null ? property.value : this.property),
        $Value: ($Value != null ? $Value.value : this.$Value),
        isRequired: (isRequired != null ? isRequired.value : this.isRequired));
  }
}

@JsonSerializable(explicitToJson: true)
class PublicSystemInfo {
  const PublicSystemInfo({
    this.localAddress,
    this.serverName,
    this.version,
    this.productName,
    this.operatingSystem,
    this.id,
    this.startupWizardCompleted,
  });

  factory PublicSystemInfo.fromJson(Map<String, dynamic> json) =>
      _$PublicSystemInfoFromJson(json);

  static const toJsonFactory = _$PublicSystemInfoToJson;
  Map<String, dynamic> toJson() => _$PublicSystemInfoToJson(this);

  @JsonKey(name: 'LocalAddress')
  final String? localAddress;
  @JsonKey(name: 'ServerName')
  final String? serverName;
  @JsonKey(name: 'Version')
  final String? version;
  @JsonKey(name: 'ProductName')
  final String? productName;
  @JsonKey(name: 'OperatingSystem')
  @deprecated
  final String? operatingSystem;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'StartupWizardCompleted')
  final bool? startupWizardCompleted;
  static const fromJsonFactory = _$PublicSystemInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PublicSystemInfo &&
            (identical(other.localAddress, localAddress) ||
                const DeepCollectionEquality()
                    .equals(other.localAddress, localAddress)) &&
            (identical(other.serverName, serverName) ||
                const DeepCollectionEquality()
                    .equals(other.serverName, serverName)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.productName, productName) ||
                const DeepCollectionEquality()
                    .equals(other.productName, productName)) &&
            (identical(other.operatingSystem, operatingSystem) ||
                const DeepCollectionEquality()
                    .equals(other.operatingSystem, operatingSystem)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.startupWizardCompleted, startupWizardCompleted) ||
                const DeepCollectionEquality().equals(
                    other.startupWizardCompleted, startupWizardCompleted)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(localAddress) ^
      const DeepCollectionEquality().hash(serverName) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(productName) ^
      const DeepCollectionEquality().hash(operatingSystem) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(startupWizardCompleted) ^
      runtimeType.hashCode;
}

extension $PublicSystemInfoExtension on PublicSystemInfo {
  PublicSystemInfo copyWith(
      {String? localAddress,
      String? serverName,
      String? version,
      String? productName,
      String? operatingSystem,
      String? id,
      bool? startupWizardCompleted}) {
    return PublicSystemInfo(
        localAddress: localAddress ?? this.localAddress,
        serverName: serverName ?? this.serverName,
        version: version ?? this.version,
        productName: productName ?? this.productName,
        operatingSystem: operatingSystem ?? this.operatingSystem,
        id: id ?? this.id,
        startupWizardCompleted:
            startupWizardCompleted ?? this.startupWizardCompleted);
  }

  PublicSystemInfo copyWithWrapped(
      {Wrapped<String?>? localAddress,
      Wrapped<String?>? serverName,
      Wrapped<String?>? version,
      Wrapped<String?>? productName,
      Wrapped<String?>? operatingSystem,
      Wrapped<String?>? id,
      Wrapped<bool?>? startupWizardCompleted}) {
    return PublicSystemInfo(
        localAddress:
            (localAddress != null ? localAddress.value : this.localAddress),
        serverName: (serverName != null ? serverName.value : this.serverName),
        version: (version != null ? version.value : this.version),
        productName:
            (productName != null ? productName.value : this.productName),
        operatingSystem: (operatingSystem != null
            ? operatingSystem.value
            : this.operatingSystem),
        id: (id != null ? id.value : this.id),
        startupWizardCompleted: (startupWizardCompleted != null
            ? startupWizardCompleted.value
            : this.startupWizardCompleted));
  }
}

@JsonSerializable(explicitToJson: true)
class QueryFilters {
  const QueryFilters({
    this.genres,
    this.tags,
  });

  factory QueryFilters.fromJson(Map<String, dynamic> json) =>
      _$QueryFiltersFromJson(json);

  static const toJsonFactory = _$QueryFiltersToJson;
  Map<String, dynamic> toJson() => _$QueryFiltersToJson(this);

  @JsonKey(name: 'Genres', defaultValue: <NameGuidPair>[])
  final List<NameGuidPair>? genres;
  @JsonKey(name: 'Tags', defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$QueryFiltersFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QueryFilters &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $QueryFiltersExtension on QueryFilters {
  QueryFilters copyWith({List<NameGuidPair>? genres, List<String>? tags}) {
    return QueryFilters(genres: genres ?? this.genres, tags: tags ?? this.tags);
  }

  QueryFilters copyWithWrapped(
      {Wrapped<List<NameGuidPair>?>? genres, Wrapped<List<String>?>? tags}) {
    return QueryFilters(
        genres: (genres != null ? genres.value : this.genres),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class QueryFiltersLegacy {
  const QueryFiltersLegacy({
    this.genres,
    this.tags,
    this.officialRatings,
    this.years,
  });

  factory QueryFiltersLegacy.fromJson(Map<String, dynamic> json) =>
      _$QueryFiltersLegacyFromJson(json);

  static const toJsonFactory = _$QueryFiltersLegacyToJson;
  Map<String, dynamic> toJson() => _$QueryFiltersLegacyToJson(this);

  @JsonKey(name: 'Genres', defaultValue: <String>[])
  final List<String>? genres;
  @JsonKey(name: 'Tags', defaultValue: <String>[])
  final List<String>? tags;
  @JsonKey(name: 'OfficialRatings', defaultValue: <String>[])
  final List<String>? officialRatings;
  @JsonKey(name: 'Years', defaultValue: <int>[])
  final List<int>? years;
  static const fromJsonFactory = _$QueryFiltersLegacyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QueryFiltersLegacy &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.officialRatings, officialRatings) ||
                const DeepCollectionEquality()
                    .equals(other.officialRatings, officialRatings)) &&
            (identical(other.years, years) ||
                const DeepCollectionEquality().equals(other.years, years)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(officialRatings) ^
      const DeepCollectionEquality().hash(years) ^
      runtimeType.hashCode;
}

extension $QueryFiltersLegacyExtension on QueryFiltersLegacy {
  QueryFiltersLegacy copyWith(
      {List<String>? genres,
      List<String>? tags,
      List<String>? officialRatings,
      List<int>? years}) {
    return QueryFiltersLegacy(
        genres: genres ?? this.genres,
        tags: tags ?? this.tags,
        officialRatings: officialRatings ?? this.officialRatings,
        years: years ?? this.years);
  }

  QueryFiltersLegacy copyWithWrapped(
      {Wrapped<List<String>?>? genres,
      Wrapped<List<String>?>? tags,
      Wrapped<List<String>?>? officialRatings,
      Wrapped<List<int>?>? years}) {
    return QueryFiltersLegacy(
        genres: (genres != null ? genres.value : this.genres),
        tags: (tags != null ? tags.value : this.tags),
        officialRatings: (officialRatings != null
            ? officialRatings.value
            : this.officialRatings),
        years: (years != null ? years.value : this.years));
  }
}

@JsonSerializable(explicitToJson: true)
class QueueItem {
  const QueueItem({
    this.id,
    this.playlistItemId,
  });

  factory QueueItem.fromJson(Map<String, dynamic> json) =>
      _$QueueItemFromJson(json);

  static const toJsonFactory = _$QueueItemToJson;
  Map<String, dynamic> toJson() => _$QueueItemToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  static const fromJsonFactory = _$QueueItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QueueItem &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      runtimeType.hashCode;
}

extension $QueueItemExtension on QueueItem {
  QueueItem copyWith({String? id, String? playlistItemId}) {
    return QueueItem(
        id: id ?? this.id,
        playlistItemId: playlistItemId ?? this.playlistItemId);
  }

  QueueItem copyWithWrapped(
      {Wrapped<String?>? id, Wrapped<String?>? playlistItemId}) {
    return QueueItem(
        id: (id != null ? id.value : this.id),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId));
  }
}

@JsonSerializable(explicitToJson: true)
class QueueRequestDto {
  const QueueRequestDto({
    this.itemIds,
    this.mode,
  });

  factory QueueRequestDto.fromJson(Map<String, dynamic> json) =>
      _$QueueRequestDtoFromJson(json);

  static const toJsonFactory = _$QueueRequestDtoToJson;
  Map<String, dynamic> toJson() => _$QueueRequestDtoToJson(this);

  @JsonKey(name: 'ItemIds', defaultValue: <String>[])
  final List<String>? itemIds;
  @JsonKey(
    name: 'Mode',
    toJson: groupQueueModeNullableToJson,
    fromJson: groupQueueModeNullableFromJson,
  )
  final enums.GroupQueueMode? mode;
  static const fromJsonFactory = _$QueueRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QueueRequestDto &&
            (identical(other.itemIds, itemIds) ||
                const DeepCollectionEquality()
                    .equals(other.itemIds, itemIds)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemIds) ^
      const DeepCollectionEquality().hash(mode) ^
      runtimeType.hashCode;
}

extension $QueueRequestDtoExtension on QueueRequestDto {
  QueueRequestDto copyWith(
      {List<String>? itemIds, enums.GroupQueueMode? mode}) {
    return QueueRequestDto(
        itemIds: itemIds ?? this.itemIds, mode: mode ?? this.mode);
  }

  QueueRequestDto copyWithWrapped(
      {Wrapped<List<String>?>? itemIds, Wrapped<enums.GroupQueueMode?>? mode}) {
    return QueueRequestDto(
        itemIds: (itemIds != null ? itemIds.value : this.itemIds),
        mode: (mode != null ? mode.value : this.mode));
  }
}

@JsonSerializable(explicitToJson: true)
class QuickConnectDto {
  const QuickConnectDto({
    required this.secret,
  });

  factory QuickConnectDto.fromJson(Map<String, dynamic> json) =>
      _$QuickConnectDtoFromJson(json);

  static const toJsonFactory = _$QuickConnectDtoToJson;
  Map<String, dynamic> toJson() => _$QuickConnectDtoToJson(this);

  @JsonKey(name: 'Secret')
  final String secret;
  static const fromJsonFactory = _$QuickConnectDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QuickConnectDto &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^ runtimeType.hashCode;
}

extension $QuickConnectDtoExtension on QuickConnectDto {
  QuickConnectDto copyWith({String? secret}) {
    return QuickConnectDto(secret: secret ?? this.secret);
  }

  QuickConnectDto copyWithWrapped({Wrapped<String>? secret}) {
    return QuickConnectDto(
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class QuickConnectResult {
  const QuickConnectResult({
    this.authenticated,
    this.secret,
    this.code,
    this.deviceId,
    this.deviceName,
    this.appName,
    this.appVersion,
    this.dateAdded,
  });

  factory QuickConnectResult.fromJson(Map<String, dynamic> json) =>
      _$QuickConnectResultFromJson(json);

  static const toJsonFactory = _$QuickConnectResultToJson;
  Map<String, dynamic> toJson() => _$QuickConnectResultToJson(this);

  @JsonKey(name: 'Authenticated')
  final bool? authenticated;
  @JsonKey(name: 'Secret')
  final String? secret;
  @JsonKey(name: 'Code')
  final String? code;
  @JsonKey(name: 'DeviceId')
  final String? deviceId;
  @JsonKey(name: 'DeviceName')
  final String? deviceName;
  @JsonKey(name: 'AppName')
  final String? appName;
  @JsonKey(name: 'AppVersion')
  final String? appVersion;
  @JsonKey(name: 'DateAdded')
  final DateTime? dateAdded;
  static const fromJsonFactory = _$QuickConnectResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QuickConnectResult &&
            (identical(other.authenticated, authenticated) ||
                const DeepCollectionEquality()
                    .equals(other.authenticated, authenticated)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.deviceName, deviceName) ||
                const DeepCollectionEquality()
                    .equals(other.deviceName, deviceName)) &&
            (identical(other.appName, appName) ||
                const DeepCollectionEquality()
                    .equals(other.appName, appName)) &&
            (identical(other.appVersion, appVersion) ||
                const DeepCollectionEquality()
                    .equals(other.appVersion, appVersion)) &&
            (identical(other.dateAdded, dateAdded) ||
                const DeepCollectionEquality()
                    .equals(other.dateAdded, dateAdded)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticated) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(deviceName) ^
      const DeepCollectionEquality().hash(appName) ^
      const DeepCollectionEquality().hash(appVersion) ^
      const DeepCollectionEquality().hash(dateAdded) ^
      runtimeType.hashCode;
}

extension $QuickConnectResultExtension on QuickConnectResult {
  QuickConnectResult copyWith(
      {bool? authenticated,
      String? secret,
      String? code,
      String? deviceId,
      String? deviceName,
      String? appName,
      String? appVersion,
      DateTime? dateAdded}) {
    return QuickConnectResult(
        authenticated: authenticated ?? this.authenticated,
        secret: secret ?? this.secret,
        code: code ?? this.code,
        deviceId: deviceId ?? this.deviceId,
        deviceName: deviceName ?? this.deviceName,
        appName: appName ?? this.appName,
        appVersion: appVersion ?? this.appVersion,
        dateAdded: dateAdded ?? this.dateAdded);
  }

  QuickConnectResult copyWithWrapped(
      {Wrapped<bool?>? authenticated,
      Wrapped<String?>? secret,
      Wrapped<String?>? code,
      Wrapped<String?>? deviceId,
      Wrapped<String?>? deviceName,
      Wrapped<String?>? appName,
      Wrapped<String?>? appVersion,
      Wrapped<DateTime?>? dateAdded}) {
    return QuickConnectResult(
        authenticated:
            (authenticated != null ? authenticated.value : this.authenticated),
        secret: (secret != null ? secret.value : this.secret),
        code: (code != null ? code.value : this.code),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        deviceName: (deviceName != null ? deviceName.value : this.deviceName),
        appName: (appName != null ? appName.value : this.appName),
        appVersion: (appVersion != null ? appVersion.value : this.appVersion),
        dateAdded: (dateAdded != null ? dateAdded.value : this.dateAdded));
  }
}

@JsonSerializable(explicitToJson: true)
class ReadyRequestDto {
  const ReadyRequestDto({
    this.when,
    this.positionTicks,
    this.isPlaying,
    this.playlistItemId,
  });

  factory ReadyRequestDto.fromJson(Map<String, dynamic> json) =>
      _$ReadyRequestDtoFromJson(json);

  static const toJsonFactory = _$ReadyRequestDtoToJson;
  Map<String, dynamic> toJson() => _$ReadyRequestDtoToJson(this);

  @JsonKey(name: 'When')
  final DateTime? when;
  @JsonKey(name: 'PositionTicks')
  final int? positionTicks;
  @JsonKey(name: 'IsPlaying')
  final bool? isPlaying;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  static const fromJsonFactory = _$ReadyRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReadyRequestDto &&
            (identical(other.when, when) ||
                const DeepCollectionEquality().equals(other.when, when)) &&
            (identical(other.positionTicks, positionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.positionTicks, positionTicks)) &&
            (identical(other.isPlaying, isPlaying) ||
                const DeepCollectionEquality()
                    .equals(other.isPlaying, isPlaying)) &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(when) ^
      const DeepCollectionEquality().hash(positionTicks) ^
      const DeepCollectionEquality().hash(isPlaying) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      runtimeType.hashCode;
}

extension $ReadyRequestDtoExtension on ReadyRequestDto {
  ReadyRequestDto copyWith(
      {DateTime? when,
      int? positionTicks,
      bool? isPlaying,
      String? playlistItemId}) {
    return ReadyRequestDto(
        when: when ?? this.when,
        positionTicks: positionTicks ?? this.positionTicks,
        isPlaying: isPlaying ?? this.isPlaying,
        playlistItemId: playlistItemId ?? this.playlistItemId);
  }

  ReadyRequestDto copyWithWrapped(
      {Wrapped<DateTime?>? when,
      Wrapped<int?>? positionTicks,
      Wrapped<bool?>? isPlaying,
      Wrapped<String?>? playlistItemId}) {
    return ReadyRequestDto(
        when: (when != null ? when.value : this.when),
        positionTicks:
            (positionTicks != null ? positionTicks.value : this.positionTicks),
        isPlaying: (isPlaying != null ? isPlaying.value : this.isPlaying),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId));
  }
}

@JsonSerializable(explicitToJson: true)
class RecommendationDto {
  const RecommendationDto({
    this.items,
    this.recommendationType,
    this.baselineItemName,
    this.categoryId,
  });

  factory RecommendationDto.fromJson(Map<String, dynamic> json) =>
      _$RecommendationDtoFromJson(json);

  static const toJsonFactory = _$RecommendationDtoToJson;
  Map<String, dynamic> toJson() => _$RecommendationDtoToJson(this);

  @JsonKey(name: 'Items', defaultValue: <BaseItemDto>[])
  final List<BaseItemDto>? items;
  @JsonKey(
    name: 'RecommendationType',
    toJson: recommendationTypeNullableToJson,
    fromJson: recommendationTypeNullableFromJson,
  )
  final enums.RecommendationType? recommendationType;
  @JsonKey(name: 'BaselineItemName')
  final String? baselineItemName;
  @JsonKey(name: 'CategoryId')
  final String? categoryId;
  static const fromJsonFactory = _$RecommendationDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RecommendationDto &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.recommendationType, recommendationType) ||
                const DeepCollectionEquality()
                    .equals(other.recommendationType, recommendationType)) &&
            (identical(other.baselineItemName, baselineItemName) ||
                const DeepCollectionEquality()
                    .equals(other.baselineItemName, baselineItemName)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(recommendationType) ^
      const DeepCollectionEquality().hash(baselineItemName) ^
      const DeepCollectionEquality().hash(categoryId) ^
      runtimeType.hashCode;
}

extension $RecommendationDtoExtension on RecommendationDto {
  RecommendationDto copyWith(
      {List<BaseItemDto>? items,
      enums.RecommendationType? recommendationType,
      String? baselineItemName,
      String? categoryId}) {
    return RecommendationDto(
        items: items ?? this.items,
        recommendationType: recommendationType ?? this.recommendationType,
        baselineItemName: baselineItemName ?? this.baselineItemName,
        categoryId: categoryId ?? this.categoryId);
  }

  RecommendationDto copyWithWrapped(
      {Wrapped<List<BaseItemDto>?>? items,
      Wrapped<enums.RecommendationType?>? recommendationType,
      Wrapped<String?>? baselineItemName,
      Wrapped<String?>? categoryId}) {
    return RecommendationDto(
        items: (items != null ? items.value : this.items),
        recommendationType: (recommendationType != null
            ? recommendationType.value
            : this.recommendationType),
        baselineItemName: (baselineItemName != null
            ? baselineItemName.value
            : this.baselineItemName),
        categoryId: (categoryId != null ? categoryId.value : this.categoryId));
  }
}

@JsonSerializable(explicitToJson: true)
class RefreshProgressMessage {
  const RefreshProgressMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory RefreshProgressMessage.fromJson(Map<String, dynamic> json) =>
      _$RefreshProgressMessageFromJson(json);

  static const toJsonFactory = _$RefreshProgressMessageToJson;
  Map<String, dynamic> toJson() => _$RefreshProgressMessageToJson(this);

  @JsonKey(name: 'Data')
  final Map<String, dynamic>? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.refreshprogress);

  static const fromJsonFactory = _$RefreshProgressMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RefreshProgressMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $RefreshProgressMessageExtension on RefreshProgressMessage {
  RefreshProgressMessage copyWith(
      {Map<String, dynamic>? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return RefreshProgressMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  RefreshProgressMessage copyWithWrapped(
      {Wrapped<Map<String, dynamic>?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return RefreshProgressMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoteImageInfo {
  const RemoteImageInfo({
    this.providerName,
    this.url,
    this.thumbnailUrl,
    this.height,
    this.width,
    this.communityRating,
    this.voteCount,
    this.language,
    this.type,
    this.ratingType,
  });

  factory RemoteImageInfo.fromJson(Map<String, dynamic> json) =>
      _$RemoteImageInfoFromJson(json);

  static const toJsonFactory = _$RemoteImageInfoToJson;
  Map<String, dynamic> toJson() => _$RemoteImageInfoToJson(this);

  @JsonKey(name: 'ProviderName')
  final String? providerName;
  @JsonKey(name: 'Url')
  final String? url;
  @JsonKey(name: 'ThumbnailUrl')
  final String? thumbnailUrl;
  @JsonKey(name: 'Height')
  final int? height;
  @JsonKey(name: 'Width')
  final int? width;
  @JsonKey(name: 'CommunityRating')
  final double? communityRating;
  @JsonKey(name: 'VoteCount')
  final int? voteCount;
  @JsonKey(name: 'Language')
  final String? language;
  @JsonKey(
    name: 'Type',
    toJson: imageTypeNullableToJson,
    fromJson: imageTypeNullableFromJson,
  )
  final enums.ImageType? type;
  @JsonKey(
    name: 'RatingType',
    toJson: ratingTypeNullableToJson,
    fromJson: ratingTypeNullableFromJson,
  )
  final enums.RatingType? ratingType;
  static const fromJsonFactory = _$RemoteImageInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoteImageInfo &&
            (identical(other.providerName, providerName) ||
                const DeepCollectionEquality()
                    .equals(other.providerName, providerName)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                const DeepCollectionEquality()
                    .equals(other.thumbnailUrl, thumbnailUrl)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.communityRating, communityRating) ||
                const DeepCollectionEquality()
                    .equals(other.communityRating, communityRating)) &&
            (identical(other.voteCount, voteCount) ||
                const DeepCollectionEquality()
                    .equals(other.voteCount, voteCount)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.ratingType, ratingType) ||
                const DeepCollectionEquality()
                    .equals(other.ratingType, ratingType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(providerName) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(thumbnailUrl) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(communityRating) ^
      const DeepCollectionEquality().hash(voteCount) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(ratingType) ^
      runtimeType.hashCode;
}

extension $RemoteImageInfoExtension on RemoteImageInfo {
  RemoteImageInfo copyWith(
      {String? providerName,
      String? url,
      String? thumbnailUrl,
      int? height,
      int? width,
      double? communityRating,
      int? voteCount,
      String? language,
      enums.ImageType? type,
      enums.RatingType? ratingType}) {
    return RemoteImageInfo(
        providerName: providerName ?? this.providerName,
        url: url ?? this.url,
        thumbnailUrl: thumbnailUrl ?? this.thumbnailUrl,
        height: height ?? this.height,
        width: width ?? this.width,
        communityRating: communityRating ?? this.communityRating,
        voteCount: voteCount ?? this.voteCount,
        language: language ?? this.language,
        type: type ?? this.type,
        ratingType: ratingType ?? this.ratingType);
  }

  RemoteImageInfo copyWithWrapped(
      {Wrapped<String?>? providerName,
      Wrapped<String?>? url,
      Wrapped<String?>? thumbnailUrl,
      Wrapped<int?>? height,
      Wrapped<int?>? width,
      Wrapped<double?>? communityRating,
      Wrapped<int?>? voteCount,
      Wrapped<String?>? language,
      Wrapped<enums.ImageType?>? type,
      Wrapped<enums.RatingType?>? ratingType}) {
    return RemoteImageInfo(
        providerName:
            (providerName != null ? providerName.value : this.providerName),
        url: (url != null ? url.value : this.url),
        thumbnailUrl:
            (thumbnailUrl != null ? thumbnailUrl.value : this.thumbnailUrl),
        height: (height != null ? height.value : this.height),
        width: (width != null ? width.value : this.width),
        communityRating: (communityRating != null
            ? communityRating.value
            : this.communityRating),
        voteCount: (voteCount != null ? voteCount.value : this.voteCount),
        language: (language != null ? language.value : this.language),
        type: (type != null ? type.value : this.type),
        ratingType: (ratingType != null ? ratingType.value : this.ratingType));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoteImageResult {
  const RemoteImageResult({
    this.images,
    this.totalRecordCount,
    this.providers,
  });

  factory RemoteImageResult.fromJson(Map<String, dynamic> json) =>
      _$RemoteImageResultFromJson(json);

  static const toJsonFactory = _$RemoteImageResultToJson;
  Map<String, dynamic> toJson() => _$RemoteImageResultToJson(this);

  @JsonKey(name: 'Images', defaultValue: <RemoteImageInfo>[])
  final List<RemoteImageInfo>? images;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  @JsonKey(name: 'Providers', defaultValue: <String>[])
  final List<String>? providers;
  static const fromJsonFactory = _$RemoteImageResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoteImageResult &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)) &&
            (identical(other.providers, providers) ||
                const DeepCollectionEquality()
                    .equals(other.providers, providers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      const DeepCollectionEquality().hash(providers) ^
      runtimeType.hashCode;
}

extension $RemoteImageResultExtension on RemoteImageResult {
  RemoteImageResult copyWith(
      {List<RemoteImageInfo>? images,
      int? totalRecordCount,
      List<String>? providers}) {
    return RemoteImageResult(
        images: images ?? this.images,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount,
        providers: providers ?? this.providers);
  }

  RemoteImageResult copyWithWrapped(
      {Wrapped<List<RemoteImageInfo>?>? images,
      Wrapped<int?>? totalRecordCount,
      Wrapped<List<String>?>? providers}) {
    return RemoteImageResult(
        images: (images != null ? images.value : this.images),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount),
        providers: (providers != null ? providers.value : this.providers));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoteLyricInfoDto {
  const RemoteLyricInfoDto({
    this.id,
    this.providerName,
    this.lyrics,
  });

  factory RemoteLyricInfoDto.fromJson(Map<String, dynamic> json) =>
      _$RemoteLyricInfoDtoFromJson(json);

  static const toJsonFactory = _$RemoteLyricInfoDtoToJson;
  Map<String, dynamic> toJson() => _$RemoteLyricInfoDtoToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'ProviderName')
  final String? providerName;
  @JsonKey(name: 'Lyrics')
  final LyricDto? lyrics;
  static const fromJsonFactory = _$RemoteLyricInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoteLyricInfoDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.providerName, providerName) ||
                const DeepCollectionEquality()
                    .equals(other.providerName, providerName)) &&
            (identical(other.lyrics, lyrics) ||
                const DeepCollectionEquality().equals(other.lyrics, lyrics)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(providerName) ^
      const DeepCollectionEquality().hash(lyrics) ^
      runtimeType.hashCode;
}

extension $RemoteLyricInfoDtoExtension on RemoteLyricInfoDto {
  RemoteLyricInfoDto copyWith(
      {String? id, String? providerName, LyricDto? lyrics}) {
    return RemoteLyricInfoDto(
        id: id ?? this.id,
        providerName: providerName ?? this.providerName,
        lyrics: lyrics ?? this.lyrics);
  }

  RemoteLyricInfoDto copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? providerName,
      Wrapped<LyricDto?>? lyrics}) {
    return RemoteLyricInfoDto(
        id: (id != null ? id.value : this.id),
        providerName:
            (providerName != null ? providerName.value : this.providerName),
        lyrics: (lyrics != null ? lyrics.value : this.lyrics));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoteSearchResult {
  const RemoteSearchResult({
    this.name,
    this.providerIds,
    this.productionYear,
    this.indexNumber,
    this.indexNumberEnd,
    this.parentIndexNumber,
    this.premiereDate,
    this.imageUrl,
    this.searchProviderName,
    this.overview,
    this.albumArtist,
    this.artists,
  });

  factory RemoteSearchResult.fromJson(Map<String, dynamic> json) =>
      _$RemoteSearchResultFromJson(json);

  static const toJsonFactory = _$RemoteSearchResultToJson;
  Map<String, dynamic> toJson() => _$RemoteSearchResultToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'ProductionYear')
  final int? productionYear;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'IndexNumberEnd')
  final int? indexNumberEnd;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'ImageUrl')
  final String? imageUrl;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'Overview')
  final String? overview;
  @JsonKey(name: 'AlbumArtist')
  final RemoteSearchResult? albumArtist;
  @JsonKey(name: 'Artists', defaultValue: <RemoteSearchResult>[])
  final List<RemoteSearchResult>? artists;
  static const fromJsonFactory = _$RemoteSearchResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoteSearchResult &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.productionYear, productionYear) ||
                const DeepCollectionEquality()
                    .equals(other.productionYear, productionYear)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.indexNumberEnd, indexNumberEnd) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumberEnd, indexNumberEnd)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(other.overview, overview) ||
                const DeepCollectionEquality()
                    .equals(other.overview, overview)) &&
            (identical(other.albumArtist, albumArtist) ||
                const DeepCollectionEquality()
                    .equals(other.albumArtist, albumArtist)) &&
            (identical(other.artists, artists) ||
                const DeepCollectionEquality().equals(other.artists, artists)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(productionYear) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(indexNumberEnd) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(overview) ^
      const DeepCollectionEquality().hash(albumArtist) ^
      const DeepCollectionEquality().hash(artists) ^
      runtimeType.hashCode;
}

extension $RemoteSearchResultExtension on RemoteSearchResult {
  RemoteSearchResult copyWith(
      {String? name,
      Map<String, dynamic>? providerIds,
      int? productionYear,
      int? indexNumber,
      int? indexNumberEnd,
      int? parentIndexNumber,
      DateTime? premiereDate,
      String? imageUrl,
      String? searchProviderName,
      String? overview,
      RemoteSearchResult? albumArtist,
      List<RemoteSearchResult>? artists}) {
    return RemoteSearchResult(
        name: name ?? this.name,
        providerIds: providerIds ?? this.providerIds,
        productionYear: productionYear ?? this.productionYear,
        indexNumber: indexNumber ?? this.indexNumber,
        indexNumberEnd: indexNumberEnd ?? this.indexNumberEnd,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        imageUrl: imageUrl ?? this.imageUrl,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        overview: overview ?? this.overview,
        albumArtist: albumArtist ?? this.albumArtist,
        artists: artists ?? this.artists);
  }

  RemoteSearchResult copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? productionYear,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? indexNumberEnd,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<String?>? imageUrl,
      Wrapped<String?>? searchProviderName,
      Wrapped<String?>? overview,
      Wrapped<RemoteSearchResult?>? albumArtist,
      Wrapped<List<RemoteSearchResult>?>? artists}) {
    return RemoteSearchResult(
        name: (name != null ? name.value : this.name),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        productionYear: (productionYear != null
            ? productionYear.value
            : this.productionYear),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        indexNumberEnd: (indexNumberEnd != null
            ? indexNumberEnd.value
            : this.indexNumberEnd),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        overview: (overview != null ? overview.value : this.overview),
        albumArtist:
            (albumArtist != null ? albumArtist.value : this.albumArtist),
        artists: (artists != null ? artists.value : this.artists));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoteSubtitleInfo {
  const RemoteSubtitleInfo({
    this.threeLetterISOLanguageName,
    this.id,
    this.providerName,
    this.name,
    this.format,
    this.author,
    this.comment,
    this.dateCreated,
    this.communityRating,
    this.frameRate,
    this.downloadCount,
    this.isHashMatch,
    this.aiTranslated,
    this.machineTranslated,
    this.forced,
    this.hearingImpaired,
  });

  factory RemoteSubtitleInfo.fromJson(Map<String, dynamic> json) =>
      _$RemoteSubtitleInfoFromJson(json);

  static const toJsonFactory = _$RemoteSubtitleInfoToJson;
  Map<String, dynamic> toJson() => _$RemoteSubtitleInfoToJson(this);

  @JsonKey(name: 'ThreeLetterISOLanguageName')
  final String? threeLetterISOLanguageName;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'ProviderName')
  final String? providerName;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Format')
  final String? format;
  @JsonKey(name: 'Author')
  final String? author;
  @JsonKey(name: 'Comment')
  final String? comment;
  @JsonKey(name: 'DateCreated')
  final DateTime? dateCreated;
  @JsonKey(name: 'CommunityRating')
  final double? communityRating;
  @JsonKey(name: 'FrameRate')
  final double? frameRate;
  @JsonKey(name: 'DownloadCount')
  final int? downloadCount;
  @JsonKey(name: 'IsHashMatch')
  final bool? isHashMatch;
  @JsonKey(name: 'AiTranslated')
  final bool? aiTranslated;
  @JsonKey(name: 'MachineTranslated')
  final bool? machineTranslated;
  @JsonKey(name: 'Forced')
  final bool? forced;
  @JsonKey(name: 'HearingImpaired')
  final bool? hearingImpaired;
  static const fromJsonFactory = _$RemoteSubtitleInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoteSubtitleInfo &&
            (identical(other.threeLetterISOLanguageName,
                    threeLetterISOLanguageName) ||
                const DeepCollectionEquality().equals(
                    other.threeLetterISOLanguageName,
                    threeLetterISOLanguageName)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.providerName, providerName) ||
                const DeepCollectionEquality()
                    .equals(other.providerName, providerName)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.dateCreated, dateCreated) ||
                const DeepCollectionEquality()
                    .equals(other.dateCreated, dateCreated)) &&
            (identical(other.communityRating, communityRating) ||
                const DeepCollectionEquality()
                    .equals(other.communityRating, communityRating)) &&
            (identical(other.frameRate, frameRate) ||
                const DeepCollectionEquality()
                    .equals(other.frameRate, frameRate)) &&
            (identical(other.downloadCount, downloadCount) ||
                const DeepCollectionEquality()
                    .equals(other.downloadCount, downloadCount)) &&
            (identical(other.isHashMatch, isHashMatch) ||
                const DeepCollectionEquality()
                    .equals(other.isHashMatch, isHashMatch)) &&
            (identical(other.aiTranslated, aiTranslated) ||
                const DeepCollectionEquality()
                    .equals(other.aiTranslated, aiTranslated)) &&
            (identical(other.machineTranslated, machineTranslated) ||
                const DeepCollectionEquality()
                    .equals(other.machineTranslated, machineTranslated)) &&
            (identical(other.forced, forced) ||
                const DeepCollectionEquality().equals(other.forced, forced)) &&
            (identical(other.hearingImpaired, hearingImpaired) ||
                const DeepCollectionEquality()
                    .equals(other.hearingImpaired, hearingImpaired)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(threeLetterISOLanguageName) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(providerName) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(dateCreated) ^
      const DeepCollectionEquality().hash(communityRating) ^
      const DeepCollectionEquality().hash(frameRate) ^
      const DeepCollectionEquality().hash(downloadCount) ^
      const DeepCollectionEquality().hash(isHashMatch) ^
      const DeepCollectionEquality().hash(aiTranslated) ^
      const DeepCollectionEquality().hash(machineTranslated) ^
      const DeepCollectionEquality().hash(forced) ^
      const DeepCollectionEquality().hash(hearingImpaired) ^
      runtimeType.hashCode;
}

extension $RemoteSubtitleInfoExtension on RemoteSubtitleInfo {
  RemoteSubtitleInfo copyWith(
      {String? threeLetterISOLanguageName,
      String? id,
      String? providerName,
      String? name,
      String? format,
      String? author,
      String? comment,
      DateTime? dateCreated,
      double? communityRating,
      double? frameRate,
      int? downloadCount,
      bool? isHashMatch,
      bool? aiTranslated,
      bool? machineTranslated,
      bool? forced,
      bool? hearingImpaired}) {
    return RemoteSubtitleInfo(
        threeLetterISOLanguageName:
            threeLetterISOLanguageName ?? this.threeLetterISOLanguageName,
        id: id ?? this.id,
        providerName: providerName ?? this.providerName,
        name: name ?? this.name,
        format: format ?? this.format,
        author: author ?? this.author,
        comment: comment ?? this.comment,
        dateCreated: dateCreated ?? this.dateCreated,
        communityRating: communityRating ?? this.communityRating,
        frameRate: frameRate ?? this.frameRate,
        downloadCount: downloadCount ?? this.downloadCount,
        isHashMatch: isHashMatch ?? this.isHashMatch,
        aiTranslated: aiTranslated ?? this.aiTranslated,
        machineTranslated: machineTranslated ?? this.machineTranslated,
        forced: forced ?? this.forced,
        hearingImpaired: hearingImpaired ?? this.hearingImpaired);
  }

  RemoteSubtitleInfo copyWithWrapped(
      {Wrapped<String?>? threeLetterISOLanguageName,
      Wrapped<String?>? id,
      Wrapped<String?>? providerName,
      Wrapped<String?>? name,
      Wrapped<String?>? format,
      Wrapped<String?>? author,
      Wrapped<String?>? comment,
      Wrapped<DateTime?>? dateCreated,
      Wrapped<double?>? communityRating,
      Wrapped<double?>? frameRate,
      Wrapped<int?>? downloadCount,
      Wrapped<bool?>? isHashMatch,
      Wrapped<bool?>? aiTranslated,
      Wrapped<bool?>? machineTranslated,
      Wrapped<bool?>? forced,
      Wrapped<bool?>? hearingImpaired}) {
    return RemoteSubtitleInfo(
        threeLetterISOLanguageName: (threeLetterISOLanguageName != null
            ? threeLetterISOLanguageName.value
            : this.threeLetterISOLanguageName),
        id: (id != null ? id.value : this.id),
        providerName:
            (providerName != null ? providerName.value : this.providerName),
        name: (name != null ? name.value : this.name),
        format: (format != null ? format.value : this.format),
        author: (author != null ? author.value : this.author),
        comment: (comment != null ? comment.value : this.comment),
        dateCreated:
            (dateCreated != null ? dateCreated.value : this.dateCreated),
        communityRating: (communityRating != null
            ? communityRating.value
            : this.communityRating),
        frameRate: (frameRate != null ? frameRate.value : this.frameRate),
        downloadCount:
            (downloadCount != null ? downloadCount.value : this.downloadCount),
        isHashMatch:
            (isHashMatch != null ? isHashMatch.value : this.isHashMatch),
        aiTranslated:
            (aiTranslated != null ? aiTranslated.value : this.aiTranslated),
        machineTranslated: (machineTranslated != null
            ? machineTranslated.value
            : this.machineTranslated),
        forced: (forced != null ? forced.value : this.forced),
        hearingImpaired: (hearingImpaired != null
            ? hearingImpaired.value
            : this.hearingImpaired));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoveFromPlaylistRequestDto {
  const RemoveFromPlaylistRequestDto({
    this.playlistItemIds,
    this.clearPlaylist,
    this.clearPlayingItem,
  });

  factory RemoveFromPlaylistRequestDto.fromJson(Map<String, dynamic> json) =>
      _$RemoveFromPlaylistRequestDtoFromJson(json);

  static const toJsonFactory = _$RemoveFromPlaylistRequestDtoToJson;
  Map<String, dynamic> toJson() => _$RemoveFromPlaylistRequestDtoToJson(this);

  @JsonKey(name: 'PlaylistItemIds', defaultValue: <String>[])
  final List<String>? playlistItemIds;
  @JsonKey(name: 'ClearPlaylist')
  final bool? clearPlaylist;
  @JsonKey(name: 'ClearPlayingItem')
  final bool? clearPlayingItem;
  static const fromJsonFactory = _$RemoveFromPlaylistRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoveFromPlaylistRequestDto &&
            (identical(other.playlistItemIds, playlistItemIds) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemIds, playlistItemIds)) &&
            (identical(other.clearPlaylist, clearPlaylist) ||
                const DeepCollectionEquality()
                    .equals(other.clearPlaylist, clearPlaylist)) &&
            (identical(other.clearPlayingItem, clearPlayingItem) ||
                const DeepCollectionEquality()
                    .equals(other.clearPlayingItem, clearPlayingItem)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(playlistItemIds) ^
      const DeepCollectionEquality().hash(clearPlaylist) ^
      const DeepCollectionEquality().hash(clearPlayingItem) ^
      runtimeType.hashCode;
}

extension $RemoveFromPlaylistRequestDtoExtension
    on RemoveFromPlaylistRequestDto {
  RemoveFromPlaylistRequestDto copyWith(
      {List<String>? playlistItemIds,
      bool? clearPlaylist,
      bool? clearPlayingItem}) {
    return RemoveFromPlaylistRequestDto(
        playlistItemIds: playlistItemIds ?? this.playlistItemIds,
        clearPlaylist: clearPlaylist ?? this.clearPlaylist,
        clearPlayingItem: clearPlayingItem ?? this.clearPlayingItem);
  }

  RemoveFromPlaylistRequestDto copyWithWrapped(
      {Wrapped<List<String>?>? playlistItemIds,
      Wrapped<bool?>? clearPlaylist,
      Wrapped<bool?>? clearPlayingItem}) {
    return RemoveFromPlaylistRequestDto(
        playlistItemIds: (playlistItemIds != null
            ? playlistItemIds.value
            : this.playlistItemIds),
        clearPlaylist:
            (clearPlaylist != null ? clearPlaylist.value : this.clearPlaylist),
        clearPlayingItem: (clearPlayingItem != null
            ? clearPlayingItem.value
            : this.clearPlayingItem));
  }
}

@JsonSerializable(explicitToJson: true)
class RepositoryInfo {
  const RepositoryInfo({
    this.name,
    this.url,
    this.enabled,
  });

  factory RepositoryInfo.fromJson(Map<String, dynamic> json) =>
      _$RepositoryInfoFromJson(json);

  static const toJsonFactory = _$RepositoryInfoToJson;
  Map<String, dynamic> toJson() => _$RepositoryInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Url')
  final String? url;
  @JsonKey(name: 'Enabled')
  final bool? enabled;
  static const fromJsonFactory = _$RepositoryInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RepositoryInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality().equals(other.enabled, enabled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(enabled) ^
      runtimeType.hashCode;
}

extension $RepositoryInfoExtension on RepositoryInfo {
  RepositoryInfo copyWith({String? name, String? url, bool? enabled}) {
    return RepositoryInfo(
        name: name ?? this.name,
        url: url ?? this.url,
        enabled: enabled ?? this.enabled);
  }

  RepositoryInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? url,
      Wrapped<bool?>? enabled}) {
    return RepositoryInfo(
        name: (name != null ? name.value : this.name),
        url: (url != null ? url.value : this.url),
        enabled: (enabled != null ? enabled.value : this.enabled));
  }
}

@JsonSerializable(explicitToJson: true)
class RestartRequiredMessage {
  const RestartRequiredMessage({
    this.messageId,
    this.messageType,
  });

  factory RestartRequiredMessage.fromJson(Map<String, dynamic> json) =>
      _$RestartRequiredMessageFromJson(json);

  static const toJsonFactory = _$RestartRequiredMessageToJson;
  Map<String, dynamic> toJson() => _$RestartRequiredMessageToJson(this);

  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.restartrequired);

  static const fromJsonFactory = _$RestartRequiredMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RestartRequiredMessage &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $RestartRequiredMessageExtension on RestartRequiredMessage {
  RestartRequiredMessage copyWith(
      {String? messageId, enums.SessionMessageType? messageType}) {
    return RestartRequiredMessage(
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  RestartRequiredMessage copyWithWrapped(
      {Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return RestartRequiredMessage(
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class ScheduledTaskEndedMessage {
  const ScheduledTaskEndedMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory ScheduledTaskEndedMessage.fromJson(Map<String, dynamic> json) =>
      _$ScheduledTaskEndedMessageFromJson(json);

  static const toJsonFactory = _$ScheduledTaskEndedMessageToJson;
  Map<String, dynamic> toJson() => _$ScheduledTaskEndedMessageToJson(this);

  @JsonKey(name: 'Data')
  final TaskResult? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.scheduledtaskended);

  static const fromJsonFactory = _$ScheduledTaskEndedMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScheduledTaskEndedMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $ScheduledTaskEndedMessageExtension on ScheduledTaskEndedMessage {
  ScheduledTaskEndedMessage copyWith(
      {TaskResult? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return ScheduledTaskEndedMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  ScheduledTaskEndedMessage copyWithWrapped(
      {Wrapped<TaskResult?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return ScheduledTaskEndedMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class ScheduledTasksInfoMessage {
  const ScheduledTasksInfoMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory ScheduledTasksInfoMessage.fromJson(Map<String, dynamic> json) =>
      _$ScheduledTasksInfoMessageFromJson(json);

  static const toJsonFactory = _$ScheduledTasksInfoMessageToJson;
  Map<String, dynamic> toJson() => _$ScheduledTasksInfoMessageToJson(this);

  @JsonKey(name: 'Data', defaultValue: <TaskInfo>[])
  final List<TaskInfo>? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.scheduledtasksinfo);

  static const fromJsonFactory = _$ScheduledTasksInfoMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScheduledTasksInfoMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $ScheduledTasksInfoMessageExtension on ScheduledTasksInfoMessage {
  ScheduledTasksInfoMessage copyWith(
      {List<TaskInfo>? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return ScheduledTasksInfoMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  ScheduledTasksInfoMessage copyWithWrapped(
      {Wrapped<List<TaskInfo>?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return ScheduledTasksInfoMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class ScheduledTasksInfoStartMessage {
  const ScheduledTasksInfoStartMessage({
    this.data,
    this.messageType,
  });

  factory ScheduledTasksInfoStartMessage.fromJson(Map<String, dynamic> json) =>
      _$ScheduledTasksInfoStartMessageFromJson(json);

  static const toJsonFactory = _$ScheduledTasksInfoStartMessageToJson;
  Map<String, dynamic> toJson() => _$ScheduledTasksInfoStartMessageToJson(this);

  @JsonKey(name: 'Data')
  final String? data;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.scheduledtasksinfostart);

  static const fromJsonFactory = _$ScheduledTasksInfoStartMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScheduledTasksInfoStartMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $ScheduledTasksInfoStartMessageExtension
    on ScheduledTasksInfoStartMessage {
  ScheduledTasksInfoStartMessage copyWith(
      {String? data, enums.SessionMessageType? messageType}) {
    return ScheduledTasksInfoStartMessage(
        data: data ?? this.data, messageType: messageType ?? this.messageType);
  }

  ScheduledTasksInfoStartMessage copyWithWrapped(
      {Wrapped<String?>? data,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return ScheduledTasksInfoStartMessage(
        data: (data != null ? data.value : this.data),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class ScheduledTasksInfoStopMessage {
  const ScheduledTasksInfoStopMessage({
    this.messageType,
  });

  factory ScheduledTasksInfoStopMessage.fromJson(Map<String, dynamic> json) =>
      _$ScheduledTasksInfoStopMessageFromJson(json);

  static const toJsonFactory = _$ScheduledTasksInfoStopMessageToJson;
  Map<String, dynamic> toJson() => _$ScheduledTasksInfoStopMessageToJson(this);

  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.scheduledtasksinfostop);

  static const fromJsonFactory = _$ScheduledTasksInfoStopMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScheduledTasksInfoStopMessage &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(messageType) ^ runtimeType.hashCode;
}

extension $ScheduledTasksInfoStopMessageExtension
    on ScheduledTasksInfoStopMessage {
  ScheduledTasksInfoStopMessage copyWith(
      {enums.SessionMessageType? messageType}) {
    return ScheduledTasksInfoStopMessage(
        messageType: messageType ?? this.messageType);
  }

  ScheduledTasksInfoStopMessage copyWithWrapped(
      {Wrapped<enums.SessionMessageType?>? messageType}) {
    return ScheduledTasksInfoStopMessage(
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class SearchHint {
  const SearchHint({
    this.itemId,
    this.id,
    this.name,
    this.matchedTerm,
    this.indexNumber,
    this.productionYear,
    this.parentIndexNumber,
    this.primaryImageTag,
    this.thumbImageTag,
    this.thumbImageItemId,
    this.backdropImageTag,
    this.backdropImageItemId,
    this.type,
    this.isFolder,
    this.runTimeTicks,
    this.mediaType,
    this.startDate,
    this.endDate,
    this.series,
    this.status,
    this.album,
    this.albumId,
    this.albumArtist,
    this.artists,
    this.songCount,
    this.episodeCount,
    this.channelId,
    this.channelName,
    this.primaryImageAspectRatio,
  });

  factory SearchHint.fromJson(Map<String, dynamic> json) =>
      _$SearchHintFromJson(json);

  static const toJsonFactory = _$SearchHintToJson;
  Map<String, dynamic> toJson() => _$SearchHintToJson(this);

  @JsonKey(name: 'ItemId')
  @deprecated
  final String? itemId;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'MatchedTerm')
  final String? matchedTerm;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ProductionYear')
  final int? productionYear;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PrimaryImageTag')
  final String? primaryImageTag;
  @JsonKey(name: 'ThumbImageTag')
  final String? thumbImageTag;
  @JsonKey(name: 'ThumbImageItemId')
  final String? thumbImageItemId;
  @JsonKey(name: 'BackdropImageTag')
  final String? backdropImageTag;
  @JsonKey(name: 'BackdropImageItemId')
  final String? backdropImageItemId;
  @JsonKey(
    name: 'Type',
    toJson: baseItemKindNullableToJson,
    fromJson: baseItemKindNullableFromJson,
  )
  final enums.BaseItemKind? type;
  @JsonKey(name: 'IsFolder')
  final bool? isFolder;
  @JsonKey(name: 'RunTimeTicks')
  final int? runTimeTicks;
  @JsonKey(
    name: 'MediaType',
    toJson: mediaTypeNullableToJson,
    fromJson: mediaTypeNullableFromJson,
  )
  final enums.MediaType? mediaType;
  @JsonKey(name: 'StartDate')
  final DateTime? startDate;
  @JsonKey(name: 'EndDate')
  final DateTime? endDate;
  @JsonKey(name: 'Series')
  final String? series;
  @JsonKey(name: 'Status')
  final String? status;
  @JsonKey(name: 'Album')
  final String? album;
  @JsonKey(name: 'AlbumId')
  final String? albumId;
  @JsonKey(name: 'AlbumArtist')
  final String? albumArtist;
  @JsonKey(name: 'Artists', defaultValue: <String>[])
  final List<String>? artists;
  @JsonKey(name: 'SongCount')
  final int? songCount;
  @JsonKey(name: 'EpisodeCount')
  final int? episodeCount;
  @JsonKey(name: 'ChannelId')
  final String? channelId;
  @JsonKey(name: 'ChannelName')
  final String? channelName;
  @JsonKey(name: 'PrimaryImageAspectRatio')
  final double? primaryImageAspectRatio;
  static const fromJsonFactory = _$SearchHintFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchHint &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.matchedTerm, matchedTerm) ||
                const DeepCollectionEquality()
                    .equals(other.matchedTerm, matchedTerm)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.productionYear, productionYear) ||
                const DeepCollectionEquality()
                    .equals(other.productionYear, productionYear)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.primaryImageTag, primaryImageTag) ||
                const DeepCollectionEquality()
                    .equals(other.primaryImageTag, primaryImageTag)) &&
            (identical(other.thumbImageTag, thumbImageTag) ||
                const DeepCollectionEquality()
                    .equals(other.thumbImageTag, thumbImageTag)) &&
            (identical(other.thumbImageItemId, thumbImageItemId) ||
                const DeepCollectionEquality()
                    .equals(other.thumbImageItemId, thumbImageItemId)) &&
            (identical(other.backdropImageTag, backdropImageTag) ||
                const DeepCollectionEquality()
                    .equals(other.backdropImageTag, backdropImageTag)) &&
            (identical(other.backdropImageItemId, backdropImageItemId) ||
                const DeepCollectionEquality()
                    .equals(other.backdropImageItemId, backdropImageItemId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.isFolder, isFolder) ||
                const DeepCollectionEquality()
                    .equals(other.isFolder, isFolder)) &&
            (identical(other.runTimeTicks, runTimeTicks) ||
                const DeepCollectionEquality()
                    .equals(other.runTimeTicks, runTimeTicks)) &&
            (identical(other.mediaType, mediaType) ||
                const DeepCollectionEquality()
                    .equals(other.mediaType, mediaType)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.album, album) ||
                const DeepCollectionEquality().equals(other.album, album)) &&
            (identical(other.albumId, albumId) ||
                const DeepCollectionEquality()
                    .equals(other.albumId, albumId)) &&
            (identical(other.albumArtist, albumArtist) ||
                const DeepCollectionEquality()
                    .equals(other.albumArtist, albumArtist)) &&
            (identical(other.artists, artists) ||
                const DeepCollectionEquality()
                    .equals(other.artists, artists)) &&
            (identical(other.songCount, songCount) ||
                const DeepCollectionEquality()
                    .equals(other.songCount, songCount)) &&
            (identical(other.episodeCount, episodeCount) || const DeepCollectionEquality().equals(other.episodeCount, episodeCount)) &&
            (identical(other.channelId, channelId) || const DeepCollectionEquality().equals(other.channelId, channelId)) &&
            (identical(other.channelName, channelName) || const DeepCollectionEquality().equals(other.channelName, channelName)) &&
            (identical(other.primaryImageAspectRatio, primaryImageAspectRatio) || const DeepCollectionEquality().equals(other.primaryImageAspectRatio, primaryImageAspectRatio)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(matchedTerm) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(productionYear) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(primaryImageTag) ^
      const DeepCollectionEquality().hash(thumbImageTag) ^
      const DeepCollectionEquality().hash(thumbImageItemId) ^
      const DeepCollectionEquality().hash(backdropImageTag) ^
      const DeepCollectionEquality().hash(backdropImageItemId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(isFolder) ^
      const DeepCollectionEquality().hash(runTimeTicks) ^
      const DeepCollectionEquality().hash(mediaType) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(album) ^
      const DeepCollectionEquality().hash(albumId) ^
      const DeepCollectionEquality().hash(albumArtist) ^
      const DeepCollectionEquality().hash(artists) ^
      const DeepCollectionEquality().hash(songCount) ^
      const DeepCollectionEquality().hash(episodeCount) ^
      const DeepCollectionEquality().hash(channelId) ^
      const DeepCollectionEquality().hash(channelName) ^
      const DeepCollectionEquality().hash(primaryImageAspectRatio) ^
      runtimeType.hashCode;
}

extension $SearchHintExtension on SearchHint {
  SearchHint copyWith(
      {String? itemId,
      String? id,
      String? name,
      String? matchedTerm,
      int? indexNumber,
      int? productionYear,
      int? parentIndexNumber,
      String? primaryImageTag,
      String? thumbImageTag,
      String? thumbImageItemId,
      String? backdropImageTag,
      String? backdropImageItemId,
      enums.BaseItemKind? type,
      bool? isFolder,
      int? runTimeTicks,
      enums.MediaType? mediaType,
      DateTime? startDate,
      DateTime? endDate,
      String? series,
      String? status,
      String? album,
      String? albumId,
      String? albumArtist,
      List<String>? artists,
      int? songCount,
      int? episodeCount,
      String? channelId,
      String? channelName,
      double? primaryImageAspectRatio}) {
    return SearchHint(
        itemId: itemId ?? this.itemId,
        id: id ?? this.id,
        name: name ?? this.name,
        matchedTerm: matchedTerm ?? this.matchedTerm,
        indexNumber: indexNumber ?? this.indexNumber,
        productionYear: productionYear ?? this.productionYear,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        primaryImageTag: primaryImageTag ?? this.primaryImageTag,
        thumbImageTag: thumbImageTag ?? this.thumbImageTag,
        thumbImageItemId: thumbImageItemId ?? this.thumbImageItemId,
        backdropImageTag: backdropImageTag ?? this.backdropImageTag,
        backdropImageItemId: backdropImageItemId ?? this.backdropImageItemId,
        type: type ?? this.type,
        isFolder: isFolder ?? this.isFolder,
        runTimeTicks: runTimeTicks ?? this.runTimeTicks,
        mediaType: mediaType ?? this.mediaType,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        series: series ?? this.series,
        status: status ?? this.status,
        album: album ?? this.album,
        albumId: albumId ?? this.albumId,
        albumArtist: albumArtist ?? this.albumArtist,
        artists: artists ?? this.artists,
        songCount: songCount ?? this.songCount,
        episodeCount: episodeCount ?? this.episodeCount,
        channelId: channelId ?? this.channelId,
        channelName: channelName ?? this.channelName,
        primaryImageAspectRatio:
            primaryImageAspectRatio ?? this.primaryImageAspectRatio);
  }

  SearchHint copyWithWrapped(
      {Wrapped<String?>? itemId,
      Wrapped<String?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? matchedTerm,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? productionYear,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<String?>? primaryImageTag,
      Wrapped<String?>? thumbImageTag,
      Wrapped<String?>? thumbImageItemId,
      Wrapped<String?>? backdropImageTag,
      Wrapped<String?>? backdropImageItemId,
      Wrapped<enums.BaseItemKind?>? type,
      Wrapped<bool?>? isFolder,
      Wrapped<int?>? runTimeTicks,
      Wrapped<enums.MediaType?>? mediaType,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<String?>? series,
      Wrapped<String?>? status,
      Wrapped<String?>? album,
      Wrapped<String?>? albumId,
      Wrapped<String?>? albumArtist,
      Wrapped<List<String>?>? artists,
      Wrapped<int?>? songCount,
      Wrapped<int?>? episodeCount,
      Wrapped<String?>? channelId,
      Wrapped<String?>? channelName,
      Wrapped<double?>? primaryImageAspectRatio}) {
    return SearchHint(
        itemId: (itemId != null ? itemId.value : this.itemId),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        matchedTerm:
            (matchedTerm != null ? matchedTerm.value : this.matchedTerm),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        productionYear: (productionYear != null
            ? productionYear.value
            : this.productionYear),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        primaryImageTag: (primaryImageTag != null
            ? primaryImageTag.value
            : this.primaryImageTag),
        thumbImageTag:
            (thumbImageTag != null ? thumbImageTag.value : this.thumbImageTag),
        thumbImageItemId: (thumbImageItemId != null
            ? thumbImageItemId.value
            : this.thumbImageItemId),
        backdropImageTag: (backdropImageTag != null
            ? backdropImageTag.value
            : this.backdropImageTag),
        backdropImageItemId: (backdropImageItemId != null
            ? backdropImageItemId.value
            : this.backdropImageItemId),
        type: (type != null ? type.value : this.type),
        isFolder: (isFolder != null ? isFolder.value : this.isFolder),
        runTimeTicks:
            (runTimeTicks != null ? runTimeTicks.value : this.runTimeTicks),
        mediaType: (mediaType != null ? mediaType.value : this.mediaType),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        series: (series != null ? series.value : this.series),
        status: (status != null ? status.value : this.status),
        album: (album != null ? album.value : this.album),
        albumId: (albumId != null ? albumId.value : this.albumId),
        albumArtist:
            (albumArtist != null ? albumArtist.value : this.albumArtist),
        artists: (artists != null ? artists.value : this.artists),
        songCount: (songCount != null ? songCount.value : this.songCount),
        episodeCount:
            (episodeCount != null ? episodeCount.value : this.episodeCount),
        channelId: (channelId != null ? channelId.value : this.channelId),
        channelName:
            (channelName != null ? channelName.value : this.channelName),
        primaryImageAspectRatio: (primaryImageAspectRatio != null
            ? primaryImageAspectRatio.value
            : this.primaryImageAspectRatio));
  }
}

@JsonSerializable(explicitToJson: true)
class SearchHintResult {
  const SearchHintResult({
    this.searchHints,
    this.totalRecordCount,
  });

  factory SearchHintResult.fromJson(Map<String, dynamic> json) =>
      _$SearchHintResultFromJson(json);

  static const toJsonFactory = _$SearchHintResultToJson;
  Map<String, dynamic> toJson() => _$SearchHintResultToJson(this);

  @JsonKey(name: 'SearchHints', defaultValue: <SearchHint>[])
  final List<SearchHint>? searchHints;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  static const fromJsonFactory = _$SearchHintResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchHintResult &&
            (identical(other.searchHints, searchHints) ||
                const DeepCollectionEquality()
                    .equals(other.searchHints, searchHints)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchHints) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      runtimeType.hashCode;
}

extension $SearchHintResultExtension on SearchHintResult {
  SearchHintResult copyWith(
      {List<SearchHint>? searchHints, int? totalRecordCount}) {
    return SearchHintResult(
        searchHints: searchHints ?? this.searchHints,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount);
  }

  SearchHintResult copyWithWrapped(
      {Wrapped<List<SearchHint>?>? searchHints,
      Wrapped<int?>? totalRecordCount}) {
    return SearchHintResult(
        searchHints:
            (searchHints != null ? searchHints.value : this.searchHints),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount));
  }
}

@JsonSerializable(explicitToJson: true)
class SeekRequestDto {
  const SeekRequestDto({
    this.positionTicks,
  });

  factory SeekRequestDto.fromJson(Map<String, dynamic> json) =>
      _$SeekRequestDtoFromJson(json);

  static const toJsonFactory = _$SeekRequestDtoToJson;
  Map<String, dynamic> toJson() => _$SeekRequestDtoToJson(this);

  @JsonKey(name: 'PositionTicks')
  final int? positionTicks;
  static const fromJsonFactory = _$SeekRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeekRequestDto &&
            (identical(other.positionTicks, positionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.positionTicks, positionTicks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(positionTicks) ^ runtimeType.hashCode;
}

extension $SeekRequestDtoExtension on SeekRequestDto {
  SeekRequestDto copyWith({int? positionTicks}) {
    return SeekRequestDto(positionTicks: positionTicks ?? this.positionTicks);
  }

  SeekRequestDto copyWithWrapped({Wrapped<int?>? positionTicks}) {
    return SeekRequestDto(
        positionTicks:
            (positionTicks != null ? positionTicks.value : this.positionTicks));
  }
}

@JsonSerializable(explicitToJson: true)
class SendCommand {
  const SendCommand({
    this.groupId,
    this.playlistItemId,
    this.when,
    this.positionTicks,
    this.command,
    this.emittedAt,
  });

  factory SendCommand.fromJson(Map<String, dynamic> json) =>
      _$SendCommandFromJson(json);

  static const toJsonFactory = _$SendCommandToJson;
  Map<String, dynamic> toJson() => _$SendCommandToJson(this);

  @JsonKey(name: 'GroupId')
  final String? groupId;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  @JsonKey(name: 'When')
  final DateTime? when;
  @JsonKey(name: 'PositionTicks')
  final int? positionTicks;
  @JsonKey(
    name: 'Command',
    toJson: sendCommandTypeNullableToJson,
    fromJson: sendCommandTypeNullableFromJson,
  )
  final enums.SendCommandType? command;
  @JsonKey(name: 'EmittedAt')
  final DateTime? emittedAt;
  static const fromJsonFactory = _$SendCommandFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SendCommand &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)) &&
            (identical(other.when, when) ||
                const DeepCollectionEquality().equals(other.when, when)) &&
            (identical(other.positionTicks, positionTicks) ||
                const DeepCollectionEquality()
                    .equals(other.positionTicks, positionTicks)) &&
            (identical(other.command, command) ||
                const DeepCollectionEquality()
                    .equals(other.command, command)) &&
            (identical(other.emittedAt, emittedAt) ||
                const DeepCollectionEquality()
                    .equals(other.emittedAt, emittedAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      const DeepCollectionEquality().hash(when) ^
      const DeepCollectionEquality().hash(positionTicks) ^
      const DeepCollectionEquality().hash(command) ^
      const DeepCollectionEquality().hash(emittedAt) ^
      runtimeType.hashCode;
}

extension $SendCommandExtension on SendCommand {
  SendCommand copyWith(
      {String? groupId,
      String? playlistItemId,
      DateTime? when,
      int? positionTicks,
      enums.SendCommandType? command,
      DateTime? emittedAt}) {
    return SendCommand(
        groupId: groupId ?? this.groupId,
        playlistItemId: playlistItemId ?? this.playlistItemId,
        when: when ?? this.when,
        positionTicks: positionTicks ?? this.positionTicks,
        command: command ?? this.command,
        emittedAt: emittedAt ?? this.emittedAt);
  }

  SendCommand copyWithWrapped(
      {Wrapped<String?>? groupId,
      Wrapped<String?>? playlistItemId,
      Wrapped<DateTime?>? when,
      Wrapped<int?>? positionTicks,
      Wrapped<enums.SendCommandType?>? command,
      Wrapped<DateTime?>? emittedAt}) {
    return SendCommand(
        groupId: (groupId != null ? groupId.value : this.groupId),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId),
        when: (when != null ? when.value : this.when),
        positionTicks:
            (positionTicks != null ? positionTicks.value : this.positionTicks),
        command: (command != null ? command.value : this.command),
        emittedAt: (emittedAt != null ? emittedAt.value : this.emittedAt));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesInfo {
  const SeriesInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
  });

  factory SeriesInfo.fromJson(Map<String, dynamic> json) =>
      _$SeriesInfoFromJson(json);

  static const toJsonFactory = _$SeriesInfoToJson;
  Map<String, dynamic> toJson() => _$SeriesInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  static const fromJsonFactory = _$SeriesInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      runtimeType.hashCode;
}

extension $SeriesInfoExtension on SeriesInfo {
  SeriesInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated}) {
    return SeriesInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated);
  }

  SeriesInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated}) {
    return SeriesInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesInfoRemoteSearchQuery {
  const SeriesInfoRemoteSearchQuery({
    this.searchInfo,
    this.itemId,
    this.searchProviderName,
    this.includeDisabledProviders,
  });

  factory SeriesInfoRemoteSearchQuery.fromJson(Map<String, dynamic> json) =>
      _$SeriesInfoRemoteSearchQueryFromJson(json);

  static const toJsonFactory = _$SeriesInfoRemoteSearchQueryToJson;
  Map<String, dynamic> toJson() => _$SeriesInfoRemoteSearchQueryToJson(this);

  @JsonKey(name: 'SearchInfo')
  final SeriesInfo? searchInfo;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'IncludeDisabledProviders')
  final bool? includeDisabledProviders;
  static const fromJsonFactory = _$SeriesInfoRemoteSearchQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesInfoRemoteSearchQuery &&
            (identical(other.searchInfo, searchInfo) ||
                const DeepCollectionEquality()
                    .equals(other.searchInfo, searchInfo)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(
                    other.includeDisabledProviders, includeDisabledProviders) ||
                const DeepCollectionEquality().equals(
                    other.includeDisabledProviders, includeDisabledProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchInfo) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(includeDisabledProviders) ^
      runtimeType.hashCode;
}

extension $SeriesInfoRemoteSearchQueryExtension on SeriesInfoRemoteSearchQuery {
  SeriesInfoRemoteSearchQuery copyWith(
      {SeriesInfo? searchInfo,
      String? itemId,
      String? searchProviderName,
      bool? includeDisabledProviders}) {
    return SeriesInfoRemoteSearchQuery(
        searchInfo: searchInfo ?? this.searchInfo,
        itemId: itemId ?? this.itemId,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        includeDisabledProviders:
            includeDisabledProviders ?? this.includeDisabledProviders);
  }

  SeriesInfoRemoteSearchQuery copyWithWrapped(
      {Wrapped<SeriesInfo?>? searchInfo,
      Wrapped<String?>? itemId,
      Wrapped<String?>? searchProviderName,
      Wrapped<bool?>? includeDisabledProviders}) {
    return SeriesInfoRemoteSearchQuery(
        searchInfo: (searchInfo != null ? searchInfo.value : this.searchInfo),
        itemId: (itemId != null ? itemId.value : this.itemId),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        includeDisabledProviders: (includeDisabledProviders != null
            ? includeDisabledProviders.value
            : this.includeDisabledProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesTimerCancelledMessage {
  const SeriesTimerCancelledMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory SeriesTimerCancelledMessage.fromJson(Map<String, dynamic> json) =>
      _$SeriesTimerCancelledMessageFromJson(json);

  static const toJsonFactory = _$SeriesTimerCancelledMessageToJson;
  Map<String, dynamic> toJson() => _$SeriesTimerCancelledMessageToJson(this);

  @JsonKey(name: 'Data')
  final TimerEventInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.seriestimercancelled);

  static const fromJsonFactory = _$SeriesTimerCancelledMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesTimerCancelledMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $SeriesTimerCancelledMessageExtension on SeriesTimerCancelledMessage {
  SeriesTimerCancelledMessage copyWith(
      {TimerEventInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return SeriesTimerCancelledMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  SeriesTimerCancelledMessage copyWithWrapped(
      {Wrapped<TimerEventInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return SeriesTimerCancelledMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesTimerCreatedMessage {
  const SeriesTimerCreatedMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory SeriesTimerCreatedMessage.fromJson(Map<String, dynamic> json) =>
      _$SeriesTimerCreatedMessageFromJson(json);

  static const toJsonFactory = _$SeriesTimerCreatedMessageToJson;
  Map<String, dynamic> toJson() => _$SeriesTimerCreatedMessageToJson(this);

  @JsonKey(name: 'Data')
  final TimerEventInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.seriestimercreated);

  static const fromJsonFactory = _$SeriesTimerCreatedMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesTimerCreatedMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $SeriesTimerCreatedMessageExtension on SeriesTimerCreatedMessage {
  SeriesTimerCreatedMessage copyWith(
      {TimerEventInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return SeriesTimerCreatedMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  SeriesTimerCreatedMessage copyWithWrapped(
      {Wrapped<TimerEventInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return SeriesTimerCreatedMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesTimerInfoDto {
  const SeriesTimerInfoDto({
    this.id,
    this.type,
    this.serverId,
    this.externalId,
    this.channelId,
    this.externalChannelId,
    this.channelName,
    this.channelPrimaryImageTag,
    this.programId,
    this.externalProgramId,
    this.name,
    this.overview,
    this.startDate,
    this.endDate,
    this.serviceName,
    this.priority,
    this.prePaddingSeconds,
    this.postPaddingSeconds,
    this.isPrePaddingRequired,
    this.parentBackdropItemId,
    this.parentBackdropImageTags,
    this.isPostPaddingRequired,
    this.keepUntil,
    this.recordAnyTime,
    this.skipEpisodesInLibrary,
    this.recordAnyChannel,
    this.keepUpTo,
    this.recordNewOnly,
    this.days,
    this.dayPattern,
    this.imageTags,
    this.parentThumbItemId,
    this.parentThumbImageTag,
    this.parentPrimaryImageItemId,
    this.parentPrimaryImageTag,
  });

  factory SeriesTimerInfoDto.fromJson(Map<String, dynamic> json) =>
      _$SeriesTimerInfoDtoFromJson(json);

  static const toJsonFactory = _$SeriesTimerInfoDtoToJson;
  Map<String, dynamic> toJson() => _$SeriesTimerInfoDtoToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Type')
  final String? type;
  @JsonKey(name: 'ServerId')
  final String? serverId;
  @JsonKey(name: 'ExternalId')
  final String? externalId;
  @JsonKey(name: 'ChannelId')
  final String? channelId;
  @JsonKey(name: 'ExternalChannelId')
  final String? externalChannelId;
  @JsonKey(name: 'ChannelName')
  final String? channelName;
  @JsonKey(name: 'ChannelPrimaryImageTag')
  final String? channelPrimaryImageTag;
  @JsonKey(name: 'ProgramId')
  final String? programId;
  @JsonKey(name: 'ExternalProgramId')
  final String? externalProgramId;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Overview')
  final String? overview;
  @JsonKey(name: 'StartDate')
  final DateTime? startDate;
  @JsonKey(name: 'EndDate')
  final DateTime? endDate;
  @JsonKey(name: 'ServiceName')
  final String? serviceName;
  @JsonKey(name: 'Priority')
  final int? priority;
  @JsonKey(name: 'PrePaddingSeconds')
  final int? prePaddingSeconds;
  @JsonKey(name: 'PostPaddingSeconds')
  final int? postPaddingSeconds;
  @JsonKey(name: 'IsPrePaddingRequired')
  final bool? isPrePaddingRequired;
  @JsonKey(name: 'ParentBackdropItemId')
  final String? parentBackdropItemId;
  @JsonKey(name: 'ParentBackdropImageTags', defaultValue: <String>[])
  final List<String>? parentBackdropImageTags;
  @JsonKey(name: 'IsPostPaddingRequired')
  final bool? isPostPaddingRequired;
  @JsonKey(
    name: 'KeepUntil',
    toJson: keepUntilNullableToJson,
    fromJson: keepUntilNullableFromJson,
  )
  final enums.KeepUntil? keepUntil;
  @JsonKey(name: 'RecordAnyTime')
  final bool? recordAnyTime;
  @JsonKey(name: 'SkipEpisodesInLibrary')
  final bool? skipEpisodesInLibrary;
  @JsonKey(name: 'RecordAnyChannel')
  final bool? recordAnyChannel;
  @JsonKey(name: 'KeepUpTo')
  final int? keepUpTo;
  @JsonKey(name: 'RecordNewOnly')
  final bool? recordNewOnly;
  @JsonKey(
    name: 'Days',
    toJson: dayOfWeekListToJson,
    fromJson: dayOfWeekListFromJson,
  )
  final List<enums.DayOfWeek>? days;
  @JsonKey(
    name: 'DayPattern',
    toJson: dayPatternNullableToJson,
    fromJson: dayPatternNullableFromJson,
  )
  final enums.DayPattern? dayPattern;
  @JsonKey(name: 'ImageTags')
  final Map<String, dynamic>? imageTags;
  @JsonKey(name: 'ParentThumbItemId')
  final String? parentThumbItemId;
  @JsonKey(name: 'ParentThumbImageTag')
  final String? parentThumbImageTag;
  @JsonKey(name: 'ParentPrimaryImageItemId')
  final String? parentPrimaryImageItemId;
  @JsonKey(name: 'ParentPrimaryImageTag')
  final String? parentPrimaryImageTag;
  static const fromJsonFactory = _$SeriesTimerInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesTimerInfoDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.serverId, serverId) ||
                const DeepCollectionEquality()
                    .equals(other.serverId, serverId)) &&
            (identical(other.externalId, externalId) ||
                const DeepCollectionEquality()
                    .equals(other.externalId, externalId)) &&
            (identical(other.channelId, channelId) ||
                const DeepCollectionEquality()
                    .equals(other.channelId, channelId)) &&
            (identical(other.externalChannelId, externalChannelId) ||
                const DeepCollectionEquality()
                    .equals(other.externalChannelId, externalChannelId)) &&
            (identical(other.channelName, channelName) ||
                const DeepCollectionEquality()
                    .equals(other.channelName, channelName)) &&
            (identical(other.channelPrimaryImageTag, channelPrimaryImageTag) ||
                const DeepCollectionEquality().equals(
                    other.channelPrimaryImageTag, channelPrimaryImageTag)) &&
            (identical(other.programId, programId) ||
                const DeepCollectionEquality()
                    .equals(other.programId, programId)) &&
            (identical(other.externalProgramId, externalProgramId) ||
                const DeepCollectionEquality()
                    .equals(other.externalProgramId, externalProgramId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.overview, overview) ||
                const DeepCollectionEquality()
                    .equals(other.overview, overview)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.serviceName, serviceName) ||
                const DeepCollectionEquality()
                    .equals(other.serviceName, serviceName)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.prePaddingSeconds, prePaddingSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.prePaddingSeconds, prePaddingSeconds)) &&
            (identical(other.postPaddingSeconds, postPaddingSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.postPaddingSeconds, postPaddingSeconds)) &&
            (identical(other.isPrePaddingRequired, isPrePaddingRequired) ||
                const DeepCollectionEquality().equals(
                    other.isPrePaddingRequired, isPrePaddingRequired)) &&
            (identical(other.parentBackdropItemId, parentBackdropItemId) ||
                const DeepCollectionEquality().equals(
                    other.parentBackdropItemId, parentBackdropItemId)) &&
            (identical(other.parentBackdropImageTags, parentBackdropImageTags) ||
                const DeepCollectionEquality().equals(
                    other.parentBackdropImageTags, parentBackdropImageTags)) &&
            (identical(other.isPostPaddingRequired, isPostPaddingRequired) ||
                const DeepCollectionEquality().equals(
                    other.isPostPaddingRequired, isPostPaddingRequired)) &&
            (identical(other.keepUntil, keepUntil) || const DeepCollectionEquality().equals(other.keepUntil, keepUntil)) &&
            (identical(other.recordAnyTime, recordAnyTime) || const DeepCollectionEquality().equals(other.recordAnyTime, recordAnyTime)) &&
            (identical(other.skipEpisodesInLibrary, skipEpisodesInLibrary) || const DeepCollectionEquality().equals(other.skipEpisodesInLibrary, skipEpisodesInLibrary)) &&
            (identical(other.recordAnyChannel, recordAnyChannel) || const DeepCollectionEquality().equals(other.recordAnyChannel, recordAnyChannel)) &&
            (identical(other.keepUpTo, keepUpTo) || const DeepCollectionEquality().equals(other.keepUpTo, keepUpTo)) &&
            (identical(other.recordNewOnly, recordNewOnly) || const DeepCollectionEquality().equals(other.recordNewOnly, recordNewOnly)) &&
            (identical(other.days, days) || const DeepCollectionEquality().equals(other.days, days)) &&
            (identical(other.dayPattern, dayPattern) || const DeepCollectionEquality().equals(other.dayPattern, dayPattern)) &&
            (identical(other.imageTags, imageTags) || const DeepCollectionEquality().equals(other.imageTags, imageTags)) &&
            (identical(other.parentThumbItemId, parentThumbItemId) || const DeepCollectionEquality().equals(other.parentThumbItemId, parentThumbItemId)) &&
            (identical(other.parentThumbImageTag, parentThumbImageTag) || const DeepCollectionEquality().equals(other.parentThumbImageTag, parentThumbImageTag)) &&
            (identical(other.parentPrimaryImageItemId, parentPrimaryImageItemId) || const DeepCollectionEquality().equals(other.parentPrimaryImageItemId, parentPrimaryImageItemId)) &&
            (identical(other.parentPrimaryImageTag, parentPrimaryImageTag) || const DeepCollectionEquality().equals(other.parentPrimaryImageTag, parentPrimaryImageTag)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(serverId) ^
      const DeepCollectionEquality().hash(externalId) ^
      const DeepCollectionEquality().hash(channelId) ^
      const DeepCollectionEquality().hash(externalChannelId) ^
      const DeepCollectionEquality().hash(channelName) ^
      const DeepCollectionEquality().hash(channelPrimaryImageTag) ^
      const DeepCollectionEquality().hash(programId) ^
      const DeepCollectionEquality().hash(externalProgramId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(overview) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(serviceName) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(prePaddingSeconds) ^
      const DeepCollectionEquality().hash(postPaddingSeconds) ^
      const DeepCollectionEquality().hash(isPrePaddingRequired) ^
      const DeepCollectionEquality().hash(parentBackdropItemId) ^
      const DeepCollectionEquality().hash(parentBackdropImageTags) ^
      const DeepCollectionEquality().hash(isPostPaddingRequired) ^
      const DeepCollectionEquality().hash(keepUntil) ^
      const DeepCollectionEquality().hash(recordAnyTime) ^
      const DeepCollectionEquality().hash(skipEpisodesInLibrary) ^
      const DeepCollectionEquality().hash(recordAnyChannel) ^
      const DeepCollectionEquality().hash(keepUpTo) ^
      const DeepCollectionEquality().hash(recordNewOnly) ^
      const DeepCollectionEquality().hash(days) ^
      const DeepCollectionEquality().hash(dayPattern) ^
      const DeepCollectionEquality().hash(imageTags) ^
      const DeepCollectionEquality().hash(parentThumbItemId) ^
      const DeepCollectionEquality().hash(parentThumbImageTag) ^
      const DeepCollectionEquality().hash(parentPrimaryImageItemId) ^
      const DeepCollectionEquality().hash(parentPrimaryImageTag) ^
      runtimeType.hashCode;
}

extension $SeriesTimerInfoDtoExtension on SeriesTimerInfoDto {
  SeriesTimerInfoDto copyWith(
      {String? id,
      String? type,
      String? serverId,
      String? externalId,
      String? channelId,
      String? externalChannelId,
      String? channelName,
      String? channelPrimaryImageTag,
      String? programId,
      String? externalProgramId,
      String? name,
      String? overview,
      DateTime? startDate,
      DateTime? endDate,
      String? serviceName,
      int? priority,
      int? prePaddingSeconds,
      int? postPaddingSeconds,
      bool? isPrePaddingRequired,
      String? parentBackdropItemId,
      List<String>? parentBackdropImageTags,
      bool? isPostPaddingRequired,
      enums.KeepUntil? keepUntil,
      bool? recordAnyTime,
      bool? skipEpisodesInLibrary,
      bool? recordAnyChannel,
      int? keepUpTo,
      bool? recordNewOnly,
      List<enums.DayOfWeek>? days,
      enums.DayPattern? dayPattern,
      Map<String, dynamic>? imageTags,
      String? parentThumbItemId,
      String? parentThumbImageTag,
      String? parentPrimaryImageItemId,
      String? parentPrimaryImageTag}) {
    return SeriesTimerInfoDto(
        id: id ?? this.id,
        type: type ?? this.type,
        serverId: serverId ?? this.serverId,
        externalId: externalId ?? this.externalId,
        channelId: channelId ?? this.channelId,
        externalChannelId: externalChannelId ?? this.externalChannelId,
        channelName: channelName ?? this.channelName,
        channelPrimaryImageTag:
            channelPrimaryImageTag ?? this.channelPrimaryImageTag,
        programId: programId ?? this.programId,
        externalProgramId: externalProgramId ?? this.externalProgramId,
        name: name ?? this.name,
        overview: overview ?? this.overview,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        serviceName: serviceName ?? this.serviceName,
        priority: priority ?? this.priority,
        prePaddingSeconds: prePaddingSeconds ?? this.prePaddingSeconds,
        postPaddingSeconds: postPaddingSeconds ?? this.postPaddingSeconds,
        isPrePaddingRequired: isPrePaddingRequired ?? this.isPrePaddingRequired,
        parentBackdropItemId: parentBackdropItemId ?? this.parentBackdropItemId,
        parentBackdropImageTags:
            parentBackdropImageTags ?? this.parentBackdropImageTags,
        isPostPaddingRequired:
            isPostPaddingRequired ?? this.isPostPaddingRequired,
        keepUntil: keepUntil ?? this.keepUntil,
        recordAnyTime: recordAnyTime ?? this.recordAnyTime,
        skipEpisodesInLibrary:
            skipEpisodesInLibrary ?? this.skipEpisodesInLibrary,
        recordAnyChannel: recordAnyChannel ?? this.recordAnyChannel,
        keepUpTo: keepUpTo ?? this.keepUpTo,
        recordNewOnly: recordNewOnly ?? this.recordNewOnly,
        days: days ?? this.days,
        dayPattern: dayPattern ?? this.dayPattern,
        imageTags: imageTags ?? this.imageTags,
        parentThumbItemId: parentThumbItemId ?? this.parentThumbItemId,
        parentThumbImageTag: parentThumbImageTag ?? this.parentThumbImageTag,
        parentPrimaryImageItemId:
            parentPrimaryImageItemId ?? this.parentPrimaryImageItemId,
        parentPrimaryImageTag:
            parentPrimaryImageTag ?? this.parentPrimaryImageTag);
  }

  SeriesTimerInfoDto copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? type,
      Wrapped<String?>? serverId,
      Wrapped<String?>? externalId,
      Wrapped<String?>? channelId,
      Wrapped<String?>? externalChannelId,
      Wrapped<String?>? channelName,
      Wrapped<String?>? channelPrimaryImageTag,
      Wrapped<String?>? programId,
      Wrapped<String?>? externalProgramId,
      Wrapped<String?>? name,
      Wrapped<String?>? overview,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<String?>? serviceName,
      Wrapped<int?>? priority,
      Wrapped<int?>? prePaddingSeconds,
      Wrapped<int?>? postPaddingSeconds,
      Wrapped<bool?>? isPrePaddingRequired,
      Wrapped<String?>? parentBackdropItemId,
      Wrapped<List<String>?>? parentBackdropImageTags,
      Wrapped<bool?>? isPostPaddingRequired,
      Wrapped<enums.KeepUntil?>? keepUntil,
      Wrapped<bool?>? recordAnyTime,
      Wrapped<bool?>? skipEpisodesInLibrary,
      Wrapped<bool?>? recordAnyChannel,
      Wrapped<int?>? keepUpTo,
      Wrapped<bool?>? recordNewOnly,
      Wrapped<List<enums.DayOfWeek>?>? days,
      Wrapped<enums.DayPattern?>? dayPattern,
      Wrapped<Map<String, dynamic>?>? imageTags,
      Wrapped<String?>? parentThumbItemId,
      Wrapped<String?>? parentThumbImageTag,
      Wrapped<String?>? parentPrimaryImageItemId,
      Wrapped<String?>? parentPrimaryImageTag}) {
    return SeriesTimerInfoDto(
        id: (id != null ? id.value : this.id),
        type: (type != null ? type.value : this.type),
        serverId: (serverId != null ? serverId.value : this.serverId),
        externalId: (externalId != null ? externalId.value : this.externalId),
        channelId: (channelId != null ? channelId.value : this.channelId),
        externalChannelId: (externalChannelId != null
            ? externalChannelId.value
            : this.externalChannelId),
        channelName:
            (channelName != null ? channelName.value : this.channelName),
        channelPrimaryImageTag: (channelPrimaryImageTag != null
            ? channelPrimaryImageTag.value
            : this.channelPrimaryImageTag),
        programId: (programId != null ? programId.value : this.programId),
        externalProgramId: (externalProgramId != null
            ? externalProgramId.value
            : this.externalProgramId),
        name: (name != null ? name.value : this.name),
        overview: (overview != null ? overview.value : this.overview),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        serviceName:
            (serviceName != null ? serviceName.value : this.serviceName),
        priority: (priority != null ? priority.value : this.priority),
        prePaddingSeconds: (prePaddingSeconds != null
            ? prePaddingSeconds.value
            : this.prePaddingSeconds),
        postPaddingSeconds: (postPaddingSeconds != null
            ? postPaddingSeconds.value
            : this.postPaddingSeconds),
        isPrePaddingRequired: (isPrePaddingRequired != null
            ? isPrePaddingRequired.value
            : this.isPrePaddingRequired),
        parentBackdropItemId: (parentBackdropItemId != null
            ? parentBackdropItemId.value
            : this.parentBackdropItemId),
        parentBackdropImageTags: (parentBackdropImageTags != null
            ? parentBackdropImageTags.value
            : this.parentBackdropImageTags),
        isPostPaddingRequired: (isPostPaddingRequired != null
            ? isPostPaddingRequired.value
            : this.isPostPaddingRequired),
        keepUntil: (keepUntil != null ? keepUntil.value : this.keepUntil),
        recordAnyTime:
            (recordAnyTime != null ? recordAnyTime.value : this.recordAnyTime),
        skipEpisodesInLibrary: (skipEpisodesInLibrary != null
            ? skipEpisodesInLibrary.value
            : this.skipEpisodesInLibrary),
        recordAnyChannel: (recordAnyChannel != null
            ? recordAnyChannel.value
            : this.recordAnyChannel),
        keepUpTo: (keepUpTo != null ? keepUpTo.value : this.keepUpTo),
        recordNewOnly:
            (recordNewOnly != null ? recordNewOnly.value : this.recordNewOnly),
        days: (days != null ? days.value : this.days),
        dayPattern: (dayPattern != null ? dayPattern.value : this.dayPattern),
        imageTags: (imageTags != null ? imageTags.value : this.imageTags),
        parentThumbItemId: (parentThumbItemId != null
            ? parentThumbItemId.value
            : this.parentThumbItemId),
        parentThumbImageTag: (parentThumbImageTag != null
            ? parentThumbImageTag.value
            : this.parentThumbImageTag),
        parentPrimaryImageItemId: (parentPrimaryImageItemId != null
            ? parentPrimaryImageItemId.value
            : this.parentPrimaryImageItemId),
        parentPrimaryImageTag: (parentPrimaryImageTag != null
            ? parentPrimaryImageTag.value
            : this.parentPrimaryImageTag));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesTimerInfoDtoQueryResult {
  const SeriesTimerInfoDtoQueryResult({
    this.items,
    this.totalRecordCount,
    this.startIndex,
  });

  factory SeriesTimerInfoDtoQueryResult.fromJson(Map<String, dynamic> json) =>
      _$SeriesTimerInfoDtoQueryResultFromJson(json);

  static const toJsonFactory = _$SeriesTimerInfoDtoQueryResultToJson;
  Map<String, dynamic> toJson() => _$SeriesTimerInfoDtoQueryResultToJson(this);

  @JsonKey(name: 'Items', defaultValue: <SeriesTimerInfoDto>[])
  final List<SeriesTimerInfoDto>? items;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  static const fromJsonFactory = _$SeriesTimerInfoDtoQueryResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesTimerInfoDtoQueryResult &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      const DeepCollectionEquality().hash(startIndex) ^
      runtimeType.hashCode;
}

extension $SeriesTimerInfoDtoQueryResultExtension
    on SeriesTimerInfoDtoQueryResult {
  SeriesTimerInfoDtoQueryResult copyWith(
      {List<SeriesTimerInfoDto>? items,
      int? totalRecordCount,
      int? startIndex}) {
    return SeriesTimerInfoDtoQueryResult(
        items: items ?? this.items,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount,
        startIndex: startIndex ?? this.startIndex);
  }

  SeriesTimerInfoDtoQueryResult copyWithWrapped(
      {Wrapped<List<SeriesTimerInfoDto>?>? items,
      Wrapped<int?>? totalRecordCount,
      Wrapped<int?>? startIndex}) {
    return SeriesTimerInfoDtoQueryResult(
        items: (items != null ? items.value : this.items),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex));
  }
}

@JsonSerializable(explicitToJson: true)
class ServerConfiguration {
  const ServerConfiguration({
    this.logFileRetentionDays,
    this.isStartupWizardCompleted,
    this.cachePath,
    this.previousVersion,
    this.previousVersionStr,
    this.enableMetrics,
    this.enableNormalizedItemByNameIds,
    this.isPortAuthorized,
    this.quickConnectAvailable,
    this.enableCaseSensitiveItemIds,
    this.disableLiveTvChannelUserDataName,
    this.metadataPath,
    this.preferredMetadataLanguage,
    this.metadataCountryCode,
    this.sortReplaceCharacters,
    this.sortRemoveCharacters,
    this.sortRemoveWords,
    this.minResumePct,
    this.maxResumePct,
    this.minResumeDurationSeconds,
    this.minAudiobookResume,
    this.maxAudiobookResume,
    this.inactiveSessionThreshold,
    this.libraryMonitorDelay,
    this.libraryUpdateDuration,
    this.imageSavingConvention,
    this.metadataOptions,
    this.skipDeserializationForBasicTypes,
    this.serverName,
    this.uICulture,
    this.saveMetadataHidden,
    this.contentTypes,
    this.remoteClientBitrateLimit,
    this.enableFolderView,
    this.enableGroupingIntoCollections,
    this.displaySpecialsWithinSeasons,
    this.codecsUsed,
    this.pluginRepositories,
    this.enableExternalContentInSuggestions,
    this.imageExtractionTimeoutMs,
    this.pathSubstitutions,
    this.enableSlowResponseWarning,
    this.slowResponseThresholdMs,
    this.corsHosts,
    this.activityLogRetentionDays,
    this.libraryScanFanoutConcurrency,
    this.libraryMetadataRefreshConcurrency,
    this.removeOldPlugins,
    this.allowClientLogUpload,
    this.dummyChapterDuration,
    this.chapterImageResolution,
    this.parallelImageEncodingLimit,
    this.castReceiverApplications,
    this.trickplayOptions,
  });

  factory ServerConfiguration.fromJson(Map<String, dynamic> json) =>
      _$ServerConfigurationFromJson(json);

  static const toJsonFactory = _$ServerConfigurationToJson;
  Map<String, dynamic> toJson() => _$ServerConfigurationToJson(this);

  @JsonKey(name: 'LogFileRetentionDays')
  final int? logFileRetentionDays;
  @JsonKey(name: 'IsStartupWizardCompleted')
  final bool? isStartupWizardCompleted;
  @JsonKey(name: 'CachePath')
  final String? cachePath;
  @JsonKey(name: 'PreviousVersion')
  final String? previousVersion;
  @JsonKey(name: 'PreviousVersionStr')
  final String? previousVersionStr;
  @JsonKey(name: 'EnableMetrics')
  final bool? enableMetrics;
  @JsonKey(name: 'EnableNormalizedItemByNameIds')
  final bool? enableNormalizedItemByNameIds;
  @JsonKey(name: 'IsPortAuthorized')
  final bool? isPortAuthorized;
  @JsonKey(name: 'QuickConnectAvailable')
  final bool? quickConnectAvailable;
  @JsonKey(name: 'EnableCaseSensitiveItemIds')
  final bool? enableCaseSensitiveItemIds;
  @JsonKey(name: 'DisableLiveTvChannelUserDataName')
  final bool? disableLiveTvChannelUserDataName;
  @JsonKey(name: 'MetadataPath')
  final String? metadataPath;
  @JsonKey(name: 'PreferredMetadataLanguage')
  final String? preferredMetadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'SortReplaceCharacters', defaultValue: <String>[])
  final List<String>? sortReplaceCharacters;
  @JsonKey(name: 'SortRemoveCharacters', defaultValue: <String>[])
  final List<String>? sortRemoveCharacters;
  @JsonKey(name: 'SortRemoveWords', defaultValue: <String>[])
  final List<String>? sortRemoveWords;
  @JsonKey(name: 'MinResumePct')
  final int? minResumePct;
  @JsonKey(name: 'MaxResumePct')
  final int? maxResumePct;
  @JsonKey(name: 'MinResumeDurationSeconds')
  final int? minResumeDurationSeconds;
  @JsonKey(name: 'MinAudiobookResume')
  final int? minAudiobookResume;
  @JsonKey(name: 'MaxAudiobookResume')
  final int? maxAudiobookResume;
  @JsonKey(name: 'InactiveSessionThreshold')
  final int? inactiveSessionThreshold;
  @JsonKey(name: 'LibraryMonitorDelay')
  final int? libraryMonitorDelay;
  @JsonKey(name: 'LibraryUpdateDuration')
  final int? libraryUpdateDuration;
  @JsonKey(
    name: 'ImageSavingConvention',
    toJson: imageSavingConventionNullableToJson,
    fromJson: imageSavingConventionNullableFromJson,
  )
  final enums.ImageSavingConvention? imageSavingConvention;
  @JsonKey(name: 'MetadataOptions', defaultValue: <MetadataOptions>[])
  final List<MetadataOptions>? metadataOptions;
  @JsonKey(name: 'SkipDeserializationForBasicTypes')
  final bool? skipDeserializationForBasicTypes;
  @JsonKey(name: 'ServerName')
  final String? serverName;
  @JsonKey(name: 'UICulture')
  final String? uICulture;
  @JsonKey(name: 'SaveMetadataHidden')
  final bool? saveMetadataHidden;
  @JsonKey(name: 'ContentTypes', defaultValue: <NameValuePair>[])
  final List<NameValuePair>? contentTypes;
  @JsonKey(name: 'RemoteClientBitrateLimit')
  final int? remoteClientBitrateLimit;
  @JsonKey(name: 'EnableFolderView')
  final bool? enableFolderView;
  @JsonKey(name: 'EnableGroupingIntoCollections')
  final bool? enableGroupingIntoCollections;
  @JsonKey(name: 'DisplaySpecialsWithinSeasons')
  final bool? displaySpecialsWithinSeasons;
  @JsonKey(name: 'CodecsUsed', defaultValue: <String>[])
  final List<String>? codecsUsed;
  @JsonKey(name: 'PluginRepositories', defaultValue: <RepositoryInfo>[])
  final List<RepositoryInfo>? pluginRepositories;
  @JsonKey(name: 'EnableExternalContentInSuggestions')
  final bool? enableExternalContentInSuggestions;
  @JsonKey(name: 'ImageExtractionTimeoutMs')
  final int? imageExtractionTimeoutMs;
  @JsonKey(name: 'PathSubstitutions', defaultValue: <PathSubstitution>[])
  final List<PathSubstitution>? pathSubstitutions;
  @JsonKey(name: 'EnableSlowResponseWarning')
  final bool? enableSlowResponseWarning;
  @JsonKey(name: 'SlowResponseThresholdMs')
  final int? slowResponseThresholdMs;
  @JsonKey(name: 'CorsHosts', defaultValue: <String>[])
  final List<String>? corsHosts;
  @JsonKey(name: 'ActivityLogRetentionDays')
  final int? activityLogRetentionDays;
  @JsonKey(name: 'LibraryScanFanoutConcurrency')
  final int? libraryScanFanoutConcurrency;
  @JsonKey(name: 'LibraryMetadataRefreshConcurrency')
  final int? libraryMetadataRefreshConcurrency;
  @JsonKey(name: 'RemoveOldPlugins')
  final bool? removeOldPlugins;
  @JsonKey(name: 'AllowClientLogUpload')
  final bool? allowClientLogUpload;
  @JsonKey(name: 'DummyChapterDuration')
  final int? dummyChapterDuration;
  @JsonKey(
    name: 'ChapterImageResolution',
    toJson: imageResolutionNullableToJson,
    fromJson: imageResolutionNullableFromJson,
  )
  final enums.ImageResolution? chapterImageResolution;
  @JsonKey(name: 'ParallelImageEncodingLimit')
  final int? parallelImageEncodingLimit;
  @JsonKey(
      name: 'CastReceiverApplications',
      defaultValue: <CastReceiverApplication>[])
  final List<CastReceiverApplication>? castReceiverApplications;
  @JsonKey(name: 'TrickplayOptions')
  final TrickplayOptions? trickplayOptions;
  static const fromJsonFactory = _$ServerConfigurationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ServerConfiguration &&
            (identical(other.logFileRetentionDays, logFileRetentionDays) ||
                const DeepCollectionEquality().equals(
                    other.logFileRetentionDays, logFileRetentionDays)) &&
            (identical(other.isStartupWizardCompleted, isStartupWizardCompleted) ||
                const DeepCollectionEquality().equals(
                    other.isStartupWizardCompleted,
                    isStartupWizardCompleted)) &&
            (identical(other.cachePath, cachePath) ||
                const DeepCollectionEquality()
                    .equals(other.cachePath, cachePath)) &&
            (identical(other.previousVersion, previousVersion) ||
                const DeepCollectionEquality()
                    .equals(other.previousVersion, previousVersion)) &&
            (identical(other.previousVersionStr, previousVersionStr) ||
                const DeepCollectionEquality()
                    .equals(other.previousVersionStr, previousVersionStr)) &&
            (identical(other.enableMetrics, enableMetrics) ||
                const DeepCollectionEquality()
                    .equals(other.enableMetrics, enableMetrics)) &&
            (identical(other.enableNormalizedItemByNameIds, enableNormalizedItemByNameIds) ||
                const DeepCollectionEquality().equals(
                    other.enableNormalizedItemByNameIds,
                    enableNormalizedItemByNameIds)) &&
            (identical(other.isPortAuthorized, isPortAuthorized) ||
                const DeepCollectionEquality()
                    .equals(other.isPortAuthorized, isPortAuthorized)) &&
            (identical(other.quickConnectAvailable, quickConnectAvailable) ||
                const DeepCollectionEquality().equals(
                    other.quickConnectAvailable, quickConnectAvailable)) &&
            (identical(other.enableCaseSensitiveItemIds, enableCaseSensitiveItemIds) ||
                const DeepCollectionEquality().equals(
                    other.enableCaseSensitiveItemIds,
                    enableCaseSensitiveItemIds)) &&
            (identical(other.disableLiveTvChannelUserDataName, disableLiveTvChannelUserDataName) ||
                const DeepCollectionEquality().equals(
                    other.disableLiveTvChannelUserDataName,
                    disableLiveTvChannelUserDataName)) &&
            (identical(other.metadataPath, metadataPath) ||
                const DeepCollectionEquality()
                    .equals(other.metadataPath, metadataPath)) &&
            (identical(other.preferredMetadataLanguage, preferredMetadataLanguage) ||
                const DeepCollectionEquality().equals(other.preferredMetadataLanguage, preferredMetadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) || const DeepCollectionEquality().equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.sortReplaceCharacters, sortReplaceCharacters) || const DeepCollectionEquality().equals(other.sortReplaceCharacters, sortReplaceCharacters)) &&
            (identical(other.sortRemoveCharacters, sortRemoveCharacters) || const DeepCollectionEquality().equals(other.sortRemoveCharacters, sortRemoveCharacters)) &&
            (identical(other.sortRemoveWords, sortRemoveWords) || const DeepCollectionEquality().equals(other.sortRemoveWords, sortRemoveWords)) &&
            (identical(other.minResumePct, minResumePct) || const DeepCollectionEquality().equals(other.minResumePct, minResumePct)) &&
            (identical(other.maxResumePct, maxResumePct) || const DeepCollectionEquality().equals(other.maxResumePct, maxResumePct)) &&
            (identical(other.minResumeDurationSeconds, minResumeDurationSeconds) || const DeepCollectionEquality().equals(other.minResumeDurationSeconds, minResumeDurationSeconds)) &&
            (identical(other.minAudiobookResume, minAudiobookResume) || const DeepCollectionEquality().equals(other.minAudiobookResume, minAudiobookResume)) &&
            (identical(other.maxAudiobookResume, maxAudiobookResume) || const DeepCollectionEquality().equals(other.maxAudiobookResume, maxAudiobookResume)) &&
            (identical(other.inactiveSessionThreshold, inactiveSessionThreshold) || const DeepCollectionEquality().equals(other.inactiveSessionThreshold, inactiveSessionThreshold)) &&
            (identical(other.libraryMonitorDelay, libraryMonitorDelay) || const DeepCollectionEquality().equals(other.libraryMonitorDelay, libraryMonitorDelay)) &&
            (identical(other.libraryUpdateDuration, libraryUpdateDuration) || const DeepCollectionEquality().equals(other.libraryUpdateDuration, libraryUpdateDuration)) &&
            (identical(other.imageSavingConvention, imageSavingConvention) || const DeepCollectionEquality().equals(other.imageSavingConvention, imageSavingConvention)) &&
            (identical(other.metadataOptions, metadataOptions) || const DeepCollectionEquality().equals(other.metadataOptions, metadataOptions)) &&
            (identical(other.skipDeserializationForBasicTypes, skipDeserializationForBasicTypes) || const DeepCollectionEquality().equals(other.skipDeserializationForBasicTypes, skipDeserializationForBasicTypes)) &&
            (identical(other.serverName, serverName) || const DeepCollectionEquality().equals(other.serverName, serverName)) &&
            (identical(other.uICulture, uICulture) || const DeepCollectionEquality().equals(other.uICulture, uICulture)) &&
            (identical(other.saveMetadataHidden, saveMetadataHidden) || const DeepCollectionEquality().equals(other.saveMetadataHidden, saveMetadataHidden)) &&
            (identical(other.contentTypes, contentTypes) || const DeepCollectionEquality().equals(other.contentTypes, contentTypes)) &&
            (identical(other.remoteClientBitrateLimit, remoteClientBitrateLimit) || const DeepCollectionEquality().equals(other.remoteClientBitrateLimit, remoteClientBitrateLimit)) &&
            (identical(other.enableFolderView, enableFolderView) || const DeepCollectionEquality().equals(other.enableFolderView, enableFolderView)) &&
            (identical(other.enableGroupingIntoCollections, enableGroupingIntoCollections) || const DeepCollectionEquality().equals(other.enableGroupingIntoCollections, enableGroupingIntoCollections)) &&
            (identical(other.displaySpecialsWithinSeasons, displaySpecialsWithinSeasons) || const DeepCollectionEquality().equals(other.displaySpecialsWithinSeasons, displaySpecialsWithinSeasons)) &&
            (identical(other.codecsUsed, codecsUsed) || const DeepCollectionEquality().equals(other.codecsUsed, codecsUsed)) &&
            (identical(other.pluginRepositories, pluginRepositories) || const DeepCollectionEquality().equals(other.pluginRepositories, pluginRepositories)) &&
            (identical(other.enableExternalContentInSuggestions, enableExternalContentInSuggestions) || const DeepCollectionEquality().equals(other.enableExternalContentInSuggestions, enableExternalContentInSuggestions)) &&
            (identical(other.imageExtractionTimeoutMs, imageExtractionTimeoutMs) || const DeepCollectionEquality().equals(other.imageExtractionTimeoutMs, imageExtractionTimeoutMs)) &&
            (identical(other.pathSubstitutions, pathSubstitutions) || const DeepCollectionEquality().equals(other.pathSubstitutions, pathSubstitutions)) &&
            (identical(other.enableSlowResponseWarning, enableSlowResponseWarning) || const DeepCollectionEquality().equals(other.enableSlowResponseWarning, enableSlowResponseWarning)) &&
            (identical(other.slowResponseThresholdMs, slowResponseThresholdMs) || const DeepCollectionEquality().equals(other.slowResponseThresholdMs, slowResponseThresholdMs)) &&
            (identical(other.corsHosts, corsHosts) || const DeepCollectionEquality().equals(other.corsHosts, corsHosts)) &&
            (identical(other.activityLogRetentionDays, activityLogRetentionDays) || const DeepCollectionEquality().equals(other.activityLogRetentionDays, activityLogRetentionDays)) &&
            (identical(other.libraryScanFanoutConcurrency, libraryScanFanoutConcurrency) || const DeepCollectionEquality().equals(other.libraryScanFanoutConcurrency, libraryScanFanoutConcurrency)) &&
            (identical(other.libraryMetadataRefreshConcurrency, libraryMetadataRefreshConcurrency) || const DeepCollectionEquality().equals(other.libraryMetadataRefreshConcurrency, libraryMetadataRefreshConcurrency)) &&
            (identical(other.removeOldPlugins, removeOldPlugins) || const DeepCollectionEquality().equals(other.removeOldPlugins, removeOldPlugins)) &&
            (identical(other.allowClientLogUpload, allowClientLogUpload) || const DeepCollectionEquality().equals(other.allowClientLogUpload, allowClientLogUpload)) &&
            (identical(other.dummyChapterDuration, dummyChapterDuration) || const DeepCollectionEquality().equals(other.dummyChapterDuration, dummyChapterDuration)) &&
            (identical(other.chapterImageResolution, chapterImageResolution) || const DeepCollectionEquality().equals(other.chapterImageResolution, chapterImageResolution)) &&
            (identical(other.parallelImageEncodingLimit, parallelImageEncodingLimit) || const DeepCollectionEquality().equals(other.parallelImageEncodingLimit, parallelImageEncodingLimit)) &&
            (identical(other.castReceiverApplications, castReceiverApplications) || const DeepCollectionEquality().equals(other.castReceiverApplications, castReceiverApplications)) &&
            (identical(other.trickplayOptions, trickplayOptions) || const DeepCollectionEquality().equals(other.trickplayOptions, trickplayOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(logFileRetentionDays) ^
      const DeepCollectionEquality().hash(isStartupWizardCompleted) ^
      const DeepCollectionEquality().hash(cachePath) ^
      const DeepCollectionEquality().hash(previousVersion) ^
      const DeepCollectionEquality().hash(previousVersionStr) ^
      const DeepCollectionEquality().hash(enableMetrics) ^
      const DeepCollectionEquality().hash(enableNormalizedItemByNameIds) ^
      const DeepCollectionEquality().hash(isPortAuthorized) ^
      const DeepCollectionEquality().hash(quickConnectAvailable) ^
      const DeepCollectionEquality().hash(enableCaseSensitiveItemIds) ^
      const DeepCollectionEquality().hash(disableLiveTvChannelUserDataName) ^
      const DeepCollectionEquality().hash(metadataPath) ^
      const DeepCollectionEquality().hash(preferredMetadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(sortReplaceCharacters) ^
      const DeepCollectionEquality().hash(sortRemoveCharacters) ^
      const DeepCollectionEquality().hash(sortRemoveWords) ^
      const DeepCollectionEquality().hash(minResumePct) ^
      const DeepCollectionEquality().hash(maxResumePct) ^
      const DeepCollectionEquality().hash(minResumeDurationSeconds) ^
      const DeepCollectionEquality().hash(minAudiobookResume) ^
      const DeepCollectionEquality().hash(maxAudiobookResume) ^
      const DeepCollectionEquality().hash(inactiveSessionThreshold) ^
      const DeepCollectionEquality().hash(libraryMonitorDelay) ^
      const DeepCollectionEquality().hash(libraryUpdateDuration) ^
      const DeepCollectionEquality().hash(imageSavingConvention) ^
      const DeepCollectionEquality().hash(metadataOptions) ^
      const DeepCollectionEquality().hash(skipDeserializationForBasicTypes) ^
      const DeepCollectionEquality().hash(serverName) ^
      const DeepCollectionEquality().hash(uICulture) ^
      const DeepCollectionEquality().hash(saveMetadataHidden) ^
      const DeepCollectionEquality().hash(contentTypes) ^
      const DeepCollectionEquality().hash(remoteClientBitrateLimit) ^
      const DeepCollectionEquality().hash(enableFolderView) ^
      const DeepCollectionEquality().hash(enableGroupingIntoCollections) ^
      const DeepCollectionEquality().hash(displaySpecialsWithinSeasons) ^
      const DeepCollectionEquality().hash(codecsUsed) ^
      const DeepCollectionEquality().hash(pluginRepositories) ^
      const DeepCollectionEquality().hash(enableExternalContentInSuggestions) ^
      const DeepCollectionEquality().hash(imageExtractionTimeoutMs) ^
      const DeepCollectionEquality().hash(pathSubstitutions) ^
      const DeepCollectionEquality().hash(enableSlowResponseWarning) ^
      const DeepCollectionEquality().hash(slowResponseThresholdMs) ^
      const DeepCollectionEquality().hash(corsHosts) ^
      const DeepCollectionEquality().hash(activityLogRetentionDays) ^
      const DeepCollectionEquality().hash(libraryScanFanoutConcurrency) ^
      const DeepCollectionEquality().hash(libraryMetadataRefreshConcurrency) ^
      const DeepCollectionEquality().hash(removeOldPlugins) ^
      const DeepCollectionEquality().hash(allowClientLogUpload) ^
      const DeepCollectionEquality().hash(dummyChapterDuration) ^
      const DeepCollectionEquality().hash(chapterImageResolution) ^
      const DeepCollectionEquality().hash(parallelImageEncodingLimit) ^
      const DeepCollectionEquality().hash(castReceiverApplications) ^
      const DeepCollectionEquality().hash(trickplayOptions) ^
      runtimeType.hashCode;
}

extension $ServerConfigurationExtension on ServerConfiguration {
  ServerConfiguration copyWith(
      {int? logFileRetentionDays,
      bool? isStartupWizardCompleted,
      String? cachePath,
      String? previousVersion,
      String? previousVersionStr,
      bool? enableMetrics,
      bool? enableNormalizedItemByNameIds,
      bool? isPortAuthorized,
      bool? quickConnectAvailable,
      bool? enableCaseSensitiveItemIds,
      bool? disableLiveTvChannelUserDataName,
      String? metadataPath,
      String? preferredMetadataLanguage,
      String? metadataCountryCode,
      List<String>? sortReplaceCharacters,
      List<String>? sortRemoveCharacters,
      List<String>? sortRemoveWords,
      int? minResumePct,
      int? maxResumePct,
      int? minResumeDurationSeconds,
      int? minAudiobookResume,
      int? maxAudiobookResume,
      int? inactiveSessionThreshold,
      int? libraryMonitorDelay,
      int? libraryUpdateDuration,
      enums.ImageSavingConvention? imageSavingConvention,
      List<MetadataOptions>? metadataOptions,
      bool? skipDeserializationForBasicTypes,
      String? serverName,
      String? uICulture,
      bool? saveMetadataHidden,
      List<NameValuePair>? contentTypes,
      int? remoteClientBitrateLimit,
      bool? enableFolderView,
      bool? enableGroupingIntoCollections,
      bool? displaySpecialsWithinSeasons,
      List<String>? codecsUsed,
      List<RepositoryInfo>? pluginRepositories,
      bool? enableExternalContentInSuggestions,
      int? imageExtractionTimeoutMs,
      List<PathSubstitution>? pathSubstitutions,
      bool? enableSlowResponseWarning,
      int? slowResponseThresholdMs,
      List<String>? corsHosts,
      int? activityLogRetentionDays,
      int? libraryScanFanoutConcurrency,
      int? libraryMetadataRefreshConcurrency,
      bool? removeOldPlugins,
      bool? allowClientLogUpload,
      int? dummyChapterDuration,
      enums.ImageResolution? chapterImageResolution,
      int? parallelImageEncodingLimit,
      List<CastReceiverApplication>? castReceiverApplications,
      TrickplayOptions? trickplayOptions}) {
    return ServerConfiguration(
        logFileRetentionDays: logFileRetentionDays ?? this.logFileRetentionDays,
        isStartupWizardCompleted:
            isStartupWizardCompleted ?? this.isStartupWizardCompleted,
        cachePath: cachePath ?? this.cachePath,
        previousVersion: previousVersion ?? this.previousVersion,
        previousVersionStr: previousVersionStr ?? this.previousVersionStr,
        enableMetrics: enableMetrics ?? this.enableMetrics,
        enableNormalizedItemByNameIds:
            enableNormalizedItemByNameIds ?? this.enableNormalizedItemByNameIds,
        isPortAuthorized: isPortAuthorized ?? this.isPortAuthorized,
        quickConnectAvailable:
            quickConnectAvailable ?? this.quickConnectAvailable,
        enableCaseSensitiveItemIds:
            enableCaseSensitiveItemIds ?? this.enableCaseSensitiveItemIds,
        disableLiveTvChannelUserDataName: disableLiveTvChannelUserDataName ??
            this.disableLiveTvChannelUserDataName,
        metadataPath: metadataPath ?? this.metadataPath,
        preferredMetadataLanguage:
            preferredMetadataLanguage ?? this.preferredMetadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        sortReplaceCharacters:
            sortReplaceCharacters ?? this.sortReplaceCharacters,
        sortRemoveCharacters: sortRemoveCharacters ?? this.sortRemoveCharacters,
        sortRemoveWords: sortRemoveWords ?? this.sortRemoveWords,
        minResumePct: minResumePct ?? this.minResumePct,
        maxResumePct: maxResumePct ?? this.maxResumePct,
        minResumeDurationSeconds:
            minResumeDurationSeconds ?? this.minResumeDurationSeconds,
        minAudiobookResume: minAudiobookResume ?? this.minAudiobookResume,
        maxAudiobookResume: maxAudiobookResume ?? this.maxAudiobookResume,
        inactiveSessionThreshold:
            inactiveSessionThreshold ?? this.inactiveSessionThreshold,
        libraryMonitorDelay: libraryMonitorDelay ?? this.libraryMonitorDelay,
        libraryUpdateDuration:
            libraryUpdateDuration ?? this.libraryUpdateDuration,
        imageSavingConvention:
            imageSavingConvention ?? this.imageSavingConvention,
        metadataOptions: metadataOptions ?? this.metadataOptions,
        skipDeserializationForBasicTypes: skipDeserializationForBasicTypes ??
            this.skipDeserializationForBasicTypes,
        serverName: serverName ?? this.serverName,
        uICulture: uICulture ?? this.uICulture,
        saveMetadataHidden: saveMetadataHidden ?? this.saveMetadataHidden,
        contentTypes: contentTypes ?? this.contentTypes,
        remoteClientBitrateLimit:
            remoteClientBitrateLimit ?? this.remoteClientBitrateLimit,
        enableFolderView: enableFolderView ?? this.enableFolderView,
        enableGroupingIntoCollections:
            enableGroupingIntoCollections ?? this.enableGroupingIntoCollections,
        displaySpecialsWithinSeasons:
            displaySpecialsWithinSeasons ?? this.displaySpecialsWithinSeasons,
        codecsUsed: codecsUsed ?? this.codecsUsed,
        pluginRepositories: pluginRepositories ?? this.pluginRepositories,
        enableExternalContentInSuggestions:
            enableExternalContentInSuggestions ??
                this.enableExternalContentInSuggestions,
        imageExtractionTimeoutMs:
            imageExtractionTimeoutMs ?? this.imageExtractionTimeoutMs,
        pathSubstitutions: pathSubstitutions ?? this.pathSubstitutions,
        enableSlowResponseWarning:
            enableSlowResponseWarning ?? this.enableSlowResponseWarning,
        slowResponseThresholdMs:
            slowResponseThresholdMs ?? this.slowResponseThresholdMs,
        corsHosts: corsHosts ?? this.corsHosts,
        activityLogRetentionDays:
            activityLogRetentionDays ?? this.activityLogRetentionDays,
        libraryScanFanoutConcurrency:
            libraryScanFanoutConcurrency ?? this.libraryScanFanoutConcurrency,
        libraryMetadataRefreshConcurrency: libraryMetadataRefreshConcurrency ??
            this.libraryMetadataRefreshConcurrency,
        removeOldPlugins: removeOldPlugins ?? this.removeOldPlugins,
        allowClientLogUpload: allowClientLogUpload ?? this.allowClientLogUpload,
        dummyChapterDuration: dummyChapterDuration ?? this.dummyChapterDuration,
        chapterImageResolution:
            chapterImageResolution ?? this.chapterImageResolution,
        parallelImageEncodingLimit:
            parallelImageEncodingLimit ?? this.parallelImageEncodingLimit,
        castReceiverApplications:
            castReceiverApplications ?? this.castReceiverApplications,
        trickplayOptions: trickplayOptions ?? this.trickplayOptions);
  }

  ServerConfiguration copyWithWrapped(
      {Wrapped<int?>? logFileRetentionDays,
      Wrapped<bool?>? isStartupWizardCompleted,
      Wrapped<String?>? cachePath,
      Wrapped<String?>? previousVersion,
      Wrapped<String?>? previousVersionStr,
      Wrapped<bool?>? enableMetrics,
      Wrapped<bool?>? enableNormalizedItemByNameIds,
      Wrapped<bool?>? isPortAuthorized,
      Wrapped<bool?>? quickConnectAvailable,
      Wrapped<bool?>? enableCaseSensitiveItemIds,
      Wrapped<bool?>? disableLiveTvChannelUserDataName,
      Wrapped<String?>? metadataPath,
      Wrapped<String?>? preferredMetadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<List<String>?>? sortReplaceCharacters,
      Wrapped<List<String>?>? sortRemoveCharacters,
      Wrapped<List<String>?>? sortRemoveWords,
      Wrapped<int?>? minResumePct,
      Wrapped<int?>? maxResumePct,
      Wrapped<int?>? minResumeDurationSeconds,
      Wrapped<int?>? minAudiobookResume,
      Wrapped<int?>? maxAudiobookResume,
      Wrapped<int?>? inactiveSessionThreshold,
      Wrapped<int?>? libraryMonitorDelay,
      Wrapped<int?>? libraryUpdateDuration,
      Wrapped<enums.ImageSavingConvention?>? imageSavingConvention,
      Wrapped<List<MetadataOptions>?>? metadataOptions,
      Wrapped<bool?>? skipDeserializationForBasicTypes,
      Wrapped<String?>? serverName,
      Wrapped<String?>? uICulture,
      Wrapped<bool?>? saveMetadataHidden,
      Wrapped<List<NameValuePair>?>? contentTypes,
      Wrapped<int?>? remoteClientBitrateLimit,
      Wrapped<bool?>? enableFolderView,
      Wrapped<bool?>? enableGroupingIntoCollections,
      Wrapped<bool?>? displaySpecialsWithinSeasons,
      Wrapped<List<String>?>? codecsUsed,
      Wrapped<List<RepositoryInfo>?>? pluginRepositories,
      Wrapped<bool?>? enableExternalContentInSuggestions,
      Wrapped<int?>? imageExtractionTimeoutMs,
      Wrapped<List<PathSubstitution>?>? pathSubstitutions,
      Wrapped<bool?>? enableSlowResponseWarning,
      Wrapped<int?>? slowResponseThresholdMs,
      Wrapped<List<String>?>? corsHosts,
      Wrapped<int?>? activityLogRetentionDays,
      Wrapped<int?>? libraryScanFanoutConcurrency,
      Wrapped<int?>? libraryMetadataRefreshConcurrency,
      Wrapped<bool?>? removeOldPlugins,
      Wrapped<bool?>? allowClientLogUpload,
      Wrapped<int?>? dummyChapterDuration,
      Wrapped<enums.ImageResolution?>? chapterImageResolution,
      Wrapped<int?>? parallelImageEncodingLimit,
      Wrapped<List<CastReceiverApplication>?>? castReceiverApplications,
      Wrapped<TrickplayOptions?>? trickplayOptions}) {
    return ServerConfiguration(
        logFileRetentionDays: (logFileRetentionDays != null
            ? logFileRetentionDays.value
            : this.logFileRetentionDays),
        isStartupWizardCompleted: (isStartupWizardCompleted != null
            ? isStartupWizardCompleted.value
            : this.isStartupWizardCompleted),
        cachePath: (cachePath != null ? cachePath.value : this.cachePath),
        previousVersion: (previousVersion != null
            ? previousVersion.value
            : this.previousVersion),
        previousVersionStr: (previousVersionStr != null
            ? previousVersionStr.value
            : this.previousVersionStr),
        enableMetrics:
            (enableMetrics != null ? enableMetrics.value : this.enableMetrics),
        enableNormalizedItemByNameIds: (enableNormalizedItemByNameIds != null
            ? enableNormalizedItemByNameIds.value
            : this.enableNormalizedItemByNameIds),
        isPortAuthorized: (isPortAuthorized != null
            ? isPortAuthorized.value
            : this.isPortAuthorized),
        quickConnectAvailable: (quickConnectAvailable != null
            ? quickConnectAvailable.value
            : this.quickConnectAvailable),
        enableCaseSensitiveItemIds: (enableCaseSensitiveItemIds != null
            ? enableCaseSensitiveItemIds.value
            : this.enableCaseSensitiveItemIds),
        disableLiveTvChannelUserDataName: (disableLiveTvChannelUserDataName != null
            ? disableLiveTvChannelUserDataName.value
            : this.disableLiveTvChannelUserDataName),
        metadataPath:
            (metadataPath != null ? metadataPath.value : this.metadataPath),
        preferredMetadataLanguage: (preferredMetadataLanguage != null
            ? preferredMetadataLanguage.value
            : this.preferredMetadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        sortReplaceCharacters: (sortReplaceCharacters != null
            ? sortReplaceCharacters.value
            : this.sortReplaceCharacters),
        sortRemoveCharacters: (sortRemoveCharacters != null
            ? sortRemoveCharacters.value
            : this.sortRemoveCharacters),
        sortRemoveWords: (sortRemoveWords != null
            ? sortRemoveWords.value
            : this.sortRemoveWords),
        minResumePct:
            (minResumePct != null ? minResumePct.value : this.minResumePct),
        maxResumePct:
            (maxResumePct != null ? maxResumePct.value : this.maxResumePct),
        minResumeDurationSeconds: (minResumeDurationSeconds != null
            ? minResumeDurationSeconds.value
            : this.minResumeDurationSeconds),
        minAudiobookResume: (minAudiobookResume != null
            ? minAudiobookResume.value
            : this.minAudiobookResume),
        maxAudiobookResume: (maxAudiobookResume != null
            ? maxAudiobookResume.value
            : this.maxAudiobookResume),
        inactiveSessionThreshold: (inactiveSessionThreshold != null
            ? inactiveSessionThreshold.value
            : this.inactiveSessionThreshold),
        libraryMonitorDelay: (libraryMonitorDelay != null
            ? libraryMonitorDelay.value
            : this.libraryMonitorDelay),
        libraryUpdateDuration: (libraryUpdateDuration != null
            ? libraryUpdateDuration.value
            : this.libraryUpdateDuration),
        imageSavingConvention: (imageSavingConvention != null
            ? imageSavingConvention.value
            : this.imageSavingConvention),
        metadataOptions: (metadataOptions != null
            ? metadataOptions.value
            : this.metadataOptions),
        skipDeserializationForBasicTypes: (skipDeserializationForBasicTypes != null
            ? skipDeserializationForBasicTypes.value
            : this.skipDeserializationForBasicTypes),
        serverName: (serverName != null ? serverName.value : this.serverName),
        uICulture: (uICulture != null ? uICulture.value : this.uICulture),
        saveMetadataHidden: (saveMetadataHidden != null
            ? saveMetadataHidden.value
            : this.saveMetadataHidden),
        contentTypes:
            (contentTypes != null ? contentTypes.value : this.contentTypes),
        remoteClientBitrateLimit: (remoteClientBitrateLimit != null
            ? remoteClientBitrateLimit.value
            : this.remoteClientBitrateLimit),
        enableFolderView: (enableFolderView != null
            ? enableFolderView.value
            : this.enableFolderView),
        enableGroupingIntoCollections: (enableGroupingIntoCollections != null
            ? enableGroupingIntoCollections.value
            : this.enableGroupingIntoCollections),
        displaySpecialsWithinSeasons: (displaySpecialsWithinSeasons != null
            ? displaySpecialsWithinSeasons.value
            : this.displaySpecialsWithinSeasons),
        codecsUsed: (codecsUsed != null ? codecsUsed.value : this.codecsUsed),
        pluginRepositories: (pluginRepositories != null
            ? pluginRepositories.value
            : this.pluginRepositories),
        enableExternalContentInSuggestions: (enableExternalContentInSuggestions != null
            ? enableExternalContentInSuggestions.value
            : this.enableExternalContentInSuggestions),
        imageExtractionTimeoutMs: (imageExtractionTimeoutMs != null
            ? imageExtractionTimeoutMs.value
            : this.imageExtractionTimeoutMs),
        pathSubstitutions: (pathSubstitutions != null
            ? pathSubstitutions.value
            : this.pathSubstitutions),
        enableSlowResponseWarning: (enableSlowResponseWarning != null
            ? enableSlowResponseWarning.value
            : this.enableSlowResponseWarning),
        slowResponseThresholdMs: (slowResponseThresholdMs != null
            ? slowResponseThresholdMs.value
            : this.slowResponseThresholdMs),
        corsHosts: (corsHosts != null ? corsHosts.value : this.corsHosts),
        activityLogRetentionDays:
            (activityLogRetentionDays != null ? activityLogRetentionDays.value : this.activityLogRetentionDays),
        libraryScanFanoutConcurrency: (libraryScanFanoutConcurrency != null ? libraryScanFanoutConcurrency.value : this.libraryScanFanoutConcurrency),
        libraryMetadataRefreshConcurrency: (libraryMetadataRefreshConcurrency != null ? libraryMetadataRefreshConcurrency.value : this.libraryMetadataRefreshConcurrency),
        removeOldPlugins: (removeOldPlugins != null ? removeOldPlugins.value : this.removeOldPlugins),
        allowClientLogUpload: (allowClientLogUpload != null ? allowClientLogUpload.value : this.allowClientLogUpload),
        dummyChapterDuration: (dummyChapterDuration != null ? dummyChapterDuration.value : this.dummyChapterDuration),
        chapterImageResolution: (chapterImageResolution != null ? chapterImageResolution.value : this.chapterImageResolution),
        parallelImageEncodingLimit: (parallelImageEncodingLimit != null ? parallelImageEncodingLimit.value : this.parallelImageEncodingLimit),
        castReceiverApplications: (castReceiverApplications != null ? castReceiverApplications.value : this.castReceiverApplications),
        trickplayOptions: (trickplayOptions != null ? trickplayOptions.value : this.trickplayOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class ServerDiscoveryInfo {
  const ServerDiscoveryInfo({
    this.address,
    this.id,
    this.name,
    this.endpointAddress,
  });

  factory ServerDiscoveryInfo.fromJson(Map<String, dynamic> json) =>
      _$ServerDiscoveryInfoFromJson(json);

  static const toJsonFactory = _$ServerDiscoveryInfoToJson;
  Map<String, dynamic> toJson() => _$ServerDiscoveryInfoToJson(this);

  @JsonKey(name: 'Address')
  final String? address;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'EndpointAddress')
  final String? endpointAddress;
  static const fromJsonFactory = _$ServerDiscoveryInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ServerDiscoveryInfo &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.endpointAddress, endpointAddress) ||
                const DeepCollectionEquality()
                    .equals(other.endpointAddress, endpointAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(endpointAddress) ^
      runtimeType.hashCode;
}

extension $ServerDiscoveryInfoExtension on ServerDiscoveryInfo {
  ServerDiscoveryInfo copyWith(
      {String? address, String? id, String? name, String? endpointAddress}) {
    return ServerDiscoveryInfo(
        address: address ?? this.address,
        id: id ?? this.id,
        name: name ?? this.name,
        endpointAddress: endpointAddress ?? this.endpointAddress);
  }

  ServerDiscoveryInfo copyWithWrapped(
      {Wrapped<String?>? address,
      Wrapped<String?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? endpointAddress}) {
    return ServerDiscoveryInfo(
        address: (address != null ? address.value : this.address),
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        endpointAddress: (endpointAddress != null
            ? endpointAddress.value
            : this.endpointAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class ServerRestartingMessage {
  const ServerRestartingMessage({
    this.messageId,
    this.messageType,
  });

  factory ServerRestartingMessage.fromJson(Map<String, dynamic> json) =>
      _$ServerRestartingMessageFromJson(json);

  static const toJsonFactory = _$ServerRestartingMessageToJson;
  Map<String, dynamic> toJson() => _$ServerRestartingMessageToJson(this);

  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.serverrestarting);

  static const fromJsonFactory = _$ServerRestartingMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ServerRestartingMessage &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $ServerRestartingMessageExtension on ServerRestartingMessage {
  ServerRestartingMessage copyWith(
      {String? messageId, enums.SessionMessageType? messageType}) {
    return ServerRestartingMessage(
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  ServerRestartingMessage copyWithWrapped(
      {Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return ServerRestartingMessage(
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class ServerShuttingDownMessage {
  const ServerShuttingDownMessage({
    this.messageId,
    this.messageType,
  });

  factory ServerShuttingDownMessage.fromJson(Map<String, dynamic> json) =>
      _$ServerShuttingDownMessageFromJson(json);

  static const toJsonFactory = _$ServerShuttingDownMessageToJson;
  Map<String, dynamic> toJson() => _$ServerShuttingDownMessageToJson(this);

  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.servershuttingdown);

  static const fromJsonFactory = _$ServerShuttingDownMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ServerShuttingDownMessage &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $ServerShuttingDownMessageExtension on ServerShuttingDownMessage {
  ServerShuttingDownMessage copyWith(
      {String? messageId, enums.SessionMessageType? messageType}) {
    return ServerShuttingDownMessage(
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  ServerShuttingDownMessage copyWithWrapped(
      {Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return ServerShuttingDownMessage(
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class SessionInfoDto {
  const SessionInfoDto({
    this.playState,
    this.additionalUsers,
    this.capabilities,
    this.remoteEndPoint,
    this.playableMediaTypes,
    this.id,
    this.userId,
    this.userName,
    this.$Client,
    this.lastActivityDate,
    this.lastPlaybackCheckIn,
    this.lastPausedDate,
    this.deviceName,
    this.deviceType,
    this.nowPlayingItem,
    this.nowViewingItem,
    this.deviceId,
    this.applicationVersion,
    this.transcodingInfo,
    this.isActive,
    this.supportsMediaControl,
    this.supportsRemoteControl,
    this.nowPlayingQueue,
    this.nowPlayingQueueFullItems,
    this.hasCustomDeviceName,
    this.playlistItemId,
    this.serverId,
    this.userPrimaryImageTag,
    this.supportedCommands,
  });

  factory SessionInfoDto.fromJson(Map<String, dynamic> json) =>
      _$SessionInfoDtoFromJson(json);

  static const toJsonFactory = _$SessionInfoDtoToJson;
  Map<String, dynamic> toJson() => _$SessionInfoDtoToJson(this);

  @JsonKey(name: 'PlayState')
  final PlayerStateInfo? playState;
  @JsonKey(name: 'AdditionalUsers', defaultValue: <SessionUserInfo>[])
  final List<SessionUserInfo>? additionalUsers;
  @JsonKey(name: 'Capabilities')
  final ClientCapabilitiesDto? capabilities;
  @JsonKey(name: 'RemoteEndPoint')
  final String? remoteEndPoint;
  @JsonKey(
    name: 'PlayableMediaTypes',
    toJson: mediaTypeListToJson,
    fromJson: mediaTypeListFromJson,
  )
  final List<enums.MediaType>? playableMediaTypes;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'UserName')
  final String? userName;
  @JsonKey(name: 'Client')
  final String? $Client;
  @JsonKey(name: 'LastActivityDate')
  final DateTime? lastActivityDate;
  @JsonKey(name: 'LastPlaybackCheckIn')
  final DateTime? lastPlaybackCheckIn;
  @JsonKey(name: 'LastPausedDate')
  final DateTime? lastPausedDate;
  @JsonKey(name: 'DeviceName')
  final String? deviceName;
  @JsonKey(name: 'DeviceType')
  final String? deviceType;
  @JsonKey(name: 'NowPlayingItem')
  final BaseItemDto? nowPlayingItem;
  @JsonKey(name: 'NowViewingItem')
  final BaseItemDto? nowViewingItem;
  @JsonKey(name: 'DeviceId')
  final String? deviceId;
  @JsonKey(name: 'ApplicationVersion')
  final String? applicationVersion;
  @JsonKey(name: 'TranscodingInfo')
  final TranscodingInfo? transcodingInfo;
  @JsonKey(name: 'IsActive')
  final bool? isActive;
  @JsonKey(name: 'SupportsMediaControl')
  final bool? supportsMediaControl;
  @JsonKey(name: 'SupportsRemoteControl')
  final bool? supportsRemoteControl;
  @JsonKey(name: 'NowPlayingQueue', defaultValue: <QueueItem>[])
  final List<QueueItem>? nowPlayingQueue;
  @JsonKey(name: 'NowPlayingQueueFullItems', defaultValue: <BaseItemDto>[])
  final List<BaseItemDto>? nowPlayingQueueFullItems;
  @JsonKey(name: 'HasCustomDeviceName')
  final bool? hasCustomDeviceName;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  @JsonKey(name: 'ServerId')
  final String? serverId;
  @JsonKey(name: 'UserPrimaryImageTag')
  final String? userPrimaryImageTag;
  @JsonKey(
    name: 'SupportedCommands',
    toJson: generalCommandTypeListToJson,
    fromJson: generalCommandTypeListFromJson,
  )
  final List<enums.GeneralCommandType>? supportedCommands;
  static const fromJsonFactory = _$SessionInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SessionInfoDto &&
            (identical(other.playState, playState) ||
                const DeepCollectionEquality()
                    .equals(other.playState, playState)) &&
            (identical(other.additionalUsers, additionalUsers) ||
                const DeepCollectionEquality()
                    .equals(other.additionalUsers, additionalUsers)) &&
            (identical(other.capabilities, capabilities) ||
                const DeepCollectionEquality()
                    .equals(other.capabilities, capabilities)) &&
            (identical(other.remoteEndPoint, remoteEndPoint) ||
                const DeepCollectionEquality()
                    .equals(other.remoteEndPoint, remoteEndPoint)) &&
            (identical(other.playableMediaTypes, playableMediaTypes) ||
                const DeepCollectionEquality()
                    .equals(other.playableMediaTypes, playableMediaTypes)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.$Client, $Client) ||
                const DeepCollectionEquality()
                    .equals(other.$Client, $Client)) &&
            (identical(other.lastActivityDate, lastActivityDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastActivityDate, lastActivityDate)) &&
            (identical(other.lastPlaybackCheckIn, lastPlaybackCheckIn) ||
                const DeepCollectionEquality()
                    .equals(other.lastPlaybackCheckIn, lastPlaybackCheckIn)) &&
            (identical(other.lastPausedDate, lastPausedDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPausedDate, lastPausedDate)) &&
            (identical(other.deviceName, deviceName) ||
                const DeepCollectionEquality()
                    .equals(other.deviceName, deviceName)) &&
            (identical(other.deviceType, deviceType) ||
                const DeepCollectionEquality()
                    .equals(other.deviceType, deviceType)) &&
            (identical(other.nowPlayingItem, nowPlayingItem) ||
                const DeepCollectionEquality()
                    .equals(other.nowPlayingItem, nowPlayingItem)) &&
            (identical(other.nowViewingItem, nowViewingItem) ||
                const DeepCollectionEquality()
                    .equals(other.nowViewingItem, nowViewingItem)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.applicationVersion, applicationVersion) ||
                const DeepCollectionEquality()
                    .equals(other.applicationVersion, applicationVersion)) &&
            (identical(other.transcodingInfo, transcodingInfo) ||
                const DeepCollectionEquality()
                    .equals(other.transcodingInfo, transcodingInfo)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.supportsMediaControl, supportsMediaControl) ||
                const DeepCollectionEquality().equals(
                    other.supportsMediaControl, supportsMediaControl)) &&
            (identical(other.supportsRemoteControl, supportsRemoteControl) ||
                const DeepCollectionEquality().equals(
                    other.supportsRemoteControl, supportsRemoteControl)) &&
            (identical(other.nowPlayingQueue, nowPlayingQueue) || const DeepCollectionEquality().equals(other.nowPlayingQueue, nowPlayingQueue)) &&
            (identical(other.nowPlayingQueueFullItems, nowPlayingQueueFullItems) || const DeepCollectionEquality().equals(other.nowPlayingQueueFullItems, nowPlayingQueueFullItems)) &&
            (identical(other.hasCustomDeviceName, hasCustomDeviceName) || const DeepCollectionEquality().equals(other.hasCustomDeviceName, hasCustomDeviceName)) &&
            (identical(other.playlistItemId, playlistItemId) || const DeepCollectionEquality().equals(other.playlistItemId, playlistItemId)) &&
            (identical(other.serverId, serverId) || const DeepCollectionEquality().equals(other.serverId, serverId)) &&
            (identical(other.userPrimaryImageTag, userPrimaryImageTag) || const DeepCollectionEquality().equals(other.userPrimaryImageTag, userPrimaryImageTag)) &&
            (identical(other.supportedCommands, supportedCommands) || const DeepCollectionEquality().equals(other.supportedCommands, supportedCommands)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(playState) ^
      const DeepCollectionEquality().hash(additionalUsers) ^
      const DeepCollectionEquality().hash(capabilities) ^
      const DeepCollectionEquality().hash(remoteEndPoint) ^
      const DeepCollectionEquality().hash(playableMediaTypes) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash($Client) ^
      const DeepCollectionEquality().hash(lastActivityDate) ^
      const DeepCollectionEquality().hash(lastPlaybackCheckIn) ^
      const DeepCollectionEquality().hash(lastPausedDate) ^
      const DeepCollectionEquality().hash(deviceName) ^
      const DeepCollectionEquality().hash(deviceType) ^
      const DeepCollectionEquality().hash(nowPlayingItem) ^
      const DeepCollectionEquality().hash(nowViewingItem) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(applicationVersion) ^
      const DeepCollectionEquality().hash(transcodingInfo) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(supportsMediaControl) ^
      const DeepCollectionEquality().hash(supportsRemoteControl) ^
      const DeepCollectionEquality().hash(nowPlayingQueue) ^
      const DeepCollectionEquality().hash(nowPlayingQueueFullItems) ^
      const DeepCollectionEquality().hash(hasCustomDeviceName) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      const DeepCollectionEquality().hash(serverId) ^
      const DeepCollectionEquality().hash(userPrimaryImageTag) ^
      const DeepCollectionEquality().hash(supportedCommands) ^
      runtimeType.hashCode;
}

extension $SessionInfoDtoExtension on SessionInfoDto {
  SessionInfoDto copyWith(
      {PlayerStateInfo? playState,
      List<SessionUserInfo>? additionalUsers,
      ClientCapabilitiesDto? capabilities,
      String? remoteEndPoint,
      List<enums.MediaType>? playableMediaTypes,
      String? id,
      String? userId,
      String? userName,
      String? $Client,
      DateTime? lastActivityDate,
      DateTime? lastPlaybackCheckIn,
      DateTime? lastPausedDate,
      String? deviceName,
      String? deviceType,
      BaseItemDto? nowPlayingItem,
      BaseItemDto? nowViewingItem,
      String? deviceId,
      String? applicationVersion,
      TranscodingInfo? transcodingInfo,
      bool? isActive,
      bool? supportsMediaControl,
      bool? supportsRemoteControl,
      List<QueueItem>? nowPlayingQueue,
      List<BaseItemDto>? nowPlayingQueueFullItems,
      bool? hasCustomDeviceName,
      String? playlistItemId,
      String? serverId,
      String? userPrimaryImageTag,
      List<enums.GeneralCommandType>? supportedCommands}) {
    return SessionInfoDto(
        playState: playState ?? this.playState,
        additionalUsers: additionalUsers ?? this.additionalUsers,
        capabilities: capabilities ?? this.capabilities,
        remoteEndPoint: remoteEndPoint ?? this.remoteEndPoint,
        playableMediaTypes: playableMediaTypes ?? this.playableMediaTypes,
        id: id ?? this.id,
        userId: userId ?? this.userId,
        userName: userName ?? this.userName,
        $Client: $Client ?? this.$Client,
        lastActivityDate: lastActivityDate ?? this.lastActivityDate,
        lastPlaybackCheckIn: lastPlaybackCheckIn ?? this.lastPlaybackCheckIn,
        lastPausedDate: lastPausedDate ?? this.lastPausedDate,
        deviceName: deviceName ?? this.deviceName,
        deviceType: deviceType ?? this.deviceType,
        nowPlayingItem: nowPlayingItem ?? this.nowPlayingItem,
        nowViewingItem: nowViewingItem ?? this.nowViewingItem,
        deviceId: deviceId ?? this.deviceId,
        applicationVersion: applicationVersion ?? this.applicationVersion,
        transcodingInfo: transcodingInfo ?? this.transcodingInfo,
        isActive: isActive ?? this.isActive,
        supportsMediaControl: supportsMediaControl ?? this.supportsMediaControl,
        supportsRemoteControl:
            supportsRemoteControl ?? this.supportsRemoteControl,
        nowPlayingQueue: nowPlayingQueue ?? this.nowPlayingQueue,
        nowPlayingQueueFullItems:
            nowPlayingQueueFullItems ?? this.nowPlayingQueueFullItems,
        hasCustomDeviceName: hasCustomDeviceName ?? this.hasCustomDeviceName,
        playlistItemId: playlistItemId ?? this.playlistItemId,
        serverId: serverId ?? this.serverId,
        userPrimaryImageTag: userPrimaryImageTag ?? this.userPrimaryImageTag,
        supportedCommands: supportedCommands ?? this.supportedCommands);
  }

  SessionInfoDto copyWithWrapped(
      {Wrapped<PlayerStateInfo?>? playState,
      Wrapped<List<SessionUserInfo>?>? additionalUsers,
      Wrapped<ClientCapabilitiesDto?>? capabilities,
      Wrapped<String?>? remoteEndPoint,
      Wrapped<List<enums.MediaType>?>? playableMediaTypes,
      Wrapped<String?>? id,
      Wrapped<String?>? userId,
      Wrapped<String?>? userName,
      Wrapped<String?>? $Client,
      Wrapped<DateTime?>? lastActivityDate,
      Wrapped<DateTime?>? lastPlaybackCheckIn,
      Wrapped<DateTime?>? lastPausedDate,
      Wrapped<String?>? deviceName,
      Wrapped<String?>? deviceType,
      Wrapped<BaseItemDto?>? nowPlayingItem,
      Wrapped<BaseItemDto?>? nowViewingItem,
      Wrapped<String?>? deviceId,
      Wrapped<String?>? applicationVersion,
      Wrapped<TranscodingInfo?>? transcodingInfo,
      Wrapped<bool?>? isActive,
      Wrapped<bool?>? supportsMediaControl,
      Wrapped<bool?>? supportsRemoteControl,
      Wrapped<List<QueueItem>?>? nowPlayingQueue,
      Wrapped<List<BaseItemDto>?>? nowPlayingQueueFullItems,
      Wrapped<bool?>? hasCustomDeviceName,
      Wrapped<String?>? playlistItemId,
      Wrapped<String?>? serverId,
      Wrapped<String?>? userPrimaryImageTag,
      Wrapped<List<enums.GeneralCommandType>?>? supportedCommands}) {
    return SessionInfoDto(
        playState: (playState != null ? playState.value : this.playState),
        additionalUsers: (additionalUsers != null
            ? additionalUsers.value
            : this.additionalUsers),
        capabilities:
            (capabilities != null ? capabilities.value : this.capabilities),
        remoteEndPoint: (remoteEndPoint != null
            ? remoteEndPoint.value
            : this.remoteEndPoint),
        playableMediaTypes: (playableMediaTypes != null
            ? playableMediaTypes.value
            : this.playableMediaTypes),
        id: (id != null ? id.value : this.id),
        userId: (userId != null ? userId.value : this.userId),
        userName: (userName != null ? userName.value : this.userName),
        $Client: ($Client != null ? $Client.value : this.$Client),
        lastActivityDate: (lastActivityDate != null
            ? lastActivityDate.value
            : this.lastActivityDate),
        lastPlaybackCheckIn: (lastPlaybackCheckIn != null
            ? lastPlaybackCheckIn.value
            : this.lastPlaybackCheckIn),
        lastPausedDate: (lastPausedDate != null
            ? lastPausedDate.value
            : this.lastPausedDate),
        deviceName: (deviceName != null ? deviceName.value : this.deviceName),
        deviceType: (deviceType != null ? deviceType.value : this.deviceType),
        nowPlayingItem: (nowPlayingItem != null
            ? nowPlayingItem.value
            : this.nowPlayingItem),
        nowViewingItem: (nowViewingItem != null
            ? nowViewingItem.value
            : this.nowViewingItem),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        applicationVersion: (applicationVersion != null
            ? applicationVersion.value
            : this.applicationVersion),
        transcodingInfo: (transcodingInfo != null
            ? transcodingInfo.value
            : this.transcodingInfo),
        isActive: (isActive != null ? isActive.value : this.isActive),
        supportsMediaControl: (supportsMediaControl != null
            ? supportsMediaControl.value
            : this.supportsMediaControl),
        supportsRemoteControl: (supportsRemoteControl != null
            ? supportsRemoteControl.value
            : this.supportsRemoteControl),
        nowPlayingQueue: (nowPlayingQueue != null
            ? nowPlayingQueue.value
            : this.nowPlayingQueue),
        nowPlayingQueueFullItems: (nowPlayingQueueFullItems != null
            ? nowPlayingQueueFullItems.value
            : this.nowPlayingQueueFullItems),
        hasCustomDeviceName: (hasCustomDeviceName != null
            ? hasCustomDeviceName.value
            : this.hasCustomDeviceName),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId),
        serverId: (serverId != null ? serverId.value : this.serverId),
        userPrimaryImageTag: (userPrimaryImageTag != null
            ? userPrimaryImageTag.value
            : this.userPrimaryImageTag),
        supportedCommands: (supportedCommands != null
            ? supportedCommands.value
            : this.supportedCommands));
  }
}

@JsonSerializable(explicitToJson: true)
class SessionsMessage {
  const SessionsMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory SessionsMessage.fromJson(Map<String, dynamic> json) =>
      _$SessionsMessageFromJson(json);

  static const toJsonFactory = _$SessionsMessageToJson;
  Map<String, dynamic> toJson() => _$SessionsMessageToJson(this);

  @JsonKey(name: 'Data', defaultValue: <SessionInfoDto>[])
  final List<SessionInfoDto>? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.sessions);

  static const fromJsonFactory = _$SessionsMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SessionsMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $SessionsMessageExtension on SessionsMessage {
  SessionsMessage copyWith(
      {List<SessionInfoDto>? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return SessionsMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  SessionsMessage copyWithWrapped(
      {Wrapped<List<SessionInfoDto>?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return SessionsMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class SessionsStartMessage {
  const SessionsStartMessage({
    this.data,
    this.messageType,
  });

  factory SessionsStartMessage.fromJson(Map<String, dynamic> json) =>
      _$SessionsStartMessageFromJson(json);

  static const toJsonFactory = _$SessionsStartMessageToJson;
  Map<String, dynamic> toJson() => _$SessionsStartMessageToJson(this);

  @JsonKey(name: 'Data')
  final String? data;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.sessionsstart);

  static const fromJsonFactory = _$SessionsStartMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SessionsStartMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $SessionsStartMessageExtension on SessionsStartMessage {
  SessionsStartMessage copyWith(
      {String? data, enums.SessionMessageType? messageType}) {
    return SessionsStartMessage(
        data: data ?? this.data, messageType: messageType ?? this.messageType);
  }

  SessionsStartMessage copyWithWrapped(
      {Wrapped<String?>? data,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return SessionsStartMessage(
        data: (data != null ? data.value : this.data),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class SessionsStopMessage {
  const SessionsStopMessage({
    this.messageType,
  });

  factory SessionsStopMessage.fromJson(Map<String, dynamic> json) =>
      _$SessionsStopMessageFromJson(json);

  static const toJsonFactory = _$SessionsStopMessageToJson;
  Map<String, dynamic> toJson() => _$SessionsStopMessageToJson(this);

  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.sessionsstop);

  static const fromJsonFactory = _$SessionsStopMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SessionsStopMessage &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(messageType) ^ runtimeType.hashCode;
}

extension $SessionsStopMessageExtension on SessionsStopMessage {
  SessionsStopMessage copyWith({enums.SessionMessageType? messageType}) {
    return SessionsStopMessage(messageType: messageType ?? this.messageType);
  }

  SessionsStopMessage copyWithWrapped(
      {Wrapped<enums.SessionMessageType?>? messageType}) {
    return SessionsStopMessage(
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class SessionUserInfo {
  const SessionUserInfo({
    this.userId,
    this.userName,
  });

  factory SessionUserInfo.fromJson(Map<String, dynamic> json) =>
      _$SessionUserInfoFromJson(json);

  static const toJsonFactory = _$SessionUserInfoToJson;
  Map<String, dynamic> toJson() => _$SessionUserInfoToJson(this);

  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'UserName')
  final String? userName;
  static const fromJsonFactory = _$SessionUserInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SessionUserInfo &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userName) ^
      runtimeType.hashCode;
}

extension $SessionUserInfoExtension on SessionUserInfo {
  SessionUserInfo copyWith({String? userId, String? userName}) {
    return SessionUserInfo(
        userId: userId ?? this.userId, userName: userName ?? this.userName);
  }

  SessionUserInfo copyWithWrapped(
      {Wrapped<String?>? userId, Wrapped<String?>? userName}) {
    return SessionUserInfo(
        userId: (userId != null ? userId.value : this.userId),
        userName: (userName != null ? userName.value : this.userName));
  }
}

@JsonSerializable(explicitToJson: true)
class SetChannelMappingDto {
  const SetChannelMappingDto({
    required this.providerId,
    required this.tunerChannelId,
    required this.providerChannelId,
  });

  factory SetChannelMappingDto.fromJson(Map<String, dynamic> json) =>
      _$SetChannelMappingDtoFromJson(json);

  static const toJsonFactory = _$SetChannelMappingDtoToJson;
  Map<String, dynamic> toJson() => _$SetChannelMappingDtoToJson(this);

  @JsonKey(name: 'ProviderId')
  final String providerId;
  @JsonKey(name: 'TunerChannelId')
  final String tunerChannelId;
  @JsonKey(name: 'ProviderChannelId')
  final String providerChannelId;
  static const fromJsonFactory = _$SetChannelMappingDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetChannelMappingDto &&
            (identical(other.providerId, providerId) ||
                const DeepCollectionEquality()
                    .equals(other.providerId, providerId)) &&
            (identical(other.tunerChannelId, tunerChannelId) ||
                const DeepCollectionEquality()
                    .equals(other.tunerChannelId, tunerChannelId)) &&
            (identical(other.providerChannelId, providerChannelId) ||
                const DeepCollectionEquality()
                    .equals(other.providerChannelId, providerChannelId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(providerId) ^
      const DeepCollectionEquality().hash(tunerChannelId) ^
      const DeepCollectionEquality().hash(providerChannelId) ^
      runtimeType.hashCode;
}

extension $SetChannelMappingDtoExtension on SetChannelMappingDto {
  SetChannelMappingDto copyWith(
      {String? providerId, String? tunerChannelId, String? providerChannelId}) {
    return SetChannelMappingDto(
        providerId: providerId ?? this.providerId,
        tunerChannelId: tunerChannelId ?? this.tunerChannelId,
        providerChannelId: providerChannelId ?? this.providerChannelId);
  }

  SetChannelMappingDto copyWithWrapped(
      {Wrapped<String>? providerId,
      Wrapped<String>? tunerChannelId,
      Wrapped<String>? providerChannelId}) {
    return SetChannelMappingDto(
        providerId: (providerId != null ? providerId.value : this.providerId),
        tunerChannelId: (tunerChannelId != null
            ? tunerChannelId.value
            : this.tunerChannelId),
        providerChannelId: (providerChannelId != null
            ? providerChannelId.value
            : this.providerChannelId));
  }
}

@JsonSerializable(explicitToJson: true)
class SetPlaylistItemRequestDto {
  const SetPlaylistItemRequestDto({
    this.playlistItemId,
  });

  factory SetPlaylistItemRequestDto.fromJson(Map<String, dynamic> json) =>
      _$SetPlaylistItemRequestDtoFromJson(json);

  static const toJsonFactory = _$SetPlaylistItemRequestDtoToJson;
  Map<String, dynamic> toJson() => _$SetPlaylistItemRequestDtoToJson(this);

  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  static const fromJsonFactory = _$SetPlaylistItemRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetPlaylistItemRequestDto &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(playlistItemId) ^
      runtimeType.hashCode;
}

extension $SetPlaylistItemRequestDtoExtension on SetPlaylistItemRequestDto {
  SetPlaylistItemRequestDto copyWith({String? playlistItemId}) {
    return SetPlaylistItemRequestDto(
        playlistItemId: playlistItemId ?? this.playlistItemId);
  }

  SetPlaylistItemRequestDto copyWithWrapped(
      {Wrapped<String?>? playlistItemId}) {
    return SetPlaylistItemRequestDto(
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId));
  }
}

@JsonSerializable(explicitToJson: true)
class SetRepeatModeRequestDto {
  const SetRepeatModeRequestDto({
    this.mode,
  });

  factory SetRepeatModeRequestDto.fromJson(Map<String, dynamic> json) =>
      _$SetRepeatModeRequestDtoFromJson(json);

  static const toJsonFactory = _$SetRepeatModeRequestDtoToJson;
  Map<String, dynamic> toJson() => _$SetRepeatModeRequestDtoToJson(this);

  @JsonKey(
    name: 'Mode',
    toJson: groupRepeatModeNullableToJson,
    fromJson: groupRepeatModeNullableFromJson,
  )
  final enums.GroupRepeatMode? mode;
  static const fromJsonFactory = _$SetRepeatModeRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetRepeatModeRequestDto &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(mode) ^ runtimeType.hashCode;
}

extension $SetRepeatModeRequestDtoExtension on SetRepeatModeRequestDto {
  SetRepeatModeRequestDto copyWith({enums.GroupRepeatMode? mode}) {
    return SetRepeatModeRequestDto(mode: mode ?? this.mode);
  }

  SetRepeatModeRequestDto copyWithWrapped(
      {Wrapped<enums.GroupRepeatMode?>? mode}) {
    return SetRepeatModeRequestDto(
        mode: (mode != null ? mode.value : this.mode));
  }
}

@JsonSerializable(explicitToJson: true)
class SetShuffleModeRequestDto {
  const SetShuffleModeRequestDto({
    this.mode,
  });

  factory SetShuffleModeRequestDto.fromJson(Map<String, dynamic> json) =>
      _$SetShuffleModeRequestDtoFromJson(json);

  static const toJsonFactory = _$SetShuffleModeRequestDtoToJson;
  Map<String, dynamic> toJson() => _$SetShuffleModeRequestDtoToJson(this);

  @JsonKey(
    name: 'Mode',
    toJson: groupShuffleModeNullableToJson,
    fromJson: groupShuffleModeNullableFromJson,
  )
  final enums.GroupShuffleMode? mode;
  static const fromJsonFactory = _$SetShuffleModeRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SetShuffleModeRequestDto &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(mode) ^ runtimeType.hashCode;
}

extension $SetShuffleModeRequestDtoExtension on SetShuffleModeRequestDto {
  SetShuffleModeRequestDto copyWith({enums.GroupShuffleMode? mode}) {
    return SetShuffleModeRequestDto(mode: mode ?? this.mode);
  }

  SetShuffleModeRequestDto copyWithWrapped(
      {Wrapped<enums.GroupShuffleMode?>? mode}) {
    return SetShuffleModeRequestDto(
        mode: (mode != null ? mode.value : this.mode));
  }
}

@JsonSerializable(explicitToJson: true)
class SongInfo {
  const SongInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
    this.albumArtists,
    this.album,
    this.artists,
  });

  factory SongInfo.fromJson(Map<String, dynamic> json) =>
      _$SongInfoFromJson(json);

  static const toJsonFactory = _$SongInfoToJson;
  Map<String, dynamic> toJson() => _$SongInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  @JsonKey(name: 'AlbumArtists', defaultValue: <String>[])
  final List<String>? albumArtists;
  @JsonKey(name: 'Album')
  final String? album;
  @JsonKey(name: 'Artists', defaultValue: <String>[])
  final List<String>? artists;
  static const fromJsonFactory = _$SongInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SongInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)) &&
            (identical(other.albumArtists, albumArtists) ||
                const DeepCollectionEquality()
                    .equals(other.albumArtists, albumArtists)) &&
            (identical(other.album, album) ||
                const DeepCollectionEquality().equals(other.album, album)) &&
            (identical(other.artists, artists) ||
                const DeepCollectionEquality().equals(other.artists, artists)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      const DeepCollectionEquality().hash(albumArtists) ^
      const DeepCollectionEquality().hash(album) ^
      const DeepCollectionEquality().hash(artists) ^
      runtimeType.hashCode;
}

extension $SongInfoExtension on SongInfo {
  SongInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated,
      List<String>? albumArtists,
      String? album,
      List<String>? artists}) {
    return SongInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated,
        albumArtists: albumArtists ?? this.albumArtists,
        album: album ?? this.album,
        artists: artists ?? this.artists);
  }

  SongInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated,
      Wrapped<List<String>?>? albumArtists,
      Wrapped<String?>? album,
      Wrapped<List<String>?>? artists}) {
    return SongInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated),
        albumArtists:
            (albumArtists != null ? albumArtists.value : this.albumArtists),
        album: (album != null ? album.value : this.album),
        artists: (artists != null ? artists.value : this.artists));
  }
}

@JsonSerializable(explicitToJson: true)
class SpecialViewOptionDto {
  const SpecialViewOptionDto({
    this.name,
    this.id,
  });

  factory SpecialViewOptionDto.fromJson(Map<String, dynamic> json) =>
      _$SpecialViewOptionDtoFromJson(json);

  static const toJsonFactory = _$SpecialViewOptionDtoToJson;
  Map<String, dynamic> toJson() => _$SpecialViewOptionDtoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Id')
  final String? id;
  static const fromJsonFactory = _$SpecialViewOptionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpecialViewOptionDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $SpecialViewOptionDtoExtension on SpecialViewOptionDto {
  SpecialViewOptionDto copyWith({String? name, String? id}) {
    return SpecialViewOptionDto(name: name ?? this.name, id: id ?? this.id);
  }

  SpecialViewOptionDto copyWithWrapped(
      {Wrapped<String?>? name, Wrapped<String?>? id}) {
    return SpecialViewOptionDto(
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class StartupConfigurationDto {
  const StartupConfigurationDto({
    this.uICulture,
    this.metadataCountryCode,
    this.preferredMetadataLanguage,
  });

  factory StartupConfigurationDto.fromJson(Map<String, dynamic> json) =>
      _$StartupConfigurationDtoFromJson(json);

  static const toJsonFactory = _$StartupConfigurationDtoToJson;
  Map<String, dynamic> toJson() => _$StartupConfigurationDtoToJson(this);

  @JsonKey(name: 'UICulture')
  final String? uICulture;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'PreferredMetadataLanguage')
  final String? preferredMetadataLanguage;
  static const fromJsonFactory = _$StartupConfigurationDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StartupConfigurationDto &&
            (identical(other.uICulture, uICulture) ||
                const DeepCollectionEquality()
                    .equals(other.uICulture, uICulture)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.preferredMetadataLanguage,
                    preferredMetadataLanguage) ||
                const DeepCollectionEquality().equals(
                    other.preferredMetadataLanguage,
                    preferredMetadataLanguage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(uICulture) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(preferredMetadataLanguage) ^
      runtimeType.hashCode;
}

extension $StartupConfigurationDtoExtension on StartupConfigurationDto {
  StartupConfigurationDto copyWith(
      {String? uICulture,
      String? metadataCountryCode,
      String? preferredMetadataLanguage}) {
    return StartupConfigurationDto(
        uICulture: uICulture ?? this.uICulture,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        preferredMetadataLanguage:
            preferredMetadataLanguage ?? this.preferredMetadataLanguage);
  }

  StartupConfigurationDto copyWithWrapped(
      {Wrapped<String?>? uICulture,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<String?>? preferredMetadataLanguage}) {
    return StartupConfigurationDto(
        uICulture: (uICulture != null ? uICulture.value : this.uICulture),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        preferredMetadataLanguage: (preferredMetadataLanguage != null
            ? preferredMetadataLanguage.value
            : this.preferredMetadataLanguage));
  }
}

@JsonSerializable(explicitToJson: true)
class StartupRemoteAccessDto {
  const StartupRemoteAccessDto({
    required this.enableRemoteAccess,
    required this.enableAutomaticPortMapping,
  });

  factory StartupRemoteAccessDto.fromJson(Map<String, dynamic> json) =>
      _$StartupRemoteAccessDtoFromJson(json);

  static const toJsonFactory = _$StartupRemoteAccessDtoToJson;
  Map<String, dynamic> toJson() => _$StartupRemoteAccessDtoToJson(this);

  @JsonKey(name: 'EnableRemoteAccess')
  final bool enableRemoteAccess;
  @JsonKey(name: 'EnableAutomaticPortMapping')
  final bool enableAutomaticPortMapping;
  static const fromJsonFactory = _$StartupRemoteAccessDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StartupRemoteAccessDto &&
            (identical(other.enableRemoteAccess, enableRemoteAccess) ||
                const DeepCollectionEquality()
                    .equals(other.enableRemoteAccess, enableRemoteAccess)) &&
            (identical(other.enableAutomaticPortMapping,
                    enableAutomaticPortMapping) ||
                const DeepCollectionEquality().equals(
                    other.enableAutomaticPortMapping,
                    enableAutomaticPortMapping)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enableRemoteAccess) ^
      const DeepCollectionEquality().hash(enableAutomaticPortMapping) ^
      runtimeType.hashCode;
}

extension $StartupRemoteAccessDtoExtension on StartupRemoteAccessDto {
  StartupRemoteAccessDto copyWith(
      {bool? enableRemoteAccess, bool? enableAutomaticPortMapping}) {
    return StartupRemoteAccessDto(
        enableRemoteAccess: enableRemoteAccess ?? this.enableRemoteAccess,
        enableAutomaticPortMapping:
            enableAutomaticPortMapping ?? this.enableAutomaticPortMapping);
  }

  StartupRemoteAccessDto copyWithWrapped(
      {Wrapped<bool>? enableRemoteAccess,
      Wrapped<bool>? enableAutomaticPortMapping}) {
    return StartupRemoteAccessDto(
        enableRemoteAccess: (enableRemoteAccess != null
            ? enableRemoteAccess.value
            : this.enableRemoteAccess),
        enableAutomaticPortMapping: (enableAutomaticPortMapping != null
            ? enableAutomaticPortMapping.value
            : this.enableAutomaticPortMapping));
  }
}

@JsonSerializable(explicitToJson: true)
class StartupUserDto {
  const StartupUserDto({
    this.name,
    this.password,
  });

  factory StartupUserDto.fromJson(Map<String, dynamic> json) =>
      _$StartupUserDtoFromJson(json);

  static const toJsonFactory = _$StartupUserDtoToJson;
  Map<String, dynamic> toJson() => _$StartupUserDtoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Password')
  final String? password;
  static const fromJsonFactory = _$StartupUserDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StartupUserDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(password) ^
      runtimeType.hashCode;
}

extension $StartupUserDtoExtension on StartupUserDto {
  StartupUserDto copyWith({String? name, String? password}) {
    return StartupUserDto(
        name: name ?? this.name, password: password ?? this.password);
  }

  StartupUserDto copyWithWrapped(
      {Wrapped<String?>? name, Wrapped<String?>? password}) {
    return StartupUserDto(
        name: (name != null ? name.value : this.name),
        password: (password != null ? password.value : this.password));
  }
}

@JsonSerializable(explicitToJson: true)
class StringGroupUpdate {
  const StringGroupUpdate({
    this.groupId,
    this.type,
    this.data,
  });

  factory StringGroupUpdate.fromJson(Map<String, dynamic> json) =>
      _$StringGroupUpdateFromJson(json);

  static const toJsonFactory = _$StringGroupUpdateToJson;
  Map<String, dynamic> toJson() => _$StringGroupUpdateToJson(this);

  @JsonKey(name: 'GroupId')
  final String? groupId;
  @JsonKey(
    name: 'Type',
    toJson: groupUpdateTypeNullableToJson,
    fromJson: groupUpdateTypeNullableFromJson,
  )
  final enums.GroupUpdateType? type;
  @JsonKey(name: 'Data')
  final String? data;
  static const fromJsonFactory = _$StringGroupUpdateFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StringGroupUpdate &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $StringGroupUpdateExtension on StringGroupUpdate {
  StringGroupUpdate copyWith(
      {String? groupId, enums.GroupUpdateType? type, String? data}) {
    return StringGroupUpdate(
        groupId: groupId ?? this.groupId,
        type: type ?? this.type,
        data: data ?? this.data);
  }

  StringGroupUpdate copyWithWrapped(
      {Wrapped<String?>? groupId,
      Wrapped<enums.GroupUpdateType?>? type,
      Wrapped<String?>? data}) {
    return StringGroupUpdate(
        groupId: (groupId != null ? groupId.value : this.groupId),
        type: (type != null ? type.value : this.type),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class SubtitleOptions {
  const SubtitleOptions({
    this.skipIfEmbeddedSubtitlesPresent,
    this.skipIfAudioTrackMatches,
    this.downloadLanguages,
    this.downloadMovieSubtitles,
    this.downloadEpisodeSubtitles,
    this.openSubtitlesUsername,
    this.openSubtitlesPasswordHash,
    this.isOpenSubtitleVipAccount,
    this.requirePerfectMatch,
  });

  factory SubtitleOptions.fromJson(Map<String, dynamic> json) =>
      _$SubtitleOptionsFromJson(json);

  static const toJsonFactory = _$SubtitleOptionsToJson;
  Map<String, dynamic> toJson() => _$SubtitleOptionsToJson(this);

  @JsonKey(name: 'SkipIfEmbeddedSubtitlesPresent')
  final bool? skipIfEmbeddedSubtitlesPresent;
  @JsonKey(name: 'SkipIfAudioTrackMatches')
  final bool? skipIfAudioTrackMatches;
  @JsonKey(name: 'DownloadLanguages', defaultValue: <String>[])
  final List<String>? downloadLanguages;
  @JsonKey(name: 'DownloadMovieSubtitles')
  final bool? downloadMovieSubtitles;
  @JsonKey(name: 'DownloadEpisodeSubtitles')
  final bool? downloadEpisodeSubtitles;
  @JsonKey(name: 'OpenSubtitlesUsername')
  final String? openSubtitlesUsername;
  @JsonKey(name: 'OpenSubtitlesPasswordHash')
  final String? openSubtitlesPasswordHash;
  @JsonKey(name: 'IsOpenSubtitleVipAccount')
  final bool? isOpenSubtitleVipAccount;
  @JsonKey(name: 'RequirePerfectMatch')
  final bool? requirePerfectMatch;
  static const fromJsonFactory = _$SubtitleOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SubtitleOptions &&
            (identical(other.skipIfEmbeddedSubtitlesPresent, skipIfEmbeddedSubtitlesPresent) ||
                const DeepCollectionEquality().equals(
                    other.skipIfEmbeddedSubtitlesPresent,
                    skipIfEmbeddedSubtitlesPresent)) &&
            (identical(other.skipIfAudioTrackMatches, skipIfAudioTrackMatches) ||
                const DeepCollectionEquality().equals(
                    other.skipIfAudioTrackMatches, skipIfAudioTrackMatches)) &&
            (identical(other.downloadLanguages, downloadLanguages) ||
                const DeepCollectionEquality()
                    .equals(other.downloadLanguages, downloadLanguages)) &&
            (identical(other.downloadMovieSubtitles, downloadMovieSubtitles) ||
                const DeepCollectionEquality().equals(
                    other.downloadMovieSubtitles, downloadMovieSubtitles)) &&
            (identical(other.downloadEpisodeSubtitles, downloadEpisodeSubtitles) ||
                const DeepCollectionEquality().equals(
                    other.downloadEpisodeSubtitles,
                    downloadEpisodeSubtitles)) &&
            (identical(other.openSubtitlesUsername, openSubtitlesUsername) ||
                const DeepCollectionEquality().equals(
                    other.openSubtitlesUsername, openSubtitlesUsername)) &&
            (identical(other.openSubtitlesPasswordHash, openSubtitlesPasswordHash) ||
                const DeepCollectionEquality().equals(
                    other.openSubtitlesPasswordHash,
                    openSubtitlesPasswordHash)) &&
            (identical(other.isOpenSubtitleVipAccount, isOpenSubtitleVipAccount) ||
                const DeepCollectionEquality().equals(
                    other.isOpenSubtitleVipAccount,
                    isOpenSubtitleVipAccount)) &&
            (identical(other.requirePerfectMatch, requirePerfectMatch) ||
                const DeepCollectionEquality()
                    .equals(other.requirePerfectMatch, requirePerfectMatch)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(skipIfEmbeddedSubtitlesPresent) ^
      const DeepCollectionEquality().hash(skipIfAudioTrackMatches) ^
      const DeepCollectionEquality().hash(downloadLanguages) ^
      const DeepCollectionEquality().hash(downloadMovieSubtitles) ^
      const DeepCollectionEquality().hash(downloadEpisodeSubtitles) ^
      const DeepCollectionEquality().hash(openSubtitlesUsername) ^
      const DeepCollectionEquality().hash(openSubtitlesPasswordHash) ^
      const DeepCollectionEquality().hash(isOpenSubtitleVipAccount) ^
      const DeepCollectionEquality().hash(requirePerfectMatch) ^
      runtimeType.hashCode;
}

extension $SubtitleOptionsExtension on SubtitleOptions {
  SubtitleOptions copyWith(
      {bool? skipIfEmbeddedSubtitlesPresent,
      bool? skipIfAudioTrackMatches,
      List<String>? downloadLanguages,
      bool? downloadMovieSubtitles,
      bool? downloadEpisodeSubtitles,
      String? openSubtitlesUsername,
      String? openSubtitlesPasswordHash,
      bool? isOpenSubtitleVipAccount,
      bool? requirePerfectMatch}) {
    return SubtitleOptions(
        skipIfEmbeddedSubtitlesPresent: skipIfEmbeddedSubtitlesPresent ??
            this.skipIfEmbeddedSubtitlesPresent,
        skipIfAudioTrackMatches:
            skipIfAudioTrackMatches ?? this.skipIfAudioTrackMatches,
        downloadLanguages: downloadLanguages ?? this.downloadLanguages,
        downloadMovieSubtitles:
            downloadMovieSubtitles ?? this.downloadMovieSubtitles,
        downloadEpisodeSubtitles:
            downloadEpisodeSubtitles ?? this.downloadEpisodeSubtitles,
        openSubtitlesUsername:
            openSubtitlesUsername ?? this.openSubtitlesUsername,
        openSubtitlesPasswordHash:
            openSubtitlesPasswordHash ?? this.openSubtitlesPasswordHash,
        isOpenSubtitleVipAccount:
            isOpenSubtitleVipAccount ?? this.isOpenSubtitleVipAccount,
        requirePerfectMatch: requirePerfectMatch ?? this.requirePerfectMatch);
  }

  SubtitleOptions copyWithWrapped(
      {Wrapped<bool?>? skipIfEmbeddedSubtitlesPresent,
      Wrapped<bool?>? skipIfAudioTrackMatches,
      Wrapped<List<String>?>? downloadLanguages,
      Wrapped<bool?>? downloadMovieSubtitles,
      Wrapped<bool?>? downloadEpisodeSubtitles,
      Wrapped<String?>? openSubtitlesUsername,
      Wrapped<String?>? openSubtitlesPasswordHash,
      Wrapped<bool?>? isOpenSubtitleVipAccount,
      Wrapped<bool?>? requirePerfectMatch}) {
    return SubtitleOptions(
        skipIfEmbeddedSubtitlesPresent: (skipIfEmbeddedSubtitlesPresent != null
            ? skipIfEmbeddedSubtitlesPresent.value
            : this.skipIfEmbeddedSubtitlesPresent),
        skipIfAudioTrackMatches: (skipIfAudioTrackMatches != null
            ? skipIfAudioTrackMatches.value
            : this.skipIfAudioTrackMatches),
        downloadLanguages: (downloadLanguages != null
            ? downloadLanguages.value
            : this.downloadLanguages),
        downloadMovieSubtitles: (downloadMovieSubtitles != null
            ? downloadMovieSubtitles.value
            : this.downloadMovieSubtitles),
        downloadEpisodeSubtitles: (downloadEpisodeSubtitles != null
            ? downloadEpisodeSubtitles.value
            : this.downloadEpisodeSubtitles),
        openSubtitlesUsername: (openSubtitlesUsername != null
            ? openSubtitlesUsername.value
            : this.openSubtitlesUsername),
        openSubtitlesPasswordHash: (openSubtitlesPasswordHash != null
            ? openSubtitlesPasswordHash.value
            : this.openSubtitlesPasswordHash),
        isOpenSubtitleVipAccount: (isOpenSubtitleVipAccount != null
            ? isOpenSubtitleVipAccount.value
            : this.isOpenSubtitleVipAccount),
        requirePerfectMatch: (requirePerfectMatch != null
            ? requirePerfectMatch.value
            : this.requirePerfectMatch));
  }
}

@JsonSerializable(explicitToJson: true)
class SubtitleProfile {
  const SubtitleProfile({
    this.format,
    this.method,
    this.didlMode,
    this.language,
    this.container,
  });

  factory SubtitleProfile.fromJson(Map<String, dynamic> json) =>
      _$SubtitleProfileFromJson(json);

  static const toJsonFactory = _$SubtitleProfileToJson;
  Map<String, dynamic> toJson() => _$SubtitleProfileToJson(this);

  @JsonKey(name: 'Format')
  final String? format;
  @JsonKey(
    name: 'Method',
    toJson: subtitleDeliveryMethodNullableToJson,
    fromJson: subtitleDeliveryMethodNullableFromJson,
  )
  final enums.SubtitleDeliveryMethod? method;
  @JsonKey(name: 'DidlMode')
  final String? didlMode;
  @JsonKey(name: 'Language')
  final String? language;
  @JsonKey(name: 'Container')
  final String? container;
  static const fromJsonFactory = _$SubtitleProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SubtitleProfile &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.method, method) ||
                const DeepCollectionEquality().equals(other.method, method)) &&
            (identical(other.didlMode, didlMode) ||
                const DeepCollectionEquality()
                    .equals(other.didlMode, didlMode)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(method) ^
      const DeepCollectionEquality().hash(didlMode) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(container) ^
      runtimeType.hashCode;
}

extension $SubtitleProfileExtension on SubtitleProfile {
  SubtitleProfile copyWith(
      {String? format,
      enums.SubtitleDeliveryMethod? method,
      String? didlMode,
      String? language,
      String? container}) {
    return SubtitleProfile(
        format: format ?? this.format,
        method: method ?? this.method,
        didlMode: didlMode ?? this.didlMode,
        language: language ?? this.language,
        container: container ?? this.container);
  }

  SubtitleProfile copyWithWrapped(
      {Wrapped<String?>? format,
      Wrapped<enums.SubtitleDeliveryMethod?>? method,
      Wrapped<String?>? didlMode,
      Wrapped<String?>? language,
      Wrapped<String?>? container}) {
    return SubtitleProfile(
        format: (format != null ? format.value : this.format),
        method: (method != null ? method.value : this.method),
        didlMode: (didlMode != null ? didlMode.value : this.didlMode),
        language: (language != null ? language.value : this.language),
        container: (container != null ? container.value : this.container));
  }
}

@JsonSerializable(explicitToJson: true)
class SyncPlayCommandMessage {
  const SyncPlayCommandMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory SyncPlayCommandMessage.fromJson(Map<String, dynamic> json) =>
      _$SyncPlayCommandMessageFromJson(json);

  static const toJsonFactory = _$SyncPlayCommandMessageToJson;
  Map<String, dynamic> toJson() => _$SyncPlayCommandMessageToJson(this);

  @JsonKey(name: 'Data')
  final SendCommand? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.syncplaycommand);

  static const fromJsonFactory = _$SyncPlayCommandMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SyncPlayCommandMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $SyncPlayCommandMessageExtension on SyncPlayCommandMessage {
  SyncPlayCommandMessage copyWith(
      {SendCommand? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return SyncPlayCommandMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  SyncPlayCommandMessage copyWithWrapped(
      {Wrapped<SendCommand?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return SyncPlayCommandMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class SyncPlayGroupUpdateCommandMessage {
  const SyncPlayGroupUpdateCommandMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory SyncPlayGroupUpdateCommandMessage.fromJson(
          Map<String, dynamic> json) =>
      _$SyncPlayGroupUpdateCommandMessageFromJson(json);

  static const toJsonFactory = _$SyncPlayGroupUpdateCommandMessageToJson;
  Map<String, dynamic> toJson() =>
      _$SyncPlayGroupUpdateCommandMessageToJson(this);

  @JsonKey(name: 'Data')
  final GroupUpdate? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.syncplaygroupupdate);

  static const fromJsonFactory = _$SyncPlayGroupUpdateCommandMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SyncPlayGroupUpdateCommandMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $SyncPlayGroupUpdateCommandMessageExtension
    on SyncPlayGroupUpdateCommandMessage {
  SyncPlayGroupUpdateCommandMessage copyWith(
      {GroupUpdate? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return SyncPlayGroupUpdateCommandMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  SyncPlayGroupUpdateCommandMessage copyWithWrapped(
      {Wrapped<GroupUpdate?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return SyncPlayGroupUpdateCommandMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class SyncPlayQueueItem {
  const SyncPlayQueueItem({
    this.itemId,
    this.playlistItemId,
  });

  factory SyncPlayQueueItem.fromJson(Map<String, dynamic> json) =>
      _$SyncPlayQueueItemFromJson(json);

  static const toJsonFactory = _$SyncPlayQueueItemToJson;
  Map<String, dynamic> toJson() => _$SyncPlayQueueItemToJson(this);

  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'PlaylistItemId')
  final String? playlistItemId;
  static const fromJsonFactory = _$SyncPlayQueueItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SyncPlayQueueItem &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.playlistItemId, playlistItemId) ||
                const DeepCollectionEquality()
                    .equals(other.playlistItemId, playlistItemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(playlistItemId) ^
      runtimeType.hashCode;
}

extension $SyncPlayQueueItemExtension on SyncPlayQueueItem {
  SyncPlayQueueItem copyWith({String? itemId, String? playlistItemId}) {
    return SyncPlayQueueItem(
        itemId: itemId ?? this.itemId,
        playlistItemId: playlistItemId ?? this.playlistItemId);
  }

  SyncPlayQueueItem copyWithWrapped(
      {Wrapped<String?>? itemId, Wrapped<String?>? playlistItemId}) {
    return SyncPlayQueueItem(
        itemId: (itemId != null ? itemId.value : this.itemId),
        playlistItemId: (playlistItemId != null
            ? playlistItemId.value
            : this.playlistItemId));
  }
}

@JsonSerializable(explicitToJson: true)
class SystemInfo {
  const SystemInfo({
    this.localAddress,
    this.serverName,
    this.version,
    this.productName,
    this.operatingSystem,
    this.id,
    this.startupWizardCompleted,
    this.operatingSystemDisplayName,
    this.packageName,
    this.hasPendingRestart,
    this.isShuttingDown,
    this.supportsLibraryMonitor,
    this.webSocketPortNumber,
    this.completedInstallations,
    this.canSelfRestart,
    this.canLaunchWebBrowser,
    this.programDataPath,
    this.webPath,
    this.itemsByNamePath,
    this.cachePath,
    this.logPath,
    this.internalMetadataPath,
    this.transcodingTempPath,
    this.castReceiverApplications,
    this.hasUpdateAvailable,
    this.encoderLocation,
    this.systemArchitecture,
  });

  factory SystemInfo.fromJson(Map<String, dynamic> json) =>
      _$SystemInfoFromJson(json);

  static const toJsonFactory = _$SystemInfoToJson;
  Map<String, dynamic> toJson() => _$SystemInfoToJson(this);

  @JsonKey(name: 'LocalAddress')
  final String? localAddress;
  @JsonKey(name: 'ServerName')
  final String? serverName;
  @JsonKey(name: 'Version')
  final String? version;
  @JsonKey(name: 'ProductName')
  final String? productName;
  @JsonKey(name: 'OperatingSystem')
  @deprecated
  final String? operatingSystem;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'StartupWizardCompleted')
  final bool? startupWizardCompleted;
  @JsonKey(name: 'OperatingSystemDisplayName')
  @deprecated
  final String? operatingSystemDisplayName;
  @JsonKey(name: 'PackageName')
  final String? packageName;
  @JsonKey(name: 'HasPendingRestart')
  final bool? hasPendingRestart;
  @JsonKey(name: 'IsShuttingDown')
  final bool? isShuttingDown;
  @JsonKey(name: 'SupportsLibraryMonitor')
  final bool? supportsLibraryMonitor;
  @JsonKey(name: 'WebSocketPortNumber')
  final int? webSocketPortNumber;
  @JsonKey(name: 'CompletedInstallations', defaultValue: <InstallationInfo>[])
  final List<InstallationInfo>? completedInstallations;
  @JsonKey(name: 'CanSelfRestart', defaultValue: true)
  @deprecated
  final bool? canSelfRestart;
  @JsonKey(name: 'CanLaunchWebBrowser', defaultValue: false)
  @deprecated
  final bool? canLaunchWebBrowser;
  @JsonKey(name: 'ProgramDataPath')
  final String? programDataPath;
  @JsonKey(name: 'WebPath')
  final String? webPath;
  @JsonKey(name: 'ItemsByNamePath')
  final String? itemsByNamePath;
  @JsonKey(name: 'CachePath')
  final String? cachePath;
  @JsonKey(name: 'LogPath')
  final String? logPath;
  @JsonKey(name: 'InternalMetadataPath')
  final String? internalMetadataPath;
  @JsonKey(name: 'TranscodingTempPath')
  final String? transcodingTempPath;
  @JsonKey(
      name: 'CastReceiverApplications',
      defaultValue: <CastReceiverApplication>[])
  final List<CastReceiverApplication>? castReceiverApplications;
  @JsonKey(name: 'HasUpdateAvailable', defaultValue: false)
  @deprecated
  final bool? hasUpdateAvailable;
  @JsonKey(name: 'EncoderLocation')
  @deprecated
  final String? encoderLocation;
  @JsonKey(name: 'SystemArchitecture')
  @deprecated
  final String? systemArchitecture;
  static const fromJsonFactory = _$SystemInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SystemInfo &&
            (identical(other.localAddress, localAddress) ||
                const DeepCollectionEquality()
                    .equals(other.localAddress, localAddress)) &&
            (identical(other.serverName, serverName) ||
                const DeepCollectionEquality()
                    .equals(other.serverName, serverName)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.productName, productName) ||
                const DeepCollectionEquality()
                    .equals(other.productName, productName)) &&
            (identical(other.operatingSystem, operatingSystem) ||
                const DeepCollectionEquality()
                    .equals(other.operatingSystem, operatingSystem)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.startupWizardCompleted, startupWizardCompleted) ||
                const DeepCollectionEquality().equals(
                    other.startupWizardCompleted, startupWizardCompleted)) &&
            (identical(other.operatingSystemDisplayName, operatingSystemDisplayName) ||
                const DeepCollectionEquality().equals(
                    other.operatingSystemDisplayName,
                    operatingSystemDisplayName)) &&
            (identical(other.packageName, packageName) ||
                const DeepCollectionEquality()
                    .equals(other.packageName, packageName)) &&
            (identical(other.hasPendingRestart, hasPendingRestart) ||
                const DeepCollectionEquality()
                    .equals(other.hasPendingRestart, hasPendingRestart)) &&
            (identical(other.isShuttingDown, isShuttingDown) ||
                const DeepCollectionEquality()
                    .equals(other.isShuttingDown, isShuttingDown)) &&
            (identical(other.supportsLibraryMonitor, supportsLibraryMonitor) ||
                const DeepCollectionEquality().equals(
                    other.supportsLibraryMonitor, supportsLibraryMonitor)) &&
            (identical(other.webSocketPortNumber, webSocketPortNumber) ||
                const DeepCollectionEquality()
                    .equals(other.webSocketPortNumber, webSocketPortNumber)) &&
            (identical(other.completedInstallations, completedInstallations) ||
                const DeepCollectionEquality().equals(
                    other.completedInstallations, completedInstallations)) &&
            (identical(other.canSelfRestart, canSelfRestart) ||
                const DeepCollectionEquality()
                    .equals(other.canSelfRestart, canSelfRestart)) &&
            (identical(other.canLaunchWebBrowser, canLaunchWebBrowser) ||
                const DeepCollectionEquality()
                    .equals(other.canLaunchWebBrowser, canLaunchWebBrowser)) &&
            (identical(other.programDataPath, programDataPath) ||
                const DeepCollectionEquality()
                    .equals(other.programDataPath, programDataPath)) &&
            (identical(other.webPath, webPath) ||
                const DeepCollectionEquality()
                    .equals(other.webPath, webPath)) &&
            (identical(other.itemsByNamePath, itemsByNamePath) || const DeepCollectionEquality().equals(other.itemsByNamePath, itemsByNamePath)) &&
            (identical(other.cachePath, cachePath) || const DeepCollectionEquality().equals(other.cachePath, cachePath)) &&
            (identical(other.logPath, logPath) || const DeepCollectionEquality().equals(other.logPath, logPath)) &&
            (identical(other.internalMetadataPath, internalMetadataPath) || const DeepCollectionEquality().equals(other.internalMetadataPath, internalMetadataPath)) &&
            (identical(other.transcodingTempPath, transcodingTempPath) || const DeepCollectionEquality().equals(other.transcodingTempPath, transcodingTempPath)) &&
            (identical(other.castReceiverApplications, castReceiverApplications) || const DeepCollectionEquality().equals(other.castReceiverApplications, castReceiverApplications)) &&
            (identical(other.hasUpdateAvailable, hasUpdateAvailable) || const DeepCollectionEquality().equals(other.hasUpdateAvailable, hasUpdateAvailable)) &&
            (identical(other.encoderLocation, encoderLocation) || const DeepCollectionEquality().equals(other.encoderLocation, encoderLocation)) &&
            (identical(other.systemArchitecture, systemArchitecture) || const DeepCollectionEquality().equals(other.systemArchitecture, systemArchitecture)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(localAddress) ^
      const DeepCollectionEquality().hash(serverName) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(productName) ^
      const DeepCollectionEquality().hash(operatingSystem) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(startupWizardCompleted) ^
      const DeepCollectionEquality().hash(operatingSystemDisplayName) ^
      const DeepCollectionEquality().hash(packageName) ^
      const DeepCollectionEquality().hash(hasPendingRestart) ^
      const DeepCollectionEquality().hash(isShuttingDown) ^
      const DeepCollectionEquality().hash(supportsLibraryMonitor) ^
      const DeepCollectionEquality().hash(webSocketPortNumber) ^
      const DeepCollectionEquality().hash(completedInstallations) ^
      const DeepCollectionEquality().hash(canSelfRestart) ^
      const DeepCollectionEquality().hash(canLaunchWebBrowser) ^
      const DeepCollectionEquality().hash(programDataPath) ^
      const DeepCollectionEquality().hash(webPath) ^
      const DeepCollectionEquality().hash(itemsByNamePath) ^
      const DeepCollectionEquality().hash(cachePath) ^
      const DeepCollectionEquality().hash(logPath) ^
      const DeepCollectionEquality().hash(internalMetadataPath) ^
      const DeepCollectionEquality().hash(transcodingTempPath) ^
      const DeepCollectionEquality().hash(castReceiverApplications) ^
      const DeepCollectionEquality().hash(hasUpdateAvailable) ^
      const DeepCollectionEquality().hash(encoderLocation) ^
      const DeepCollectionEquality().hash(systemArchitecture) ^
      runtimeType.hashCode;
}

extension $SystemInfoExtension on SystemInfo {
  SystemInfo copyWith(
      {String? localAddress,
      String? serverName,
      String? version,
      String? productName,
      String? operatingSystem,
      String? id,
      bool? startupWizardCompleted,
      String? operatingSystemDisplayName,
      String? packageName,
      bool? hasPendingRestart,
      bool? isShuttingDown,
      bool? supportsLibraryMonitor,
      int? webSocketPortNumber,
      List<InstallationInfo>? completedInstallations,
      bool? canSelfRestart,
      bool? canLaunchWebBrowser,
      String? programDataPath,
      String? webPath,
      String? itemsByNamePath,
      String? cachePath,
      String? logPath,
      String? internalMetadataPath,
      String? transcodingTempPath,
      List<CastReceiverApplication>? castReceiverApplications,
      bool? hasUpdateAvailable,
      String? encoderLocation,
      String? systemArchitecture}) {
    return SystemInfo(
        localAddress: localAddress ?? this.localAddress,
        serverName: serverName ?? this.serverName,
        version: version ?? this.version,
        productName: productName ?? this.productName,
        operatingSystem: operatingSystem ?? this.operatingSystem,
        id: id ?? this.id,
        startupWizardCompleted:
            startupWizardCompleted ?? this.startupWizardCompleted,
        operatingSystemDisplayName:
            operatingSystemDisplayName ?? this.operatingSystemDisplayName,
        packageName: packageName ?? this.packageName,
        hasPendingRestart: hasPendingRestart ?? this.hasPendingRestart,
        isShuttingDown: isShuttingDown ?? this.isShuttingDown,
        supportsLibraryMonitor:
            supportsLibraryMonitor ?? this.supportsLibraryMonitor,
        webSocketPortNumber: webSocketPortNumber ?? this.webSocketPortNumber,
        completedInstallations:
            completedInstallations ?? this.completedInstallations,
        canSelfRestart: canSelfRestart ?? this.canSelfRestart,
        canLaunchWebBrowser: canLaunchWebBrowser ?? this.canLaunchWebBrowser,
        programDataPath: programDataPath ?? this.programDataPath,
        webPath: webPath ?? this.webPath,
        itemsByNamePath: itemsByNamePath ?? this.itemsByNamePath,
        cachePath: cachePath ?? this.cachePath,
        logPath: logPath ?? this.logPath,
        internalMetadataPath: internalMetadataPath ?? this.internalMetadataPath,
        transcodingTempPath: transcodingTempPath ?? this.transcodingTempPath,
        castReceiverApplications:
            castReceiverApplications ?? this.castReceiverApplications,
        hasUpdateAvailable: hasUpdateAvailable ?? this.hasUpdateAvailable,
        encoderLocation: encoderLocation ?? this.encoderLocation,
        systemArchitecture: systemArchitecture ?? this.systemArchitecture);
  }

  SystemInfo copyWithWrapped(
      {Wrapped<String?>? localAddress,
      Wrapped<String?>? serverName,
      Wrapped<String?>? version,
      Wrapped<String?>? productName,
      Wrapped<String?>? operatingSystem,
      Wrapped<String?>? id,
      Wrapped<bool?>? startupWizardCompleted,
      Wrapped<String?>? operatingSystemDisplayName,
      Wrapped<String?>? packageName,
      Wrapped<bool?>? hasPendingRestart,
      Wrapped<bool?>? isShuttingDown,
      Wrapped<bool?>? supportsLibraryMonitor,
      Wrapped<int?>? webSocketPortNumber,
      Wrapped<List<InstallationInfo>?>? completedInstallations,
      Wrapped<bool?>? canSelfRestart,
      Wrapped<bool?>? canLaunchWebBrowser,
      Wrapped<String?>? programDataPath,
      Wrapped<String?>? webPath,
      Wrapped<String?>? itemsByNamePath,
      Wrapped<String?>? cachePath,
      Wrapped<String?>? logPath,
      Wrapped<String?>? internalMetadataPath,
      Wrapped<String?>? transcodingTempPath,
      Wrapped<List<CastReceiverApplication>?>? castReceiverApplications,
      Wrapped<bool?>? hasUpdateAvailable,
      Wrapped<String?>? encoderLocation,
      Wrapped<String?>? systemArchitecture}) {
    return SystemInfo(
        localAddress:
            (localAddress != null ? localAddress.value : this.localAddress),
        serverName: (serverName != null ? serverName.value : this.serverName),
        version: (version != null ? version.value : this.version),
        productName:
            (productName != null ? productName.value : this.productName),
        operatingSystem: (operatingSystem != null
            ? operatingSystem.value
            : this.operatingSystem),
        id: (id != null ? id.value : this.id),
        startupWizardCompleted: (startupWizardCompleted != null
            ? startupWizardCompleted.value
            : this.startupWizardCompleted),
        operatingSystemDisplayName: (operatingSystemDisplayName != null
            ? operatingSystemDisplayName.value
            : this.operatingSystemDisplayName),
        packageName:
            (packageName != null ? packageName.value : this.packageName),
        hasPendingRestart: (hasPendingRestart != null
            ? hasPendingRestart.value
            : this.hasPendingRestart),
        isShuttingDown: (isShuttingDown != null
            ? isShuttingDown.value
            : this.isShuttingDown),
        supportsLibraryMonitor: (supportsLibraryMonitor != null
            ? supportsLibraryMonitor.value
            : this.supportsLibraryMonitor),
        webSocketPortNumber: (webSocketPortNumber != null
            ? webSocketPortNumber.value
            : this.webSocketPortNumber),
        completedInstallations: (completedInstallations != null
            ? completedInstallations.value
            : this.completedInstallations),
        canSelfRestart: (canSelfRestart != null
            ? canSelfRestart.value
            : this.canSelfRestart),
        canLaunchWebBrowser: (canLaunchWebBrowser != null
            ? canLaunchWebBrowser.value
            : this.canLaunchWebBrowser),
        programDataPath: (programDataPath != null
            ? programDataPath.value
            : this.programDataPath),
        webPath: (webPath != null ? webPath.value : this.webPath),
        itemsByNamePath: (itemsByNamePath != null
            ? itemsByNamePath.value
            : this.itemsByNamePath),
        cachePath: (cachePath != null ? cachePath.value : this.cachePath),
        logPath: (logPath != null ? logPath.value : this.logPath),
        internalMetadataPath: (internalMetadataPath != null
            ? internalMetadataPath.value
            : this.internalMetadataPath),
        transcodingTempPath: (transcodingTempPath != null
            ? transcodingTempPath.value
            : this.transcodingTempPath),
        castReceiverApplications: (castReceiverApplications != null
            ? castReceiverApplications.value
            : this.castReceiverApplications),
        hasUpdateAvailable: (hasUpdateAvailable != null
            ? hasUpdateAvailable.value
            : this.hasUpdateAvailable),
        encoderLocation: (encoderLocation != null
            ? encoderLocation.value
            : this.encoderLocation),
        systemArchitecture: (systemArchitecture != null
            ? systemArchitecture.value
            : this.systemArchitecture));
  }
}

@JsonSerializable(explicitToJson: true)
class TaskInfo {
  const TaskInfo({
    this.name,
    this.state,
    this.currentProgressPercentage,
    this.id,
    this.lastExecutionResult,
    this.triggers,
    this.description,
    this.category,
    this.isHidden,
    this.key,
  });

  factory TaskInfo.fromJson(Map<String, dynamic> json) =>
      _$TaskInfoFromJson(json);

  static const toJsonFactory = _$TaskInfoToJson;
  Map<String, dynamic> toJson() => _$TaskInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(
    name: 'State',
    toJson: taskStateNullableToJson,
    fromJson: taskStateNullableFromJson,
  )
  final enums.TaskState? state;
  @JsonKey(name: 'CurrentProgressPercentage')
  final double? currentProgressPercentage;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'LastExecutionResult')
  final TaskResult? lastExecutionResult;
  @JsonKey(name: 'Triggers', defaultValue: <TaskTriggerInfo>[])
  final List<TaskTriggerInfo>? triggers;
  @JsonKey(name: 'Description')
  final String? description;
  @JsonKey(name: 'Category')
  final String? category;
  @JsonKey(name: 'IsHidden')
  final bool? isHidden;
  @JsonKey(name: 'Key')
  final String? key;
  static const fromJsonFactory = _$TaskInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TaskInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.currentProgressPercentage,
                    currentProgressPercentage) ||
                const DeepCollectionEquality().equals(
                    other.currentProgressPercentage,
                    currentProgressPercentage)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.lastExecutionResult, lastExecutionResult) ||
                const DeepCollectionEquality()
                    .equals(other.lastExecutionResult, lastExecutionResult)) &&
            (identical(other.triggers, triggers) ||
                const DeepCollectionEquality()
                    .equals(other.triggers, triggers)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.isHidden, isHidden) ||
                const DeepCollectionEquality()
                    .equals(other.isHidden, isHidden)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(currentProgressPercentage) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(lastExecutionResult) ^
      const DeepCollectionEquality().hash(triggers) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(isHidden) ^
      const DeepCollectionEquality().hash(key) ^
      runtimeType.hashCode;
}

extension $TaskInfoExtension on TaskInfo {
  TaskInfo copyWith(
      {String? name,
      enums.TaskState? state,
      double? currentProgressPercentage,
      String? id,
      TaskResult? lastExecutionResult,
      List<TaskTriggerInfo>? triggers,
      String? description,
      String? category,
      bool? isHidden,
      String? key}) {
    return TaskInfo(
        name: name ?? this.name,
        state: state ?? this.state,
        currentProgressPercentage:
            currentProgressPercentage ?? this.currentProgressPercentage,
        id: id ?? this.id,
        lastExecutionResult: lastExecutionResult ?? this.lastExecutionResult,
        triggers: triggers ?? this.triggers,
        description: description ?? this.description,
        category: category ?? this.category,
        isHidden: isHidden ?? this.isHidden,
        key: key ?? this.key);
  }

  TaskInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<enums.TaskState?>? state,
      Wrapped<double?>? currentProgressPercentage,
      Wrapped<String?>? id,
      Wrapped<TaskResult?>? lastExecutionResult,
      Wrapped<List<TaskTriggerInfo>?>? triggers,
      Wrapped<String?>? description,
      Wrapped<String?>? category,
      Wrapped<bool?>? isHidden,
      Wrapped<String?>? key}) {
    return TaskInfo(
        name: (name != null ? name.value : this.name),
        state: (state != null ? state.value : this.state),
        currentProgressPercentage: (currentProgressPercentage != null
            ? currentProgressPercentage.value
            : this.currentProgressPercentage),
        id: (id != null ? id.value : this.id),
        lastExecutionResult: (lastExecutionResult != null
            ? lastExecutionResult.value
            : this.lastExecutionResult),
        triggers: (triggers != null ? triggers.value : this.triggers),
        description:
            (description != null ? description.value : this.description),
        category: (category != null ? category.value : this.category),
        isHidden: (isHidden != null ? isHidden.value : this.isHidden),
        key: (key != null ? key.value : this.key));
  }
}

@JsonSerializable(explicitToJson: true)
class TaskResult {
  const TaskResult({
    this.startTimeUtc,
    this.endTimeUtc,
    this.status,
    this.name,
    this.key,
    this.id,
    this.errorMessage,
    this.longErrorMessage,
  });

  factory TaskResult.fromJson(Map<String, dynamic> json) =>
      _$TaskResultFromJson(json);

  static const toJsonFactory = _$TaskResultToJson;
  Map<String, dynamic> toJson() => _$TaskResultToJson(this);

  @JsonKey(name: 'StartTimeUtc')
  final DateTime? startTimeUtc;
  @JsonKey(name: 'EndTimeUtc')
  final DateTime? endTimeUtc;
  @JsonKey(
    name: 'Status',
    toJson: taskCompletionStatusNullableToJson,
    fromJson: taskCompletionStatusNullableFromJson,
  )
  final enums.TaskCompletionStatus? status;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Key')
  final String? key;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'ErrorMessage')
  final String? errorMessage;
  @JsonKey(name: 'LongErrorMessage')
  final String? longErrorMessage;
  static const fromJsonFactory = _$TaskResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TaskResult &&
            (identical(other.startTimeUtc, startTimeUtc) ||
                const DeepCollectionEquality()
                    .equals(other.startTimeUtc, startTimeUtc)) &&
            (identical(other.endTimeUtc, endTimeUtc) ||
                const DeepCollectionEquality()
                    .equals(other.endTimeUtc, endTimeUtc)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)) &&
            (identical(other.longErrorMessage, longErrorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.longErrorMessage, longErrorMessage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startTimeUtc) ^
      const DeepCollectionEquality().hash(endTimeUtc) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      const DeepCollectionEquality().hash(longErrorMessage) ^
      runtimeType.hashCode;
}

extension $TaskResultExtension on TaskResult {
  TaskResult copyWith(
      {DateTime? startTimeUtc,
      DateTime? endTimeUtc,
      enums.TaskCompletionStatus? status,
      String? name,
      String? key,
      String? id,
      String? errorMessage,
      String? longErrorMessage}) {
    return TaskResult(
        startTimeUtc: startTimeUtc ?? this.startTimeUtc,
        endTimeUtc: endTimeUtc ?? this.endTimeUtc,
        status: status ?? this.status,
        name: name ?? this.name,
        key: key ?? this.key,
        id: id ?? this.id,
        errorMessage: errorMessage ?? this.errorMessage,
        longErrorMessage: longErrorMessage ?? this.longErrorMessage);
  }

  TaskResult copyWithWrapped(
      {Wrapped<DateTime?>? startTimeUtc,
      Wrapped<DateTime?>? endTimeUtc,
      Wrapped<enums.TaskCompletionStatus?>? status,
      Wrapped<String?>? name,
      Wrapped<String?>? key,
      Wrapped<String?>? id,
      Wrapped<String?>? errorMessage,
      Wrapped<String?>? longErrorMessage}) {
    return TaskResult(
        startTimeUtc:
            (startTimeUtc != null ? startTimeUtc.value : this.startTimeUtc),
        endTimeUtc: (endTimeUtc != null ? endTimeUtc.value : this.endTimeUtc),
        status: (status != null ? status.value : this.status),
        name: (name != null ? name.value : this.name),
        key: (key != null ? key.value : this.key),
        id: (id != null ? id.value : this.id),
        errorMessage:
            (errorMessage != null ? errorMessage.value : this.errorMessage),
        longErrorMessage: (longErrorMessage != null
            ? longErrorMessage.value
            : this.longErrorMessage));
  }
}

@JsonSerializable(explicitToJson: true)
class TaskTriggerInfo {
  const TaskTriggerInfo({
    this.type,
    this.timeOfDayTicks,
    this.intervalTicks,
    this.dayOfWeek,
    this.maxRuntimeTicks,
  });

  factory TaskTriggerInfo.fromJson(Map<String, dynamic> json) =>
      _$TaskTriggerInfoFromJson(json);

  static const toJsonFactory = _$TaskTriggerInfoToJson;
  Map<String, dynamic> toJson() => _$TaskTriggerInfoToJson(this);

  @JsonKey(name: 'Type')
  final String? type;
  @JsonKey(name: 'TimeOfDayTicks')
  final int? timeOfDayTicks;
  @JsonKey(name: 'IntervalTicks')
  final int? intervalTicks;
  @JsonKey(
    name: 'DayOfWeek',
    toJson: dayOfWeekNullableToJson,
    fromJson: dayOfWeekNullableFromJson,
  )
  final enums.DayOfWeek? dayOfWeek;
  @JsonKey(name: 'MaxRuntimeTicks')
  final int? maxRuntimeTicks;
  static const fromJsonFactory = _$TaskTriggerInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TaskTriggerInfo &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.timeOfDayTicks, timeOfDayTicks) ||
                const DeepCollectionEquality()
                    .equals(other.timeOfDayTicks, timeOfDayTicks)) &&
            (identical(other.intervalTicks, intervalTicks) ||
                const DeepCollectionEquality()
                    .equals(other.intervalTicks, intervalTicks)) &&
            (identical(other.dayOfWeek, dayOfWeek) ||
                const DeepCollectionEquality()
                    .equals(other.dayOfWeek, dayOfWeek)) &&
            (identical(other.maxRuntimeTicks, maxRuntimeTicks) ||
                const DeepCollectionEquality()
                    .equals(other.maxRuntimeTicks, maxRuntimeTicks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(timeOfDayTicks) ^
      const DeepCollectionEquality().hash(intervalTicks) ^
      const DeepCollectionEquality().hash(dayOfWeek) ^
      const DeepCollectionEquality().hash(maxRuntimeTicks) ^
      runtimeType.hashCode;
}

extension $TaskTriggerInfoExtension on TaskTriggerInfo {
  TaskTriggerInfo copyWith(
      {String? type,
      int? timeOfDayTicks,
      int? intervalTicks,
      enums.DayOfWeek? dayOfWeek,
      int? maxRuntimeTicks}) {
    return TaskTriggerInfo(
        type: type ?? this.type,
        timeOfDayTicks: timeOfDayTicks ?? this.timeOfDayTicks,
        intervalTicks: intervalTicks ?? this.intervalTicks,
        dayOfWeek: dayOfWeek ?? this.dayOfWeek,
        maxRuntimeTicks: maxRuntimeTicks ?? this.maxRuntimeTicks);
  }

  TaskTriggerInfo copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<int?>? timeOfDayTicks,
      Wrapped<int?>? intervalTicks,
      Wrapped<enums.DayOfWeek?>? dayOfWeek,
      Wrapped<int?>? maxRuntimeTicks}) {
    return TaskTriggerInfo(
        type: (type != null ? type.value : this.type),
        timeOfDayTicks: (timeOfDayTicks != null
            ? timeOfDayTicks.value
            : this.timeOfDayTicks),
        intervalTicks:
            (intervalTicks != null ? intervalTicks.value : this.intervalTicks),
        dayOfWeek: (dayOfWeek != null ? dayOfWeek.value : this.dayOfWeek),
        maxRuntimeTicks: (maxRuntimeTicks != null
            ? maxRuntimeTicks.value
            : this.maxRuntimeTicks));
  }
}

@JsonSerializable(explicitToJson: true)
class ThemeMediaResult {
  const ThemeMediaResult({
    this.items,
    this.totalRecordCount,
    this.startIndex,
    this.ownerId,
  });

  factory ThemeMediaResult.fromJson(Map<String, dynamic> json) =>
      _$ThemeMediaResultFromJson(json);

  static const toJsonFactory = _$ThemeMediaResultToJson;
  Map<String, dynamic> toJson() => _$ThemeMediaResultToJson(this);

  @JsonKey(name: 'Items', defaultValue: <BaseItemDto>[])
  final List<BaseItemDto>? items;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  @JsonKey(name: 'OwnerId')
  final String? ownerId;
  static const fromJsonFactory = _$ThemeMediaResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ThemeMediaResult &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)) &&
            (identical(other.ownerId, ownerId) ||
                const DeepCollectionEquality().equals(other.ownerId, ownerId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      const DeepCollectionEquality().hash(startIndex) ^
      const DeepCollectionEquality().hash(ownerId) ^
      runtimeType.hashCode;
}

extension $ThemeMediaResultExtension on ThemeMediaResult {
  ThemeMediaResult copyWith(
      {List<BaseItemDto>? items,
      int? totalRecordCount,
      int? startIndex,
      String? ownerId}) {
    return ThemeMediaResult(
        items: items ?? this.items,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount,
        startIndex: startIndex ?? this.startIndex,
        ownerId: ownerId ?? this.ownerId);
  }

  ThemeMediaResult copyWithWrapped(
      {Wrapped<List<BaseItemDto>?>? items,
      Wrapped<int?>? totalRecordCount,
      Wrapped<int?>? startIndex,
      Wrapped<String?>? ownerId}) {
    return ThemeMediaResult(
        items: (items != null ? items.value : this.items),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex),
        ownerId: (ownerId != null ? ownerId.value : this.ownerId));
  }
}

@JsonSerializable(explicitToJson: true)
class TimerCancelledMessage {
  const TimerCancelledMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory TimerCancelledMessage.fromJson(Map<String, dynamic> json) =>
      _$TimerCancelledMessageFromJson(json);

  static const toJsonFactory = _$TimerCancelledMessageToJson;
  Map<String, dynamic> toJson() => _$TimerCancelledMessageToJson(this);

  @JsonKey(name: 'Data')
  final TimerEventInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.timercancelled);

  static const fromJsonFactory = _$TimerCancelledMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimerCancelledMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $TimerCancelledMessageExtension on TimerCancelledMessage {
  TimerCancelledMessage copyWith(
      {TimerEventInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return TimerCancelledMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  TimerCancelledMessage copyWithWrapped(
      {Wrapped<TimerEventInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return TimerCancelledMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class TimerCreatedMessage {
  const TimerCreatedMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory TimerCreatedMessage.fromJson(Map<String, dynamic> json) =>
      _$TimerCreatedMessageFromJson(json);

  static const toJsonFactory = _$TimerCreatedMessageToJson;
  Map<String, dynamic> toJson() => _$TimerCreatedMessageToJson(this);

  @JsonKey(name: 'Data')
  final TimerEventInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.timercreated);

  static const fromJsonFactory = _$TimerCreatedMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimerCreatedMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $TimerCreatedMessageExtension on TimerCreatedMessage {
  TimerCreatedMessage copyWith(
      {TimerEventInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return TimerCreatedMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  TimerCreatedMessage copyWithWrapped(
      {Wrapped<TimerEventInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return TimerCreatedMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class TimerEventInfo {
  const TimerEventInfo({
    this.id,
    this.programId,
  });

  factory TimerEventInfo.fromJson(Map<String, dynamic> json) =>
      _$TimerEventInfoFromJson(json);

  static const toJsonFactory = _$TimerEventInfoToJson;
  Map<String, dynamic> toJson() => _$TimerEventInfoToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'ProgramId')
  final String? programId;
  static const fromJsonFactory = _$TimerEventInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimerEventInfo &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.programId, programId) ||
                const DeepCollectionEquality()
                    .equals(other.programId, programId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(programId) ^
      runtimeType.hashCode;
}

extension $TimerEventInfoExtension on TimerEventInfo {
  TimerEventInfo copyWith({String? id, String? programId}) {
    return TimerEventInfo(
        id: id ?? this.id, programId: programId ?? this.programId);
  }

  TimerEventInfo copyWithWrapped(
      {Wrapped<String?>? id, Wrapped<String?>? programId}) {
    return TimerEventInfo(
        id: (id != null ? id.value : this.id),
        programId: (programId != null ? programId.value : this.programId));
  }
}

@JsonSerializable(explicitToJson: true)
class TimerInfoDto {
  const TimerInfoDto({
    this.id,
    this.type,
    this.serverId,
    this.externalId,
    this.channelId,
    this.externalChannelId,
    this.channelName,
    this.channelPrimaryImageTag,
    this.programId,
    this.externalProgramId,
    this.name,
    this.overview,
    this.startDate,
    this.endDate,
    this.serviceName,
    this.priority,
    this.prePaddingSeconds,
    this.postPaddingSeconds,
    this.isPrePaddingRequired,
    this.parentBackdropItemId,
    this.parentBackdropImageTags,
    this.isPostPaddingRequired,
    this.keepUntil,
    this.status,
    this.seriesTimerId,
    this.externalSeriesTimerId,
    this.runTimeTicks,
    this.programInfo,
  });

  factory TimerInfoDto.fromJson(Map<String, dynamic> json) =>
      _$TimerInfoDtoFromJson(json);

  static const toJsonFactory = _$TimerInfoDtoToJson;
  Map<String, dynamic> toJson() => _$TimerInfoDtoToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Type')
  final String? type;
  @JsonKey(name: 'ServerId')
  final String? serverId;
  @JsonKey(name: 'ExternalId')
  final String? externalId;
  @JsonKey(name: 'ChannelId')
  final String? channelId;
  @JsonKey(name: 'ExternalChannelId')
  final String? externalChannelId;
  @JsonKey(name: 'ChannelName')
  final String? channelName;
  @JsonKey(name: 'ChannelPrimaryImageTag')
  final String? channelPrimaryImageTag;
  @JsonKey(name: 'ProgramId')
  final String? programId;
  @JsonKey(name: 'ExternalProgramId')
  final String? externalProgramId;
  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Overview')
  final String? overview;
  @JsonKey(name: 'StartDate')
  final DateTime? startDate;
  @JsonKey(name: 'EndDate')
  final DateTime? endDate;
  @JsonKey(name: 'ServiceName')
  final String? serviceName;
  @JsonKey(name: 'Priority')
  final int? priority;
  @JsonKey(name: 'PrePaddingSeconds')
  final int? prePaddingSeconds;
  @JsonKey(name: 'PostPaddingSeconds')
  final int? postPaddingSeconds;
  @JsonKey(name: 'IsPrePaddingRequired')
  final bool? isPrePaddingRequired;
  @JsonKey(name: 'ParentBackdropItemId')
  final String? parentBackdropItemId;
  @JsonKey(name: 'ParentBackdropImageTags', defaultValue: <String>[])
  final List<String>? parentBackdropImageTags;
  @JsonKey(name: 'IsPostPaddingRequired')
  final bool? isPostPaddingRequired;
  @JsonKey(
    name: 'KeepUntil',
    toJson: keepUntilNullableToJson,
    fromJson: keepUntilNullableFromJson,
  )
  final enums.KeepUntil? keepUntil;
  @JsonKey(
    name: 'Status',
    toJson: recordingStatusNullableToJson,
    fromJson: recordingStatusNullableFromJson,
  )
  final enums.RecordingStatus? status;
  @JsonKey(name: 'SeriesTimerId')
  final String? seriesTimerId;
  @JsonKey(name: 'ExternalSeriesTimerId')
  final String? externalSeriesTimerId;
  @JsonKey(name: 'RunTimeTicks')
  final int? runTimeTicks;
  @JsonKey(name: 'ProgramInfo')
  final BaseItemDto? programInfo;
  static const fromJsonFactory = _$TimerInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimerInfoDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.serverId, serverId) ||
                const DeepCollectionEquality()
                    .equals(other.serverId, serverId)) &&
            (identical(other.externalId, externalId) ||
                const DeepCollectionEquality()
                    .equals(other.externalId, externalId)) &&
            (identical(other.channelId, channelId) ||
                const DeepCollectionEquality()
                    .equals(other.channelId, channelId)) &&
            (identical(other.externalChannelId, externalChannelId) ||
                const DeepCollectionEquality()
                    .equals(other.externalChannelId, externalChannelId)) &&
            (identical(other.channelName, channelName) ||
                const DeepCollectionEquality()
                    .equals(other.channelName, channelName)) &&
            (identical(other.channelPrimaryImageTag, channelPrimaryImageTag) ||
                const DeepCollectionEquality().equals(
                    other.channelPrimaryImageTag, channelPrimaryImageTag)) &&
            (identical(other.programId, programId) ||
                const DeepCollectionEquality()
                    .equals(other.programId, programId)) &&
            (identical(other.externalProgramId, externalProgramId) ||
                const DeepCollectionEquality()
                    .equals(other.externalProgramId, externalProgramId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.overview, overview) ||
                const DeepCollectionEquality()
                    .equals(other.overview, overview)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.serviceName, serviceName) ||
                const DeepCollectionEquality()
                    .equals(other.serviceName, serviceName)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.prePaddingSeconds, prePaddingSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.prePaddingSeconds, prePaddingSeconds)) &&
            (identical(other.postPaddingSeconds, postPaddingSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.postPaddingSeconds, postPaddingSeconds)) &&
            (identical(other.isPrePaddingRequired, isPrePaddingRequired) ||
                const DeepCollectionEquality().equals(
                    other.isPrePaddingRequired, isPrePaddingRequired)) &&
            (identical(other.parentBackdropItemId, parentBackdropItemId) ||
                const DeepCollectionEquality().equals(
                    other.parentBackdropItemId, parentBackdropItemId)) &&
            (identical(other.parentBackdropImageTags, parentBackdropImageTags) ||
                const DeepCollectionEquality().equals(
                    other.parentBackdropImageTags, parentBackdropImageTags)) &&
            (identical(other.isPostPaddingRequired, isPostPaddingRequired) ||
                const DeepCollectionEquality().equals(
                    other.isPostPaddingRequired, isPostPaddingRequired)) &&
            (identical(other.keepUntil, keepUntil) || const DeepCollectionEquality().equals(other.keepUntil, keepUntil)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.seriesTimerId, seriesTimerId) || const DeepCollectionEquality().equals(other.seriesTimerId, seriesTimerId)) &&
            (identical(other.externalSeriesTimerId, externalSeriesTimerId) || const DeepCollectionEquality().equals(other.externalSeriesTimerId, externalSeriesTimerId)) &&
            (identical(other.runTimeTicks, runTimeTicks) || const DeepCollectionEquality().equals(other.runTimeTicks, runTimeTicks)) &&
            (identical(other.programInfo, programInfo) || const DeepCollectionEquality().equals(other.programInfo, programInfo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(serverId) ^
      const DeepCollectionEquality().hash(externalId) ^
      const DeepCollectionEquality().hash(channelId) ^
      const DeepCollectionEquality().hash(externalChannelId) ^
      const DeepCollectionEquality().hash(channelName) ^
      const DeepCollectionEquality().hash(channelPrimaryImageTag) ^
      const DeepCollectionEquality().hash(programId) ^
      const DeepCollectionEquality().hash(externalProgramId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(overview) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(serviceName) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(prePaddingSeconds) ^
      const DeepCollectionEquality().hash(postPaddingSeconds) ^
      const DeepCollectionEquality().hash(isPrePaddingRequired) ^
      const DeepCollectionEquality().hash(parentBackdropItemId) ^
      const DeepCollectionEquality().hash(parentBackdropImageTags) ^
      const DeepCollectionEquality().hash(isPostPaddingRequired) ^
      const DeepCollectionEquality().hash(keepUntil) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(seriesTimerId) ^
      const DeepCollectionEquality().hash(externalSeriesTimerId) ^
      const DeepCollectionEquality().hash(runTimeTicks) ^
      const DeepCollectionEquality().hash(programInfo) ^
      runtimeType.hashCode;
}

extension $TimerInfoDtoExtension on TimerInfoDto {
  TimerInfoDto copyWith(
      {String? id,
      String? type,
      String? serverId,
      String? externalId,
      String? channelId,
      String? externalChannelId,
      String? channelName,
      String? channelPrimaryImageTag,
      String? programId,
      String? externalProgramId,
      String? name,
      String? overview,
      DateTime? startDate,
      DateTime? endDate,
      String? serviceName,
      int? priority,
      int? prePaddingSeconds,
      int? postPaddingSeconds,
      bool? isPrePaddingRequired,
      String? parentBackdropItemId,
      List<String>? parentBackdropImageTags,
      bool? isPostPaddingRequired,
      enums.KeepUntil? keepUntil,
      enums.RecordingStatus? status,
      String? seriesTimerId,
      String? externalSeriesTimerId,
      int? runTimeTicks,
      BaseItemDto? programInfo}) {
    return TimerInfoDto(
        id: id ?? this.id,
        type: type ?? this.type,
        serverId: serverId ?? this.serverId,
        externalId: externalId ?? this.externalId,
        channelId: channelId ?? this.channelId,
        externalChannelId: externalChannelId ?? this.externalChannelId,
        channelName: channelName ?? this.channelName,
        channelPrimaryImageTag:
            channelPrimaryImageTag ?? this.channelPrimaryImageTag,
        programId: programId ?? this.programId,
        externalProgramId: externalProgramId ?? this.externalProgramId,
        name: name ?? this.name,
        overview: overview ?? this.overview,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        serviceName: serviceName ?? this.serviceName,
        priority: priority ?? this.priority,
        prePaddingSeconds: prePaddingSeconds ?? this.prePaddingSeconds,
        postPaddingSeconds: postPaddingSeconds ?? this.postPaddingSeconds,
        isPrePaddingRequired: isPrePaddingRequired ?? this.isPrePaddingRequired,
        parentBackdropItemId: parentBackdropItemId ?? this.parentBackdropItemId,
        parentBackdropImageTags:
            parentBackdropImageTags ?? this.parentBackdropImageTags,
        isPostPaddingRequired:
            isPostPaddingRequired ?? this.isPostPaddingRequired,
        keepUntil: keepUntil ?? this.keepUntil,
        status: status ?? this.status,
        seriesTimerId: seriesTimerId ?? this.seriesTimerId,
        externalSeriesTimerId:
            externalSeriesTimerId ?? this.externalSeriesTimerId,
        runTimeTicks: runTimeTicks ?? this.runTimeTicks,
        programInfo: programInfo ?? this.programInfo);
  }

  TimerInfoDto copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? type,
      Wrapped<String?>? serverId,
      Wrapped<String?>? externalId,
      Wrapped<String?>? channelId,
      Wrapped<String?>? externalChannelId,
      Wrapped<String?>? channelName,
      Wrapped<String?>? channelPrimaryImageTag,
      Wrapped<String?>? programId,
      Wrapped<String?>? externalProgramId,
      Wrapped<String?>? name,
      Wrapped<String?>? overview,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<String?>? serviceName,
      Wrapped<int?>? priority,
      Wrapped<int?>? prePaddingSeconds,
      Wrapped<int?>? postPaddingSeconds,
      Wrapped<bool?>? isPrePaddingRequired,
      Wrapped<String?>? parentBackdropItemId,
      Wrapped<List<String>?>? parentBackdropImageTags,
      Wrapped<bool?>? isPostPaddingRequired,
      Wrapped<enums.KeepUntil?>? keepUntil,
      Wrapped<enums.RecordingStatus?>? status,
      Wrapped<String?>? seriesTimerId,
      Wrapped<String?>? externalSeriesTimerId,
      Wrapped<int?>? runTimeTicks,
      Wrapped<BaseItemDto?>? programInfo}) {
    return TimerInfoDto(
        id: (id != null ? id.value : this.id),
        type: (type != null ? type.value : this.type),
        serverId: (serverId != null ? serverId.value : this.serverId),
        externalId: (externalId != null ? externalId.value : this.externalId),
        channelId: (channelId != null ? channelId.value : this.channelId),
        externalChannelId: (externalChannelId != null
            ? externalChannelId.value
            : this.externalChannelId),
        channelName:
            (channelName != null ? channelName.value : this.channelName),
        channelPrimaryImageTag: (channelPrimaryImageTag != null
            ? channelPrimaryImageTag.value
            : this.channelPrimaryImageTag),
        programId: (programId != null ? programId.value : this.programId),
        externalProgramId: (externalProgramId != null
            ? externalProgramId.value
            : this.externalProgramId),
        name: (name != null ? name.value : this.name),
        overview: (overview != null ? overview.value : this.overview),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        serviceName:
            (serviceName != null ? serviceName.value : this.serviceName),
        priority: (priority != null ? priority.value : this.priority),
        prePaddingSeconds: (prePaddingSeconds != null
            ? prePaddingSeconds.value
            : this.prePaddingSeconds),
        postPaddingSeconds: (postPaddingSeconds != null
            ? postPaddingSeconds.value
            : this.postPaddingSeconds),
        isPrePaddingRequired: (isPrePaddingRequired != null
            ? isPrePaddingRequired.value
            : this.isPrePaddingRequired),
        parentBackdropItemId: (parentBackdropItemId != null
            ? parentBackdropItemId.value
            : this.parentBackdropItemId),
        parentBackdropImageTags: (parentBackdropImageTags != null
            ? parentBackdropImageTags.value
            : this.parentBackdropImageTags),
        isPostPaddingRequired: (isPostPaddingRequired != null
            ? isPostPaddingRequired.value
            : this.isPostPaddingRequired),
        keepUntil: (keepUntil != null ? keepUntil.value : this.keepUntil),
        status: (status != null ? status.value : this.status),
        seriesTimerId:
            (seriesTimerId != null ? seriesTimerId.value : this.seriesTimerId),
        externalSeriesTimerId: (externalSeriesTimerId != null
            ? externalSeriesTimerId.value
            : this.externalSeriesTimerId),
        runTimeTicks:
            (runTimeTicks != null ? runTimeTicks.value : this.runTimeTicks),
        programInfo:
            (programInfo != null ? programInfo.value : this.programInfo));
  }
}

@JsonSerializable(explicitToJson: true)
class TimerInfoDtoQueryResult {
  const TimerInfoDtoQueryResult({
    this.items,
    this.totalRecordCount,
    this.startIndex,
  });

  factory TimerInfoDtoQueryResult.fromJson(Map<String, dynamic> json) =>
      _$TimerInfoDtoQueryResultFromJson(json);

  static const toJsonFactory = _$TimerInfoDtoQueryResultToJson;
  Map<String, dynamic> toJson() => _$TimerInfoDtoQueryResultToJson(this);

  @JsonKey(name: 'Items', defaultValue: <TimerInfoDto>[])
  final List<TimerInfoDto>? items;
  @JsonKey(name: 'TotalRecordCount')
  final int? totalRecordCount;
  @JsonKey(name: 'StartIndex')
  final int? startIndex;
  static const fromJsonFactory = _$TimerInfoDtoQueryResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TimerInfoDtoQueryResult &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.totalRecordCount, totalRecordCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecordCount, totalRecordCount)) &&
            (identical(other.startIndex, startIndex) ||
                const DeepCollectionEquality()
                    .equals(other.startIndex, startIndex)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(totalRecordCount) ^
      const DeepCollectionEquality().hash(startIndex) ^
      runtimeType.hashCode;
}

extension $TimerInfoDtoQueryResultExtension on TimerInfoDtoQueryResult {
  TimerInfoDtoQueryResult copyWith(
      {List<TimerInfoDto>? items, int? totalRecordCount, int? startIndex}) {
    return TimerInfoDtoQueryResult(
        items: items ?? this.items,
        totalRecordCount: totalRecordCount ?? this.totalRecordCount,
        startIndex: startIndex ?? this.startIndex);
  }

  TimerInfoDtoQueryResult copyWithWrapped(
      {Wrapped<List<TimerInfoDto>?>? items,
      Wrapped<int?>? totalRecordCount,
      Wrapped<int?>? startIndex}) {
    return TimerInfoDtoQueryResult(
        items: (items != null ? items.value : this.items),
        totalRecordCount: (totalRecordCount != null
            ? totalRecordCount.value
            : this.totalRecordCount),
        startIndex: (startIndex != null ? startIndex.value : this.startIndex));
  }
}

@JsonSerializable(explicitToJson: true)
class TrailerInfo {
  const TrailerInfo({
    this.name,
    this.originalTitle,
    this.path,
    this.metadataLanguage,
    this.metadataCountryCode,
    this.providerIds,
    this.year,
    this.indexNumber,
    this.parentIndexNumber,
    this.premiereDate,
    this.isAutomated,
  });

  factory TrailerInfo.fromJson(Map<String, dynamic> json) =>
      _$TrailerInfoFromJson(json);

  static const toJsonFactory = _$TrailerInfoToJson;
  Map<String, dynamic> toJson() => _$TrailerInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'OriginalTitle')
  final String? originalTitle;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'MetadataLanguage')
  final String? metadataLanguage;
  @JsonKey(name: 'MetadataCountryCode')
  final String? metadataCountryCode;
  @JsonKey(name: 'ProviderIds')
  final Map<String, dynamic>? providerIds;
  @JsonKey(name: 'Year')
  final int? year;
  @JsonKey(name: 'IndexNumber')
  final int? indexNumber;
  @JsonKey(name: 'ParentIndexNumber')
  final int? parentIndexNumber;
  @JsonKey(name: 'PremiereDate')
  final DateTime? premiereDate;
  @JsonKey(name: 'IsAutomated')
  final bool? isAutomated;
  static const fromJsonFactory = _$TrailerInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrailerInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalTitle, originalTitle) ||
                const DeepCollectionEquality()
                    .equals(other.originalTitle, originalTitle)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.metadataLanguage, metadataLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.metadataLanguage, metadataLanguage)) &&
            (identical(other.metadataCountryCode, metadataCountryCode) ||
                const DeepCollectionEquality()
                    .equals(other.metadataCountryCode, metadataCountryCode)) &&
            (identical(other.providerIds, providerIds) ||
                const DeepCollectionEquality()
                    .equals(other.providerIds, providerIds)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.indexNumber, indexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.indexNumber, indexNumber)) &&
            (identical(other.parentIndexNumber, parentIndexNumber) ||
                const DeepCollectionEquality()
                    .equals(other.parentIndexNumber, parentIndexNumber)) &&
            (identical(other.premiereDate, premiereDate) ||
                const DeepCollectionEquality()
                    .equals(other.premiereDate, premiereDate)) &&
            (identical(other.isAutomated, isAutomated) ||
                const DeepCollectionEquality()
                    .equals(other.isAutomated, isAutomated)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalTitle) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(metadataLanguage) ^
      const DeepCollectionEquality().hash(metadataCountryCode) ^
      const DeepCollectionEquality().hash(providerIds) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(indexNumber) ^
      const DeepCollectionEquality().hash(parentIndexNumber) ^
      const DeepCollectionEquality().hash(premiereDate) ^
      const DeepCollectionEquality().hash(isAutomated) ^
      runtimeType.hashCode;
}

extension $TrailerInfoExtension on TrailerInfo {
  TrailerInfo copyWith(
      {String? name,
      String? originalTitle,
      String? path,
      String? metadataLanguage,
      String? metadataCountryCode,
      Map<String, dynamic>? providerIds,
      int? year,
      int? indexNumber,
      int? parentIndexNumber,
      DateTime? premiereDate,
      bool? isAutomated}) {
    return TrailerInfo(
        name: name ?? this.name,
        originalTitle: originalTitle ?? this.originalTitle,
        path: path ?? this.path,
        metadataLanguage: metadataLanguage ?? this.metadataLanguage,
        metadataCountryCode: metadataCountryCode ?? this.metadataCountryCode,
        providerIds: providerIds ?? this.providerIds,
        year: year ?? this.year,
        indexNumber: indexNumber ?? this.indexNumber,
        parentIndexNumber: parentIndexNumber ?? this.parentIndexNumber,
        premiereDate: premiereDate ?? this.premiereDate,
        isAutomated: isAutomated ?? this.isAutomated);
  }

  TrailerInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? originalTitle,
      Wrapped<String?>? path,
      Wrapped<String?>? metadataLanguage,
      Wrapped<String?>? metadataCountryCode,
      Wrapped<Map<String, dynamic>?>? providerIds,
      Wrapped<int?>? year,
      Wrapped<int?>? indexNumber,
      Wrapped<int?>? parentIndexNumber,
      Wrapped<DateTime?>? premiereDate,
      Wrapped<bool?>? isAutomated}) {
    return TrailerInfo(
        name: (name != null ? name.value : this.name),
        originalTitle:
            (originalTitle != null ? originalTitle.value : this.originalTitle),
        path: (path != null ? path.value : this.path),
        metadataLanguage: (metadataLanguage != null
            ? metadataLanguage.value
            : this.metadataLanguage),
        metadataCountryCode: (metadataCountryCode != null
            ? metadataCountryCode.value
            : this.metadataCountryCode),
        providerIds:
            (providerIds != null ? providerIds.value : this.providerIds),
        year: (year != null ? year.value : this.year),
        indexNumber:
            (indexNumber != null ? indexNumber.value : this.indexNumber),
        parentIndexNumber: (parentIndexNumber != null
            ? parentIndexNumber.value
            : this.parentIndexNumber),
        premiereDate:
            (premiereDate != null ? premiereDate.value : this.premiereDate),
        isAutomated:
            (isAutomated != null ? isAutomated.value : this.isAutomated));
  }
}

@JsonSerializable(explicitToJson: true)
class TrailerInfoRemoteSearchQuery {
  const TrailerInfoRemoteSearchQuery({
    this.searchInfo,
    this.itemId,
    this.searchProviderName,
    this.includeDisabledProviders,
  });

  factory TrailerInfoRemoteSearchQuery.fromJson(Map<String, dynamic> json) =>
      _$TrailerInfoRemoteSearchQueryFromJson(json);

  static const toJsonFactory = _$TrailerInfoRemoteSearchQueryToJson;
  Map<String, dynamic> toJson() => _$TrailerInfoRemoteSearchQueryToJson(this);

  @JsonKey(name: 'SearchInfo')
  final TrailerInfo? searchInfo;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'SearchProviderName')
  final String? searchProviderName;
  @JsonKey(name: 'IncludeDisabledProviders')
  final bool? includeDisabledProviders;
  static const fromJsonFactory = _$TrailerInfoRemoteSearchQueryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrailerInfoRemoteSearchQuery &&
            (identical(other.searchInfo, searchInfo) ||
                const DeepCollectionEquality()
                    .equals(other.searchInfo, searchInfo)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.searchProviderName, searchProviderName) ||
                const DeepCollectionEquality()
                    .equals(other.searchProviderName, searchProviderName)) &&
            (identical(
                    other.includeDisabledProviders, includeDisabledProviders) ||
                const DeepCollectionEquality().equals(
                    other.includeDisabledProviders, includeDisabledProviders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchInfo) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(searchProviderName) ^
      const DeepCollectionEquality().hash(includeDisabledProviders) ^
      runtimeType.hashCode;
}

extension $TrailerInfoRemoteSearchQueryExtension
    on TrailerInfoRemoteSearchQuery {
  TrailerInfoRemoteSearchQuery copyWith(
      {TrailerInfo? searchInfo,
      String? itemId,
      String? searchProviderName,
      bool? includeDisabledProviders}) {
    return TrailerInfoRemoteSearchQuery(
        searchInfo: searchInfo ?? this.searchInfo,
        itemId: itemId ?? this.itemId,
        searchProviderName: searchProviderName ?? this.searchProviderName,
        includeDisabledProviders:
            includeDisabledProviders ?? this.includeDisabledProviders);
  }

  TrailerInfoRemoteSearchQuery copyWithWrapped(
      {Wrapped<TrailerInfo?>? searchInfo,
      Wrapped<String?>? itemId,
      Wrapped<String?>? searchProviderName,
      Wrapped<bool?>? includeDisabledProviders}) {
    return TrailerInfoRemoteSearchQuery(
        searchInfo: (searchInfo != null ? searchInfo.value : this.searchInfo),
        itemId: (itemId != null ? itemId.value : this.itemId),
        searchProviderName: (searchProviderName != null
            ? searchProviderName.value
            : this.searchProviderName),
        includeDisabledProviders: (includeDisabledProviders != null
            ? includeDisabledProviders.value
            : this.includeDisabledProviders));
  }
}

@JsonSerializable(explicitToJson: true)
class TranscodingInfo {
  const TranscodingInfo({
    this.audioCodec,
    this.videoCodec,
    this.container,
    this.isVideoDirect,
    this.isAudioDirect,
    this.bitrate,
    this.framerate,
    this.completionPercentage,
    this.width,
    this.height,
    this.audioChannels,
    this.hardwareAccelerationType,
    this.transcodeReasons,
  });

  factory TranscodingInfo.fromJson(Map<String, dynamic> json) =>
      _$TranscodingInfoFromJson(json);

  static const toJsonFactory = _$TranscodingInfoToJson;
  Map<String, dynamic> toJson() => _$TranscodingInfoToJson(this);

  @JsonKey(name: 'AudioCodec')
  final String? audioCodec;
  @JsonKey(name: 'VideoCodec')
  final String? videoCodec;
  @JsonKey(name: 'Container')
  final String? container;
  @JsonKey(name: 'IsVideoDirect')
  final bool? isVideoDirect;
  @JsonKey(name: 'IsAudioDirect')
  final bool? isAudioDirect;
  @JsonKey(name: 'Bitrate')
  final int? bitrate;
  @JsonKey(name: 'Framerate')
  final double? framerate;
  @JsonKey(name: 'CompletionPercentage')
  final double? completionPercentage;
  @JsonKey(name: 'Width')
  final int? width;
  @JsonKey(name: 'Height')
  final int? height;
  @JsonKey(name: 'AudioChannels')
  final int? audioChannels;
  @JsonKey(
    name: 'HardwareAccelerationType',
    toJson: hardwareAccelerationTypeNullableToJson,
    fromJson: hardwareAccelerationTypeNullableFromJson,
  )
  final enums.HardwareAccelerationType? hardwareAccelerationType;
  @JsonKey(
    name: 'TranscodeReasons',
    toJson: transcodeReasonListToJson,
    fromJson: transcodeReasonListFromJson,
  )
  final List<enums.TranscodeReason>? transcodeReasons;
  static const fromJsonFactory = _$TranscodingInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TranscodingInfo &&
            (identical(other.audioCodec, audioCodec) ||
                const DeepCollectionEquality()
                    .equals(other.audioCodec, audioCodec)) &&
            (identical(other.videoCodec, videoCodec) ||
                const DeepCollectionEquality()
                    .equals(other.videoCodec, videoCodec)) &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)) &&
            (identical(other.isVideoDirect, isVideoDirect) ||
                const DeepCollectionEquality()
                    .equals(other.isVideoDirect, isVideoDirect)) &&
            (identical(other.isAudioDirect, isAudioDirect) ||
                const DeepCollectionEquality()
                    .equals(other.isAudioDirect, isAudioDirect)) &&
            (identical(other.bitrate, bitrate) ||
                const DeepCollectionEquality()
                    .equals(other.bitrate, bitrate)) &&
            (identical(other.framerate, framerate) ||
                const DeepCollectionEquality()
                    .equals(other.framerate, framerate)) &&
            (identical(other.completionPercentage, completionPercentage) ||
                const DeepCollectionEquality().equals(
                    other.completionPercentage, completionPercentage)) &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.audioChannels, audioChannels) ||
                const DeepCollectionEquality()
                    .equals(other.audioChannels, audioChannels)) &&
            (identical(
                    other.hardwareAccelerationType, hardwareAccelerationType) ||
                const DeepCollectionEquality().equals(
                    other.hardwareAccelerationType,
                    hardwareAccelerationType)) &&
            (identical(other.transcodeReasons, transcodeReasons) ||
                const DeepCollectionEquality()
                    .equals(other.transcodeReasons, transcodeReasons)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audioCodec) ^
      const DeepCollectionEquality().hash(videoCodec) ^
      const DeepCollectionEquality().hash(container) ^
      const DeepCollectionEquality().hash(isVideoDirect) ^
      const DeepCollectionEquality().hash(isAudioDirect) ^
      const DeepCollectionEquality().hash(bitrate) ^
      const DeepCollectionEquality().hash(framerate) ^
      const DeepCollectionEquality().hash(completionPercentage) ^
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(audioChannels) ^
      const DeepCollectionEquality().hash(hardwareAccelerationType) ^
      const DeepCollectionEquality().hash(transcodeReasons) ^
      runtimeType.hashCode;
}

extension $TranscodingInfoExtension on TranscodingInfo {
  TranscodingInfo copyWith(
      {String? audioCodec,
      String? videoCodec,
      String? container,
      bool? isVideoDirect,
      bool? isAudioDirect,
      int? bitrate,
      double? framerate,
      double? completionPercentage,
      int? width,
      int? height,
      int? audioChannels,
      enums.HardwareAccelerationType? hardwareAccelerationType,
      List<enums.TranscodeReason>? transcodeReasons}) {
    return TranscodingInfo(
        audioCodec: audioCodec ?? this.audioCodec,
        videoCodec: videoCodec ?? this.videoCodec,
        container: container ?? this.container,
        isVideoDirect: isVideoDirect ?? this.isVideoDirect,
        isAudioDirect: isAudioDirect ?? this.isAudioDirect,
        bitrate: bitrate ?? this.bitrate,
        framerate: framerate ?? this.framerate,
        completionPercentage: completionPercentage ?? this.completionPercentage,
        width: width ?? this.width,
        height: height ?? this.height,
        audioChannels: audioChannels ?? this.audioChannels,
        hardwareAccelerationType:
            hardwareAccelerationType ?? this.hardwareAccelerationType,
        transcodeReasons: transcodeReasons ?? this.transcodeReasons);
  }

  TranscodingInfo copyWithWrapped(
      {Wrapped<String?>? audioCodec,
      Wrapped<String?>? videoCodec,
      Wrapped<String?>? container,
      Wrapped<bool?>? isVideoDirect,
      Wrapped<bool?>? isAudioDirect,
      Wrapped<int?>? bitrate,
      Wrapped<double?>? framerate,
      Wrapped<double?>? completionPercentage,
      Wrapped<int?>? width,
      Wrapped<int?>? height,
      Wrapped<int?>? audioChannels,
      Wrapped<enums.HardwareAccelerationType?>? hardwareAccelerationType,
      Wrapped<List<enums.TranscodeReason>?>? transcodeReasons}) {
    return TranscodingInfo(
        audioCodec: (audioCodec != null ? audioCodec.value : this.audioCodec),
        videoCodec: (videoCodec != null ? videoCodec.value : this.videoCodec),
        container: (container != null ? container.value : this.container),
        isVideoDirect:
            (isVideoDirect != null ? isVideoDirect.value : this.isVideoDirect),
        isAudioDirect:
            (isAudioDirect != null ? isAudioDirect.value : this.isAudioDirect),
        bitrate: (bitrate != null ? bitrate.value : this.bitrate),
        framerate: (framerate != null ? framerate.value : this.framerate),
        completionPercentage: (completionPercentage != null
            ? completionPercentage.value
            : this.completionPercentage),
        width: (width != null ? width.value : this.width),
        height: (height != null ? height.value : this.height),
        audioChannels:
            (audioChannels != null ? audioChannels.value : this.audioChannels),
        hardwareAccelerationType: (hardwareAccelerationType != null
            ? hardwareAccelerationType.value
            : this.hardwareAccelerationType),
        transcodeReasons: (transcodeReasons != null
            ? transcodeReasons.value
            : this.transcodeReasons));
  }
}

@JsonSerializable(explicitToJson: true)
class TranscodingProfile {
  const TranscodingProfile({
    this.container,
    this.type,
    this.videoCodec,
    this.audioCodec,
    this.protocol,
    this.estimateContentLength,
    this.enableMpegtsM2TsMode,
    this.transcodeSeekInfo,
    this.copyTimestamps,
    this.context,
    this.enableSubtitlesInManifest,
    this.maxAudioChannels,
    this.minSegments,
    this.segmentLength,
    this.breakOnNonKeyFrames,
    this.conditions,
    this.enableAudioVbrEncoding,
  });

  factory TranscodingProfile.fromJson(Map<String, dynamic> json) =>
      _$TranscodingProfileFromJson(json);

  static const toJsonFactory = _$TranscodingProfileToJson;
  Map<String, dynamic> toJson() => _$TranscodingProfileToJson(this);

  @JsonKey(name: 'Container')
  final String? container;
  @JsonKey(
    name: 'Type',
    toJson: dlnaProfileTypeNullableToJson,
    fromJson: dlnaProfileTypeNullableFromJson,
  )
  final enums.DlnaProfileType? type;
  @JsonKey(name: 'VideoCodec')
  final String? videoCodec;
  @JsonKey(name: 'AudioCodec')
  final String? audioCodec;
  @JsonKey(
    name: 'Protocol',
    toJson: mediaStreamProtocolNullableToJson,
    fromJson: mediaStreamProtocolNullableFromJson,
  )
  final enums.MediaStreamProtocol? protocol;
  @JsonKey(name: 'EstimateContentLength', defaultValue: false)
  final bool? estimateContentLength;
  @JsonKey(name: 'EnableMpegtsM2TsMode', defaultValue: false)
  final bool? enableMpegtsM2TsMode;
  @JsonKey(
    name: 'TranscodeSeekInfo',
    toJson: transcodeSeekInfoNullableToJson,
    fromJson: transcodeSeekInfoTranscodeSeekInfoNullableFromJson,
  )
  final enums.TranscodeSeekInfo? transcodeSeekInfo;
  static enums.TranscodeSeekInfo?
      transcodeSeekInfoTranscodeSeekInfoNullableFromJson(Object? value) =>
          transcodeSeekInfoNullableFromJson(
              value, enums.TranscodeSeekInfo.auto);

  @JsonKey(name: 'CopyTimestamps', defaultValue: false)
  final bool? copyTimestamps;
  @JsonKey(
    name: 'Context',
    toJson: encodingContextNullableToJson,
    fromJson: encodingContextContextNullableFromJson,
  )
  final enums.EncodingContext? context;
  static enums.EncodingContext? encodingContextContextNullableFromJson(
          Object? value) =>
      encodingContextNullableFromJson(value, enums.EncodingContext.streaming);

  @JsonKey(name: 'EnableSubtitlesInManifest', defaultValue: false)
  final bool? enableSubtitlesInManifest;
  @JsonKey(name: 'MaxAudioChannels')
  final String? maxAudioChannels;
  @JsonKey(name: 'MinSegments')
  final int? minSegments;
  @JsonKey(name: 'SegmentLength')
  final int? segmentLength;
  @JsonKey(name: 'BreakOnNonKeyFrames', defaultValue: false)
  final bool? breakOnNonKeyFrames;
  @JsonKey(name: 'Conditions', defaultValue: <ProfileCondition>[])
  final List<ProfileCondition>? conditions;
  @JsonKey(name: 'EnableAudioVbrEncoding', defaultValue: true)
  final bool? enableAudioVbrEncoding;
  static const fromJsonFactory = _$TranscodingProfileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TranscodingProfile &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.videoCodec, videoCodec) ||
                const DeepCollectionEquality()
                    .equals(other.videoCodec, videoCodec)) &&
            (identical(other.audioCodec, audioCodec) ||
                const DeepCollectionEquality()
                    .equals(other.audioCodec, audioCodec)) &&
            (identical(other.protocol, protocol) ||
                const DeepCollectionEquality()
                    .equals(other.protocol, protocol)) &&
            (identical(other.estimateContentLength, estimateContentLength) ||
                const DeepCollectionEquality().equals(
                    other.estimateContentLength, estimateContentLength)) &&
            (identical(other.enableMpegtsM2TsMode, enableMpegtsM2TsMode) ||
                const DeepCollectionEquality().equals(
                    other.enableMpegtsM2TsMode, enableMpegtsM2TsMode)) &&
            (identical(other.transcodeSeekInfo, transcodeSeekInfo) ||
                const DeepCollectionEquality()
                    .equals(other.transcodeSeekInfo, transcodeSeekInfo)) &&
            (identical(other.copyTimestamps, copyTimestamps) ||
                const DeepCollectionEquality()
                    .equals(other.copyTimestamps, copyTimestamps)) &&
            (identical(other.context, context) ||
                const DeepCollectionEquality()
                    .equals(other.context, context)) &&
            (identical(other.enableSubtitlesInManifest,
                    enableSubtitlesInManifest) ||
                const DeepCollectionEquality().equals(
                    other.enableSubtitlesInManifest,
                    enableSubtitlesInManifest)) &&
            (identical(other.maxAudioChannels, maxAudioChannels) ||
                const DeepCollectionEquality()
                    .equals(other.maxAudioChannels, maxAudioChannels)) &&
            (identical(other.minSegments, minSegments) ||
                const DeepCollectionEquality()
                    .equals(other.minSegments, minSegments)) &&
            (identical(other.segmentLength, segmentLength) ||
                const DeepCollectionEquality()
                    .equals(other.segmentLength, segmentLength)) &&
            (identical(other.breakOnNonKeyFrames, breakOnNonKeyFrames) ||
                const DeepCollectionEquality()
                    .equals(other.breakOnNonKeyFrames, breakOnNonKeyFrames)) &&
            (identical(other.conditions, conditions) ||
                const DeepCollectionEquality()
                    .equals(other.conditions, conditions)) &&
            (identical(other.enableAudioVbrEncoding, enableAudioVbrEncoding) ||
                const DeepCollectionEquality().equals(
                    other.enableAudioVbrEncoding, enableAudioVbrEncoding)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(container) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(videoCodec) ^
      const DeepCollectionEquality().hash(audioCodec) ^
      const DeepCollectionEquality().hash(protocol) ^
      const DeepCollectionEquality().hash(estimateContentLength) ^
      const DeepCollectionEquality().hash(enableMpegtsM2TsMode) ^
      const DeepCollectionEquality().hash(transcodeSeekInfo) ^
      const DeepCollectionEquality().hash(copyTimestamps) ^
      const DeepCollectionEquality().hash(context) ^
      const DeepCollectionEquality().hash(enableSubtitlesInManifest) ^
      const DeepCollectionEquality().hash(maxAudioChannels) ^
      const DeepCollectionEquality().hash(minSegments) ^
      const DeepCollectionEquality().hash(segmentLength) ^
      const DeepCollectionEquality().hash(breakOnNonKeyFrames) ^
      const DeepCollectionEquality().hash(conditions) ^
      const DeepCollectionEquality().hash(enableAudioVbrEncoding) ^
      runtimeType.hashCode;
}

extension $TranscodingProfileExtension on TranscodingProfile {
  TranscodingProfile copyWith(
      {String? container,
      enums.DlnaProfileType? type,
      String? videoCodec,
      String? audioCodec,
      enums.MediaStreamProtocol? protocol,
      bool? estimateContentLength,
      bool? enableMpegtsM2TsMode,
      enums.TranscodeSeekInfo? transcodeSeekInfo,
      bool? copyTimestamps,
      enums.EncodingContext? context,
      bool? enableSubtitlesInManifest,
      String? maxAudioChannels,
      int? minSegments,
      int? segmentLength,
      bool? breakOnNonKeyFrames,
      List<ProfileCondition>? conditions,
      bool? enableAudioVbrEncoding}) {
    return TranscodingProfile(
        container: container ?? this.container,
        type: type ?? this.type,
        videoCodec: videoCodec ?? this.videoCodec,
        audioCodec: audioCodec ?? this.audioCodec,
        protocol: protocol ?? this.protocol,
        estimateContentLength:
            estimateContentLength ?? this.estimateContentLength,
        enableMpegtsM2TsMode: enableMpegtsM2TsMode ?? this.enableMpegtsM2TsMode,
        transcodeSeekInfo: transcodeSeekInfo ?? this.transcodeSeekInfo,
        copyTimestamps: copyTimestamps ?? this.copyTimestamps,
        context: context ?? this.context,
        enableSubtitlesInManifest:
            enableSubtitlesInManifest ?? this.enableSubtitlesInManifest,
        maxAudioChannels: maxAudioChannels ?? this.maxAudioChannels,
        minSegments: minSegments ?? this.minSegments,
        segmentLength: segmentLength ?? this.segmentLength,
        breakOnNonKeyFrames: breakOnNonKeyFrames ?? this.breakOnNonKeyFrames,
        conditions: conditions ?? this.conditions,
        enableAudioVbrEncoding:
            enableAudioVbrEncoding ?? this.enableAudioVbrEncoding);
  }

  TranscodingProfile copyWithWrapped(
      {Wrapped<String?>? container,
      Wrapped<enums.DlnaProfileType?>? type,
      Wrapped<String?>? videoCodec,
      Wrapped<String?>? audioCodec,
      Wrapped<enums.MediaStreamProtocol?>? protocol,
      Wrapped<bool?>? estimateContentLength,
      Wrapped<bool?>? enableMpegtsM2TsMode,
      Wrapped<enums.TranscodeSeekInfo?>? transcodeSeekInfo,
      Wrapped<bool?>? copyTimestamps,
      Wrapped<enums.EncodingContext?>? context,
      Wrapped<bool?>? enableSubtitlesInManifest,
      Wrapped<String?>? maxAudioChannels,
      Wrapped<int?>? minSegments,
      Wrapped<int?>? segmentLength,
      Wrapped<bool?>? breakOnNonKeyFrames,
      Wrapped<List<ProfileCondition>?>? conditions,
      Wrapped<bool?>? enableAudioVbrEncoding}) {
    return TranscodingProfile(
        container: (container != null ? container.value : this.container),
        type: (type != null ? type.value : this.type),
        videoCodec: (videoCodec != null ? videoCodec.value : this.videoCodec),
        audioCodec: (audioCodec != null ? audioCodec.value : this.audioCodec),
        protocol: (protocol != null ? protocol.value : this.protocol),
        estimateContentLength: (estimateContentLength != null
            ? estimateContentLength.value
            : this.estimateContentLength),
        enableMpegtsM2TsMode: (enableMpegtsM2TsMode != null
            ? enableMpegtsM2TsMode.value
            : this.enableMpegtsM2TsMode),
        transcodeSeekInfo: (transcodeSeekInfo != null
            ? transcodeSeekInfo.value
            : this.transcodeSeekInfo),
        copyTimestamps: (copyTimestamps != null
            ? copyTimestamps.value
            : this.copyTimestamps),
        context: (context != null ? context.value : this.context),
        enableSubtitlesInManifest: (enableSubtitlesInManifest != null
            ? enableSubtitlesInManifest.value
            : this.enableSubtitlesInManifest),
        maxAudioChannels: (maxAudioChannels != null
            ? maxAudioChannels.value
            : this.maxAudioChannels),
        minSegments:
            (minSegments != null ? minSegments.value : this.minSegments),
        segmentLength:
            (segmentLength != null ? segmentLength.value : this.segmentLength),
        breakOnNonKeyFrames: (breakOnNonKeyFrames != null
            ? breakOnNonKeyFrames.value
            : this.breakOnNonKeyFrames),
        conditions: (conditions != null ? conditions.value : this.conditions),
        enableAudioVbrEncoding: (enableAudioVbrEncoding != null
            ? enableAudioVbrEncoding.value
            : this.enableAudioVbrEncoding));
  }
}

@JsonSerializable(explicitToJson: true)
class TrickplayInfo {
  const TrickplayInfo({
    this.width,
    this.height,
    this.tileWidth,
    this.tileHeight,
    this.thumbnailCount,
    this.interval,
    this.bandwidth,
  });

  factory TrickplayInfo.fromJson(Map<String, dynamic> json) =>
      _$TrickplayInfoFromJson(json);

  static const toJsonFactory = _$TrickplayInfoToJson;
  Map<String, dynamic> toJson() => _$TrickplayInfoToJson(this);

  @JsonKey(name: 'Width')
  final int? width;
  @JsonKey(name: 'Height')
  final int? height;
  @JsonKey(name: 'TileWidth')
  final int? tileWidth;
  @JsonKey(name: 'TileHeight')
  final int? tileHeight;
  @JsonKey(name: 'ThumbnailCount')
  final int? thumbnailCount;
  @JsonKey(name: 'Interval')
  final int? interval;
  @JsonKey(name: 'Bandwidth')
  final int? bandwidth;
  static const fromJsonFactory = _$TrickplayInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrickplayInfo &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.tileWidth, tileWidth) ||
                const DeepCollectionEquality()
                    .equals(other.tileWidth, tileWidth)) &&
            (identical(other.tileHeight, tileHeight) ||
                const DeepCollectionEquality()
                    .equals(other.tileHeight, tileHeight)) &&
            (identical(other.thumbnailCount, thumbnailCount) ||
                const DeepCollectionEquality()
                    .equals(other.thumbnailCount, thumbnailCount)) &&
            (identical(other.interval, interval) ||
                const DeepCollectionEquality()
                    .equals(other.interval, interval)) &&
            (identical(other.bandwidth, bandwidth) ||
                const DeepCollectionEquality()
                    .equals(other.bandwidth, bandwidth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(tileWidth) ^
      const DeepCollectionEquality().hash(tileHeight) ^
      const DeepCollectionEquality().hash(thumbnailCount) ^
      const DeepCollectionEquality().hash(interval) ^
      const DeepCollectionEquality().hash(bandwidth) ^
      runtimeType.hashCode;
}

extension $TrickplayInfoExtension on TrickplayInfo {
  TrickplayInfo copyWith(
      {int? width,
      int? height,
      int? tileWidth,
      int? tileHeight,
      int? thumbnailCount,
      int? interval,
      int? bandwidth}) {
    return TrickplayInfo(
        width: width ?? this.width,
        height: height ?? this.height,
        tileWidth: tileWidth ?? this.tileWidth,
        tileHeight: tileHeight ?? this.tileHeight,
        thumbnailCount: thumbnailCount ?? this.thumbnailCount,
        interval: interval ?? this.interval,
        bandwidth: bandwidth ?? this.bandwidth);
  }

  TrickplayInfo copyWithWrapped(
      {Wrapped<int?>? width,
      Wrapped<int?>? height,
      Wrapped<int?>? tileWidth,
      Wrapped<int?>? tileHeight,
      Wrapped<int?>? thumbnailCount,
      Wrapped<int?>? interval,
      Wrapped<int?>? bandwidth}) {
    return TrickplayInfo(
        width: (width != null ? width.value : this.width),
        height: (height != null ? height.value : this.height),
        tileWidth: (tileWidth != null ? tileWidth.value : this.tileWidth),
        tileHeight: (tileHeight != null ? tileHeight.value : this.tileHeight),
        thumbnailCount: (thumbnailCount != null
            ? thumbnailCount.value
            : this.thumbnailCount),
        interval: (interval != null ? interval.value : this.interval),
        bandwidth: (bandwidth != null ? bandwidth.value : this.bandwidth));
  }
}

@JsonSerializable(explicitToJson: true)
class TrickplayOptions {
  const TrickplayOptions({
    this.enableHwAcceleration,
    this.enableHwEncoding,
    this.enableKeyFrameOnlyExtraction,
    this.scanBehavior,
    this.processPriority,
    this.interval,
    this.widthResolutions,
    this.tileWidth,
    this.tileHeight,
    this.qscale,
    this.jpegQuality,
    this.processThreads,
  });

  factory TrickplayOptions.fromJson(Map<String, dynamic> json) =>
      _$TrickplayOptionsFromJson(json);

  static const toJsonFactory = _$TrickplayOptionsToJson;
  Map<String, dynamic> toJson() => _$TrickplayOptionsToJson(this);

  @JsonKey(name: 'EnableHwAcceleration')
  final bool? enableHwAcceleration;
  @JsonKey(name: 'EnableHwEncoding')
  final bool? enableHwEncoding;
  @JsonKey(name: 'EnableKeyFrameOnlyExtraction')
  final bool? enableKeyFrameOnlyExtraction;
  @JsonKey(
    name: 'ScanBehavior',
    toJson: trickplayScanBehaviorNullableToJson,
    fromJson: trickplayScanBehaviorNullableFromJson,
  )
  final enums.TrickplayScanBehavior? scanBehavior;
  @JsonKey(
    name: 'ProcessPriority',
    toJson: processPriorityClassNullableToJson,
    fromJson: processPriorityClassNullableFromJson,
  )
  final enums.ProcessPriorityClass? processPriority;
  @JsonKey(name: 'Interval')
  final int? interval;
  @JsonKey(name: 'WidthResolutions', defaultValue: <int>[])
  final List<int>? widthResolutions;
  @JsonKey(name: 'TileWidth')
  final int? tileWidth;
  @JsonKey(name: 'TileHeight')
  final int? tileHeight;
  @JsonKey(name: 'Qscale')
  final int? qscale;
  @JsonKey(name: 'JpegQuality')
  final int? jpegQuality;
  @JsonKey(name: 'ProcessThreads')
  final int? processThreads;
  static const fromJsonFactory = _$TrickplayOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TrickplayOptions &&
            (identical(other.enableHwAcceleration, enableHwAcceleration) ||
                const DeepCollectionEquality().equals(
                    other.enableHwAcceleration, enableHwAcceleration)) &&
            (identical(other.enableHwEncoding, enableHwEncoding) ||
                const DeepCollectionEquality()
                    .equals(other.enableHwEncoding, enableHwEncoding)) &&
            (identical(other.enableKeyFrameOnlyExtraction,
                    enableKeyFrameOnlyExtraction) ||
                const DeepCollectionEquality().equals(
                    other.enableKeyFrameOnlyExtraction,
                    enableKeyFrameOnlyExtraction)) &&
            (identical(other.scanBehavior, scanBehavior) ||
                const DeepCollectionEquality()
                    .equals(other.scanBehavior, scanBehavior)) &&
            (identical(other.processPriority, processPriority) ||
                const DeepCollectionEquality()
                    .equals(other.processPriority, processPriority)) &&
            (identical(other.interval, interval) ||
                const DeepCollectionEquality()
                    .equals(other.interval, interval)) &&
            (identical(other.widthResolutions, widthResolutions) ||
                const DeepCollectionEquality()
                    .equals(other.widthResolutions, widthResolutions)) &&
            (identical(other.tileWidth, tileWidth) ||
                const DeepCollectionEquality()
                    .equals(other.tileWidth, tileWidth)) &&
            (identical(other.tileHeight, tileHeight) ||
                const DeepCollectionEquality()
                    .equals(other.tileHeight, tileHeight)) &&
            (identical(other.qscale, qscale) ||
                const DeepCollectionEquality().equals(other.qscale, qscale)) &&
            (identical(other.jpegQuality, jpegQuality) ||
                const DeepCollectionEquality()
                    .equals(other.jpegQuality, jpegQuality)) &&
            (identical(other.processThreads, processThreads) ||
                const DeepCollectionEquality()
                    .equals(other.processThreads, processThreads)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enableHwAcceleration) ^
      const DeepCollectionEquality().hash(enableHwEncoding) ^
      const DeepCollectionEquality().hash(enableKeyFrameOnlyExtraction) ^
      const DeepCollectionEquality().hash(scanBehavior) ^
      const DeepCollectionEquality().hash(processPriority) ^
      const DeepCollectionEquality().hash(interval) ^
      const DeepCollectionEquality().hash(widthResolutions) ^
      const DeepCollectionEquality().hash(tileWidth) ^
      const DeepCollectionEquality().hash(tileHeight) ^
      const DeepCollectionEquality().hash(qscale) ^
      const DeepCollectionEquality().hash(jpegQuality) ^
      const DeepCollectionEquality().hash(processThreads) ^
      runtimeType.hashCode;
}

extension $TrickplayOptionsExtension on TrickplayOptions {
  TrickplayOptions copyWith(
      {bool? enableHwAcceleration,
      bool? enableHwEncoding,
      bool? enableKeyFrameOnlyExtraction,
      enums.TrickplayScanBehavior? scanBehavior,
      enums.ProcessPriorityClass? processPriority,
      int? interval,
      List<int>? widthResolutions,
      int? tileWidth,
      int? tileHeight,
      int? qscale,
      int? jpegQuality,
      int? processThreads}) {
    return TrickplayOptions(
        enableHwAcceleration: enableHwAcceleration ?? this.enableHwAcceleration,
        enableHwEncoding: enableHwEncoding ?? this.enableHwEncoding,
        enableKeyFrameOnlyExtraction:
            enableKeyFrameOnlyExtraction ?? this.enableKeyFrameOnlyExtraction,
        scanBehavior: scanBehavior ?? this.scanBehavior,
        processPriority: processPriority ?? this.processPriority,
        interval: interval ?? this.interval,
        widthResolutions: widthResolutions ?? this.widthResolutions,
        tileWidth: tileWidth ?? this.tileWidth,
        tileHeight: tileHeight ?? this.tileHeight,
        qscale: qscale ?? this.qscale,
        jpegQuality: jpegQuality ?? this.jpegQuality,
        processThreads: processThreads ?? this.processThreads);
  }

  TrickplayOptions copyWithWrapped(
      {Wrapped<bool?>? enableHwAcceleration,
      Wrapped<bool?>? enableHwEncoding,
      Wrapped<bool?>? enableKeyFrameOnlyExtraction,
      Wrapped<enums.TrickplayScanBehavior?>? scanBehavior,
      Wrapped<enums.ProcessPriorityClass?>? processPriority,
      Wrapped<int?>? interval,
      Wrapped<List<int>?>? widthResolutions,
      Wrapped<int?>? tileWidth,
      Wrapped<int?>? tileHeight,
      Wrapped<int?>? qscale,
      Wrapped<int?>? jpegQuality,
      Wrapped<int?>? processThreads}) {
    return TrickplayOptions(
        enableHwAcceleration: (enableHwAcceleration != null
            ? enableHwAcceleration.value
            : this.enableHwAcceleration),
        enableHwEncoding: (enableHwEncoding != null
            ? enableHwEncoding.value
            : this.enableHwEncoding),
        enableKeyFrameOnlyExtraction: (enableKeyFrameOnlyExtraction != null
            ? enableKeyFrameOnlyExtraction.value
            : this.enableKeyFrameOnlyExtraction),
        scanBehavior:
            (scanBehavior != null ? scanBehavior.value : this.scanBehavior),
        processPriority: (processPriority != null
            ? processPriority.value
            : this.processPriority),
        interval: (interval != null ? interval.value : this.interval),
        widthResolutions: (widthResolutions != null
            ? widthResolutions.value
            : this.widthResolutions),
        tileWidth: (tileWidth != null ? tileWidth.value : this.tileWidth),
        tileHeight: (tileHeight != null ? tileHeight.value : this.tileHeight),
        qscale: (qscale != null ? qscale.value : this.qscale),
        jpegQuality:
            (jpegQuality != null ? jpegQuality.value : this.jpegQuality),
        processThreads: (processThreads != null
            ? processThreads.value
            : this.processThreads));
  }
}

@JsonSerializable(explicitToJson: true)
class TunerChannelMapping {
  const TunerChannelMapping({
    this.name,
    this.providerChannelName,
    this.providerChannelId,
    this.id,
  });

  factory TunerChannelMapping.fromJson(Map<String, dynamic> json) =>
      _$TunerChannelMappingFromJson(json);

  static const toJsonFactory = _$TunerChannelMappingToJson;
  Map<String, dynamic> toJson() => _$TunerChannelMappingToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'ProviderChannelName')
  final String? providerChannelName;
  @JsonKey(name: 'ProviderChannelId')
  final String? providerChannelId;
  @JsonKey(name: 'Id')
  final String? id;
  static const fromJsonFactory = _$TunerChannelMappingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TunerChannelMapping &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.providerChannelName, providerChannelName) ||
                const DeepCollectionEquality()
                    .equals(other.providerChannelName, providerChannelName)) &&
            (identical(other.providerChannelId, providerChannelId) ||
                const DeepCollectionEquality()
                    .equals(other.providerChannelId, providerChannelId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(providerChannelName) ^
      const DeepCollectionEquality().hash(providerChannelId) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $TunerChannelMappingExtension on TunerChannelMapping {
  TunerChannelMapping copyWith(
      {String? name,
      String? providerChannelName,
      String? providerChannelId,
      String? id}) {
    return TunerChannelMapping(
        name: name ?? this.name,
        providerChannelName: providerChannelName ?? this.providerChannelName,
        providerChannelId: providerChannelId ?? this.providerChannelId,
        id: id ?? this.id);
  }

  TunerChannelMapping copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? providerChannelName,
      Wrapped<String?>? providerChannelId,
      Wrapped<String?>? id}) {
    return TunerChannelMapping(
        name: (name != null ? name.value : this.name),
        providerChannelName: (providerChannelName != null
            ? providerChannelName.value
            : this.providerChannelName),
        providerChannelId: (providerChannelId != null
            ? providerChannelId.value
            : this.providerChannelId),
        id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class TunerHostInfo {
  const TunerHostInfo({
    this.id,
    this.url,
    this.type,
    this.deviceId,
    this.friendlyName,
    this.importFavoritesOnly,
    this.allowHWTranscoding,
    this.allowFmp4TranscodingContainer,
    this.allowStreamSharing,
    this.fallbackMaxStreamingBitrate,
    this.enableStreamLooping,
    this.source,
    this.tunerCount,
    this.userAgent,
    this.ignoreDts,
  });

  factory TunerHostInfo.fromJson(Map<String, dynamic> json) =>
      _$TunerHostInfoFromJson(json);

  static const toJsonFactory = _$TunerHostInfoToJson;
  Map<String, dynamic> toJson() => _$TunerHostInfoToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'Url')
  final String? url;
  @JsonKey(name: 'Type')
  final String? type;
  @JsonKey(name: 'DeviceId')
  final String? deviceId;
  @JsonKey(name: 'FriendlyName')
  final String? friendlyName;
  @JsonKey(name: 'ImportFavoritesOnly')
  final bool? importFavoritesOnly;
  @JsonKey(name: 'AllowHWTranscoding')
  final bool? allowHWTranscoding;
  @JsonKey(name: 'AllowFmp4TranscodingContainer')
  final bool? allowFmp4TranscodingContainer;
  @JsonKey(name: 'AllowStreamSharing')
  final bool? allowStreamSharing;
  @JsonKey(name: 'FallbackMaxStreamingBitrate')
  final int? fallbackMaxStreamingBitrate;
  @JsonKey(name: 'EnableStreamLooping')
  final bool? enableStreamLooping;
  @JsonKey(name: 'Source')
  final String? source;
  @JsonKey(name: 'TunerCount')
  final int? tunerCount;
  @JsonKey(name: 'UserAgent')
  final String? userAgent;
  @JsonKey(name: 'IgnoreDts')
  final bool? ignoreDts;
  static const fromJsonFactory = _$TunerHostInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TunerHostInfo &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.friendlyName, friendlyName) ||
                const DeepCollectionEquality()
                    .equals(other.friendlyName, friendlyName)) &&
            (identical(other.importFavoritesOnly, importFavoritesOnly) ||
                const DeepCollectionEquality()
                    .equals(other.importFavoritesOnly, importFavoritesOnly)) &&
            (identical(other.allowHWTranscoding, allowHWTranscoding) ||
                const DeepCollectionEquality()
                    .equals(other.allowHWTranscoding, allowHWTranscoding)) &&
            (identical(other.allowFmp4TranscodingContainer,
                    allowFmp4TranscodingContainer) ||
                const DeepCollectionEquality().equals(
                    other.allowFmp4TranscodingContainer,
                    allowFmp4TranscodingContainer)) &&
            (identical(other.allowStreamSharing, allowStreamSharing) ||
                const DeepCollectionEquality()
                    .equals(other.allowStreamSharing, allowStreamSharing)) &&
            (identical(other.fallbackMaxStreamingBitrate,
                    fallbackMaxStreamingBitrate) ||
                const DeepCollectionEquality().equals(
                    other.fallbackMaxStreamingBitrate,
                    fallbackMaxStreamingBitrate)) &&
            (identical(other.enableStreamLooping, enableStreamLooping) ||
                const DeepCollectionEquality()
                    .equals(other.enableStreamLooping, enableStreamLooping)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.tunerCount, tunerCount) ||
                const DeepCollectionEquality()
                    .equals(other.tunerCount, tunerCount)) &&
            (identical(other.userAgent, userAgent) ||
                const DeepCollectionEquality()
                    .equals(other.userAgent, userAgent)) &&
            (identical(other.ignoreDts, ignoreDts) ||
                const DeepCollectionEquality()
                    .equals(other.ignoreDts, ignoreDts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(friendlyName) ^
      const DeepCollectionEquality().hash(importFavoritesOnly) ^
      const DeepCollectionEquality().hash(allowHWTranscoding) ^
      const DeepCollectionEquality().hash(allowFmp4TranscodingContainer) ^
      const DeepCollectionEquality().hash(allowStreamSharing) ^
      const DeepCollectionEquality().hash(fallbackMaxStreamingBitrate) ^
      const DeepCollectionEquality().hash(enableStreamLooping) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(tunerCount) ^
      const DeepCollectionEquality().hash(userAgent) ^
      const DeepCollectionEquality().hash(ignoreDts) ^
      runtimeType.hashCode;
}

extension $TunerHostInfoExtension on TunerHostInfo {
  TunerHostInfo copyWith(
      {String? id,
      String? url,
      String? type,
      String? deviceId,
      String? friendlyName,
      bool? importFavoritesOnly,
      bool? allowHWTranscoding,
      bool? allowFmp4TranscodingContainer,
      bool? allowStreamSharing,
      int? fallbackMaxStreamingBitrate,
      bool? enableStreamLooping,
      String? source,
      int? tunerCount,
      String? userAgent,
      bool? ignoreDts}) {
    return TunerHostInfo(
        id: id ?? this.id,
        url: url ?? this.url,
        type: type ?? this.type,
        deviceId: deviceId ?? this.deviceId,
        friendlyName: friendlyName ?? this.friendlyName,
        importFavoritesOnly: importFavoritesOnly ?? this.importFavoritesOnly,
        allowHWTranscoding: allowHWTranscoding ?? this.allowHWTranscoding,
        allowFmp4TranscodingContainer:
            allowFmp4TranscodingContainer ?? this.allowFmp4TranscodingContainer,
        allowStreamSharing: allowStreamSharing ?? this.allowStreamSharing,
        fallbackMaxStreamingBitrate:
            fallbackMaxStreamingBitrate ?? this.fallbackMaxStreamingBitrate,
        enableStreamLooping: enableStreamLooping ?? this.enableStreamLooping,
        source: source ?? this.source,
        tunerCount: tunerCount ?? this.tunerCount,
        userAgent: userAgent ?? this.userAgent,
        ignoreDts: ignoreDts ?? this.ignoreDts);
  }

  TunerHostInfo copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? url,
      Wrapped<String?>? type,
      Wrapped<String?>? deviceId,
      Wrapped<String?>? friendlyName,
      Wrapped<bool?>? importFavoritesOnly,
      Wrapped<bool?>? allowHWTranscoding,
      Wrapped<bool?>? allowFmp4TranscodingContainer,
      Wrapped<bool?>? allowStreamSharing,
      Wrapped<int?>? fallbackMaxStreamingBitrate,
      Wrapped<bool?>? enableStreamLooping,
      Wrapped<String?>? source,
      Wrapped<int?>? tunerCount,
      Wrapped<String?>? userAgent,
      Wrapped<bool?>? ignoreDts}) {
    return TunerHostInfo(
        id: (id != null ? id.value : this.id),
        url: (url != null ? url.value : this.url),
        type: (type != null ? type.value : this.type),
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        friendlyName:
            (friendlyName != null ? friendlyName.value : this.friendlyName),
        importFavoritesOnly: (importFavoritesOnly != null
            ? importFavoritesOnly.value
            : this.importFavoritesOnly),
        allowHWTranscoding: (allowHWTranscoding != null
            ? allowHWTranscoding.value
            : this.allowHWTranscoding),
        allowFmp4TranscodingContainer: (allowFmp4TranscodingContainer != null
            ? allowFmp4TranscodingContainer.value
            : this.allowFmp4TranscodingContainer),
        allowStreamSharing: (allowStreamSharing != null
            ? allowStreamSharing.value
            : this.allowStreamSharing),
        fallbackMaxStreamingBitrate: (fallbackMaxStreamingBitrate != null
            ? fallbackMaxStreamingBitrate.value
            : this.fallbackMaxStreamingBitrate),
        enableStreamLooping: (enableStreamLooping != null
            ? enableStreamLooping.value
            : this.enableStreamLooping),
        source: (source != null ? source.value : this.source),
        tunerCount: (tunerCount != null ? tunerCount.value : this.tunerCount),
        userAgent: (userAgent != null ? userAgent.value : this.userAgent),
        ignoreDts: (ignoreDts != null ? ignoreDts.value : this.ignoreDts));
  }
}

@JsonSerializable(explicitToJson: true)
class TypeOptions {
  const TypeOptions({
    this.type,
    this.metadataFetchers,
    this.metadataFetcherOrder,
    this.imageFetchers,
    this.imageFetcherOrder,
    this.imageOptions,
  });

  factory TypeOptions.fromJson(Map<String, dynamic> json) =>
      _$TypeOptionsFromJson(json);

  static const toJsonFactory = _$TypeOptionsToJson;
  Map<String, dynamic> toJson() => _$TypeOptionsToJson(this);

  @JsonKey(name: 'Type')
  final String? type;
  @JsonKey(name: 'MetadataFetchers', defaultValue: <String>[])
  final List<String>? metadataFetchers;
  @JsonKey(name: 'MetadataFetcherOrder', defaultValue: <String>[])
  final List<String>? metadataFetcherOrder;
  @JsonKey(name: 'ImageFetchers', defaultValue: <String>[])
  final List<String>? imageFetchers;
  @JsonKey(name: 'ImageFetcherOrder', defaultValue: <String>[])
  final List<String>? imageFetcherOrder;
  @JsonKey(name: 'ImageOptions', defaultValue: <ImageOption>[])
  final List<ImageOption>? imageOptions;
  static const fromJsonFactory = _$TypeOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TypeOptions &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.metadataFetchers, metadataFetchers) ||
                const DeepCollectionEquality()
                    .equals(other.metadataFetchers, metadataFetchers)) &&
            (identical(other.metadataFetcherOrder, metadataFetcherOrder) ||
                const DeepCollectionEquality().equals(
                    other.metadataFetcherOrder, metadataFetcherOrder)) &&
            (identical(other.imageFetchers, imageFetchers) ||
                const DeepCollectionEquality()
                    .equals(other.imageFetchers, imageFetchers)) &&
            (identical(other.imageFetcherOrder, imageFetcherOrder) ||
                const DeepCollectionEquality()
                    .equals(other.imageFetcherOrder, imageFetcherOrder)) &&
            (identical(other.imageOptions, imageOptions) ||
                const DeepCollectionEquality()
                    .equals(other.imageOptions, imageOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(metadataFetchers) ^
      const DeepCollectionEquality().hash(metadataFetcherOrder) ^
      const DeepCollectionEquality().hash(imageFetchers) ^
      const DeepCollectionEquality().hash(imageFetcherOrder) ^
      const DeepCollectionEquality().hash(imageOptions) ^
      runtimeType.hashCode;
}

extension $TypeOptionsExtension on TypeOptions {
  TypeOptions copyWith(
      {String? type,
      List<String>? metadataFetchers,
      List<String>? metadataFetcherOrder,
      List<String>? imageFetchers,
      List<String>? imageFetcherOrder,
      List<ImageOption>? imageOptions}) {
    return TypeOptions(
        type: type ?? this.type,
        metadataFetchers: metadataFetchers ?? this.metadataFetchers,
        metadataFetcherOrder: metadataFetcherOrder ?? this.metadataFetcherOrder,
        imageFetchers: imageFetchers ?? this.imageFetchers,
        imageFetcherOrder: imageFetcherOrder ?? this.imageFetcherOrder,
        imageOptions: imageOptions ?? this.imageOptions);
  }

  TypeOptions copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<List<String>?>? metadataFetchers,
      Wrapped<List<String>?>? metadataFetcherOrder,
      Wrapped<List<String>?>? imageFetchers,
      Wrapped<List<String>?>? imageFetcherOrder,
      Wrapped<List<ImageOption>?>? imageOptions}) {
    return TypeOptions(
        type: (type != null ? type.value : this.type),
        metadataFetchers: (metadataFetchers != null
            ? metadataFetchers.value
            : this.metadataFetchers),
        metadataFetcherOrder: (metadataFetcherOrder != null
            ? metadataFetcherOrder.value
            : this.metadataFetcherOrder),
        imageFetchers:
            (imageFetchers != null ? imageFetchers.value : this.imageFetchers),
        imageFetcherOrder: (imageFetcherOrder != null
            ? imageFetcherOrder.value
            : this.imageFetcherOrder),
        imageOptions:
            (imageOptions != null ? imageOptions.value : this.imageOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateLibraryOptionsDto {
  const UpdateLibraryOptionsDto({
    this.id,
    this.libraryOptions,
  });

  factory UpdateLibraryOptionsDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateLibraryOptionsDtoFromJson(json);

  static const toJsonFactory = _$UpdateLibraryOptionsDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateLibraryOptionsDtoToJson(this);

  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'LibraryOptions')
  final LibraryOptions? libraryOptions;
  static const fromJsonFactory = _$UpdateLibraryOptionsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateLibraryOptionsDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.libraryOptions, libraryOptions) ||
                const DeepCollectionEquality()
                    .equals(other.libraryOptions, libraryOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(libraryOptions) ^
      runtimeType.hashCode;
}

extension $UpdateLibraryOptionsDtoExtension on UpdateLibraryOptionsDto {
  UpdateLibraryOptionsDto copyWith(
      {String? id, LibraryOptions? libraryOptions}) {
    return UpdateLibraryOptionsDto(
        id: id ?? this.id,
        libraryOptions: libraryOptions ?? this.libraryOptions);
  }

  UpdateLibraryOptionsDto copyWithWrapped(
      {Wrapped<String?>? id, Wrapped<LibraryOptions?>? libraryOptions}) {
    return UpdateLibraryOptionsDto(
        id: (id != null ? id.value : this.id),
        libraryOptions: (libraryOptions != null
            ? libraryOptions.value
            : this.libraryOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateMediaPathRequestDto {
  const UpdateMediaPathRequestDto({
    required this.name,
    required this.pathInfo,
  });

  factory UpdateMediaPathRequestDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateMediaPathRequestDtoFromJson(json);

  static const toJsonFactory = _$UpdateMediaPathRequestDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateMediaPathRequestDtoToJson(this);

  @JsonKey(name: 'Name')
  final String name;
  @JsonKey(name: 'PathInfo')
  final MediaPathInfo pathInfo;
  static const fromJsonFactory = _$UpdateMediaPathRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateMediaPathRequestDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.pathInfo, pathInfo) ||
                const DeepCollectionEquality()
                    .equals(other.pathInfo, pathInfo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(pathInfo) ^
      runtimeType.hashCode;
}

extension $UpdateMediaPathRequestDtoExtension on UpdateMediaPathRequestDto {
  UpdateMediaPathRequestDto copyWith({String? name, MediaPathInfo? pathInfo}) {
    return UpdateMediaPathRequestDto(
        name: name ?? this.name, pathInfo: pathInfo ?? this.pathInfo);
  }

  UpdateMediaPathRequestDto copyWithWrapped(
      {Wrapped<String>? name, Wrapped<MediaPathInfo>? pathInfo}) {
    return UpdateMediaPathRequestDto(
        name: (name != null ? name.value : this.name),
        pathInfo: (pathInfo != null ? pathInfo.value : this.pathInfo));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePlaylistDto {
  const UpdatePlaylistDto({
    this.name,
    this.ids,
    this.users,
    this.isPublic,
  });

  factory UpdatePlaylistDto.fromJson(Map<String, dynamic> json) =>
      _$UpdatePlaylistDtoFromJson(json);

  static const toJsonFactory = _$UpdatePlaylistDtoToJson;
  Map<String, dynamic> toJson() => _$UpdatePlaylistDtoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Ids', defaultValue: <String>[])
  final List<String>? ids;
  @JsonKey(name: 'Users', defaultValue: <PlaylistUserPermissions>[])
  final List<PlaylistUserPermissions>? users;
  @JsonKey(name: 'IsPublic')
  final bool? isPublic;
  static const fromJsonFactory = _$UpdatePlaylistDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePlaylistDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.ids, ids) ||
                const DeepCollectionEquality().equals(other.ids, ids)) &&
            (identical(other.users, users) ||
                const DeepCollectionEquality().equals(other.users, users)) &&
            (identical(other.isPublic, isPublic) ||
                const DeepCollectionEquality()
                    .equals(other.isPublic, isPublic)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(ids) ^
      const DeepCollectionEquality().hash(users) ^
      const DeepCollectionEquality().hash(isPublic) ^
      runtimeType.hashCode;
}

extension $UpdatePlaylistDtoExtension on UpdatePlaylistDto {
  UpdatePlaylistDto copyWith(
      {String? name,
      List<String>? ids,
      List<PlaylistUserPermissions>? users,
      bool? isPublic}) {
    return UpdatePlaylistDto(
        name: name ?? this.name,
        ids: ids ?? this.ids,
        users: users ?? this.users,
        isPublic: isPublic ?? this.isPublic);
  }

  UpdatePlaylistDto copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<List<String>?>? ids,
      Wrapped<List<PlaylistUserPermissions>?>? users,
      Wrapped<bool?>? isPublic}) {
    return UpdatePlaylistDto(
        name: (name != null ? name.value : this.name),
        ids: (ids != null ? ids.value : this.ids),
        users: (users != null ? users.value : this.users),
        isPublic: (isPublic != null ? isPublic.value : this.isPublic));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePlaylistUserDto {
  const UpdatePlaylistUserDto({
    this.canEdit,
  });

  factory UpdatePlaylistUserDto.fromJson(Map<String, dynamic> json) =>
      _$UpdatePlaylistUserDtoFromJson(json);

  static const toJsonFactory = _$UpdatePlaylistUserDtoToJson;
  Map<String, dynamic> toJson() => _$UpdatePlaylistUserDtoToJson(this);

  @JsonKey(name: 'CanEdit')
  final bool? canEdit;
  static const fromJsonFactory = _$UpdatePlaylistUserDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePlaylistUserDto &&
            (identical(other.canEdit, canEdit) ||
                const DeepCollectionEquality().equals(other.canEdit, canEdit)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(canEdit) ^ runtimeType.hashCode;
}

extension $UpdatePlaylistUserDtoExtension on UpdatePlaylistUserDto {
  UpdatePlaylistUserDto copyWith({bool? canEdit}) {
    return UpdatePlaylistUserDto(canEdit: canEdit ?? this.canEdit);
  }

  UpdatePlaylistUserDto copyWithWrapped({Wrapped<bool?>? canEdit}) {
    return UpdatePlaylistUserDto(
        canEdit: (canEdit != null ? canEdit.value : this.canEdit));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserItemDataDto {
  const UpdateUserItemDataDto({
    this.rating,
    this.playedPercentage,
    this.unplayedItemCount,
    this.playbackPositionTicks,
    this.playCount,
    this.isFavorite,
    this.likes,
    this.lastPlayedDate,
    this.played,
    this.key,
    this.itemId,
  });

  factory UpdateUserItemDataDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserItemDataDtoFromJson(json);

  static const toJsonFactory = _$UpdateUserItemDataDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateUserItemDataDtoToJson(this);

  @JsonKey(name: 'Rating')
  final double? rating;
  @JsonKey(name: 'PlayedPercentage')
  final double? playedPercentage;
  @JsonKey(name: 'UnplayedItemCount')
  final int? unplayedItemCount;
  @JsonKey(name: 'PlaybackPositionTicks')
  final int? playbackPositionTicks;
  @JsonKey(name: 'PlayCount')
  final int? playCount;
  @JsonKey(name: 'IsFavorite')
  final bool? isFavorite;
  @JsonKey(name: 'Likes')
  final bool? likes;
  @JsonKey(name: 'LastPlayedDate')
  final DateTime? lastPlayedDate;
  @JsonKey(name: 'Played')
  final bool? played;
  @JsonKey(name: 'Key')
  final String? key;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  static const fromJsonFactory = _$UpdateUserItemDataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserItemDataDto &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.playedPercentage, playedPercentage) ||
                const DeepCollectionEquality()
                    .equals(other.playedPercentage, playedPercentage)) &&
            (identical(other.unplayedItemCount, unplayedItemCount) ||
                const DeepCollectionEquality()
                    .equals(other.unplayedItemCount, unplayedItemCount)) &&
            (identical(other.playbackPositionTicks, playbackPositionTicks) ||
                const DeepCollectionEquality().equals(
                    other.playbackPositionTicks, playbackPositionTicks)) &&
            (identical(other.playCount, playCount) ||
                const DeepCollectionEquality()
                    .equals(other.playCount, playCount)) &&
            (identical(other.isFavorite, isFavorite) ||
                const DeepCollectionEquality()
                    .equals(other.isFavorite, isFavorite)) &&
            (identical(other.likes, likes) ||
                const DeepCollectionEquality().equals(other.likes, likes)) &&
            (identical(other.lastPlayedDate, lastPlayedDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPlayedDate, lastPlayedDate)) &&
            (identical(other.played, played) ||
                const DeepCollectionEquality().equals(other.played, played)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(playedPercentage) ^
      const DeepCollectionEquality().hash(unplayedItemCount) ^
      const DeepCollectionEquality().hash(playbackPositionTicks) ^
      const DeepCollectionEquality().hash(playCount) ^
      const DeepCollectionEquality().hash(isFavorite) ^
      const DeepCollectionEquality().hash(likes) ^
      const DeepCollectionEquality().hash(lastPlayedDate) ^
      const DeepCollectionEquality().hash(played) ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(itemId) ^
      runtimeType.hashCode;
}

extension $UpdateUserItemDataDtoExtension on UpdateUserItemDataDto {
  UpdateUserItemDataDto copyWith(
      {double? rating,
      double? playedPercentage,
      int? unplayedItemCount,
      int? playbackPositionTicks,
      int? playCount,
      bool? isFavorite,
      bool? likes,
      DateTime? lastPlayedDate,
      bool? played,
      String? key,
      String? itemId}) {
    return UpdateUserItemDataDto(
        rating: rating ?? this.rating,
        playedPercentage: playedPercentage ?? this.playedPercentage,
        unplayedItemCount: unplayedItemCount ?? this.unplayedItemCount,
        playbackPositionTicks:
            playbackPositionTicks ?? this.playbackPositionTicks,
        playCount: playCount ?? this.playCount,
        isFavorite: isFavorite ?? this.isFavorite,
        likes: likes ?? this.likes,
        lastPlayedDate: lastPlayedDate ?? this.lastPlayedDate,
        played: played ?? this.played,
        key: key ?? this.key,
        itemId: itemId ?? this.itemId);
  }

  UpdateUserItemDataDto copyWithWrapped(
      {Wrapped<double?>? rating,
      Wrapped<double?>? playedPercentage,
      Wrapped<int?>? unplayedItemCount,
      Wrapped<int?>? playbackPositionTicks,
      Wrapped<int?>? playCount,
      Wrapped<bool?>? isFavorite,
      Wrapped<bool?>? likes,
      Wrapped<DateTime?>? lastPlayedDate,
      Wrapped<bool?>? played,
      Wrapped<String?>? key,
      Wrapped<String?>? itemId}) {
    return UpdateUserItemDataDto(
        rating: (rating != null ? rating.value : this.rating),
        playedPercentage: (playedPercentage != null
            ? playedPercentage.value
            : this.playedPercentage),
        unplayedItemCount: (unplayedItemCount != null
            ? unplayedItemCount.value
            : this.unplayedItemCount),
        playbackPositionTicks: (playbackPositionTicks != null
            ? playbackPositionTicks.value
            : this.playbackPositionTicks),
        playCount: (playCount != null ? playCount.value : this.playCount),
        isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
        likes: (likes != null ? likes.value : this.likes),
        lastPlayedDate: (lastPlayedDate != null
            ? lastPlayedDate.value
            : this.lastPlayedDate),
        played: (played != null ? played.value : this.played),
        key: (key != null ? key.value : this.key),
        itemId: (itemId != null ? itemId.value : this.itemId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserPassword {
  const UpdateUserPassword({
    this.currentPassword,
    this.currentPw,
    this.newPw,
    this.resetPassword,
  });

  factory UpdateUserPassword.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserPasswordFromJson(json);

  static const toJsonFactory = _$UpdateUserPasswordToJson;
  Map<String, dynamic> toJson() => _$UpdateUserPasswordToJson(this);

  @JsonKey(name: 'CurrentPassword')
  final String? currentPassword;
  @JsonKey(name: 'CurrentPw')
  final String? currentPw;
  @JsonKey(name: 'NewPw')
  final String? newPw;
  @JsonKey(name: 'ResetPassword')
  final bool? resetPassword;
  static const fromJsonFactory = _$UpdateUserPasswordFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserPassword &&
            (identical(other.currentPassword, currentPassword) ||
                const DeepCollectionEquality()
                    .equals(other.currentPassword, currentPassword)) &&
            (identical(other.currentPw, currentPw) ||
                const DeepCollectionEquality()
                    .equals(other.currentPw, currentPw)) &&
            (identical(other.newPw, newPw) ||
                const DeepCollectionEquality().equals(other.newPw, newPw)) &&
            (identical(other.resetPassword, resetPassword) ||
                const DeepCollectionEquality()
                    .equals(other.resetPassword, resetPassword)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPassword) ^
      const DeepCollectionEquality().hash(currentPw) ^
      const DeepCollectionEquality().hash(newPw) ^
      const DeepCollectionEquality().hash(resetPassword) ^
      runtimeType.hashCode;
}

extension $UpdateUserPasswordExtension on UpdateUserPassword {
  UpdateUserPassword copyWith(
      {String? currentPassword,
      String? currentPw,
      String? newPw,
      bool? resetPassword}) {
    return UpdateUserPassword(
        currentPassword: currentPassword ?? this.currentPassword,
        currentPw: currentPw ?? this.currentPw,
        newPw: newPw ?? this.newPw,
        resetPassword: resetPassword ?? this.resetPassword);
  }

  UpdateUserPassword copyWithWrapped(
      {Wrapped<String?>? currentPassword,
      Wrapped<String?>? currentPw,
      Wrapped<String?>? newPw,
      Wrapped<bool?>? resetPassword}) {
    return UpdateUserPassword(
        currentPassword: (currentPassword != null
            ? currentPassword.value
            : this.currentPassword),
        currentPw: (currentPw != null ? currentPw.value : this.currentPw),
        newPw: (newPw != null ? newPw.value : this.newPw),
        resetPassword:
            (resetPassword != null ? resetPassword.value : this.resetPassword));
  }
}

@JsonSerializable(explicitToJson: true)
class UploadSubtitleDto {
  const UploadSubtitleDto({
    required this.language,
    required this.format,
    required this.isForced,
    required this.isHearingImpaired,
    required this.data,
  });

  factory UploadSubtitleDto.fromJson(Map<String, dynamic> json) =>
      _$UploadSubtitleDtoFromJson(json);

  static const toJsonFactory = _$UploadSubtitleDtoToJson;
  Map<String, dynamic> toJson() => _$UploadSubtitleDtoToJson(this);

  @JsonKey(name: 'Language')
  final String language;
  @JsonKey(name: 'Format')
  final String format;
  @JsonKey(name: 'IsForced')
  final bool isForced;
  @JsonKey(name: 'IsHearingImpaired')
  final bool isHearingImpaired;
  @JsonKey(name: 'Data')
  final String data;
  static const fromJsonFactory = _$UploadSubtitleDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UploadSubtitleDto &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.isForced, isForced) ||
                const DeepCollectionEquality()
                    .equals(other.isForced, isForced)) &&
            (identical(other.isHearingImpaired, isHearingImpaired) ||
                const DeepCollectionEquality()
                    .equals(other.isHearingImpaired, isHearingImpaired)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(isForced) ^
      const DeepCollectionEquality().hash(isHearingImpaired) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $UploadSubtitleDtoExtension on UploadSubtitleDto {
  UploadSubtitleDto copyWith(
      {String? language,
      String? format,
      bool? isForced,
      bool? isHearingImpaired,
      String? data}) {
    return UploadSubtitleDto(
        language: language ?? this.language,
        format: format ?? this.format,
        isForced: isForced ?? this.isForced,
        isHearingImpaired: isHearingImpaired ?? this.isHearingImpaired,
        data: data ?? this.data);
  }

  UploadSubtitleDto copyWithWrapped(
      {Wrapped<String>? language,
      Wrapped<String>? format,
      Wrapped<bool>? isForced,
      Wrapped<bool>? isHearingImpaired,
      Wrapped<String>? data}) {
    return UploadSubtitleDto(
        language: (language != null ? language.value : this.language),
        format: (format != null ? format.value : this.format),
        isForced: (isForced != null ? isForced.value : this.isForced),
        isHearingImpaired: (isHearingImpaired != null
            ? isHearingImpaired.value
            : this.isHearingImpaired),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class UserConfiguration {
  const UserConfiguration({
    this.audioLanguagePreference,
    this.playDefaultAudioTrack,
    this.subtitleLanguagePreference,
    this.displayMissingEpisodes,
    this.groupedFolders,
    this.subtitleMode,
    this.displayCollectionsView,
    this.enableLocalPassword,
    this.orderedViews,
    this.latestItemsExcludes,
    this.myMediaExcludes,
    this.hidePlayedInLatest,
    this.rememberAudioSelections,
    this.rememberSubtitleSelections,
    this.enableNextEpisodeAutoPlay,
    this.castReceiverId,
  });

  factory UserConfiguration.fromJson(Map<String, dynamic> json) =>
      _$UserConfigurationFromJson(json);

  static const toJsonFactory = _$UserConfigurationToJson;
  Map<String, dynamic> toJson() => _$UserConfigurationToJson(this);

  @JsonKey(name: 'AudioLanguagePreference')
  final String? audioLanguagePreference;
  @JsonKey(name: 'PlayDefaultAudioTrack')
  final bool? playDefaultAudioTrack;
  @JsonKey(name: 'SubtitleLanguagePreference')
  final String? subtitleLanguagePreference;
  @JsonKey(name: 'DisplayMissingEpisodes')
  final bool? displayMissingEpisodes;
  @JsonKey(name: 'GroupedFolders', defaultValue: <String>[])
  final List<String>? groupedFolders;
  @JsonKey(
    name: 'SubtitleMode',
    toJson: subtitlePlaybackModeNullableToJson,
    fromJson: subtitlePlaybackModeNullableFromJson,
  )
  final enums.SubtitlePlaybackMode? subtitleMode;
  @JsonKey(name: 'DisplayCollectionsView')
  final bool? displayCollectionsView;
  @JsonKey(name: 'EnableLocalPassword')
  final bool? enableLocalPassword;
  @JsonKey(name: 'OrderedViews', defaultValue: <String>[])
  final List<String>? orderedViews;
  @JsonKey(name: 'LatestItemsExcludes', defaultValue: <String>[])
  final List<String>? latestItemsExcludes;
  @JsonKey(name: 'MyMediaExcludes', defaultValue: <String>[])
  final List<String>? myMediaExcludes;
  @JsonKey(name: 'HidePlayedInLatest')
  final bool? hidePlayedInLatest;
  @JsonKey(name: 'RememberAudioSelections')
  final bool? rememberAudioSelections;
  @JsonKey(name: 'RememberSubtitleSelections')
  final bool? rememberSubtitleSelections;
  @JsonKey(name: 'EnableNextEpisodeAutoPlay')
  final bool? enableNextEpisodeAutoPlay;
  @JsonKey(name: 'CastReceiverId')
  final String? castReceiverId;
  static const fromJsonFactory = _$UserConfigurationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserConfiguration &&
            (identical(other.audioLanguagePreference, audioLanguagePreference) ||
                const DeepCollectionEquality().equals(
                    other.audioLanguagePreference, audioLanguagePreference)) &&
            (identical(other.playDefaultAudioTrack, playDefaultAudioTrack) ||
                const DeepCollectionEquality().equals(
                    other.playDefaultAudioTrack, playDefaultAudioTrack)) &&
            (identical(other.subtitleLanguagePreference, subtitleLanguagePreference) ||
                const DeepCollectionEquality().equals(
                    other.subtitleLanguagePreference,
                    subtitleLanguagePreference)) &&
            (identical(other.displayMissingEpisodes, displayMissingEpisodes) ||
                const DeepCollectionEquality().equals(
                    other.displayMissingEpisodes, displayMissingEpisodes)) &&
            (identical(other.groupedFolders, groupedFolders) ||
                const DeepCollectionEquality()
                    .equals(other.groupedFolders, groupedFolders)) &&
            (identical(other.subtitleMode, subtitleMode) ||
                const DeepCollectionEquality()
                    .equals(other.subtitleMode, subtitleMode)) &&
            (identical(other.displayCollectionsView, displayCollectionsView) ||
                const DeepCollectionEquality().equals(
                    other.displayCollectionsView, displayCollectionsView)) &&
            (identical(other.enableLocalPassword, enableLocalPassword) ||
                const DeepCollectionEquality()
                    .equals(other.enableLocalPassword, enableLocalPassword)) &&
            (identical(other.orderedViews, orderedViews) ||
                const DeepCollectionEquality()
                    .equals(other.orderedViews, orderedViews)) &&
            (identical(other.latestItemsExcludes, latestItemsExcludes) ||
                const DeepCollectionEquality()
                    .equals(other.latestItemsExcludes, latestItemsExcludes)) &&
            (identical(other.myMediaExcludes, myMediaExcludes) ||
                const DeepCollectionEquality()
                    .equals(other.myMediaExcludes, myMediaExcludes)) &&
            (identical(other.hidePlayedInLatest, hidePlayedInLatest) ||
                const DeepCollectionEquality()
                    .equals(other.hidePlayedInLatest, hidePlayedInLatest)) &&
            (identical(other.rememberAudioSelections, rememberAudioSelections) ||
                const DeepCollectionEquality().equals(other.rememberAudioSelections, rememberAudioSelections)) &&
            (identical(other.rememberSubtitleSelections, rememberSubtitleSelections) || const DeepCollectionEquality().equals(other.rememberSubtitleSelections, rememberSubtitleSelections)) &&
            (identical(other.enableNextEpisodeAutoPlay, enableNextEpisodeAutoPlay) || const DeepCollectionEquality().equals(other.enableNextEpisodeAutoPlay, enableNextEpisodeAutoPlay)) &&
            (identical(other.castReceiverId, castReceiverId) || const DeepCollectionEquality().equals(other.castReceiverId, castReceiverId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audioLanguagePreference) ^
      const DeepCollectionEquality().hash(playDefaultAudioTrack) ^
      const DeepCollectionEquality().hash(subtitleLanguagePreference) ^
      const DeepCollectionEquality().hash(displayMissingEpisodes) ^
      const DeepCollectionEquality().hash(groupedFolders) ^
      const DeepCollectionEquality().hash(subtitleMode) ^
      const DeepCollectionEquality().hash(displayCollectionsView) ^
      const DeepCollectionEquality().hash(enableLocalPassword) ^
      const DeepCollectionEquality().hash(orderedViews) ^
      const DeepCollectionEquality().hash(latestItemsExcludes) ^
      const DeepCollectionEquality().hash(myMediaExcludes) ^
      const DeepCollectionEquality().hash(hidePlayedInLatest) ^
      const DeepCollectionEquality().hash(rememberAudioSelections) ^
      const DeepCollectionEquality().hash(rememberSubtitleSelections) ^
      const DeepCollectionEquality().hash(enableNextEpisodeAutoPlay) ^
      const DeepCollectionEquality().hash(castReceiverId) ^
      runtimeType.hashCode;
}

extension $UserConfigurationExtension on UserConfiguration {
  UserConfiguration copyWith(
      {String? audioLanguagePreference,
      bool? playDefaultAudioTrack,
      String? subtitleLanguagePreference,
      bool? displayMissingEpisodes,
      List<String>? groupedFolders,
      enums.SubtitlePlaybackMode? subtitleMode,
      bool? displayCollectionsView,
      bool? enableLocalPassword,
      List<String>? orderedViews,
      List<String>? latestItemsExcludes,
      List<String>? myMediaExcludes,
      bool? hidePlayedInLatest,
      bool? rememberAudioSelections,
      bool? rememberSubtitleSelections,
      bool? enableNextEpisodeAutoPlay,
      String? castReceiverId}) {
    return UserConfiguration(
        audioLanguagePreference:
            audioLanguagePreference ?? this.audioLanguagePreference,
        playDefaultAudioTrack:
            playDefaultAudioTrack ?? this.playDefaultAudioTrack,
        subtitleLanguagePreference:
            subtitleLanguagePreference ?? this.subtitleLanguagePreference,
        displayMissingEpisodes:
            displayMissingEpisodes ?? this.displayMissingEpisodes,
        groupedFolders: groupedFolders ?? this.groupedFolders,
        subtitleMode: subtitleMode ?? this.subtitleMode,
        displayCollectionsView:
            displayCollectionsView ?? this.displayCollectionsView,
        enableLocalPassword: enableLocalPassword ?? this.enableLocalPassword,
        orderedViews: orderedViews ?? this.orderedViews,
        latestItemsExcludes: latestItemsExcludes ?? this.latestItemsExcludes,
        myMediaExcludes: myMediaExcludes ?? this.myMediaExcludes,
        hidePlayedInLatest: hidePlayedInLatest ?? this.hidePlayedInLatest,
        rememberAudioSelections:
            rememberAudioSelections ?? this.rememberAudioSelections,
        rememberSubtitleSelections:
            rememberSubtitleSelections ?? this.rememberSubtitleSelections,
        enableNextEpisodeAutoPlay:
            enableNextEpisodeAutoPlay ?? this.enableNextEpisodeAutoPlay,
        castReceiverId: castReceiverId ?? this.castReceiverId);
  }

  UserConfiguration copyWithWrapped(
      {Wrapped<String?>? audioLanguagePreference,
      Wrapped<bool?>? playDefaultAudioTrack,
      Wrapped<String?>? subtitleLanguagePreference,
      Wrapped<bool?>? displayMissingEpisodes,
      Wrapped<List<String>?>? groupedFolders,
      Wrapped<enums.SubtitlePlaybackMode?>? subtitleMode,
      Wrapped<bool?>? displayCollectionsView,
      Wrapped<bool?>? enableLocalPassword,
      Wrapped<List<String>?>? orderedViews,
      Wrapped<List<String>?>? latestItemsExcludes,
      Wrapped<List<String>?>? myMediaExcludes,
      Wrapped<bool?>? hidePlayedInLatest,
      Wrapped<bool?>? rememberAudioSelections,
      Wrapped<bool?>? rememberSubtitleSelections,
      Wrapped<bool?>? enableNextEpisodeAutoPlay,
      Wrapped<String?>? castReceiverId}) {
    return UserConfiguration(
        audioLanguagePreference: (audioLanguagePreference != null
            ? audioLanguagePreference.value
            : this.audioLanguagePreference),
        playDefaultAudioTrack: (playDefaultAudioTrack != null
            ? playDefaultAudioTrack.value
            : this.playDefaultAudioTrack),
        subtitleLanguagePreference: (subtitleLanguagePreference != null
            ? subtitleLanguagePreference.value
            : this.subtitleLanguagePreference),
        displayMissingEpisodes: (displayMissingEpisodes != null
            ? displayMissingEpisodes.value
            : this.displayMissingEpisodes),
        groupedFolders: (groupedFolders != null
            ? groupedFolders.value
            : this.groupedFolders),
        subtitleMode:
            (subtitleMode != null ? subtitleMode.value : this.subtitleMode),
        displayCollectionsView: (displayCollectionsView != null
            ? displayCollectionsView.value
            : this.displayCollectionsView),
        enableLocalPassword: (enableLocalPassword != null
            ? enableLocalPassword.value
            : this.enableLocalPassword),
        orderedViews:
            (orderedViews != null ? orderedViews.value : this.orderedViews),
        latestItemsExcludes: (latestItemsExcludes != null
            ? latestItemsExcludes.value
            : this.latestItemsExcludes),
        myMediaExcludes: (myMediaExcludes != null
            ? myMediaExcludes.value
            : this.myMediaExcludes),
        hidePlayedInLatest: (hidePlayedInLatest != null
            ? hidePlayedInLatest.value
            : this.hidePlayedInLatest),
        rememberAudioSelections: (rememberAudioSelections != null
            ? rememberAudioSelections.value
            : this.rememberAudioSelections),
        rememberSubtitleSelections: (rememberSubtitleSelections != null
            ? rememberSubtitleSelections.value
            : this.rememberSubtitleSelections),
        enableNextEpisodeAutoPlay: (enableNextEpisodeAutoPlay != null
            ? enableNextEpisodeAutoPlay.value
            : this.enableNextEpisodeAutoPlay),
        castReceiverId: (castReceiverId != null
            ? castReceiverId.value
            : this.castReceiverId));
  }
}

@JsonSerializable(explicitToJson: true)
class UserDataChangedMessage {
  const UserDataChangedMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory UserDataChangedMessage.fromJson(Map<String, dynamic> json) =>
      _$UserDataChangedMessageFromJson(json);

  static const toJsonFactory = _$UserDataChangedMessageToJson;
  Map<String, dynamic> toJson() => _$UserDataChangedMessageToJson(this);

  @JsonKey(name: 'Data')
  final UserDataChangeInfo? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.userdatachanged);

  static const fromJsonFactory = _$UserDataChangedMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserDataChangedMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $UserDataChangedMessageExtension on UserDataChangedMessage {
  UserDataChangedMessage copyWith(
      {UserDataChangeInfo? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return UserDataChangedMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  UserDataChangedMessage copyWithWrapped(
      {Wrapped<UserDataChangeInfo?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return UserDataChangedMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class UserDataChangeInfo {
  const UserDataChangeInfo({
    this.userId,
    this.userDataList,
  });

  factory UserDataChangeInfo.fromJson(Map<String, dynamic> json) =>
      _$UserDataChangeInfoFromJson(json);

  static const toJsonFactory = _$UserDataChangeInfoToJson;
  Map<String, dynamic> toJson() => _$UserDataChangeInfoToJson(this);

  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'UserDataList', defaultValue: <UserItemDataDto>[])
  final List<UserItemDataDto>? userDataList;
  static const fromJsonFactory = _$UserDataChangeInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserDataChangeInfo &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userDataList, userDataList) ||
                const DeepCollectionEquality()
                    .equals(other.userDataList, userDataList)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userDataList) ^
      runtimeType.hashCode;
}

extension $UserDataChangeInfoExtension on UserDataChangeInfo {
  UserDataChangeInfo copyWith(
      {String? userId, List<UserItemDataDto>? userDataList}) {
    return UserDataChangeInfo(
        userId: userId ?? this.userId,
        userDataList: userDataList ?? this.userDataList);
  }

  UserDataChangeInfo copyWithWrapped(
      {Wrapped<String?>? userId,
      Wrapped<List<UserItemDataDto>?>? userDataList}) {
    return UserDataChangeInfo(
        userId: (userId != null ? userId.value : this.userId),
        userDataList:
            (userDataList != null ? userDataList.value : this.userDataList));
  }
}

@JsonSerializable(explicitToJson: true)
class UserDeletedMessage {
  const UserDeletedMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory UserDeletedMessage.fromJson(Map<String, dynamic> json) =>
      _$UserDeletedMessageFromJson(json);

  static const toJsonFactory = _$UserDeletedMessageToJson;
  Map<String, dynamic> toJson() => _$UserDeletedMessageToJson(this);

  @JsonKey(name: 'Data')
  final String? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.userdeleted);

  static const fromJsonFactory = _$UserDeletedMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserDeletedMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $UserDeletedMessageExtension on UserDeletedMessage {
  UserDeletedMessage copyWith(
      {String? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return UserDeletedMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  UserDeletedMessage copyWithWrapped(
      {Wrapped<String?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return UserDeletedMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class UserDto {
  const UserDto({
    this.name,
    this.serverId,
    this.serverName,
    this.id,
    this.primaryImageTag,
    this.hasPassword,
    this.hasConfiguredPassword,
    this.hasConfiguredEasyPassword,
    this.enableAutoLogin,
    this.lastLoginDate,
    this.lastActivityDate,
    this.configuration,
    this.policy,
    this.primaryImageAspectRatio,
  });

  factory UserDto.fromJson(Map<String, dynamic> json) =>
      _$UserDtoFromJson(json);

  static const toJsonFactory = _$UserDtoToJson;
  Map<String, dynamic> toJson() => _$UserDtoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'ServerId')
  final String? serverId;
  @JsonKey(name: 'ServerName')
  final String? serverName;
  @JsonKey(name: 'Id')
  final String? id;
  @JsonKey(name: 'PrimaryImageTag')
  final String? primaryImageTag;
  @JsonKey(name: 'HasPassword')
  final bool? hasPassword;
  @JsonKey(name: 'HasConfiguredPassword')
  final bool? hasConfiguredPassword;
  @JsonKey(name: 'HasConfiguredEasyPassword')
  @deprecated
  final bool? hasConfiguredEasyPassword;
  @JsonKey(name: 'EnableAutoLogin')
  final bool? enableAutoLogin;
  @JsonKey(name: 'LastLoginDate')
  final DateTime? lastLoginDate;
  @JsonKey(name: 'LastActivityDate')
  final DateTime? lastActivityDate;
  @JsonKey(name: 'Configuration')
  final UserConfiguration? configuration;
  @JsonKey(name: 'Policy')
  final UserPolicy? policy;
  @JsonKey(name: 'PrimaryImageAspectRatio')
  final double? primaryImageAspectRatio;
  static const fromJsonFactory = _$UserDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.serverId, serverId) ||
                const DeepCollectionEquality()
                    .equals(other.serverId, serverId)) &&
            (identical(other.serverName, serverName) ||
                const DeepCollectionEquality()
                    .equals(other.serverName, serverName)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.primaryImageTag, primaryImageTag) ||
                const DeepCollectionEquality()
                    .equals(other.primaryImageTag, primaryImageTag)) &&
            (identical(other.hasPassword, hasPassword) ||
                const DeepCollectionEquality()
                    .equals(other.hasPassword, hasPassword)) &&
            (identical(other.hasConfiguredPassword, hasConfiguredPassword) ||
                const DeepCollectionEquality().equals(
                    other.hasConfiguredPassword, hasConfiguredPassword)) &&
            (identical(other.hasConfiguredEasyPassword,
                    hasConfiguredEasyPassword) ||
                const DeepCollectionEquality().equals(
                    other.hasConfiguredEasyPassword,
                    hasConfiguredEasyPassword)) &&
            (identical(other.enableAutoLogin, enableAutoLogin) ||
                const DeepCollectionEquality()
                    .equals(other.enableAutoLogin, enableAutoLogin)) &&
            (identical(other.lastLoginDate, lastLoginDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastLoginDate, lastLoginDate)) &&
            (identical(other.lastActivityDate, lastActivityDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastActivityDate, lastActivityDate)) &&
            (identical(other.configuration, configuration) ||
                const DeepCollectionEquality()
                    .equals(other.configuration, configuration)) &&
            (identical(other.policy, policy) ||
                const DeepCollectionEquality().equals(other.policy, policy)) &&
            (identical(
                    other.primaryImageAspectRatio, primaryImageAspectRatio) ||
                const DeepCollectionEquality().equals(
                    other.primaryImageAspectRatio, primaryImageAspectRatio)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(serverId) ^
      const DeepCollectionEquality().hash(serverName) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(primaryImageTag) ^
      const DeepCollectionEquality().hash(hasPassword) ^
      const DeepCollectionEquality().hash(hasConfiguredPassword) ^
      const DeepCollectionEquality().hash(hasConfiguredEasyPassword) ^
      const DeepCollectionEquality().hash(enableAutoLogin) ^
      const DeepCollectionEquality().hash(lastLoginDate) ^
      const DeepCollectionEquality().hash(lastActivityDate) ^
      const DeepCollectionEquality().hash(configuration) ^
      const DeepCollectionEquality().hash(policy) ^
      const DeepCollectionEquality().hash(primaryImageAspectRatio) ^
      runtimeType.hashCode;
}

extension $UserDtoExtension on UserDto {
  UserDto copyWith(
      {String? name,
      String? serverId,
      String? serverName,
      String? id,
      String? primaryImageTag,
      bool? hasPassword,
      bool? hasConfiguredPassword,
      bool? hasConfiguredEasyPassword,
      bool? enableAutoLogin,
      DateTime? lastLoginDate,
      DateTime? lastActivityDate,
      UserConfiguration? configuration,
      UserPolicy? policy,
      double? primaryImageAspectRatio}) {
    return UserDto(
        name: name ?? this.name,
        serverId: serverId ?? this.serverId,
        serverName: serverName ?? this.serverName,
        id: id ?? this.id,
        primaryImageTag: primaryImageTag ?? this.primaryImageTag,
        hasPassword: hasPassword ?? this.hasPassword,
        hasConfiguredPassword:
            hasConfiguredPassword ?? this.hasConfiguredPassword,
        hasConfiguredEasyPassword:
            hasConfiguredEasyPassword ?? this.hasConfiguredEasyPassword,
        enableAutoLogin: enableAutoLogin ?? this.enableAutoLogin,
        lastLoginDate: lastLoginDate ?? this.lastLoginDate,
        lastActivityDate: lastActivityDate ?? this.lastActivityDate,
        configuration: configuration ?? this.configuration,
        policy: policy ?? this.policy,
        primaryImageAspectRatio:
            primaryImageAspectRatio ?? this.primaryImageAspectRatio);
  }

  UserDto copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? serverId,
      Wrapped<String?>? serverName,
      Wrapped<String?>? id,
      Wrapped<String?>? primaryImageTag,
      Wrapped<bool?>? hasPassword,
      Wrapped<bool?>? hasConfiguredPassword,
      Wrapped<bool?>? hasConfiguredEasyPassword,
      Wrapped<bool?>? enableAutoLogin,
      Wrapped<DateTime?>? lastLoginDate,
      Wrapped<DateTime?>? lastActivityDate,
      Wrapped<UserConfiguration?>? configuration,
      Wrapped<UserPolicy?>? policy,
      Wrapped<double?>? primaryImageAspectRatio}) {
    return UserDto(
        name: (name != null ? name.value : this.name),
        serverId: (serverId != null ? serverId.value : this.serverId),
        serverName: (serverName != null ? serverName.value : this.serverName),
        id: (id != null ? id.value : this.id),
        primaryImageTag: (primaryImageTag != null
            ? primaryImageTag.value
            : this.primaryImageTag),
        hasPassword:
            (hasPassword != null ? hasPassword.value : this.hasPassword),
        hasConfiguredPassword: (hasConfiguredPassword != null
            ? hasConfiguredPassword.value
            : this.hasConfiguredPassword),
        hasConfiguredEasyPassword: (hasConfiguredEasyPassword != null
            ? hasConfiguredEasyPassword.value
            : this.hasConfiguredEasyPassword),
        enableAutoLogin: (enableAutoLogin != null
            ? enableAutoLogin.value
            : this.enableAutoLogin),
        lastLoginDate:
            (lastLoginDate != null ? lastLoginDate.value : this.lastLoginDate),
        lastActivityDate: (lastActivityDate != null
            ? lastActivityDate.value
            : this.lastActivityDate),
        configuration:
            (configuration != null ? configuration.value : this.configuration),
        policy: (policy != null ? policy.value : this.policy),
        primaryImageAspectRatio: (primaryImageAspectRatio != null
            ? primaryImageAspectRatio.value
            : this.primaryImageAspectRatio));
  }
}

@JsonSerializable(explicitToJson: true)
class UserItemDataDto {
  const UserItemDataDto({
    this.rating,
    this.playedPercentage,
    this.unplayedItemCount,
    this.playbackPositionTicks,
    this.playCount,
    this.isFavorite,
    this.likes,
    this.lastPlayedDate,
    this.played,
    this.key,
    this.itemId,
  });

  factory UserItemDataDto.fromJson(Map<String, dynamic> json) =>
      _$UserItemDataDtoFromJson(json);

  static const toJsonFactory = _$UserItemDataDtoToJson;
  Map<String, dynamic> toJson() => _$UserItemDataDtoToJson(this);

  @JsonKey(name: 'Rating')
  final double? rating;
  @JsonKey(name: 'PlayedPercentage')
  final double? playedPercentage;
  @JsonKey(name: 'UnplayedItemCount')
  final int? unplayedItemCount;
  @JsonKey(name: 'PlaybackPositionTicks')
  final int? playbackPositionTicks;
  @JsonKey(name: 'PlayCount')
  final int? playCount;
  @JsonKey(name: 'IsFavorite')
  final bool? isFavorite;
  @JsonKey(name: 'Likes')
  final bool? likes;
  @JsonKey(name: 'LastPlayedDate')
  final DateTime? lastPlayedDate;
  @JsonKey(name: 'Played')
  final bool? played;
  @JsonKey(name: 'Key')
  final String? key;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  static const fromJsonFactory = _$UserItemDataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserItemDataDto &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.playedPercentage, playedPercentage) ||
                const DeepCollectionEquality()
                    .equals(other.playedPercentage, playedPercentage)) &&
            (identical(other.unplayedItemCount, unplayedItemCount) ||
                const DeepCollectionEquality()
                    .equals(other.unplayedItemCount, unplayedItemCount)) &&
            (identical(other.playbackPositionTicks, playbackPositionTicks) ||
                const DeepCollectionEquality().equals(
                    other.playbackPositionTicks, playbackPositionTicks)) &&
            (identical(other.playCount, playCount) ||
                const DeepCollectionEquality()
                    .equals(other.playCount, playCount)) &&
            (identical(other.isFavorite, isFavorite) ||
                const DeepCollectionEquality()
                    .equals(other.isFavorite, isFavorite)) &&
            (identical(other.likes, likes) ||
                const DeepCollectionEquality().equals(other.likes, likes)) &&
            (identical(other.lastPlayedDate, lastPlayedDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPlayedDate, lastPlayedDate)) &&
            (identical(other.played, played) ||
                const DeepCollectionEquality().equals(other.played, played)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(playedPercentage) ^
      const DeepCollectionEquality().hash(unplayedItemCount) ^
      const DeepCollectionEquality().hash(playbackPositionTicks) ^
      const DeepCollectionEquality().hash(playCount) ^
      const DeepCollectionEquality().hash(isFavorite) ^
      const DeepCollectionEquality().hash(likes) ^
      const DeepCollectionEquality().hash(lastPlayedDate) ^
      const DeepCollectionEquality().hash(played) ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(itemId) ^
      runtimeType.hashCode;
}

extension $UserItemDataDtoExtension on UserItemDataDto {
  UserItemDataDto copyWith(
      {double? rating,
      double? playedPercentage,
      int? unplayedItemCount,
      int? playbackPositionTicks,
      int? playCount,
      bool? isFavorite,
      bool? likes,
      DateTime? lastPlayedDate,
      bool? played,
      String? key,
      String? itemId}) {
    return UserItemDataDto(
        rating: rating ?? this.rating,
        playedPercentage: playedPercentage ?? this.playedPercentage,
        unplayedItemCount: unplayedItemCount ?? this.unplayedItemCount,
        playbackPositionTicks:
            playbackPositionTicks ?? this.playbackPositionTicks,
        playCount: playCount ?? this.playCount,
        isFavorite: isFavorite ?? this.isFavorite,
        likes: likes ?? this.likes,
        lastPlayedDate: lastPlayedDate ?? this.lastPlayedDate,
        played: played ?? this.played,
        key: key ?? this.key,
        itemId: itemId ?? this.itemId);
  }

  UserItemDataDto copyWithWrapped(
      {Wrapped<double?>? rating,
      Wrapped<double?>? playedPercentage,
      Wrapped<int?>? unplayedItemCount,
      Wrapped<int?>? playbackPositionTicks,
      Wrapped<int?>? playCount,
      Wrapped<bool?>? isFavorite,
      Wrapped<bool?>? likes,
      Wrapped<DateTime?>? lastPlayedDate,
      Wrapped<bool?>? played,
      Wrapped<String?>? key,
      Wrapped<String?>? itemId}) {
    return UserItemDataDto(
        rating: (rating != null ? rating.value : this.rating),
        playedPercentage: (playedPercentage != null
            ? playedPercentage.value
            : this.playedPercentage),
        unplayedItemCount: (unplayedItemCount != null
            ? unplayedItemCount.value
            : this.unplayedItemCount),
        playbackPositionTicks: (playbackPositionTicks != null
            ? playbackPositionTicks.value
            : this.playbackPositionTicks),
        playCount: (playCount != null ? playCount.value : this.playCount),
        isFavorite: (isFavorite != null ? isFavorite.value : this.isFavorite),
        likes: (likes != null ? likes.value : this.likes),
        lastPlayedDate: (lastPlayedDate != null
            ? lastPlayedDate.value
            : this.lastPlayedDate),
        played: (played != null ? played.value : this.played),
        key: (key != null ? key.value : this.key),
        itemId: (itemId != null ? itemId.value : this.itemId));
  }
}

@JsonSerializable(explicitToJson: true)
class UserPolicy {
  const UserPolicy({
    this.isAdministrator,
    this.isHidden,
    this.enableCollectionManagement,
    this.enableSubtitleManagement,
    this.enableLyricManagement,
    this.isDisabled,
    this.maxParentalRating,
    this.blockedTags,
    this.allowedTags,
    this.enableUserPreferenceAccess,
    this.accessSchedules,
    this.blockUnratedItems,
    this.enableRemoteControlOfOtherUsers,
    this.enableSharedDeviceControl,
    this.enableRemoteAccess,
    this.enableLiveTvManagement,
    this.enableLiveTvAccess,
    this.enableMediaPlayback,
    this.enableAudioPlaybackTranscoding,
    this.enableVideoPlaybackTranscoding,
    this.enablePlaybackRemuxing,
    this.forceRemoteSourceTranscoding,
    this.enableContentDeletion,
    this.enableContentDeletionFromFolders,
    this.enableContentDownloading,
    this.enableSyncTranscoding,
    this.enableMediaConversion,
    this.enabledDevices,
    this.enableAllDevices,
    this.enabledChannels,
    this.enableAllChannels,
    this.enabledFolders,
    this.enableAllFolders,
    this.invalidLoginAttemptCount,
    this.loginAttemptsBeforeLockout,
    this.maxActiveSessions,
    this.enablePublicSharing,
    this.blockedMediaFolders,
    this.blockedChannels,
    this.remoteClientBitrateLimit,
    required this.authenticationProviderId,
    required this.passwordResetProviderId,
    this.syncPlayAccess,
  });

  factory UserPolicy.fromJson(Map<String, dynamic> json) =>
      _$UserPolicyFromJson(json);

  static const toJsonFactory = _$UserPolicyToJson;
  Map<String, dynamic> toJson() => _$UserPolicyToJson(this);

  @JsonKey(name: 'IsAdministrator')
  final bool? isAdministrator;
  @JsonKey(name: 'IsHidden')
  final bool? isHidden;
  @JsonKey(name: 'EnableCollectionManagement', defaultValue: false)
  final bool? enableCollectionManagement;
  @JsonKey(name: 'EnableSubtitleManagement', defaultValue: false)
  final bool? enableSubtitleManagement;
  @JsonKey(name: 'EnableLyricManagement', defaultValue: false)
  final bool? enableLyricManagement;
  @JsonKey(name: 'IsDisabled')
  final bool? isDisabled;
  @JsonKey(name: 'MaxParentalRating')
  final int? maxParentalRating;
  @JsonKey(name: 'BlockedTags', defaultValue: <String>[])
  final List<String>? blockedTags;
  @JsonKey(name: 'AllowedTags', defaultValue: <String>[])
  final List<String>? allowedTags;
  @JsonKey(name: 'EnableUserPreferenceAccess')
  final bool? enableUserPreferenceAccess;
  @JsonKey(name: 'AccessSchedules', defaultValue: <AccessSchedule>[])
  final List<AccessSchedule>? accessSchedules;
  @JsonKey(
    name: 'BlockUnratedItems',
    toJson: unratedItemListToJson,
    fromJson: unratedItemListFromJson,
  )
  final List<enums.UnratedItem>? blockUnratedItems;
  @JsonKey(name: 'EnableRemoteControlOfOtherUsers')
  final bool? enableRemoteControlOfOtherUsers;
  @JsonKey(name: 'EnableSharedDeviceControl')
  final bool? enableSharedDeviceControl;
  @JsonKey(name: 'EnableRemoteAccess')
  final bool? enableRemoteAccess;
  @JsonKey(name: 'EnableLiveTvManagement')
  final bool? enableLiveTvManagement;
  @JsonKey(name: 'EnableLiveTvAccess')
  final bool? enableLiveTvAccess;
  @JsonKey(name: 'EnableMediaPlayback')
  final bool? enableMediaPlayback;
  @JsonKey(name: 'EnableAudioPlaybackTranscoding')
  final bool? enableAudioPlaybackTranscoding;
  @JsonKey(name: 'EnableVideoPlaybackTranscoding')
  final bool? enableVideoPlaybackTranscoding;
  @JsonKey(name: 'EnablePlaybackRemuxing')
  final bool? enablePlaybackRemuxing;
  @JsonKey(name: 'ForceRemoteSourceTranscoding')
  final bool? forceRemoteSourceTranscoding;
  @JsonKey(name: 'EnableContentDeletion')
  final bool? enableContentDeletion;
  @JsonKey(name: 'EnableContentDeletionFromFolders', defaultValue: <String>[])
  final List<String>? enableContentDeletionFromFolders;
  @JsonKey(name: 'EnableContentDownloading')
  final bool? enableContentDownloading;
  @JsonKey(name: 'EnableSyncTranscoding')
  final bool? enableSyncTranscoding;
  @JsonKey(name: 'EnableMediaConversion')
  final bool? enableMediaConversion;
  @JsonKey(name: 'EnabledDevices', defaultValue: <String>[])
  final List<String>? enabledDevices;
  @JsonKey(name: 'EnableAllDevices')
  final bool? enableAllDevices;
  @JsonKey(name: 'EnabledChannels', defaultValue: <String>[])
  final List<String>? enabledChannels;
  @JsonKey(name: 'EnableAllChannels')
  final bool? enableAllChannels;
  @JsonKey(name: 'EnabledFolders', defaultValue: <String>[])
  final List<String>? enabledFolders;
  @JsonKey(name: 'EnableAllFolders')
  final bool? enableAllFolders;
  @JsonKey(name: 'InvalidLoginAttemptCount')
  final int? invalidLoginAttemptCount;
  @JsonKey(name: 'LoginAttemptsBeforeLockout')
  final int? loginAttemptsBeforeLockout;
  @JsonKey(name: 'MaxActiveSessions')
  final int? maxActiveSessions;
  @JsonKey(name: 'EnablePublicSharing')
  final bool? enablePublicSharing;
  @JsonKey(name: 'BlockedMediaFolders', defaultValue: <String>[])
  final List<String>? blockedMediaFolders;
  @JsonKey(name: 'BlockedChannels', defaultValue: <String>[])
  final List<String>? blockedChannels;
  @JsonKey(name: 'RemoteClientBitrateLimit')
  final int? remoteClientBitrateLimit;
  @JsonKey(name: 'AuthenticationProviderId')
  final String authenticationProviderId;
  @JsonKey(name: 'PasswordResetProviderId')
  final String passwordResetProviderId;
  @JsonKey(
    name: 'SyncPlayAccess',
    toJson: syncPlayUserAccessTypeNullableToJson,
    fromJson: syncPlayUserAccessTypeNullableFromJson,
  )
  final enums.SyncPlayUserAccessType? syncPlayAccess;
  static const fromJsonFactory = _$UserPolicyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPolicy &&
            (identical(other.isAdministrator, isAdministrator) ||
                const DeepCollectionEquality()
                    .equals(other.isAdministrator, isAdministrator)) &&
            (identical(other.isHidden, isHidden) ||
                const DeepCollectionEquality()
                    .equals(other.isHidden, isHidden)) &&
            (identical(other.enableCollectionManagement, enableCollectionManagement) ||
                const DeepCollectionEquality().equals(
                    other.enableCollectionManagement,
                    enableCollectionManagement)) &&
            (identical(other.enableSubtitleManagement, enableSubtitleManagement) ||
                const DeepCollectionEquality().equals(
                    other.enableSubtitleManagement,
                    enableSubtitleManagement)) &&
            (identical(other.enableLyricManagement, enableLyricManagement) ||
                const DeepCollectionEquality().equals(
                    other.enableLyricManagement, enableLyricManagement)) &&
            (identical(other.isDisabled, isDisabled) ||
                const DeepCollectionEquality()
                    .equals(other.isDisabled, isDisabled)) &&
            (identical(other.maxParentalRating, maxParentalRating) ||
                const DeepCollectionEquality()
                    .equals(other.maxParentalRating, maxParentalRating)) &&
            (identical(other.blockedTags, blockedTags) ||
                const DeepCollectionEquality()
                    .equals(other.blockedTags, blockedTags)) &&
            (identical(other.allowedTags, allowedTags) ||
                const DeepCollectionEquality()
                    .equals(other.allowedTags, allowedTags)) &&
            (identical(other.enableUserPreferenceAccess, enableUserPreferenceAccess) ||
                const DeepCollectionEquality().equals(
                    other.enableUserPreferenceAccess,
                    enableUserPreferenceAccess)) &&
            (identical(other.accessSchedules, accessSchedules) ||
                const DeepCollectionEquality()
                    .equals(other.accessSchedules, accessSchedules)) &&
            (identical(other.blockUnratedItems, blockUnratedItems) ||
                const DeepCollectionEquality()
                    .equals(other.blockUnratedItems, blockUnratedItems)) &&
            (identical(other.enableRemoteControlOfOtherUsers, enableRemoteControlOfOtherUsers) ||
                const DeepCollectionEquality().equals(other.enableRemoteControlOfOtherUsers, enableRemoteControlOfOtherUsers)) &&
            (identical(other.enableSharedDeviceControl, enableSharedDeviceControl) || const DeepCollectionEquality().equals(other.enableSharedDeviceControl, enableSharedDeviceControl)) &&
            (identical(other.enableRemoteAccess, enableRemoteAccess) || const DeepCollectionEquality().equals(other.enableRemoteAccess, enableRemoteAccess)) &&
            (identical(other.enableLiveTvManagement, enableLiveTvManagement) || const DeepCollectionEquality().equals(other.enableLiveTvManagement, enableLiveTvManagement)) &&
            (identical(other.enableLiveTvAccess, enableLiveTvAccess) || const DeepCollectionEquality().equals(other.enableLiveTvAccess, enableLiveTvAccess)) &&
            (identical(other.enableMediaPlayback, enableMediaPlayback) || const DeepCollectionEquality().equals(other.enableMediaPlayback, enableMediaPlayback)) &&
            (identical(other.enableAudioPlaybackTranscoding, enableAudioPlaybackTranscoding) || const DeepCollectionEquality().equals(other.enableAudioPlaybackTranscoding, enableAudioPlaybackTranscoding)) &&
            (identical(other.enableVideoPlaybackTranscoding, enableVideoPlaybackTranscoding) || const DeepCollectionEquality().equals(other.enableVideoPlaybackTranscoding, enableVideoPlaybackTranscoding)) &&
            (identical(other.enablePlaybackRemuxing, enablePlaybackRemuxing) || const DeepCollectionEquality().equals(other.enablePlaybackRemuxing, enablePlaybackRemuxing)) &&
            (identical(other.forceRemoteSourceTranscoding, forceRemoteSourceTranscoding) || const DeepCollectionEquality().equals(other.forceRemoteSourceTranscoding, forceRemoteSourceTranscoding)) &&
            (identical(other.enableContentDeletion, enableContentDeletion) || const DeepCollectionEquality().equals(other.enableContentDeletion, enableContentDeletion)) &&
            (identical(other.enableContentDeletionFromFolders, enableContentDeletionFromFolders) || const DeepCollectionEquality().equals(other.enableContentDeletionFromFolders, enableContentDeletionFromFolders)) &&
            (identical(other.enableContentDownloading, enableContentDownloading) || const DeepCollectionEquality().equals(other.enableContentDownloading, enableContentDownloading)) &&
            (identical(other.enableSyncTranscoding, enableSyncTranscoding) || const DeepCollectionEquality().equals(other.enableSyncTranscoding, enableSyncTranscoding)) &&
            (identical(other.enableMediaConversion, enableMediaConversion) || const DeepCollectionEquality().equals(other.enableMediaConversion, enableMediaConversion)) &&
            (identical(other.enabledDevices, enabledDevices) || const DeepCollectionEquality().equals(other.enabledDevices, enabledDevices)) &&
            (identical(other.enableAllDevices, enableAllDevices) || const DeepCollectionEquality().equals(other.enableAllDevices, enableAllDevices)) &&
            (identical(other.enabledChannels, enabledChannels) || const DeepCollectionEquality().equals(other.enabledChannels, enabledChannels)) &&
            (identical(other.enableAllChannels, enableAllChannels) || const DeepCollectionEquality().equals(other.enableAllChannels, enableAllChannels)) &&
            (identical(other.enabledFolders, enabledFolders) || const DeepCollectionEquality().equals(other.enabledFolders, enabledFolders)) &&
            (identical(other.enableAllFolders, enableAllFolders) || const DeepCollectionEquality().equals(other.enableAllFolders, enableAllFolders)) &&
            (identical(other.invalidLoginAttemptCount, invalidLoginAttemptCount) || const DeepCollectionEquality().equals(other.invalidLoginAttemptCount, invalidLoginAttemptCount)) &&
            (identical(other.loginAttemptsBeforeLockout, loginAttemptsBeforeLockout) || const DeepCollectionEquality().equals(other.loginAttemptsBeforeLockout, loginAttemptsBeforeLockout)) &&
            (identical(other.maxActiveSessions, maxActiveSessions) || const DeepCollectionEquality().equals(other.maxActiveSessions, maxActiveSessions)) &&
            (identical(other.enablePublicSharing, enablePublicSharing) || const DeepCollectionEquality().equals(other.enablePublicSharing, enablePublicSharing)) &&
            (identical(other.blockedMediaFolders, blockedMediaFolders) || const DeepCollectionEquality().equals(other.blockedMediaFolders, blockedMediaFolders)) &&
            (identical(other.blockedChannels, blockedChannels) || const DeepCollectionEquality().equals(other.blockedChannels, blockedChannels)) &&
            (identical(other.remoteClientBitrateLimit, remoteClientBitrateLimit) || const DeepCollectionEquality().equals(other.remoteClientBitrateLimit, remoteClientBitrateLimit)) &&
            (identical(other.authenticationProviderId, authenticationProviderId) || const DeepCollectionEquality().equals(other.authenticationProviderId, authenticationProviderId)) &&
            (identical(other.passwordResetProviderId, passwordResetProviderId) || const DeepCollectionEquality().equals(other.passwordResetProviderId, passwordResetProviderId)) &&
            (identical(other.syncPlayAccess, syncPlayAccess) || const DeepCollectionEquality().equals(other.syncPlayAccess, syncPlayAccess)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isAdministrator) ^
      const DeepCollectionEquality().hash(isHidden) ^
      const DeepCollectionEquality().hash(enableCollectionManagement) ^
      const DeepCollectionEquality().hash(enableSubtitleManagement) ^
      const DeepCollectionEquality().hash(enableLyricManagement) ^
      const DeepCollectionEquality().hash(isDisabled) ^
      const DeepCollectionEquality().hash(maxParentalRating) ^
      const DeepCollectionEquality().hash(blockedTags) ^
      const DeepCollectionEquality().hash(allowedTags) ^
      const DeepCollectionEquality().hash(enableUserPreferenceAccess) ^
      const DeepCollectionEquality().hash(accessSchedules) ^
      const DeepCollectionEquality().hash(blockUnratedItems) ^
      const DeepCollectionEquality().hash(enableRemoteControlOfOtherUsers) ^
      const DeepCollectionEquality().hash(enableSharedDeviceControl) ^
      const DeepCollectionEquality().hash(enableRemoteAccess) ^
      const DeepCollectionEquality().hash(enableLiveTvManagement) ^
      const DeepCollectionEquality().hash(enableLiveTvAccess) ^
      const DeepCollectionEquality().hash(enableMediaPlayback) ^
      const DeepCollectionEquality().hash(enableAudioPlaybackTranscoding) ^
      const DeepCollectionEquality().hash(enableVideoPlaybackTranscoding) ^
      const DeepCollectionEquality().hash(enablePlaybackRemuxing) ^
      const DeepCollectionEquality().hash(forceRemoteSourceTranscoding) ^
      const DeepCollectionEquality().hash(enableContentDeletion) ^
      const DeepCollectionEquality().hash(enableContentDeletionFromFolders) ^
      const DeepCollectionEquality().hash(enableContentDownloading) ^
      const DeepCollectionEquality().hash(enableSyncTranscoding) ^
      const DeepCollectionEquality().hash(enableMediaConversion) ^
      const DeepCollectionEquality().hash(enabledDevices) ^
      const DeepCollectionEquality().hash(enableAllDevices) ^
      const DeepCollectionEquality().hash(enabledChannels) ^
      const DeepCollectionEquality().hash(enableAllChannels) ^
      const DeepCollectionEquality().hash(enabledFolders) ^
      const DeepCollectionEquality().hash(enableAllFolders) ^
      const DeepCollectionEquality().hash(invalidLoginAttemptCount) ^
      const DeepCollectionEquality().hash(loginAttemptsBeforeLockout) ^
      const DeepCollectionEquality().hash(maxActiveSessions) ^
      const DeepCollectionEquality().hash(enablePublicSharing) ^
      const DeepCollectionEquality().hash(blockedMediaFolders) ^
      const DeepCollectionEquality().hash(blockedChannels) ^
      const DeepCollectionEquality().hash(remoteClientBitrateLimit) ^
      const DeepCollectionEquality().hash(authenticationProviderId) ^
      const DeepCollectionEquality().hash(passwordResetProviderId) ^
      const DeepCollectionEquality().hash(syncPlayAccess) ^
      runtimeType.hashCode;
}

extension $UserPolicyExtension on UserPolicy {
  UserPolicy copyWith(
      {bool? isAdministrator,
      bool? isHidden,
      bool? enableCollectionManagement,
      bool? enableSubtitleManagement,
      bool? enableLyricManagement,
      bool? isDisabled,
      int? maxParentalRating,
      List<String>? blockedTags,
      List<String>? allowedTags,
      bool? enableUserPreferenceAccess,
      List<AccessSchedule>? accessSchedules,
      List<enums.UnratedItem>? blockUnratedItems,
      bool? enableRemoteControlOfOtherUsers,
      bool? enableSharedDeviceControl,
      bool? enableRemoteAccess,
      bool? enableLiveTvManagement,
      bool? enableLiveTvAccess,
      bool? enableMediaPlayback,
      bool? enableAudioPlaybackTranscoding,
      bool? enableVideoPlaybackTranscoding,
      bool? enablePlaybackRemuxing,
      bool? forceRemoteSourceTranscoding,
      bool? enableContentDeletion,
      List<String>? enableContentDeletionFromFolders,
      bool? enableContentDownloading,
      bool? enableSyncTranscoding,
      bool? enableMediaConversion,
      List<String>? enabledDevices,
      bool? enableAllDevices,
      List<String>? enabledChannels,
      bool? enableAllChannels,
      List<String>? enabledFolders,
      bool? enableAllFolders,
      int? invalidLoginAttemptCount,
      int? loginAttemptsBeforeLockout,
      int? maxActiveSessions,
      bool? enablePublicSharing,
      List<String>? blockedMediaFolders,
      List<String>? blockedChannels,
      int? remoteClientBitrateLimit,
      String? authenticationProviderId,
      String? passwordResetProviderId,
      enums.SyncPlayUserAccessType? syncPlayAccess}) {
    return UserPolicy(
        isAdministrator: isAdministrator ?? this.isAdministrator,
        isHidden: isHidden ?? this.isHidden,
        enableCollectionManagement:
            enableCollectionManagement ?? this.enableCollectionManagement,
        enableSubtitleManagement:
            enableSubtitleManagement ?? this.enableSubtitleManagement,
        enableLyricManagement:
            enableLyricManagement ?? this.enableLyricManagement,
        isDisabled: isDisabled ?? this.isDisabled,
        maxParentalRating: maxParentalRating ?? this.maxParentalRating,
        blockedTags: blockedTags ?? this.blockedTags,
        allowedTags: allowedTags ?? this.allowedTags,
        enableUserPreferenceAccess:
            enableUserPreferenceAccess ?? this.enableUserPreferenceAccess,
        accessSchedules: accessSchedules ?? this.accessSchedules,
        blockUnratedItems: blockUnratedItems ?? this.blockUnratedItems,
        enableRemoteControlOfOtherUsers: enableRemoteControlOfOtherUsers ??
            this.enableRemoteControlOfOtherUsers,
        enableSharedDeviceControl:
            enableSharedDeviceControl ?? this.enableSharedDeviceControl,
        enableRemoteAccess: enableRemoteAccess ?? this.enableRemoteAccess,
        enableLiveTvManagement:
            enableLiveTvManagement ?? this.enableLiveTvManagement,
        enableLiveTvAccess: enableLiveTvAccess ?? this.enableLiveTvAccess,
        enableMediaPlayback: enableMediaPlayback ?? this.enableMediaPlayback,
        enableAudioPlaybackTranscoding: enableAudioPlaybackTranscoding ??
            this.enableAudioPlaybackTranscoding,
        enableVideoPlaybackTranscoding: enableVideoPlaybackTranscoding ??
            this.enableVideoPlaybackTranscoding,
        enablePlaybackRemuxing:
            enablePlaybackRemuxing ?? this.enablePlaybackRemuxing,
        forceRemoteSourceTranscoding:
            forceRemoteSourceTranscoding ?? this.forceRemoteSourceTranscoding,
        enableContentDeletion:
            enableContentDeletion ?? this.enableContentDeletion,
        enableContentDeletionFromFolders: enableContentDeletionFromFolders ??
            this.enableContentDeletionFromFolders,
        enableContentDownloading:
            enableContentDownloading ?? this.enableContentDownloading,
        enableSyncTranscoding:
            enableSyncTranscoding ?? this.enableSyncTranscoding,
        enableMediaConversion:
            enableMediaConversion ?? this.enableMediaConversion,
        enabledDevices: enabledDevices ?? this.enabledDevices,
        enableAllDevices: enableAllDevices ?? this.enableAllDevices,
        enabledChannels: enabledChannels ?? this.enabledChannels,
        enableAllChannels: enableAllChannels ?? this.enableAllChannels,
        enabledFolders: enabledFolders ?? this.enabledFolders,
        enableAllFolders: enableAllFolders ?? this.enableAllFolders,
        invalidLoginAttemptCount:
            invalidLoginAttemptCount ?? this.invalidLoginAttemptCount,
        loginAttemptsBeforeLockout:
            loginAttemptsBeforeLockout ?? this.loginAttemptsBeforeLockout,
        maxActiveSessions: maxActiveSessions ?? this.maxActiveSessions,
        enablePublicSharing: enablePublicSharing ?? this.enablePublicSharing,
        blockedMediaFolders: blockedMediaFolders ?? this.blockedMediaFolders,
        blockedChannels: blockedChannels ?? this.blockedChannels,
        remoteClientBitrateLimit:
            remoteClientBitrateLimit ?? this.remoteClientBitrateLimit,
        authenticationProviderId:
            authenticationProviderId ?? this.authenticationProviderId,
        passwordResetProviderId:
            passwordResetProviderId ?? this.passwordResetProviderId,
        syncPlayAccess: syncPlayAccess ?? this.syncPlayAccess);
  }

  UserPolicy copyWithWrapped(
      {Wrapped<bool?>? isAdministrator,
      Wrapped<bool?>? isHidden,
      Wrapped<bool?>? enableCollectionManagement,
      Wrapped<bool?>? enableSubtitleManagement,
      Wrapped<bool?>? enableLyricManagement,
      Wrapped<bool?>? isDisabled,
      Wrapped<int?>? maxParentalRating,
      Wrapped<List<String>?>? blockedTags,
      Wrapped<List<String>?>? allowedTags,
      Wrapped<bool?>? enableUserPreferenceAccess,
      Wrapped<List<AccessSchedule>?>? accessSchedules,
      Wrapped<List<enums.UnratedItem>?>? blockUnratedItems,
      Wrapped<bool?>? enableRemoteControlOfOtherUsers,
      Wrapped<bool?>? enableSharedDeviceControl,
      Wrapped<bool?>? enableRemoteAccess,
      Wrapped<bool?>? enableLiveTvManagement,
      Wrapped<bool?>? enableLiveTvAccess,
      Wrapped<bool?>? enableMediaPlayback,
      Wrapped<bool?>? enableAudioPlaybackTranscoding,
      Wrapped<bool?>? enableVideoPlaybackTranscoding,
      Wrapped<bool?>? enablePlaybackRemuxing,
      Wrapped<bool?>? forceRemoteSourceTranscoding,
      Wrapped<bool?>? enableContentDeletion,
      Wrapped<List<String>?>? enableContentDeletionFromFolders,
      Wrapped<bool?>? enableContentDownloading,
      Wrapped<bool?>? enableSyncTranscoding,
      Wrapped<bool?>? enableMediaConversion,
      Wrapped<List<String>?>? enabledDevices,
      Wrapped<bool?>? enableAllDevices,
      Wrapped<List<String>?>? enabledChannels,
      Wrapped<bool?>? enableAllChannels,
      Wrapped<List<String>?>? enabledFolders,
      Wrapped<bool?>? enableAllFolders,
      Wrapped<int?>? invalidLoginAttemptCount,
      Wrapped<int?>? loginAttemptsBeforeLockout,
      Wrapped<int?>? maxActiveSessions,
      Wrapped<bool?>? enablePublicSharing,
      Wrapped<List<String>?>? blockedMediaFolders,
      Wrapped<List<String>?>? blockedChannels,
      Wrapped<int?>? remoteClientBitrateLimit,
      Wrapped<String>? authenticationProviderId,
      Wrapped<String>? passwordResetProviderId,
      Wrapped<enums.SyncPlayUserAccessType?>? syncPlayAccess}) {
    return UserPolicy(
        isAdministrator: (isAdministrator != null
            ? isAdministrator.value
            : this.isAdministrator),
        isHidden: (isHidden != null ? isHidden.value : this.isHidden),
        enableCollectionManagement: (enableCollectionManagement != null
            ? enableCollectionManagement.value
            : this.enableCollectionManagement),
        enableSubtitleManagement: (enableSubtitleManagement != null
            ? enableSubtitleManagement.value
            : this.enableSubtitleManagement),
        enableLyricManagement: (enableLyricManagement != null
            ? enableLyricManagement.value
            : this.enableLyricManagement),
        isDisabled: (isDisabled != null ? isDisabled.value : this.isDisabled),
        maxParentalRating: (maxParentalRating != null
            ? maxParentalRating.value
            : this.maxParentalRating),
        blockedTags:
            (blockedTags != null ? blockedTags.value : this.blockedTags),
        allowedTags:
            (allowedTags != null ? allowedTags.value : this.allowedTags),
        enableUserPreferenceAccess: (enableUserPreferenceAccess != null
            ? enableUserPreferenceAccess.value
            : this.enableUserPreferenceAccess),
        accessSchedules: (accessSchedules != null
            ? accessSchedules.value
            : this.accessSchedules),
        blockUnratedItems: (blockUnratedItems != null
            ? blockUnratedItems.value
            : this.blockUnratedItems),
        enableRemoteControlOfOtherUsers: (enableRemoteControlOfOtherUsers != null
            ? enableRemoteControlOfOtherUsers.value
            : this.enableRemoteControlOfOtherUsers),
        enableSharedDeviceControl: (enableSharedDeviceControl != null
            ? enableSharedDeviceControl.value
            : this.enableSharedDeviceControl),
        enableRemoteAccess: (enableRemoteAccess != null
            ? enableRemoteAccess.value
            : this.enableRemoteAccess),
        enableLiveTvManagement: (enableLiveTvManagement != null
            ? enableLiveTvManagement.value
            : this.enableLiveTvManagement),
        enableLiveTvAccess: (enableLiveTvAccess != null
            ? enableLiveTvAccess.value
            : this.enableLiveTvAccess),
        enableMediaPlayback: (enableMediaPlayback != null
            ? enableMediaPlayback.value
            : this.enableMediaPlayback),
        enableAudioPlaybackTranscoding: (enableAudioPlaybackTranscoding != null
            ? enableAudioPlaybackTranscoding.value
            : this.enableAudioPlaybackTranscoding),
        enableVideoPlaybackTranscoding: (enableVideoPlaybackTranscoding != null
            ? enableVideoPlaybackTranscoding.value
            : this.enableVideoPlaybackTranscoding),
        enablePlaybackRemuxing: (enablePlaybackRemuxing != null
            ? enablePlaybackRemuxing.value
            : this.enablePlaybackRemuxing),
        forceRemoteSourceTranscoding: (forceRemoteSourceTranscoding != null
            ? forceRemoteSourceTranscoding.value
            : this.forceRemoteSourceTranscoding),
        enableContentDeletion: (enableContentDeletion != null
            ? enableContentDeletion.value
            : this.enableContentDeletion),
        enableContentDeletionFromFolders: (enableContentDeletionFromFolders != null
            ? enableContentDeletionFromFolders.value
            : this.enableContentDeletionFromFolders),
        enableContentDownloading: (enableContentDownloading != null
            ? enableContentDownloading.value
            : this.enableContentDownloading),
        enableSyncTranscoding: (enableSyncTranscoding != null
            ? enableSyncTranscoding.value
            : this.enableSyncTranscoding),
        enableMediaConversion: (enableMediaConversion != null
            ? enableMediaConversion.value
            : this.enableMediaConversion),
        enabledDevices: (enabledDevices != null
            ? enabledDevices.value
            : this.enabledDevices),
        enableAllDevices: (enableAllDevices != null
            ? enableAllDevices.value
            : this.enableAllDevices),
        enabledChannels: (enabledChannels != null
            ? enabledChannels.value
            : this.enabledChannels),
        enableAllChannels: (enableAllChannels != null
            ? enableAllChannels.value
            : this.enableAllChannels),
        enabledFolders: (enabledFolders != null
            ? enabledFolders.value
            : this.enabledFolders),
        enableAllFolders: (enableAllFolders != null
            ? enableAllFolders.value
            : this.enableAllFolders),
        invalidLoginAttemptCount: (invalidLoginAttemptCount != null
            ? invalidLoginAttemptCount.value
            : this.invalidLoginAttemptCount),
        loginAttemptsBeforeLockout: (loginAttemptsBeforeLockout != null
            ? loginAttemptsBeforeLockout.value
            : this.loginAttemptsBeforeLockout),
        maxActiveSessions: (maxActiveSessions != null
            ? maxActiveSessions.value
            : this.maxActiveSessions),
        enablePublicSharing: (enablePublicSharing != null
            ? enablePublicSharing.value
            : this.enablePublicSharing),
        blockedMediaFolders: (blockedMediaFolders != null
            ? blockedMediaFolders.value
            : this.blockedMediaFolders),
        blockedChannels: (blockedChannels != null
            ? blockedChannels.value
            : this.blockedChannels),
        remoteClientBitrateLimit: (remoteClientBitrateLimit != null ? remoteClientBitrateLimit.value : this.remoteClientBitrateLimit),
        authenticationProviderId: (authenticationProviderId != null ? authenticationProviderId.value : this.authenticationProviderId),
        passwordResetProviderId: (passwordResetProviderId != null ? passwordResetProviderId.value : this.passwordResetProviderId),
        syncPlayAccess: (syncPlayAccess != null ? syncPlayAccess.value : this.syncPlayAccess));
  }
}

@JsonSerializable(explicitToJson: true)
class UserUpdatedMessage {
  const UserUpdatedMessage({
    this.data,
    this.messageId,
    this.messageType,
  });

  factory UserUpdatedMessage.fromJson(Map<String, dynamic> json) =>
      _$UserUpdatedMessageFromJson(json);

  static const toJsonFactory = _$UserUpdatedMessageToJson;
  Map<String, dynamic> toJson() => _$UserUpdatedMessageToJson(this);

  @JsonKey(name: 'Data')
  final UserDto? data;
  @JsonKey(name: 'MessageId')
  final String? messageId;
  @JsonKey(
    name: 'MessageType',
    toJson: sessionMessageTypeNullableToJson,
    fromJson: sessionMessageTypeMessageTypeNullableFromJson,
  )
  final enums.SessionMessageType? messageType;
  static enums.SessionMessageType?
      sessionMessageTypeMessageTypeNullableFromJson(Object? value) =>
          sessionMessageTypeNullableFromJson(
              value, enums.SessionMessageType.userupdated);

  static const fromJsonFactory = _$UserUpdatedMessageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserUpdatedMessage &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.messageId, messageId) ||
                const DeepCollectionEquality()
                    .equals(other.messageId, messageId)) &&
            (identical(other.messageType, messageType) ||
                const DeepCollectionEquality()
                    .equals(other.messageType, messageType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(messageId) ^
      const DeepCollectionEquality().hash(messageType) ^
      runtimeType.hashCode;
}

extension $UserUpdatedMessageExtension on UserUpdatedMessage {
  UserUpdatedMessage copyWith(
      {UserDto? data,
      String? messageId,
      enums.SessionMessageType? messageType}) {
    return UserUpdatedMessage(
        data: data ?? this.data,
        messageId: messageId ?? this.messageId,
        messageType: messageType ?? this.messageType);
  }

  UserUpdatedMessage copyWithWrapped(
      {Wrapped<UserDto?>? data,
      Wrapped<String?>? messageId,
      Wrapped<enums.SessionMessageType?>? messageType}) {
    return UserUpdatedMessage(
        data: (data != null ? data.value : this.data),
        messageId: (messageId != null ? messageId.value : this.messageId),
        messageType:
            (messageType != null ? messageType.value : this.messageType));
  }
}

@JsonSerializable(explicitToJson: true)
class UtcTimeResponse {
  const UtcTimeResponse({
    this.requestReceptionTime,
    this.responseTransmissionTime,
  });

  factory UtcTimeResponse.fromJson(Map<String, dynamic> json) =>
      _$UtcTimeResponseFromJson(json);

  static const toJsonFactory = _$UtcTimeResponseToJson;
  Map<String, dynamic> toJson() => _$UtcTimeResponseToJson(this);

  @JsonKey(name: 'RequestReceptionTime')
  final DateTime? requestReceptionTime;
  @JsonKey(name: 'ResponseTransmissionTime')
  final DateTime? responseTransmissionTime;
  static const fromJsonFactory = _$UtcTimeResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UtcTimeResponse &&
            (identical(other.requestReceptionTime, requestReceptionTime) ||
                const DeepCollectionEquality().equals(
                    other.requestReceptionTime, requestReceptionTime)) &&
            (identical(
                    other.responseTransmissionTime, responseTransmissionTime) ||
                const DeepCollectionEquality().equals(
                    other.responseTransmissionTime, responseTransmissionTime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestReceptionTime) ^
      const DeepCollectionEquality().hash(responseTransmissionTime) ^
      runtimeType.hashCode;
}

extension $UtcTimeResponseExtension on UtcTimeResponse {
  UtcTimeResponse copyWith(
      {DateTime? requestReceptionTime, DateTime? responseTransmissionTime}) {
    return UtcTimeResponse(
        requestReceptionTime: requestReceptionTime ?? this.requestReceptionTime,
        responseTransmissionTime:
            responseTransmissionTime ?? this.responseTransmissionTime);
  }

  UtcTimeResponse copyWithWrapped(
      {Wrapped<DateTime?>? requestReceptionTime,
      Wrapped<DateTime?>? responseTransmissionTime}) {
    return UtcTimeResponse(
        requestReceptionTime: (requestReceptionTime != null
            ? requestReceptionTime.value
            : this.requestReceptionTime),
        responseTransmissionTime: (responseTransmissionTime != null
            ? responseTransmissionTime.value
            : this.responseTransmissionTime));
  }
}

@JsonSerializable(explicitToJson: true)
class ValidatePathDto {
  const ValidatePathDto({
    this.validateWritable,
    this.path,
    this.isFile,
  });

  factory ValidatePathDto.fromJson(Map<String, dynamic> json) =>
      _$ValidatePathDtoFromJson(json);

  static const toJsonFactory = _$ValidatePathDtoToJson;
  Map<String, dynamic> toJson() => _$ValidatePathDtoToJson(this);

  @JsonKey(name: 'ValidateWritable')
  final bool? validateWritable;
  @JsonKey(name: 'Path')
  final String? path;
  @JsonKey(name: 'IsFile')
  final bool? isFile;
  static const fromJsonFactory = _$ValidatePathDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ValidatePathDto &&
            (identical(other.validateWritable, validateWritable) ||
                const DeepCollectionEquality()
                    .equals(other.validateWritable, validateWritable)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.isFile, isFile) ||
                const DeepCollectionEquality().equals(other.isFile, isFile)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(validateWritable) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(isFile) ^
      runtimeType.hashCode;
}

extension $ValidatePathDtoExtension on ValidatePathDto {
  ValidatePathDto copyWith(
      {bool? validateWritable, String? path, bool? isFile}) {
    return ValidatePathDto(
        validateWritable: validateWritable ?? this.validateWritable,
        path: path ?? this.path,
        isFile: isFile ?? this.isFile);
  }

  ValidatePathDto copyWithWrapped(
      {Wrapped<bool?>? validateWritable,
      Wrapped<String?>? path,
      Wrapped<bool?>? isFile}) {
    return ValidatePathDto(
        validateWritable: (validateWritable != null
            ? validateWritable.value
            : this.validateWritable),
        path: (path != null ? path.value : this.path),
        isFile: (isFile != null ? isFile.value : this.isFile));
  }
}

@JsonSerializable(explicitToJson: true)
class VersionInfo {
  const VersionInfo({
    this.version,
    this.versionNumber,
    this.changelog,
    this.targetAbi,
    this.sourceUrl,
    this.checksum,
    this.timestamp,
    this.repositoryName,
    this.repositoryUrl,
  });

  factory VersionInfo.fromJson(Map<String, dynamic> json) =>
      _$VersionInfoFromJson(json);

  static const toJsonFactory = _$VersionInfoToJson;
  Map<String, dynamic> toJson() => _$VersionInfoToJson(this);

  @JsonKey(name: 'version')
  final String? version;
  @JsonKey(name: 'VersionNumber')
  final String? versionNumber;
  @JsonKey(name: 'changelog')
  final String? changelog;
  @JsonKey(name: 'targetAbi')
  final String? targetAbi;
  @JsonKey(name: 'sourceUrl')
  final String? sourceUrl;
  @JsonKey(name: 'checksum')
  final String? checksum;
  @JsonKey(name: 'timestamp')
  final String? timestamp;
  @JsonKey(name: 'repositoryName')
  final String? repositoryName;
  @JsonKey(name: 'repositoryUrl')
  final String? repositoryUrl;
  static const fromJsonFactory = _$VersionInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VersionInfo &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.versionNumber, versionNumber) ||
                const DeepCollectionEquality()
                    .equals(other.versionNumber, versionNumber)) &&
            (identical(other.changelog, changelog) ||
                const DeepCollectionEquality()
                    .equals(other.changelog, changelog)) &&
            (identical(other.targetAbi, targetAbi) ||
                const DeepCollectionEquality()
                    .equals(other.targetAbi, targetAbi)) &&
            (identical(other.sourceUrl, sourceUrl) ||
                const DeepCollectionEquality()
                    .equals(other.sourceUrl, sourceUrl)) &&
            (identical(other.checksum, checksum) ||
                const DeepCollectionEquality()
                    .equals(other.checksum, checksum)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.repositoryName, repositoryName) ||
                const DeepCollectionEquality()
                    .equals(other.repositoryName, repositoryName)) &&
            (identical(other.repositoryUrl, repositoryUrl) ||
                const DeepCollectionEquality()
                    .equals(other.repositoryUrl, repositoryUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(versionNumber) ^
      const DeepCollectionEquality().hash(changelog) ^
      const DeepCollectionEquality().hash(targetAbi) ^
      const DeepCollectionEquality().hash(sourceUrl) ^
      const DeepCollectionEquality().hash(checksum) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(repositoryName) ^
      const DeepCollectionEquality().hash(repositoryUrl) ^
      runtimeType.hashCode;
}

extension $VersionInfoExtension on VersionInfo {
  VersionInfo copyWith(
      {String? version,
      String? versionNumber,
      String? changelog,
      String? targetAbi,
      String? sourceUrl,
      String? checksum,
      String? timestamp,
      String? repositoryName,
      String? repositoryUrl}) {
    return VersionInfo(
        version: version ?? this.version,
        versionNumber: versionNumber ?? this.versionNumber,
        changelog: changelog ?? this.changelog,
        targetAbi: targetAbi ?? this.targetAbi,
        sourceUrl: sourceUrl ?? this.sourceUrl,
        checksum: checksum ?? this.checksum,
        timestamp: timestamp ?? this.timestamp,
        repositoryName: repositoryName ?? this.repositoryName,
        repositoryUrl: repositoryUrl ?? this.repositoryUrl);
  }

  VersionInfo copyWithWrapped(
      {Wrapped<String?>? version,
      Wrapped<String?>? versionNumber,
      Wrapped<String?>? changelog,
      Wrapped<String?>? targetAbi,
      Wrapped<String?>? sourceUrl,
      Wrapped<String?>? checksum,
      Wrapped<String?>? timestamp,
      Wrapped<String?>? repositoryName,
      Wrapped<String?>? repositoryUrl}) {
    return VersionInfo(
        version: (version != null ? version.value : this.version),
        versionNumber:
            (versionNumber != null ? versionNumber.value : this.versionNumber),
        changelog: (changelog != null ? changelog.value : this.changelog),
        targetAbi: (targetAbi != null ? targetAbi.value : this.targetAbi),
        sourceUrl: (sourceUrl != null ? sourceUrl.value : this.sourceUrl),
        checksum: (checksum != null ? checksum.value : this.checksum),
        timestamp: (timestamp != null ? timestamp.value : this.timestamp),
        repositoryName: (repositoryName != null
            ? repositoryName.value
            : this.repositoryName),
        repositoryUrl:
            (repositoryUrl != null ? repositoryUrl.value : this.repositoryUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class VirtualFolderInfo {
  const VirtualFolderInfo({
    this.name,
    this.locations,
    this.collectionType,
    this.libraryOptions,
    this.itemId,
    this.primaryImageItemId,
    this.refreshProgress,
    this.refreshStatus,
  });

  factory VirtualFolderInfo.fromJson(Map<String, dynamic> json) =>
      _$VirtualFolderInfoFromJson(json);

  static const toJsonFactory = _$VirtualFolderInfoToJson;
  Map<String, dynamic> toJson() => _$VirtualFolderInfoToJson(this);

  @JsonKey(name: 'Name')
  final String? name;
  @JsonKey(name: 'Locations', defaultValue: <String>[])
  final List<String>? locations;
  @JsonKey(
    name: 'CollectionType',
    toJson: collectionTypeOptionsNullableToJson,
    fromJson: collectionTypeOptionsNullableFromJson,
  )
  final enums.CollectionTypeOptions? collectionType;
  @JsonKey(name: 'LibraryOptions')
  final LibraryOptions? libraryOptions;
  @JsonKey(name: 'ItemId')
  final String? itemId;
  @JsonKey(name: 'PrimaryImageItemId')
  final String? primaryImageItemId;
  @JsonKey(name: 'RefreshProgress')
  final double? refreshProgress;
  @JsonKey(name: 'RefreshStatus')
  final String? refreshStatus;
  static const fromJsonFactory = _$VirtualFolderInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VirtualFolderInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.locations, locations) ||
                const DeepCollectionEquality()
                    .equals(other.locations, locations)) &&
            (identical(other.collectionType, collectionType) ||
                const DeepCollectionEquality()
                    .equals(other.collectionType, collectionType)) &&
            (identical(other.libraryOptions, libraryOptions) ||
                const DeepCollectionEquality()
                    .equals(other.libraryOptions, libraryOptions)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.primaryImageItemId, primaryImageItemId) ||
                const DeepCollectionEquality()
                    .equals(other.primaryImageItemId, primaryImageItemId)) &&
            (identical(other.refreshProgress, refreshProgress) ||
                const DeepCollectionEquality()
                    .equals(other.refreshProgress, refreshProgress)) &&
            (identical(other.refreshStatus, refreshStatus) ||
                const DeepCollectionEquality()
                    .equals(other.refreshStatus, refreshStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(locations) ^
      const DeepCollectionEquality().hash(collectionType) ^
      const DeepCollectionEquality().hash(libraryOptions) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(primaryImageItemId) ^
      const DeepCollectionEquality().hash(refreshProgress) ^
      const DeepCollectionEquality().hash(refreshStatus) ^
      runtimeType.hashCode;
}

extension $VirtualFolderInfoExtension on VirtualFolderInfo {
  VirtualFolderInfo copyWith(
      {String? name,
      List<String>? locations,
      enums.CollectionTypeOptions? collectionType,
      LibraryOptions? libraryOptions,
      String? itemId,
      String? primaryImageItemId,
      double? refreshProgress,
      String? refreshStatus}) {
    return VirtualFolderInfo(
        name: name ?? this.name,
        locations: locations ?? this.locations,
        collectionType: collectionType ?? this.collectionType,
        libraryOptions: libraryOptions ?? this.libraryOptions,
        itemId: itemId ?? this.itemId,
        primaryImageItemId: primaryImageItemId ?? this.primaryImageItemId,
        refreshProgress: refreshProgress ?? this.refreshProgress,
        refreshStatus: refreshStatus ?? this.refreshStatus);
  }

  VirtualFolderInfo copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<List<String>?>? locations,
      Wrapped<enums.CollectionTypeOptions?>? collectionType,
      Wrapped<LibraryOptions?>? libraryOptions,
      Wrapped<String?>? itemId,
      Wrapped<String?>? primaryImageItemId,
      Wrapped<double?>? refreshProgress,
      Wrapped<String?>? refreshStatus}) {
    return VirtualFolderInfo(
        name: (name != null ? name.value : this.name),
        locations: (locations != null ? locations.value : this.locations),
        collectionType: (collectionType != null
            ? collectionType.value
            : this.collectionType),
        libraryOptions: (libraryOptions != null
            ? libraryOptions.value
            : this.libraryOptions),
        itemId: (itemId != null ? itemId.value : this.itemId),
        primaryImageItemId: (primaryImageItemId != null
            ? primaryImageItemId.value
            : this.primaryImageItemId),
        refreshProgress: (refreshProgress != null
            ? refreshProgress.value
            : this.refreshProgress),
        refreshStatus:
            (refreshStatus != null ? refreshStatus.value : this.refreshStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class WakeOnLanInfo {
  const WakeOnLanInfo({
    this.macAddress,
    this.port,
  });

  factory WakeOnLanInfo.fromJson(Map<String, dynamic> json) =>
      _$WakeOnLanInfoFromJson(json);

  static const toJsonFactory = _$WakeOnLanInfoToJson;
  Map<String, dynamic> toJson() => _$WakeOnLanInfoToJson(this);

  @JsonKey(name: 'MacAddress')
  final String? macAddress;
  @JsonKey(name: 'Port')
  final int? port;
  static const fromJsonFactory = _$WakeOnLanInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WakeOnLanInfo &&
            (identical(other.macAddress, macAddress) ||
                const DeepCollectionEquality()
                    .equals(other.macAddress, macAddress)) &&
            (identical(other.port, port) ||
                const DeepCollectionEquality().equals(other.port, port)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(macAddress) ^
      const DeepCollectionEquality().hash(port) ^
      runtimeType.hashCode;
}

extension $WakeOnLanInfoExtension on WakeOnLanInfo {
  WakeOnLanInfo copyWith({String? macAddress, int? port}) {
    return WakeOnLanInfo(
        macAddress: macAddress ?? this.macAddress, port: port ?? this.port);
  }

  WakeOnLanInfo copyWithWrapped(
      {Wrapped<String?>? macAddress, Wrapped<int?>? port}) {
    return WakeOnLanInfo(
        macAddress: (macAddress != null ? macAddress.value : this.macAddress),
        port: (port != null ? port.value : this.port));
  }
}

@JsonSerializable(explicitToJson: true)
class WebSocketMessage {
  const WebSocketMessage();

  factory WebSocketMessage.fromJson(Map<String, dynamic> json) =>
      _$WebSocketMessageFromJson(json);

  static const toJsonFactory = _$WebSocketMessageToJson;
  Map<String, dynamic> toJson() => _$WebSocketMessageToJson(this);

  static const fromJsonFactory = _$WebSocketMessageFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class XbmcMetadataOptions {
  const XbmcMetadataOptions({
    this.userId,
    this.releaseDateFormat,
    this.saveImagePathsInNfo,
    this.enablePathSubstitution,
    this.enableExtraThumbsDuplication,
  });

  factory XbmcMetadataOptions.fromJson(Map<String, dynamic> json) =>
      _$XbmcMetadataOptionsFromJson(json);

  static const toJsonFactory = _$XbmcMetadataOptionsToJson;
  Map<String, dynamic> toJson() => _$XbmcMetadataOptionsToJson(this);

  @JsonKey(name: 'UserId')
  final String? userId;
  @JsonKey(name: 'ReleaseDateFormat')
  final String? releaseDateFormat;
  @JsonKey(name: 'SaveImagePathsInNfo')
  final bool? saveImagePathsInNfo;
  @JsonKey(name: 'EnablePathSubstitution')
  final bool? enablePathSubstitution;
  @JsonKey(name: 'EnableExtraThumbsDuplication')
  final bool? enableExtraThumbsDuplication;
  static const fromJsonFactory = _$XbmcMetadataOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is XbmcMetadataOptions &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.releaseDateFormat, releaseDateFormat) ||
                const DeepCollectionEquality()
                    .equals(other.releaseDateFormat, releaseDateFormat)) &&
            (identical(other.saveImagePathsInNfo, saveImagePathsInNfo) ||
                const DeepCollectionEquality()
                    .equals(other.saveImagePathsInNfo, saveImagePathsInNfo)) &&
            (identical(other.enablePathSubstitution, enablePathSubstitution) ||
                const DeepCollectionEquality().equals(
                    other.enablePathSubstitution, enablePathSubstitution)) &&
            (identical(other.enableExtraThumbsDuplication,
                    enableExtraThumbsDuplication) ||
                const DeepCollectionEquality().equals(
                    other.enableExtraThumbsDuplication,
                    enableExtraThumbsDuplication)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(releaseDateFormat) ^
      const DeepCollectionEquality().hash(saveImagePathsInNfo) ^
      const DeepCollectionEquality().hash(enablePathSubstitution) ^
      const DeepCollectionEquality().hash(enableExtraThumbsDuplication) ^
      runtimeType.hashCode;
}

extension $XbmcMetadataOptionsExtension on XbmcMetadataOptions {
  XbmcMetadataOptions copyWith(
      {String? userId,
      String? releaseDateFormat,
      bool? saveImagePathsInNfo,
      bool? enablePathSubstitution,
      bool? enableExtraThumbsDuplication}) {
    return XbmcMetadataOptions(
        userId: userId ?? this.userId,
        releaseDateFormat: releaseDateFormat ?? this.releaseDateFormat,
        saveImagePathsInNfo: saveImagePathsInNfo ?? this.saveImagePathsInNfo,
        enablePathSubstitution:
            enablePathSubstitution ?? this.enablePathSubstitution,
        enableExtraThumbsDuplication:
            enableExtraThumbsDuplication ?? this.enableExtraThumbsDuplication);
  }

  XbmcMetadataOptions copyWithWrapped(
      {Wrapped<String?>? userId,
      Wrapped<String?>? releaseDateFormat,
      Wrapped<bool?>? saveImagePathsInNfo,
      Wrapped<bool?>? enablePathSubstitution,
      Wrapped<bool?>? enableExtraThumbsDuplication}) {
    return XbmcMetadataOptions(
        userId: (userId != null ? userId.value : this.userId),
        releaseDateFormat: (releaseDateFormat != null
            ? releaseDateFormat.value
            : this.releaseDateFormat),
        saveImagePathsInNfo: (saveImagePathsInNfo != null
            ? saveImagePathsInNfo.value
            : this.saveImagePathsInNfo),
        enablePathSubstitution: (enablePathSubstitution != null
            ? enablePathSubstitution.value
            : this.enablePathSubstitution),
        enableExtraThumbsDuplication: (enableExtraThumbsDuplication != null
            ? enableExtraThumbsDuplication.value
            : this.enableExtraThumbsDuplication));
  }
}

@JsonSerializable(explicitToJson: true)
class BaseItemDto$ImageBlurHashes {
  const BaseItemDto$ImageBlurHashes({
    this.primary,
    this.art,
    this.backdrop,
    this.banner,
    this.logo,
    this.thumb,
    this.disc,
    this.box,
    this.screenshot,
    this.menu,
    this.chapter,
    this.boxRear,
    this.profile,
  });

  factory BaseItemDto$ImageBlurHashes.fromJson(Map<String, dynamic> json) =>
      _$BaseItemDto$ImageBlurHashesFromJson(json);

  static const toJsonFactory = _$BaseItemDto$ImageBlurHashesToJson;
  Map<String, dynamic> toJson() => _$BaseItemDto$ImageBlurHashesToJson(this);

  @JsonKey(name: 'Primary')
  final Map<String, dynamic>? primary;
  @JsonKey(name: 'Art')
  final Map<String, dynamic>? art;
  @JsonKey(name: 'Backdrop')
  final Map<String, dynamic>? backdrop;
  @JsonKey(name: 'Banner')
  final Map<String, dynamic>? banner;
  @JsonKey(name: 'Logo')
  final Map<String, dynamic>? logo;
  @JsonKey(name: 'Thumb')
  final Map<String, dynamic>? thumb;
  @JsonKey(name: 'Disc')
  final Map<String, dynamic>? disc;
  @JsonKey(name: 'Box')
  final Map<String, dynamic>? box;
  @JsonKey(name: 'Screenshot')
  final Map<String, dynamic>? screenshot;
  @JsonKey(name: 'Menu')
  final Map<String, dynamic>? menu;
  @JsonKey(name: 'Chapter')
  final Map<String, dynamic>? chapter;
  @JsonKey(name: 'BoxRear')
  final Map<String, dynamic>? boxRear;
  @JsonKey(name: 'Profile')
  final Map<String, dynamic>? profile;
  static const fromJsonFactory = _$BaseItemDto$ImageBlurHashesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseItemDto$ImageBlurHashes &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality()
                    .equals(other.primary, primary)) &&
            (identical(other.art, art) ||
                const DeepCollectionEquality().equals(other.art, art)) &&
            (identical(other.backdrop, backdrop) ||
                const DeepCollectionEquality()
                    .equals(other.backdrop, backdrop)) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.logo, logo) ||
                const DeepCollectionEquality().equals(other.logo, logo)) &&
            (identical(other.thumb, thumb) ||
                const DeepCollectionEquality().equals(other.thumb, thumb)) &&
            (identical(other.disc, disc) ||
                const DeepCollectionEquality().equals(other.disc, disc)) &&
            (identical(other.box, box) ||
                const DeepCollectionEquality().equals(other.box, box)) &&
            (identical(other.screenshot, screenshot) ||
                const DeepCollectionEquality()
                    .equals(other.screenshot, screenshot)) &&
            (identical(other.menu, menu) ||
                const DeepCollectionEquality().equals(other.menu, menu)) &&
            (identical(other.chapter, chapter) ||
                const DeepCollectionEquality()
                    .equals(other.chapter, chapter)) &&
            (identical(other.boxRear, boxRear) ||
                const DeepCollectionEquality()
                    .equals(other.boxRear, boxRear)) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(other.profile, profile)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(primary) ^
      const DeepCollectionEquality().hash(art) ^
      const DeepCollectionEquality().hash(backdrop) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(logo) ^
      const DeepCollectionEquality().hash(thumb) ^
      const DeepCollectionEquality().hash(disc) ^
      const DeepCollectionEquality().hash(box) ^
      const DeepCollectionEquality().hash(screenshot) ^
      const DeepCollectionEquality().hash(menu) ^
      const DeepCollectionEquality().hash(chapter) ^
      const DeepCollectionEquality().hash(boxRear) ^
      const DeepCollectionEquality().hash(profile) ^
      runtimeType.hashCode;
}

extension $BaseItemDto$ImageBlurHashesExtension on BaseItemDto$ImageBlurHashes {
  BaseItemDto$ImageBlurHashes copyWith(
      {Map<String, dynamic>? primary,
      Map<String, dynamic>? art,
      Map<String, dynamic>? backdrop,
      Map<String, dynamic>? banner,
      Map<String, dynamic>? logo,
      Map<String, dynamic>? thumb,
      Map<String, dynamic>? disc,
      Map<String, dynamic>? box,
      Map<String, dynamic>? screenshot,
      Map<String, dynamic>? menu,
      Map<String, dynamic>? chapter,
      Map<String, dynamic>? boxRear,
      Map<String, dynamic>? profile}) {
    return BaseItemDto$ImageBlurHashes(
        primary: primary ?? this.primary,
        art: art ?? this.art,
        backdrop: backdrop ?? this.backdrop,
        banner: banner ?? this.banner,
        logo: logo ?? this.logo,
        thumb: thumb ?? this.thumb,
        disc: disc ?? this.disc,
        box: box ?? this.box,
        screenshot: screenshot ?? this.screenshot,
        menu: menu ?? this.menu,
        chapter: chapter ?? this.chapter,
        boxRear: boxRear ?? this.boxRear,
        profile: profile ?? this.profile);
  }

  BaseItemDto$ImageBlurHashes copyWithWrapped(
      {Wrapped<Map<String, dynamic>?>? primary,
      Wrapped<Map<String, dynamic>?>? art,
      Wrapped<Map<String, dynamic>?>? backdrop,
      Wrapped<Map<String, dynamic>?>? banner,
      Wrapped<Map<String, dynamic>?>? logo,
      Wrapped<Map<String, dynamic>?>? thumb,
      Wrapped<Map<String, dynamic>?>? disc,
      Wrapped<Map<String, dynamic>?>? box,
      Wrapped<Map<String, dynamic>?>? screenshot,
      Wrapped<Map<String, dynamic>?>? menu,
      Wrapped<Map<String, dynamic>?>? chapter,
      Wrapped<Map<String, dynamic>?>? boxRear,
      Wrapped<Map<String, dynamic>?>? profile}) {
    return BaseItemDto$ImageBlurHashes(
        primary: (primary != null ? primary.value : this.primary),
        art: (art != null ? art.value : this.art),
        backdrop: (backdrop != null ? backdrop.value : this.backdrop),
        banner: (banner != null ? banner.value : this.banner),
        logo: (logo != null ? logo.value : this.logo),
        thumb: (thumb != null ? thumb.value : this.thumb),
        disc: (disc != null ? disc.value : this.disc),
        box: (box != null ? box.value : this.box),
        screenshot: (screenshot != null ? screenshot.value : this.screenshot),
        menu: (menu != null ? menu.value : this.menu),
        chapter: (chapter != null ? chapter.value : this.chapter),
        boxRear: (boxRear != null ? boxRear.value : this.boxRear),
        profile: (profile != null ? profile.value : this.profile));
  }
}

@JsonSerializable(explicitToJson: true)
class BaseItemPerson$ImageBlurHashes {
  const BaseItemPerson$ImageBlurHashes({
    this.primary,
    this.art,
    this.backdrop,
    this.banner,
    this.logo,
    this.thumb,
    this.disc,
    this.box,
    this.screenshot,
    this.menu,
    this.chapter,
    this.boxRear,
    this.profile,
  });

  factory BaseItemPerson$ImageBlurHashes.fromJson(Map<String, dynamic> json) =>
      _$BaseItemPerson$ImageBlurHashesFromJson(json);

  static const toJsonFactory = _$BaseItemPerson$ImageBlurHashesToJson;
  Map<String, dynamic> toJson() => _$BaseItemPerson$ImageBlurHashesToJson(this);

  @JsonKey(name: 'Primary')
  final Map<String, dynamic>? primary;
  @JsonKey(name: 'Art')
  final Map<String, dynamic>? art;
  @JsonKey(name: 'Backdrop')
  final Map<String, dynamic>? backdrop;
  @JsonKey(name: 'Banner')
  final Map<String, dynamic>? banner;
  @JsonKey(name: 'Logo')
  final Map<String, dynamic>? logo;
  @JsonKey(name: 'Thumb')
  final Map<String, dynamic>? thumb;
  @JsonKey(name: 'Disc')
  final Map<String, dynamic>? disc;
  @JsonKey(name: 'Box')
  final Map<String, dynamic>? box;
  @JsonKey(name: 'Screenshot')
  final Map<String, dynamic>? screenshot;
  @JsonKey(name: 'Menu')
  final Map<String, dynamic>? menu;
  @JsonKey(name: 'Chapter')
  final Map<String, dynamic>? chapter;
  @JsonKey(name: 'BoxRear')
  final Map<String, dynamic>? boxRear;
  @JsonKey(name: 'Profile')
  final Map<String, dynamic>? profile;
  static const fromJsonFactory = _$BaseItemPerson$ImageBlurHashesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BaseItemPerson$ImageBlurHashes &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality()
                    .equals(other.primary, primary)) &&
            (identical(other.art, art) ||
                const DeepCollectionEquality().equals(other.art, art)) &&
            (identical(other.backdrop, backdrop) ||
                const DeepCollectionEquality()
                    .equals(other.backdrop, backdrop)) &&
            (identical(other.banner, banner) ||
                const DeepCollectionEquality().equals(other.banner, banner)) &&
            (identical(other.logo, logo) ||
                const DeepCollectionEquality().equals(other.logo, logo)) &&
            (identical(other.thumb, thumb) ||
                const DeepCollectionEquality().equals(other.thumb, thumb)) &&
            (identical(other.disc, disc) ||
                const DeepCollectionEquality().equals(other.disc, disc)) &&
            (identical(other.box, box) ||
                const DeepCollectionEquality().equals(other.box, box)) &&
            (identical(other.screenshot, screenshot) ||
                const DeepCollectionEquality()
                    .equals(other.screenshot, screenshot)) &&
            (identical(other.menu, menu) ||
                const DeepCollectionEquality().equals(other.menu, menu)) &&
            (identical(other.chapter, chapter) ||
                const DeepCollectionEquality()
                    .equals(other.chapter, chapter)) &&
            (identical(other.boxRear, boxRear) ||
                const DeepCollectionEquality()
                    .equals(other.boxRear, boxRear)) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(other.profile, profile)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(primary) ^
      const DeepCollectionEquality().hash(art) ^
      const DeepCollectionEquality().hash(backdrop) ^
      const DeepCollectionEquality().hash(banner) ^
      const DeepCollectionEquality().hash(logo) ^
      const DeepCollectionEquality().hash(thumb) ^
      const DeepCollectionEquality().hash(disc) ^
      const DeepCollectionEquality().hash(box) ^
      const DeepCollectionEquality().hash(screenshot) ^
      const DeepCollectionEquality().hash(menu) ^
      const DeepCollectionEquality().hash(chapter) ^
      const DeepCollectionEquality().hash(boxRear) ^
      const DeepCollectionEquality().hash(profile) ^
      runtimeType.hashCode;
}

extension $BaseItemPerson$ImageBlurHashesExtension
    on BaseItemPerson$ImageBlurHashes {
  BaseItemPerson$ImageBlurHashes copyWith(
      {Map<String, dynamic>? primary,
      Map<String, dynamic>? art,
      Map<String, dynamic>? backdrop,
      Map<String, dynamic>? banner,
      Map<String, dynamic>? logo,
      Map<String, dynamic>? thumb,
      Map<String, dynamic>? disc,
      Map<String, dynamic>? box,
      Map<String, dynamic>? screenshot,
      Map<String, dynamic>? menu,
      Map<String, dynamic>? chapter,
      Map<String, dynamic>? boxRear,
      Map<String, dynamic>? profile}) {
    return BaseItemPerson$ImageBlurHashes(
        primary: primary ?? this.primary,
        art: art ?? this.art,
        backdrop: backdrop ?? this.backdrop,
        banner: banner ?? this.banner,
        logo: logo ?? this.logo,
        thumb: thumb ?? this.thumb,
        disc: disc ?? this.disc,
        box: box ?? this.box,
        screenshot: screenshot ?? this.screenshot,
        menu: menu ?? this.menu,
        chapter: chapter ?? this.chapter,
        boxRear: boxRear ?? this.boxRear,
        profile: profile ?? this.profile);
  }

  BaseItemPerson$ImageBlurHashes copyWithWrapped(
      {Wrapped<Map<String, dynamic>?>? primary,
      Wrapped<Map<String, dynamic>?>? art,
      Wrapped<Map<String, dynamic>?>? backdrop,
      Wrapped<Map<String, dynamic>?>? banner,
      Wrapped<Map<String, dynamic>?>? logo,
      Wrapped<Map<String, dynamic>?>? thumb,
      Wrapped<Map<String, dynamic>?>? disc,
      Wrapped<Map<String, dynamic>?>? box,
      Wrapped<Map<String, dynamic>?>? screenshot,
      Wrapped<Map<String, dynamic>?>? menu,
      Wrapped<Map<String, dynamic>?>? chapter,
      Wrapped<Map<String, dynamic>?>? boxRear,
      Wrapped<Map<String, dynamic>?>? profile}) {
    return BaseItemPerson$ImageBlurHashes(
        primary: (primary != null ? primary.value : this.primary),
        art: (art != null ? art.value : this.art),
        backdrop: (backdrop != null ? backdrop.value : this.backdrop),
        banner: (banner != null ? banner.value : this.banner),
        logo: (logo != null ? logo.value : this.logo),
        thumb: (thumb != null ? thumb.value : this.thumb),
        disc: (disc != null ? disc.value : this.disc),
        box: (box != null ? box.value : this.box),
        screenshot: (screenshot != null ? screenshot.value : this.screenshot),
        menu: (menu != null ? menu.value : this.menu),
        chapter: (chapter != null ? chapter.value : this.chapter),
        boxRear: (boxRear != null ? boxRear.value : this.boxRear),
        profile: (profile != null ? profile.value : this.profile));
  }
}

String? audioSpatialFormatNullableToJson(
    enums.AudioSpatialFormat? audioSpatialFormat) {
  return audioSpatialFormat?.value;
}

String? audioSpatialFormatToJson(enums.AudioSpatialFormat audioSpatialFormat) {
  return audioSpatialFormat.value;
}

enums.AudioSpatialFormat audioSpatialFormatFromJson(
  Object? audioSpatialFormat, [
  enums.AudioSpatialFormat? defaultValue,
]) {
  return enums.AudioSpatialFormat.values
          .firstWhereOrNull((e) => e.value == audioSpatialFormat) ??
      defaultValue ??
      enums.AudioSpatialFormat.swaggerGeneratedUnknown;
}

enums.AudioSpatialFormat? audioSpatialFormatNullableFromJson(
  Object? audioSpatialFormat, [
  enums.AudioSpatialFormat? defaultValue,
]) {
  if (audioSpatialFormat == null) {
    return null;
  }
  return enums.AudioSpatialFormat.values
          .firstWhereOrNull((e) => e.value == audioSpatialFormat) ??
      defaultValue;
}

String audioSpatialFormatExplodedListToJson(
    List<enums.AudioSpatialFormat>? audioSpatialFormat) {
  return audioSpatialFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> audioSpatialFormatListToJson(
    List<enums.AudioSpatialFormat>? audioSpatialFormat) {
  if (audioSpatialFormat == null) {
    return [];
  }

  return audioSpatialFormat.map((e) => e.value!).toList();
}

List<enums.AudioSpatialFormat> audioSpatialFormatListFromJson(
  List? audioSpatialFormat, [
  List<enums.AudioSpatialFormat>? defaultValue,
]) {
  if (audioSpatialFormat == null) {
    return defaultValue ?? [];
  }

  return audioSpatialFormat
      .map((e) => audioSpatialFormatFromJson(e.toString()))
      .toList();
}

List<enums.AudioSpatialFormat>? audioSpatialFormatNullableListFromJson(
  List? audioSpatialFormat, [
  List<enums.AudioSpatialFormat>? defaultValue,
]) {
  if (audioSpatialFormat == null) {
    return defaultValue;
  }

  return audioSpatialFormat
      .map((e) => audioSpatialFormatFromJson(e.toString()))
      .toList();
}

String? baseItemKindNullableToJson(enums.BaseItemKind? baseItemKind) {
  return baseItemKind?.value;
}

String? baseItemKindToJson(enums.BaseItemKind baseItemKind) {
  return baseItemKind.value;
}

enums.BaseItemKind baseItemKindFromJson(
  Object? baseItemKind, [
  enums.BaseItemKind? defaultValue,
]) {
  return enums.BaseItemKind.values
          .firstWhereOrNull((e) => e.value == baseItemKind) ??
      defaultValue ??
      enums.BaseItemKind.swaggerGeneratedUnknown;
}

enums.BaseItemKind? baseItemKindNullableFromJson(
  Object? baseItemKind, [
  enums.BaseItemKind? defaultValue,
]) {
  if (baseItemKind == null) {
    return null;
  }
  return enums.BaseItemKind.values
          .firstWhereOrNull((e) => e.value == baseItemKind) ??
      defaultValue;
}

String baseItemKindExplodedListToJson(List<enums.BaseItemKind>? baseItemKind) {
  return baseItemKind?.map((e) => e.value!).join(',') ?? '';
}

List<String> baseItemKindListToJson(List<enums.BaseItemKind>? baseItemKind) {
  if (baseItemKind == null) {
    return [];
  }

  return baseItemKind.map((e) => e.value!).toList();
}

List<enums.BaseItemKind> baseItemKindListFromJson(
  List? baseItemKind, [
  List<enums.BaseItemKind>? defaultValue,
]) {
  if (baseItemKind == null) {
    return defaultValue ?? [];
  }

  return baseItemKind.map((e) => baseItemKindFromJson(e.toString())).toList();
}

List<enums.BaseItemKind>? baseItemKindNullableListFromJson(
  List? baseItemKind, [
  List<enums.BaseItemKind>? defaultValue,
]) {
  if (baseItemKind == null) {
    return defaultValue;
  }

  return baseItemKind.map((e) => baseItemKindFromJson(e.toString())).toList();
}

String? channelItemSortFieldNullableToJson(
    enums.ChannelItemSortField? channelItemSortField) {
  return channelItemSortField?.value;
}

String? channelItemSortFieldToJson(
    enums.ChannelItemSortField channelItemSortField) {
  return channelItemSortField.value;
}

enums.ChannelItemSortField channelItemSortFieldFromJson(
  Object? channelItemSortField, [
  enums.ChannelItemSortField? defaultValue,
]) {
  return enums.ChannelItemSortField.values
          .firstWhereOrNull((e) => e.value == channelItemSortField) ??
      defaultValue ??
      enums.ChannelItemSortField.swaggerGeneratedUnknown;
}

enums.ChannelItemSortField? channelItemSortFieldNullableFromJson(
  Object? channelItemSortField, [
  enums.ChannelItemSortField? defaultValue,
]) {
  if (channelItemSortField == null) {
    return null;
  }
  return enums.ChannelItemSortField.values
          .firstWhereOrNull((e) => e.value == channelItemSortField) ??
      defaultValue;
}

String channelItemSortFieldExplodedListToJson(
    List<enums.ChannelItemSortField>? channelItemSortField) {
  return channelItemSortField?.map((e) => e.value!).join(',') ?? '';
}

List<String> channelItemSortFieldListToJson(
    List<enums.ChannelItemSortField>? channelItemSortField) {
  if (channelItemSortField == null) {
    return [];
  }

  return channelItemSortField.map((e) => e.value!).toList();
}

List<enums.ChannelItemSortField> channelItemSortFieldListFromJson(
  List? channelItemSortField, [
  List<enums.ChannelItemSortField>? defaultValue,
]) {
  if (channelItemSortField == null) {
    return defaultValue ?? [];
  }

  return channelItemSortField
      .map((e) => channelItemSortFieldFromJson(e.toString()))
      .toList();
}

List<enums.ChannelItemSortField>? channelItemSortFieldNullableListFromJson(
  List? channelItemSortField, [
  List<enums.ChannelItemSortField>? defaultValue,
]) {
  if (channelItemSortField == null) {
    return defaultValue;
  }

  return channelItemSortField
      .map((e) => channelItemSortFieldFromJson(e.toString()))
      .toList();
}

String? channelMediaContentTypeNullableToJson(
    enums.ChannelMediaContentType? channelMediaContentType) {
  return channelMediaContentType?.value;
}

String? channelMediaContentTypeToJson(
    enums.ChannelMediaContentType channelMediaContentType) {
  return channelMediaContentType.value;
}

enums.ChannelMediaContentType channelMediaContentTypeFromJson(
  Object? channelMediaContentType, [
  enums.ChannelMediaContentType? defaultValue,
]) {
  return enums.ChannelMediaContentType.values
          .firstWhereOrNull((e) => e.value == channelMediaContentType) ??
      defaultValue ??
      enums.ChannelMediaContentType.swaggerGeneratedUnknown;
}

enums.ChannelMediaContentType? channelMediaContentTypeNullableFromJson(
  Object? channelMediaContentType, [
  enums.ChannelMediaContentType? defaultValue,
]) {
  if (channelMediaContentType == null) {
    return null;
  }
  return enums.ChannelMediaContentType.values
          .firstWhereOrNull((e) => e.value == channelMediaContentType) ??
      defaultValue;
}

String channelMediaContentTypeExplodedListToJson(
    List<enums.ChannelMediaContentType>? channelMediaContentType) {
  return channelMediaContentType?.map((e) => e.value!).join(',') ?? '';
}

List<String> channelMediaContentTypeListToJson(
    List<enums.ChannelMediaContentType>? channelMediaContentType) {
  if (channelMediaContentType == null) {
    return [];
  }

  return channelMediaContentType.map((e) => e.value!).toList();
}

List<enums.ChannelMediaContentType> channelMediaContentTypeListFromJson(
  List? channelMediaContentType, [
  List<enums.ChannelMediaContentType>? defaultValue,
]) {
  if (channelMediaContentType == null) {
    return defaultValue ?? [];
  }

  return channelMediaContentType
      .map((e) => channelMediaContentTypeFromJson(e.toString()))
      .toList();
}

List<enums.ChannelMediaContentType>?
    channelMediaContentTypeNullableListFromJson(
  List? channelMediaContentType, [
  List<enums.ChannelMediaContentType>? defaultValue,
]) {
  if (channelMediaContentType == null) {
    return defaultValue;
  }

  return channelMediaContentType
      .map((e) => channelMediaContentTypeFromJson(e.toString()))
      .toList();
}

String? channelMediaTypeNullableToJson(
    enums.ChannelMediaType? channelMediaType) {
  return channelMediaType?.value;
}

String? channelMediaTypeToJson(enums.ChannelMediaType channelMediaType) {
  return channelMediaType.value;
}

enums.ChannelMediaType channelMediaTypeFromJson(
  Object? channelMediaType, [
  enums.ChannelMediaType? defaultValue,
]) {
  return enums.ChannelMediaType.values
          .firstWhereOrNull((e) => e.value == channelMediaType) ??
      defaultValue ??
      enums.ChannelMediaType.swaggerGeneratedUnknown;
}

enums.ChannelMediaType? channelMediaTypeNullableFromJson(
  Object? channelMediaType, [
  enums.ChannelMediaType? defaultValue,
]) {
  if (channelMediaType == null) {
    return null;
  }
  return enums.ChannelMediaType.values
          .firstWhereOrNull((e) => e.value == channelMediaType) ??
      defaultValue;
}

String channelMediaTypeExplodedListToJson(
    List<enums.ChannelMediaType>? channelMediaType) {
  return channelMediaType?.map((e) => e.value!).join(',') ?? '';
}

List<String> channelMediaTypeListToJson(
    List<enums.ChannelMediaType>? channelMediaType) {
  if (channelMediaType == null) {
    return [];
  }

  return channelMediaType.map((e) => e.value!).toList();
}

List<enums.ChannelMediaType> channelMediaTypeListFromJson(
  List? channelMediaType, [
  List<enums.ChannelMediaType>? defaultValue,
]) {
  if (channelMediaType == null) {
    return defaultValue ?? [];
  }

  return channelMediaType
      .map((e) => channelMediaTypeFromJson(e.toString()))
      .toList();
}

List<enums.ChannelMediaType>? channelMediaTypeNullableListFromJson(
  List? channelMediaType, [
  List<enums.ChannelMediaType>? defaultValue,
]) {
  if (channelMediaType == null) {
    return defaultValue;
  }

  return channelMediaType
      .map((e) => channelMediaTypeFromJson(e.toString()))
      .toList();
}

String? channelTypeNullableToJson(enums.ChannelType? channelType) {
  return channelType?.value;
}

String? channelTypeToJson(enums.ChannelType channelType) {
  return channelType.value;
}

enums.ChannelType channelTypeFromJson(
  Object? channelType, [
  enums.ChannelType? defaultValue,
]) {
  return enums.ChannelType.values
          .firstWhereOrNull((e) => e.value == channelType) ??
      defaultValue ??
      enums.ChannelType.swaggerGeneratedUnknown;
}

enums.ChannelType? channelTypeNullableFromJson(
  Object? channelType, [
  enums.ChannelType? defaultValue,
]) {
  if (channelType == null) {
    return null;
  }
  return enums.ChannelType.values
          .firstWhereOrNull((e) => e.value == channelType) ??
      defaultValue;
}

String channelTypeExplodedListToJson(List<enums.ChannelType>? channelType) {
  return channelType?.map((e) => e.value!).join(',') ?? '';
}

List<String> channelTypeListToJson(List<enums.ChannelType>? channelType) {
  if (channelType == null) {
    return [];
  }

  return channelType.map((e) => e.value!).toList();
}

List<enums.ChannelType> channelTypeListFromJson(
  List? channelType, [
  List<enums.ChannelType>? defaultValue,
]) {
  if (channelType == null) {
    return defaultValue ?? [];
  }

  return channelType.map((e) => channelTypeFromJson(e.toString())).toList();
}

List<enums.ChannelType>? channelTypeNullableListFromJson(
  List? channelType, [
  List<enums.ChannelType>? defaultValue,
]) {
  if (channelType == null) {
    return defaultValue;
  }

  return channelType.map((e) => channelTypeFromJson(e.toString())).toList();
}

String? codecTypeNullableToJson(enums.CodecType? codecType) {
  return codecType?.value;
}

String? codecTypeToJson(enums.CodecType codecType) {
  return codecType.value;
}

enums.CodecType codecTypeFromJson(
  Object? codecType, [
  enums.CodecType? defaultValue,
]) {
  return enums.CodecType.values.firstWhereOrNull((e) => e.value == codecType) ??
      defaultValue ??
      enums.CodecType.swaggerGeneratedUnknown;
}

enums.CodecType? codecTypeNullableFromJson(
  Object? codecType, [
  enums.CodecType? defaultValue,
]) {
  if (codecType == null) {
    return null;
  }
  return enums.CodecType.values.firstWhereOrNull((e) => e.value == codecType) ??
      defaultValue;
}

String codecTypeExplodedListToJson(List<enums.CodecType>? codecType) {
  return codecType?.map((e) => e.value!).join(',') ?? '';
}

List<String> codecTypeListToJson(List<enums.CodecType>? codecType) {
  if (codecType == null) {
    return [];
  }

  return codecType.map((e) => e.value!).toList();
}

List<enums.CodecType> codecTypeListFromJson(
  List? codecType, [
  List<enums.CodecType>? defaultValue,
]) {
  if (codecType == null) {
    return defaultValue ?? [];
  }

  return codecType.map((e) => codecTypeFromJson(e.toString())).toList();
}

List<enums.CodecType>? codecTypeNullableListFromJson(
  List? codecType, [
  List<enums.CodecType>? defaultValue,
]) {
  if (codecType == null) {
    return defaultValue;
  }

  return codecType.map((e) => codecTypeFromJson(e.toString())).toList();
}

String? collectionTypeNullableToJson(enums.CollectionType? collectionType) {
  return collectionType?.value;
}

String? collectionTypeToJson(enums.CollectionType collectionType) {
  return collectionType.value;
}

enums.CollectionType collectionTypeFromJson(
  Object? collectionType, [
  enums.CollectionType? defaultValue,
]) {
  return enums.CollectionType.values
          .firstWhereOrNull((e) => e.value == collectionType) ??
      defaultValue ??
      enums.CollectionType.swaggerGeneratedUnknown;
}

enums.CollectionType? collectionTypeNullableFromJson(
  Object? collectionType, [
  enums.CollectionType? defaultValue,
]) {
  if (collectionType == null) {
    return null;
  }
  return enums.CollectionType.values
          .firstWhereOrNull((e) => e.value == collectionType) ??
      defaultValue;
}

String collectionTypeExplodedListToJson(
    List<enums.CollectionType>? collectionType) {
  return collectionType?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionTypeListToJson(
    List<enums.CollectionType>? collectionType) {
  if (collectionType == null) {
    return [];
  }

  return collectionType.map((e) => e.value!).toList();
}

List<enums.CollectionType> collectionTypeListFromJson(
  List? collectionType, [
  List<enums.CollectionType>? defaultValue,
]) {
  if (collectionType == null) {
    return defaultValue ?? [];
  }

  return collectionType
      .map((e) => collectionTypeFromJson(e.toString()))
      .toList();
}

List<enums.CollectionType>? collectionTypeNullableListFromJson(
  List? collectionType, [
  List<enums.CollectionType>? defaultValue,
]) {
  if (collectionType == null) {
    return defaultValue;
  }

  return collectionType
      .map((e) => collectionTypeFromJson(e.toString()))
      .toList();
}

String? collectionTypeOptionsNullableToJson(
    enums.CollectionTypeOptions? collectionTypeOptions) {
  return collectionTypeOptions?.value;
}

String? collectionTypeOptionsToJson(
    enums.CollectionTypeOptions collectionTypeOptions) {
  return collectionTypeOptions.value;
}

enums.CollectionTypeOptions collectionTypeOptionsFromJson(
  Object? collectionTypeOptions, [
  enums.CollectionTypeOptions? defaultValue,
]) {
  return enums.CollectionTypeOptions.values
          .firstWhereOrNull((e) => e.value == collectionTypeOptions) ??
      defaultValue ??
      enums.CollectionTypeOptions.swaggerGeneratedUnknown;
}

enums.CollectionTypeOptions? collectionTypeOptionsNullableFromJson(
  Object? collectionTypeOptions, [
  enums.CollectionTypeOptions? defaultValue,
]) {
  if (collectionTypeOptions == null) {
    return null;
  }
  return enums.CollectionTypeOptions.values
          .firstWhereOrNull((e) => e.value == collectionTypeOptions) ??
      defaultValue;
}

String collectionTypeOptionsExplodedListToJson(
    List<enums.CollectionTypeOptions>? collectionTypeOptions) {
  return collectionTypeOptions?.map((e) => e.value!).join(',') ?? '';
}

List<String> collectionTypeOptionsListToJson(
    List<enums.CollectionTypeOptions>? collectionTypeOptions) {
  if (collectionTypeOptions == null) {
    return [];
  }

  return collectionTypeOptions.map((e) => e.value!).toList();
}

List<enums.CollectionTypeOptions> collectionTypeOptionsListFromJson(
  List? collectionTypeOptions, [
  List<enums.CollectionTypeOptions>? defaultValue,
]) {
  if (collectionTypeOptions == null) {
    return defaultValue ?? [];
  }

  return collectionTypeOptions
      .map((e) => collectionTypeOptionsFromJson(e.toString()))
      .toList();
}

List<enums.CollectionTypeOptions>? collectionTypeOptionsNullableListFromJson(
  List? collectionTypeOptions, [
  List<enums.CollectionTypeOptions>? defaultValue,
]) {
  if (collectionTypeOptions == null) {
    return defaultValue;
  }

  return collectionTypeOptions
      .map((e) => collectionTypeOptionsFromJson(e.toString()))
      .toList();
}

String? dayOfWeekNullableToJson(enums.DayOfWeek? dayOfWeek) {
  return dayOfWeek?.value;
}

String? dayOfWeekToJson(enums.DayOfWeek dayOfWeek) {
  return dayOfWeek.value;
}

enums.DayOfWeek dayOfWeekFromJson(
  Object? dayOfWeek, [
  enums.DayOfWeek? defaultValue,
]) {
  return enums.DayOfWeek.values.firstWhereOrNull((e) => e.value == dayOfWeek) ??
      defaultValue ??
      enums.DayOfWeek.swaggerGeneratedUnknown;
}

enums.DayOfWeek? dayOfWeekNullableFromJson(
  Object? dayOfWeek, [
  enums.DayOfWeek? defaultValue,
]) {
  if (dayOfWeek == null) {
    return null;
  }
  return enums.DayOfWeek.values.firstWhereOrNull((e) => e.value == dayOfWeek) ??
      defaultValue;
}

String dayOfWeekExplodedListToJson(List<enums.DayOfWeek>? dayOfWeek) {
  return dayOfWeek?.map((e) => e.value!).join(',') ?? '';
}

List<String> dayOfWeekListToJson(List<enums.DayOfWeek>? dayOfWeek) {
  if (dayOfWeek == null) {
    return [];
  }

  return dayOfWeek.map((e) => e.value!).toList();
}

List<enums.DayOfWeek> dayOfWeekListFromJson(
  List? dayOfWeek, [
  List<enums.DayOfWeek>? defaultValue,
]) {
  if (dayOfWeek == null) {
    return defaultValue ?? [];
  }

  return dayOfWeek.map((e) => dayOfWeekFromJson(e.toString())).toList();
}

List<enums.DayOfWeek>? dayOfWeekNullableListFromJson(
  List? dayOfWeek, [
  List<enums.DayOfWeek>? defaultValue,
]) {
  if (dayOfWeek == null) {
    return defaultValue;
  }

  return dayOfWeek.map((e) => dayOfWeekFromJson(e.toString())).toList();
}

String? dayPatternNullableToJson(enums.DayPattern? dayPattern) {
  return dayPattern?.value;
}

String? dayPatternToJson(enums.DayPattern dayPattern) {
  return dayPattern.value;
}

enums.DayPattern dayPatternFromJson(
  Object? dayPattern, [
  enums.DayPattern? defaultValue,
]) {
  return enums.DayPattern.values
          .firstWhereOrNull((e) => e.value == dayPattern) ??
      defaultValue ??
      enums.DayPattern.swaggerGeneratedUnknown;
}

enums.DayPattern? dayPatternNullableFromJson(
  Object? dayPattern, [
  enums.DayPattern? defaultValue,
]) {
  if (dayPattern == null) {
    return null;
  }
  return enums.DayPattern.values
          .firstWhereOrNull((e) => e.value == dayPattern) ??
      defaultValue;
}

String dayPatternExplodedListToJson(List<enums.DayPattern>? dayPattern) {
  return dayPattern?.map((e) => e.value!).join(',') ?? '';
}

List<String> dayPatternListToJson(List<enums.DayPattern>? dayPattern) {
  if (dayPattern == null) {
    return [];
  }

  return dayPattern.map((e) => e.value!).toList();
}

List<enums.DayPattern> dayPatternListFromJson(
  List? dayPattern, [
  List<enums.DayPattern>? defaultValue,
]) {
  if (dayPattern == null) {
    return defaultValue ?? [];
  }

  return dayPattern.map((e) => dayPatternFromJson(e.toString())).toList();
}

List<enums.DayPattern>? dayPatternNullableListFromJson(
  List? dayPattern, [
  List<enums.DayPattern>? defaultValue,
]) {
  if (dayPattern == null) {
    return defaultValue;
  }

  return dayPattern.map((e) => dayPatternFromJson(e.toString())).toList();
}

String? deinterlaceMethodNullableToJson(
    enums.DeinterlaceMethod? deinterlaceMethod) {
  return deinterlaceMethod?.value;
}

String? deinterlaceMethodToJson(enums.DeinterlaceMethod deinterlaceMethod) {
  return deinterlaceMethod.value;
}

enums.DeinterlaceMethod deinterlaceMethodFromJson(
  Object? deinterlaceMethod, [
  enums.DeinterlaceMethod? defaultValue,
]) {
  return enums.DeinterlaceMethod.values
          .firstWhereOrNull((e) => e.value == deinterlaceMethod) ??
      defaultValue ??
      enums.DeinterlaceMethod.swaggerGeneratedUnknown;
}

enums.DeinterlaceMethod? deinterlaceMethodNullableFromJson(
  Object? deinterlaceMethod, [
  enums.DeinterlaceMethod? defaultValue,
]) {
  if (deinterlaceMethod == null) {
    return null;
  }
  return enums.DeinterlaceMethod.values
          .firstWhereOrNull((e) => e.value == deinterlaceMethod) ??
      defaultValue;
}

String deinterlaceMethodExplodedListToJson(
    List<enums.DeinterlaceMethod>? deinterlaceMethod) {
  return deinterlaceMethod?.map((e) => e.value!).join(',') ?? '';
}

List<String> deinterlaceMethodListToJson(
    List<enums.DeinterlaceMethod>? deinterlaceMethod) {
  if (deinterlaceMethod == null) {
    return [];
  }

  return deinterlaceMethod.map((e) => e.value!).toList();
}

List<enums.DeinterlaceMethod> deinterlaceMethodListFromJson(
  List? deinterlaceMethod, [
  List<enums.DeinterlaceMethod>? defaultValue,
]) {
  if (deinterlaceMethod == null) {
    return defaultValue ?? [];
  }

  return deinterlaceMethod
      .map((e) => deinterlaceMethodFromJson(e.toString()))
      .toList();
}

List<enums.DeinterlaceMethod>? deinterlaceMethodNullableListFromJson(
  List? deinterlaceMethod, [
  List<enums.DeinterlaceMethod>? defaultValue,
]) {
  if (deinterlaceMethod == null) {
    return defaultValue;
  }

  return deinterlaceMethod
      .map((e) => deinterlaceMethodFromJson(e.toString()))
      .toList();
}

String? dlnaProfileTypeNullableToJson(enums.DlnaProfileType? dlnaProfileType) {
  return dlnaProfileType?.value;
}

String? dlnaProfileTypeToJson(enums.DlnaProfileType dlnaProfileType) {
  return dlnaProfileType.value;
}

enums.DlnaProfileType dlnaProfileTypeFromJson(
  Object? dlnaProfileType, [
  enums.DlnaProfileType? defaultValue,
]) {
  return enums.DlnaProfileType.values
          .firstWhereOrNull((e) => e.value == dlnaProfileType) ??
      defaultValue ??
      enums.DlnaProfileType.swaggerGeneratedUnknown;
}

enums.DlnaProfileType? dlnaProfileTypeNullableFromJson(
  Object? dlnaProfileType, [
  enums.DlnaProfileType? defaultValue,
]) {
  if (dlnaProfileType == null) {
    return null;
  }
  return enums.DlnaProfileType.values
          .firstWhereOrNull((e) => e.value == dlnaProfileType) ??
      defaultValue;
}

String dlnaProfileTypeExplodedListToJson(
    List<enums.DlnaProfileType>? dlnaProfileType) {
  return dlnaProfileType?.map((e) => e.value!).join(',') ?? '';
}

List<String> dlnaProfileTypeListToJson(
    List<enums.DlnaProfileType>? dlnaProfileType) {
  if (dlnaProfileType == null) {
    return [];
  }

  return dlnaProfileType.map((e) => e.value!).toList();
}

List<enums.DlnaProfileType> dlnaProfileTypeListFromJson(
  List? dlnaProfileType, [
  List<enums.DlnaProfileType>? defaultValue,
]) {
  if (dlnaProfileType == null) {
    return defaultValue ?? [];
  }

  return dlnaProfileType
      .map((e) => dlnaProfileTypeFromJson(e.toString()))
      .toList();
}

List<enums.DlnaProfileType>? dlnaProfileTypeNullableListFromJson(
  List? dlnaProfileType, [
  List<enums.DlnaProfileType>? defaultValue,
]) {
  if (dlnaProfileType == null) {
    return defaultValue;
  }

  return dlnaProfileType
      .map((e) => dlnaProfileTypeFromJson(e.toString()))
      .toList();
}

String? downMixStereoAlgorithmsNullableToJson(
    enums.DownMixStereoAlgorithms? downMixStereoAlgorithms) {
  return downMixStereoAlgorithms?.value;
}

String? downMixStereoAlgorithmsToJson(
    enums.DownMixStereoAlgorithms downMixStereoAlgorithms) {
  return downMixStereoAlgorithms.value;
}

enums.DownMixStereoAlgorithms downMixStereoAlgorithmsFromJson(
  Object? downMixStereoAlgorithms, [
  enums.DownMixStereoAlgorithms? defaultValue,
]) {
  return enums.DownMixStereoAlgorithms.values
          .firstWhereOrNull((e) => e.value == downMixStereoAlgorithms) ??
      defaultValue ??
      enums.DownMixStereoAlgorithms.swaggerGeneratedUnknown;
}

enums.DownMixStereoAlgorithms? downMixStereoAlgorithmsNullableFromJson(
  Object? downMixStereoAlgorithms, [
  enums.DownMixStereoAlgorithms? defaultValue,
]) {
  if (downMixStereoAlgorithms == null) {
    return null;
  }
  return enums.DownMixStereoAlgorithms.values
          .firstWhereOrNull((e) => e.value == downMixStereoAlgorithms) ??
      defaultValue;
}

String downMixStereoAlgorithmsExplodedListToJson(
    List<enums.DownMixStereoAlgorithms>? downMixStereoAlgorithms) {
  return downMixStereoAlgorithms?.map((e) => e.value!).join(',') ?? '';
}

List<String> downMixStereoAlgorithmsListToJson(
    List<enums.DownMixStereoAlgorithms>? downMixStereoAlgorithms) {
  if (downMixStereoAlgorithms == null) {
    return [];
  }

  return downMixStereoAlgorithms.map((e) => e.value!).toList();
}

List<enums.DownMixStereoAlgorithms> downMixStereoAlgorithmsListFromJson(
  List? downMixStereoAlgorithms, [
  List<enums.DownMixStereoAlgorithms>? defaultValue,
]) {
  if (downMixStereoAlgorithms == null) {
    return defaultValue ?? [];
  }

  return downMixStereoAlgorithms
      .map((e) => downMixStereoAlgorithmsFromJson(e.toString()))
      .toList();
}

List<enums.DownMixStereoAlgorithms>?
    downMixStereoAlgorithmsNullableListFromJson(
  List? downMixStereoAlgorithms, [
  List<enums.DownMixStereoAlgorithms>? defaultValue,
]) {
  if (downMixStereoAlgorithms == null) {
    return defaultValue;
  }

  return downMixStereoAlgorithms
      .map((e) => downMixStereoAlgorithmsFromJson(e.toString()))
      .toList();
}

String? dynamicDayOfWeekNullableToJson(
    enums.DynamicDayOfWeek? dynamicDayOfWeek) {
  return dynamicDayOfWeek?.value;
}

String? dynamicDayOfWeekToJson(enums.DynamicDayOfWeek dynamicDayOfWeek) {
  return dynamicDayOfWeek.value;
}

enums.DynamicDayOfWeek dynamicDayOfWeekFromJson(
  Object? dynamicDayOfWeek, [
  enums.DynamicDayOfWeek? defaultValue,
]) {
  return enums.DynamicDayOfWeek.values
          .firstWhereOrNull((e) => e.value == dynamicDayOfWeek) ??
      defaultValue ??
      enums.DynamicDayOfWeek.swaggerGeneratedUnknown;
}

enums.DynamicDayOfWeek? dynamicDayOfWeekNullableFromJson(
  Object? dynamicDayOfWeek, [
  enums.DynamicDayOfWeek? defaultValue,
]) {
  if (dynamicDayOfWeek == null) {
    return null;
  }
  return enums.DynamicDayOfWeek.values
          .firstWhereOrNull((e) => e.value == dynamicDayOfWeek) ??
      defaultValue;
}

String dynamicDayOfWeekExplodedListToJson(
    List<enums.DynamicDayOfWeek>? dynamicDayOfWeek) {
  return dynamicDayOfWeek?.map((e) => e.value!).join(',') ?? '';
}

List<String> dynamicDayOfWeekListToJson(
    List<enums.DynamicDayOfWeek>? dynamicDayOfWeek) {
  if (dynamicDayOfWeek == null) {
    return [];
  }

  return dynamicDayOfWeek.map((e) => e.value!).toList();
}

List<enums.DynamicDayOfWeek> dynamicDayOfWeekListFromJson(
  List? dynamicDayOfWeek, [
  List<enums.DynamicDayOfWeek>? defaultValue,
]) {
  if (dynamicDayOfWeek == null) {
    return defaultValue ?? [];
  }

  return dynamicDayOfWeek
      .map((e) => dynamicDayOfWeekFromJson(e.toString()))
      .toList();
}

List<enums.DynamicDayOfWeek>? dynamicDayOfWeekNullableListFromJson(
  List? dynamicDayOfWeek, [
  List<enums.DynamicDayOfWeek>? defaultValue,
]) {
  if (dynamicDayOfWeek == null) {
    return defaultValue;
  }

  return dynamicDayOfWeek
      .map((e) => dynamicDayOfWeekFromJson(e.toString()))
      .toList();
}

String? embeddedSubtitleOptionsNullableToJson(
    enums.EmbeddedSubtitleOptions? embeddedSubtitleOptions) {
  return embeddedSubtitleOptions?.value;
}

String? embeddedSubtitleOptionsToJson(
    enums.EmbeddedSubtitleOptions embeddedSubtitleOptions) {
  return embeddedSubtitleOptions.value;
}

enums.EmbeddedSubtitleOptions embeddedSubtitleOptionsFromJson(
  Object? embeddedSubtitleOptions, [
  enums.EmbeddedSubtitleOptions? defaultValue,
]) {
  return enums.EmbeddedSubtitleOptions.values
          .firstWhereOrNull((e) => e.value == embeddedSubtitleOptions) ??
      defaultValue ??
      enums.EmbeddedSubtitleOptions.swaggerGeneratedUnknown;
}

enums.EmbeddedSubtitleOptions? embeddedSubtitleOptionsNullableFromJson(
  Object? embeddedSubtitleOptions, [
  enums.EmbeddedSubtitleOptions? defaultValue,
]) {
  if (embeddedSubtitleOptions == null) {
    return null;
  }
  return enums.EmbeddedSubtitleOptions.values
          .firstWhereOrNull((e) => e.value == embeddedSubtitleOptions) ??
      defaultValue;
}

String embeddedSubtitleOptionsExplodedListToJson(
    List<enums.EmbeddedSubtitleOptions>? embeddedSubtitleOptions) {
  return embeddedSubtitleOptions?.map((e) => e.value!).join(',') ?? '';
}

List<String> embeddedSubtitleOptionsListToJson(
    List<enums.EmbeddedSubtitleOptions>? embeddedSubtitleOptions) {
  if (embeddedSubtitleOptions == null) {
    return [];
  }

  return embeddedSubtitleOptions.map((e) => e.value!).toList();
}

List<enums.EmbeddedSubtitleOptions> embeddedSubtitleOptionsListFromJson(
  List? embeddedSubtitleOptions, [
  List<enums.EmbeddedSubtitleOptions>? defaultValue,
]) {
  if (embeddedSubtitleOptions == null) {
    return defaultValue ?? [];
  }

  return embeddedSubtitleOptions
      .map((e) => embeddedSubtitleOptionsFromJson(e.toString()))
      .toList();
}

List<enums.EmbeddedSubtitleOptions>?
    embeddedSubtitleOptionsNullableListFromJson(
  List? embeddedSubtitleOptions, [
  List<enums.EmbeddedSubtitleOptions>? defaultValue,
]) {
  if (embeddedSubtitleOptions == null) {
    return defaultValue;
  }

  return embeddedSubtitleOptions
      .map((e) => embeddedSubtitleOptionsFromJson(e.toString()))
      .toList();
}

String? encoderPresetNullableToJson(enums.EncoderPreset? encoderPreset) {
  return encoderPreset?.value;
}

String? encoderPresetToJson(enums.EncoderPreset encoderPreset) {
  return encoderPreset.value;
}

enums.EncoderPreset encoderPresetFromJson(
  Object? encoderPreset, [
  enums.EncoderPreset? defaultValue,
]) {
  return enums.EncoderPreset.values
          .firstWhereOrNull((e) => e.value == encoderPreset) ??
      defaultValue ??
      enums.EncoderPreset.swaggerGeneratedUnknown;
}

enums.EncoderPreset? encoderPresetNullableFromJson(
  Object? encoderPreset, [
  enums.EncoderPreset? defaultValue,
]) {
  if (encoderPreset == null) {
    return null;
  }
  return enums.EncoderPreset.values
          .firstWhereOrNull((e) => e.value == encoderPreset) ??
      defaultValue;
}

String encoderPresetExplodedListToJson(
    List<enums.EncoderPreset>? encoderPreset) {
  return encoderPreset?.map((e) => e.value!).join(',') ?? '';
}

List<String> encoderPresetListToJson(List<enums.EncoderPreset>? encoderPreset) {
  if (encoderPreset == null) {
    return [];
  }

  return encoderPreset.map((e) => e.value!).toList();
}

List<enums.EncoderPreset> encoderPresetListFromJson(
  List? encoderPreset, [
  List<enums.EncoderPreset>? defaultValue,
]) {
  if (encoderPreset == null) {
    return defaultValue ?? [];
  }

  return encoderPreset.map((e) => encoderPresetFromJson(e.toString())).toList();
}

List<enums.EncoderPreset>? encoderPresetNullableListFromJson(
  List? encoderPreset, [
  List<enums.EncoderPreset>? defaultValue,
]) {
  if (encoderPreset == null) {
    return defaultValue;
  }

  return encoderPreset.map((e) => encoderPresetFromJson(e.toString())).toList();
}

String? encodingContextNullableToJson(enums.EncodingContext? encodingContext) {
  return encodingContext?.value;
}

String? encodingContextToJson(enums.EncodingContext encodingContext) {
  return encodingContext.value;
}

enums.EncodingContext encodingContextFromJson(
  Object? encodingContext, [
  enums.EncodingContext? defaultValue,
]) {
  return enums.EncodingContext.values
          .firstWhereOrNull((e) => e.value == encodingContext) ??
      defaultValue ??
      enums.EncodingContext.swaggerGeneratedUnknown;
}

enums.EncodingContext? encodingContextNullableFromJson(
  Object? encodingContext, [
  enums.EncodingContext? defaultValue,
]) {
  if (encodingContext == null) {
    return null;
  }
  return enums.EncodingContext.values
          .firstWhereOrNull((e) => e.value == encodingContext) ??
      defaultValue;
}

String encodingContextExplodedListToJson(
    List<enums.EncodingContext>? encodingContext) {
  return encodingContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> encodingContextListToJson(
    List<enums.EncodingContext>? encodingContext) {
  if (encodingContext == null) {
    return [];
  }

  return encodingContext.map((e) => e.value!).toList();
}

List<enums.EncodingContext> encodingContextListFromJson(
  List? encodingContext, [
  List<enums.EncodingContext>? defaultValue,
]) {
  if (encodingContext == null) {
    return defaultValue ?? [];
  }

  return encodingContext
      .map((e) => encodingContextFromJson(e.toString()))
      .toList();
}

List<enums.EncodingContext>? encodingContextNullableListFromJson(
  List? encodingContext, [
  List<enums.EncodingContext>? defaultValue,
]) {
  if (encodingContext == null) {
    return defaultValue;
  }

  return encodingContext
      .map((e) => encodingContextFromJson(e.toString()))
      .toList();
}

String? externalIdMediaTypeNullableToJson(
    enums.ExternalIdMediaType? externalIdMediaType) {
  return externalIdMediaType?.value;
}

String? externalIdMediaTypeToJson(
    enums.ExternalIdMediaType externalIdMediaType) {
  return externalIdMediaType.value;
}

enums.ExternalIdMediaType externalIdMediaTypeFromJson(
  Object? externalIdMediaType, [
  enums.ExternalIdMediaType? defaultValue,
]) {
  return enums.ExternalIdMediaType.values
          .firstWhereOrNull((e) => e.value == externalIdMediaType) ??
      defaultValue ??
      enums.ExternalIdMediaType.swaggerGeneratedUnknown;
}

enums.ExternalIdMediaType? externalIdMediaTypeNullableFromJson(
  Object? externalIdMediaType, [
  enums.ExternalIdMediaType? defaultValue,
]) {
  if (externalIdMediaType == null) {
    return null;
  }
  return enums.ExternalIdMediaType.values
          .firstWhereOrNull((e) => e.value == externalIdMediaType) ??
      defaultValue;
}

String externalIdMediaTypeExplodedListToJson(
    List<enums.ExternalIdMediaType>? externalIdMediaType) {
  return externalIdMediaType?.map((e) => e.value!).join(',') ?? '';
}

List<String> externalIdMediaTypeListToJson(
    List<enums.ExternalIdMediaType>? externalIdMediaType) {
  if (externalIdMediaType == null) {
    return [];
  }

  return externalIdMediaType.map((e) => e.value!).toList();
}

List<enums.ExternalIdMediaType> externalIdMediaTypeListFromJson(
  List? externalIdMediaType, [
  List<enums.ExternalIdMediaType>? defaultValue,
]) {
  if (externalIdMediaType == null) {
    return defaultValue ?? [];
  }

  return externalIdMediaType
      .map((e) => externalIdMediaTypeFromJson(e.toString()))
      .toList();
}

List<enums.ExternalIdMediaType>? externalIdMediaTypeNullableListFromJson(
  List? externalIdMediaType, [
  List<enums.ExternalIdMediaType>? defaultValue,
]) {
  if (externalIdMediaType == null) {
    return defaultValue;
  }

  return externalIdMediaType
      .map((e) => externalIdMediaTypeFromJson(e.toString()))
      .toList();
}

String? extraTypeNullableToJson(enums.ExtraType? extraType) {
  return extraType?.value;
}

String? extraTypeToJson(enums.ExtraType extraType) {
  return extraType.value;
}

enums.ExtraType extraTypeFromJson(
  Object? extraType, [
  enums.ExtraType? defaultValue,
]) {
  return enums.ExtraType.values.firstWhereOrNull((e) => e.value == extraType) ??
      defaultValue ??
      enums.ExtraType.swaggerGeneratedUnknown;
}

enums.ExtraType? extraTypeNullableFromJson(
  Object? extraType, [
  enums.ExtraType? defaultValue,
]) {
  if (extraType == null) {
    return null;
  }
  return enums.ExtraType.values.firstWhereOrNull((e) => e.value == extraType) ??
      defaultValue;
}

String extraTypeExplodedListToJson(List<enums.ExtraType>? extraType) {
  return extraType?.map((e) => e.value!).join(',') ?? '';
}

List<String> extraTypeListToJson(List<enums.ExtraType>? extraType) {
  if (extraType == null) {
    return [];
  }

  return extraType.map((e) => e.value!).toList();
}

List<enums.ExtraType> extraTypeListFromJson(
  List? extraType, [
  List<enums.ExtraType>? defaultValue,
]) {
  if (extraType == null) {
    return defaultValue ?? [];
  }

  return extraType.map((e) => extraTypeFromJson(e.toString())).toList();
}

List<enums.ExtraType>? extraTypeNullableListFromJson(
  List? extraType, [
  List<enums.ExtraType>? defaultValue,
]) {
  if (extraType == null) {
    return defaultValue;
  }

  return extraType.map((e) => extraTypeFromJson(e.toString())).toList();
}

String? fileSystemEntryTypeNullableToJson(
    enums.FileSystemEntryType? fileSystemEntryType) {
  return fileSystemEntryType?.value;
}

String? fileSystemEntryTypeToJson(
    enums.FileSystemEntryType fileSystemEntryType) {
  return fileSystemEntryType.value;
}

enums.FileSystemEntryType fileSystemEntryTypeFromJson(
  Object? fileSystemEntryType, [
  enums.FileSystemEntryType? defaultValue,
]) {
  return enums.FileSystemEntryType.values
          .firstWhereOrNull((e) => e.value == fileSystemEntryType) ??
      defaultValue ??
      enums.FileSystemEntryType.swaggerGeneratedUnknown;
}

enums.FileSystemEntryType? fileSystemEntryTypeNullableFromJson(
  Object? fileSystemEntryType, [
  enums.FileSystemEntryType? defaultValue,
]) {
  if (fileSystemEntryType == null) {
    return null;
  }
  return enums.FileSystemEntryType.values
          .firstWhereOrNull((e) => e.value == fileSystemEntryType) ??
      defaultValue;
}

String fileSystemEntryTypeExplodedListToJson(
    List<enums.FileSystemEntryType>? fileSystemEntryType) {
  return fileSystemEntryType?.map((e) => e.value!).join(',') ?? '';
}

List<String> fileSystemEntryTypeListToJson(
    List<enums.FileSystemEntryType>? fileSystemEntryType) {
  if (fileSystemEntryType == null) {
    return [];
  }

  return fileSystemEntryType.map((e) => e.value!).toList();
}

List<enums.FileSystemEntryType> fileSystemEntryTypeListFromJson(
  List? fileSystemEntryType, [
  List<enums.FileSystemEntryType>? defaultValue,
]) {
  if (fileSystemEntryType == null) {
    return defaultValue ?? [];
  }

  return fileSystemEntryType
      .map((e) => fileSystemEntryTypeFromJson(e.toString()))
      .toList();
}

List<enums.FileSystemEntryType>? fileSystemEntryTypeNullableListFromJson(
  List? fileSystemEntryType, [
  List<enums.FileSystemEntryType>? defaultValue,
]) {
  if (fileSystemEntryType == null) {
    return defaultValue;
  }

  return fileSystemEntryType
      .map((e) => fileSystemEntryTypeFromJson(e.toString()))
      .toList();
}

String? forgotPasswordActionNullableToJson(
    enums.ForgotPasswordAction? forgotPasswordAction) {
  return forgotPasswordAction?.value;
}

String? forgotPasswordActionToJson(
    enums.ForgotPasswordAction forgotPasswordAction) {
  return forgotPasswordAction.value;
}

enums.ForgotPasswordAction forgotPasswordActionFromJson(
  Object? forgotPasswordAction, [
  enums.ForgotPasswordAction? defaultValue,
]) {
  return enums.ForgotPasswordAction.values
          .firstWhereOrNull((e) => e.value == forgotPasswordAction) ??
      defaultValue ??
      enums.ForgotPasswordAction.swaggerGeneratedUnknown;
}

enums.ForgotPasswordAction? forgotPasswordActionNullableFromJson(
  Object? forgotPasswordAction, [
  enums.ForgotPasswordAction? defaultValue,
]) {
  if (forgotPasswordAction == null) {
    return null;
  }
  return enums.ForgotPasswordAction.values
          .firstWhereOrNull((e) => e.value == forgotPasswordAction) ??
      defaultValue;
}

String forgotPasswordActionExplodedListToJson(
    List<enums.ForgotPasswordAction>? forgotPasswordAction) {
  return forgotPasswordAction?.map((e) => e.value!).join(',') ?? '';
}

List<String> forgotPasswordActionListToJson(
    List<enums.ForgotPasswordAction>? forgotPasswordAction) {
  if (forgotPasswordAction == null) {
    return [];
  }

  return forgotPasswordAction.map((e) => e.value!).toList();
}

List<enums.ForgotPasswordAction> forgotPasswordActionListFromJson(
  List? forgotPasswordAction, [
  List<enums.ForgotPasswordAction>? defaultValue,
]) {
  if (forgotPasswordAction == null) {
    return defaultValue ?? [];
  }

  return forgotPasswordAction
      .map((e) => forgotPasswordActionFromJson(e.toString()))
      .toList();
}

List<enums.ForgotPasswordAction>? forgotPasswordActionNullableListFromJson(
  List? forgotPasswordAction, [
  List<enums.ForgotPasswordAction>? defaultValue,
]) {
  if (forgotPasswordAction == null) {
    return defaultValue;
  }

  return forgotPasswordAction
      .map((e) => forgotPasswordActionFromJson(e.toString()))
      .toList();
}

String? generalCommandTypeNullableToJson(
    enums.GeneralCommandType? generalCommandType) {
  return generalCommandType?.value;
}

String? generalCommandTypeToJson(enums.GeneralCommandType generalCommandType) {
  return generalCommandType.value;
}

enums.GeneralCommandType generalCommandTypeFromJson(
  Object? generalCommandType, [
  enums.GeneralCommandType? defaultValue,
]) {
  return enums.GeneralCommandType.values
          .firstWhereOrNull((e) => e.value == generalCommandType) ??
      defaultValue ??
      enums.GeneralCommandType.swaggerGeneratedUnknown;
}

enums.GeneralCommandType? generalCommandTypeNullableFromJson(
  Object? generalCommandType, [
  enums.GeneralCommandType? defaultValue,
]) {
  if (generalCommandType == null) {
    return null;
  }
  return enums.GeneralCommandType.values
          .firstWhereOrNull((e) => e.value == generalCommandType) ??
      defaultValue;
}

String generalCommandTypeExplodedListToJson(
    List<enums.GeneralCommandType>? generalCommandType) {
  return generalCommandType?.map((e) => e.value!).join(',') ?? '';
}

List<String> generalCommandTypeListToJson(
    List<enums.GeneralCommandType>? generalCommandType) {
  if (generalCommandType == null) {
    return [];
  }

  return generalCommandType.map((e) => e.value!).toList();
}

List<enums.GeneralCommandType> generalCommandTypeListFromJson(
  List? generalCommandType, [
  List<enums.GeneralCommandType>? defaultValue,
]) {
  if (generalCommandType == null) {
    return defaultValue ?? [];
  }

  return generalCommandType
      .map((e) => generalCommandTypeFromJson(e.toString()))
      .toList();
}

List<enums.GeneralCommandType>? generalCommandTypeNullableListFromJson(
  List? generalCommandType, [
  List<enums.GeneralCommandType>? defaultValue,
]) {
  if (generalCommandType == null) {
    return defaultValue;
  }

  return generalCommandType
      .map((e) => generalCommandTypeFromJson(e.toString()))
      .toList();
}

String? groupQueueModeNullableToJson(enums.GroupQueueMode? groupQueueMode) {
  return groupQueueMode?.value;
}

String? groupQueueModeToJson(enums.GroupQueueMode groupQueueMode) {
  return groupQueueMode.value;
}

enums.GroupQueueMode groupQueueModeFromJson(
  Object? groupQueueMode, [
  enums.GroupQueueMode? defaultValue,
]) {
  return enums.GroupQueueMode.values
          .firstWhereOrNull((e) => e.value == groupQueueMode) ??
      defaultValue ??
      enums.GroupQueueMode.swaggerGeneratedUnknown;
}

enums.GroupQueueMode? groupQueueModeNullableFromJson(
  Object? groupQueueMode, [
  enums.GroupQueueMode? defaultValue,
]) {
  if (groupQueueMode == null) {
    return null;
  }
  return enums.GroupQueueMode.values
          .firstWhereOrNull((e) => e.value == groupQueueMode) ??
      defaultValue;
}

String groupQueueModeExplodedListToJson(
    List<enums.GroupQueueMode>? groupQueueMode) {
  return groupQueueMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> groupQueueModeListToJson(
    List<enums.GroupQueueMode>? groupQueueMode) {
  if (groupQueueMode == null) {
    return [];
  }

  return groupQueueMode.map((e) => e.value!).toList();
}

List<enums.GroupQueueMode> groupQueueModeListFromJson(
  List? groupQueueMode, [
  List<enums.GroupQueueMode>? defaultValue,
]) {
  if (groupQueueMode == null) {
    return defaultValue ?? [];
  }

  return groupQueueMode
      .map((e) => groupQueueModeFromJson(e.toString()))
      .toList();
}

List<enums.GroupQueueMode>? groupQueueModeNullableListFromJson(
  List? groupQueueMode, [
  List<enums.GroupQueueMode>? defaultValue,
]) {
  if (groupQueueMode == null) {
    return defaultValue;
  }

  return groupQueueMode
      .map((e) => groupQueueModeFromJson(e.toString()))
      .toList();
}

String? groupRepeatModeNullableToJson(enums.GroupRepeatMode? groupRepeatMode) {
  return groupRepeatMode?.value;
}

String? groupRepeatModeToJson(enums.GroupRepeatMode groupRepeatMode) {
  return groupRepeatMode.value;
}

enums.GroupRepeatMode groupRepeatModeFromJson(
  Object? groupRepeatMode, [
  enums.GroupRepeatMode? defaultValue,
]) {
  return enums.GroupRepeatMode.values
          .firstWhereOrNull((e) => e.value == groupRepeatMode) ??
      defaultValue ??
      enums.GroupRepeatMode.swaggerGeneratedUnknown;
}

enums.GroupRepeatMode? groupRepeatModeNullableFromJson(
  Object? groupRepeatMode, [
  enums.GroupRepeatMode? defaultValue,
]) {
  if (groupRepeatMode == null) {
    return null;
  }
  return enums.GroupRepeatMode.values
          .firstWhereOrNull((e) => e.value == groupRepeatMode) ??
      defaultValue;
}

String groupRepeatModeExplodedListToJson(
    List<enums.GroupRepeatMode>? groupRepeatMode) {
  return groupRepeatMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> groupRepeatModeListToJson(
    List<enums.GroupRepeatMode>? groupRepeatMode) {
  if (groupRepeatMode == null) {
    return [];
  }

  return groupRepeatMode.map((e) => e.value!).toList();
}

List<enums.GroupRepeatMode> groupRepeatModeListFromJson(
  List? groupRepeatMode, [
  List<enums.GroupRepeatMode>? defaultValue,
]) {
  if (groupRepeatMode == null) {
    return defaultValue ?? [];
  }

  return groupRepeatMode
      .map((e) => groupRepeatModeFromJson(e.toString()))
      .toList();
}

List<enums.GroupRepeatMode>? groupRepeatModeNullableListFromJson(
  List? groupRepeatMode, [
  List<enums.GroupRepeatMode>? defaultValue,
]) {
  if (groupRepeatMode == null) {
    return defaultValue;
  }

  return groupRepeatMode
      .map((e) => groupRepeatModeFromJson(e.toString()))
      .toList();
}

String? groupShuffleModeNullableToJson(
    enums.GroupShuffleMode? groupShuffleMode) {
  return groupShuffleMode?.value;
}

String? groupShuffleModeToJson(enums.GroupShuffleMode groupShuffleMode) {
  return groupShuffleMode.value;
}

enums.GroupShuffleMode groupShuffleModeFromJson(
  Object? groupShuffleMode, [
  enums.GroupShuffleMode? defaultValue,
]) {
  return enums.GroupShuffleMode.values
          .firstWhereOrNull((e) => e.value == groupShuffleMode) ??
      defaultValue ??
      enums.GroupShuffleMode.swaggerGeneratedUnknown;
}

enums.GroupShuffleMode? groupShuffleModeNullableFromJson(
  Object? groupShuffleMode, [
  enums.GroupShuffleMode? defaultValue,
]) {
  if (groupShuffleMode == null) {
    return null;
  }
  return enums.GroupShuffleMode.values
          .firstWhereOrNull((e) => e.value == groupShuffleMode) ??
      defaultValue;
}

String groupShuffleModeExplodedListToJson(
    List<enums.GroupShuffleMode>? groupShuffleMode) {
  return groupShuffleMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> groupShuffleModeListToJson(
    List<enums.GroupShuffleMode>? groupShuffleMode) {
  if (groupShuffleMode == null) {
    return [];
  }

  return groupShuffleMode.map((e) => e.value!).toList();
}

List<enums.GroupShuffleMode> groupShuffleModeListFromJson(
  List? groupShuffleMode, [
  List<enums.GroupShuffleMode>? defaultValue,
]) {
  if (groupShuffleMode == null) {
    return defaultValue ?? [];
  }

  return groupShuffleMode
      .map((e) => groupShuffleModeFromJson(e.toString()))
      .toList();
}

List<enums.GroupShuffleMode>? groupShuffleModeNullableListFromJson(
  List? groupShuffleMode, [
  List<enums.GroupShuffleMode>? defaultValue,
]) {
  if (groupShuffleMode == null) {
    return defaultValue;
  }

  return groupShuffleMode
      .map((e) => groupShuffleModeFromJson(e.toString()))
      .toList();
}

String? groupStateTypeNullableToJson(enums.GroupStateType? groupStateType) {
  return groupStateType?.value;
}

String? groupStateTypeToJson(enums.GroupStateType groupStateType) {
  return groupStateType.value;
}

enums.GroupStateType groupStateTypeFromJson(
  Object? groupStateType, [
  enums.GroupStateType? defaultValue,
]) {
  return enums.GroupStateType.values
          .firstWhereOrNull((e) => e.value == groupStateType) ??
      defaultValue ??
      enums.GroupStateType.swaggerGeneratedUnknown;
}

enums.GroupStateType? groupStateTypeNullableFromJson(
  Object? groupStateType, [
  enums.GroupStateType? defaultValue,
]) {
  if (groupStateType == null) {
    return null;
  }
  return enums.GroupStateType.values
          .firstWhereOrNull((e) => e.value == groupStateType) ??
      defaultValue;
}

String groupStateTypeExplodedListToJson(
    List<enums.GroupStateType>? groupStateType) {
  return groupStateType?.map((e) => e.value!).join(',') ?? '';
}

List<String> groupStateTypeListToJson(
    List<enums.GroupStateType>? groupStateType) {
  if (groupStateType == null) {
    return [];
  }

  return groupStateType.map((e) => e.value!).toList();
}

List<enums.GroupStateType> groupStateTypeListFromJson(
  List? groupStateType, [
  List<enums.GroupStateType>? defaultValue,
]) {
  if (groupStateType == null) {
    return defaultValue ?? [];
  }

  return groupStateType
      .map((e) => groupStateTypeFromJson(e.toString()))
      .toList();
}

List<enums.GroupStateType>? groupStateTypeNullableListFromJson(
  List? groupStateType, [
  List<enums.GroupStateType>? defaultValue,
]) {
  if (groupStateType == null) {
    return defaultValue;
  }

  return groupStateType
      .map((e) => groupStateTypeFromJson(e.toString()))
      .toList();
}

String? groupUpdateTypeNullableToJson(enums.GroupUpdateType? groupUpdateType) {
  return groupUpdateType?.value;
}

String? groupUpdateTypeToJson(enums.GroupUpdateType groupUpdateType) {
  return groupUpdateType.value;
}

enums.GroupUpdateType groupUpdateTypeFromJson(
  Object? groupUpdateType, [
  enums.GroupUpdateType? defaultValue,
]) {
  return enums.GroupUpdateType.values
          .firstWhereOrNull((e) => e.value == groupUpdateType) ??
      defaultValue ??
      enums.GroupUpdateType.swaggerGeneratedUnknown;
}

enums.GroupUpdateType? groupUpdateTypeNullableFromJson(
  Object? groupUpdateType, [
  enums.GroupUpdateType? defaultValue,
]) {
  if (groupUpdateType == null) {
    return null;
  }
  return enums.GroupUpdateType.values
          .firstWhereOrNull((e) => e.value == groupUpdateType) ??
      defaultValue;
}

String groupUpdateTypeExplodedListToJson(
    List<enums.GroupUpdateType>? groupUpdateType) {
  return groupUpdateType?.map((e) => e.value!).join(',') ?? '';
}

List<String> groupUpdateTypeListToJson(
    List<enums.GroupUpdateType>? groupUpdateType) {
  if (groupUpdateType == null) {
    return [];
  }

  return groupUpdateType.map((e) => e.value!).toList();
}

List<enums.GroupUpdateType> groupUpdateTypeListFromJson(
  List? groupUpdateType, [
  List<enums.GroupUpdateType>? defaultValue,
]) {
  if (groupUpdateType == null) {
    return defaultValue ?? [];
  }

  return groupUpdateType
      .map((e) => groupUpdateTypeFromJson(e.toString()))
      .toList();
}

List<enums.GroupUpdateType>? groupUpdateTypeNullableListFromJson(
  List? groupUpdateType, [
  List<enums.GroupUpdateType>? defaultValue,
]) {
  if (groupUpdateType == null) {
    return defaultValue;
  }

  return groupUpdateType
      .map((e) => groupUpdateTypeFromJson(e.toString()))
      .toList();
}

String? hardwareAccelerationTypeNullableToJson(
    enums.HardwareAccelerationType? hardwareAccelerationType) {
  return hardwareAccelerationType?.value;
}

String? hardwareAccelerationTypeToJson(
    enums.HardwareAccelerationType hardwareAccelerationType) {
  return hardwareAccelerationType.value;
}

enums.HardwareAccelerationType hardwareAccelerationTypeFromJson(
  Object? hardwareAccelerationType, [
  enums.HardwareAccelerationType? defaultValue,
]) {
  return enums.HardwareAccelerationType.values
          .firstWhereOrNull((e) => e.value == hardwareAccelerationType) ??
      defaultValue ??
      enums.HardwareAccelerationType.swaggerGeneratedUnknown;
}

enums.HardwareAccelerationType? hardwareAccelerationTypeNullableFromJson(
  Object? hardwareAccelerationType, [
  enums.HardwareAccelerationType? defaultValue,
]) {
  if (hardwareAccelerationType == null) {
    return null;
  }
  return enums.HardwareAccelerationType.values
          .firstWhereOrNull((e) => e.value == hardwareAccelerationType) ??
      defaultValue;
}

String hardwareAccelerationTypeExplodedListToJson(
    List<enums.HardwareAccelerationType>? hardwareAccelerationType) {
  return hardwareAccelerationType?.map((e) => e.value!).join(',') ?? '';
}

List<String> hardwareAccelerationTypeListToJson(
    List<enums.HardwareAccelerationType>? hardwareAccelerationType) {
  if (hardwareAccelerationType == null) {
    return [];
  }

  return hardwareAccelerationType.map((e) => e.value!).toList();
}

List<enums.HardwareAccelerationType> hardwareAccelerationTypeListFromJson(
  List? hardwareAccelerationType, [
  List<enums.HardwareAccelerationType>? defaultValue,
]) {
  if (hardwareAccelerationType == null) {
    return defaultValue ?? [];
  }

  return hardwareAccelerationType
      .map((e) => hardwareAccelerationTypeFromJson(e.toString()))
      .toList();
}

List<enums.HardwareAccelerationType>?
    hardwareAccelerationTypeNullableListFromJson(
  List? hardwareAccelerationType, [
  List<enums.HardwareAccelerationType>? defaultValue,
]) {
  if (hardwareAccelerationType == null) {
    return defaultValue;
  }

  return hardwareAccelerationType
      .map((e) => hardwareAccelerationTypeFromJson(e.toString()))
      .toList();
}

String? imageFormatNullableToJson(enums.ImageFormat? imageFormat) {
  return imageFormat?.value;
}

String? imageFormatToJson(enums.ImageFormat imageFormat) {
  return imageFormat.value;
}

enums.ImageFormat imageFormatFromJson(
  Object? imageFormat, [
  enums.ImageFormat? defaultValue,
]) {
  return enums.ImageFormat.values
          .firstWhereOrNull((e) => e.value == imageFormat) ??
      defaultValue ??
      enums.ImageFormat.swaggerGeneratedUnknown;
}

enums.ImageFormat? imageFormatNullableFromJson(
  Object? imageFormat, [
  enums.ImageFormat? defaultValue,
]) {
  if (imageFormat == null) {
    return null;
  }
  return enums.ImageFormat.values
          .firstWhereOrNull((e) => e.value == imageFormat) ??
      defaultValue;
}

String imageFormatExplodedListToJson(List<enums.ImageFormat>? imageFormat) {
  return imageFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageFormatListToJson(List<enums.ImageFormat>? imageFormat) {
  if (imageFormat == null) {
    return [];
  }

  return imageFormat.map((e) => e.value!).toList();
}

List<enums.ImageFormat> imageFormatListFromJson(
  List? imageFormat, [
  List<enums.ImageFormat>? defaultValue,
]) {
  if (imageFormat == null) {
    return defaultValue ?? [];
  }

  return imageFormat.map((e) => imageFormatFromJson(e.toString())).toList();
}

List<enums.ImageFormat>? imageFormatNullableListFromJson(
  List? imageFormat, [
  List<enums.ImageFormat>? defaultValue,
]) {
  if (imageFormat == null) {
    return defaultValue;
  }

  return imageFormat.map((e) => imageFormatFromJson(e.toString())).toList();
}

String? imageOrientationNullableToJson(
    enums.ImageOrientation? imageOrientation) {
  return imageOrientation?.value;
}

String? imageOrientationToJson(enums.ImageOrientation imageOrientation) {
  return imageOrientation.value;
}

enums.ImageOrientation imageOrientationFromJson(
  Object? imageOrientation, [
  enums.ImageOrientation? defaultValue,
]) {
  return enums.ImageOrientation.values
          .firstWhereOrNull((e) => e.value == imageOrientation) ??
      defaultValue ??
      enums.ImageOrientation.swaggerGeneratedUnknown;
}

enums.ImageOrientation? imageOrientationNullableFromJson(
  Object? imageOrientation, [
  enums.ImageOrientation? defaultValue,
]) {
  if (imageOrientation == null) {
    return null;
  }
  return enums.ImageOrientation.values
          .firstWhereOrNull((e) => e.value == imageOrientation) ??
      defaultValue;
}

String imageOrientationExplodedListToJson(
    List<enums.ImageOrientation>? imageOrientation) {
  return imageOrientation?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageOrientationListToJson(
    List<enums.ImageOrientation>? imageOrientation) {
  if (imageOrientation == null) {
    return [];
  }

  return imageOrientation.map((e) => e.value!).toList();
}

List<enums.ImageOrientation> imageOrientationListFromJson(
  List? imageOrientation, [
  List<enums.ImageOrientation>? defaultValue,
]) {
  if (imageOrientation == null) {
    return defaultValue ?? [];
  }

  return imageOrientation
      .map((e) => imageOrientationFromJson(e.toString()))
      .toList();
}

List<enums.ImageOrientation>? imageOrientationNullableListFromJson(
  List? imageOrientation, [
  List<enums.ImageOrientation>? defaultValue,
]) {
  if (imageOrientation == null) {
    return defaultValue;
  }

  return imageOrientation
      .map((e) => imageOrientationFromJson(e.toString()))
      .toList();
}

String? imageResolutionNullableToJson(enums.ImageResolution? imageResolution) {
  return imageResolution?.value;
}

String? imageResolutionToJson(enums.ImageResolution imageResolution) {
  return imageResolution.value;
}

enums.ImageResolution imageResolutionFromJson(
  Object? imageResolution, [
  enums.ImageResolution? defaultValue,
]) {
  return enums.ImageResolution.values
          .firstWhereOrNull((e) => e.value == imageResolution) ??
      defaultValue ??
      enums.ImageResolution.swaggerGeneratedUnknown;
}

enums.ImageResolution? imageResolutionNullableFromJson(
  Object? imageResolution, [
  enums.ImageResolution? defaultValue,
]) {
  if (imageResolution == null) {
    return null;
  }
  return enums.ImageResolution.values
          .firstWhereOrNull((e) => e.value == imageResolution) ??
      defaultValue;
}

String imageResolutionExplodedListToJson(
    List<enums.ImageResolution>? imageResolution) {
  return imageResolution?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageResolutionListToJson(
    List<enums.ImageResolution>? imageResolution) {
  if (imageResolution == null) {
    return [];
  }

  return imageResolution.map((e) => e.value!).toList();
}

List<enums.ImageResolution> imageResolutionListFromJson(
  List? imageResolution, [
  List<enums.ImageResolution>? defaultValue,
]) {
  if (imageResolution == null) {
    return defaultValue ?? [];
  }

  return imageResolution
      .map((e) => imageResolutionFromJson(e.toString()))
      .toList();
}

List<enums.ImageResolution>? imageResolutionNullableListFromJson(
  List? imageResolution, [
  List<enums.ImageResolution>? defaultValue,
]) {
  if (imageResolution == null) {
    return defaultValue;
  }

  return imageResolution
      .map((e) => imageResolutionFromJson(e.toString()))
      .toList();
}

String? imageSavingConventionNullableToJson(
    enums.ImageSavingConvention? imageSavingConvention) {
  return imageSavingConvention?.value;
}

String? imageSavingConventionToJson(
    enums.ImageSavingConvention imageSavingConvention) {
  return imageSavingConvention.value;
}

enums.ImageSavingConvention imageSavingConventionFromJson(
  Object? imageSavingConvention, [
  enums.ImageSavingConvention? defaultValue,
]) {
  return enums.ImageSavingConvention.values
          .firstWhereOrNull((e) => e.value == imageSavingConvention) ??
      defaultValue ??
      enums.ImageSavingConvention.swaggerGeneratedUnknown;
}

enums.ImageSavingConvention? imageSavingConventionNullableFromJson(
  Object? imageSavingConvention, [
  enums.ImageSavingConvention? defaultValue,
]) {
  if (imageSavingConvention == null) {
    return null;
  }
  return enums.ImageSavingConvention.values
          .firstWhereOrNull((e) => e.value == imageSavingConvention) ??
      defaultValue;
}

String imageSavingConventionExplodedListToJson(
    List<enums.ImageSavingConvention>? imageSavingConvention) {
  return imageSavingConvention?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageSavingConventionListToJson(
    List<enums.ImageSavingConvention>? imageSavingConvention) {
  if (imageSavingConvention == null) {
    return [];
  }

  return imageSavingConvention.map((e) => e.value!).toList();
}

List<enums.ImageSavingConvention> imageSavingConventionListFromJson(
  List? imageSavingConvention, [
  List<enums.ImageSavingConvention>? defaultValue,
]) {
  if (imageSavingConvention == null) {
    return defaultValue ?? [];
  }

  return imageSavingConvention
      .map((e) => imageSavingConventionFromJson(e.toString()))
      .toList();
}

List<enums.ImageSavingConvention>? imageSavingConventionNullableListFromJson(
  List? imageSavingConvention, [
  List<enums.ImageSavingConvention>? defaultValue,
]) {
  if (imageSavingConvention == null) {
    return defaultValue;
  }

  return imageSavingConvention
      .map((e) => imageSavingConventionFromJson(e.toString()))
      .toList();
}

String? imageTypeNullableToJson(enums.ImageType? imageType) {
  return imageType?.value;
}

String? imageTypeToJson(enums.ImageType imageType) {
  return imageType.value;
}

enums.ImageType imageTypeFromJson(
  Object? imageType, [
  enums.ImageType? defaultValue,
]) {
  return enums.ImageType.values.firstWhereOrNull((e) => e.value == imageType) ??
      defaultValue ??
      enums.ImageType.swaggerGeneratedUnknown;
}

enums.ImageType? imageTypeNullableFromJson(
  Object? imageType, [
  enums.ImageType? defaultValue,
]) {
  if (imageType == null) {
    return null;
  }
  return enums.ImageType.values.firstWhereOrNull((e) => e.value == imageType) ??
      defaultValue;
}

String imageTypeExplodedListToJson(List<enums.ImageType>? imageType) {
  return imageType?.map((e) => e.value!).join(',') ?? '';
}

List<String> imageTypeListToJson(List<enums.ImageType>? imageType) {
  if (imageType == null) {
    return [];
  }

  return imageType.map((e) => e.value!).toList();
}

List<enums.ImageType> imageTypeListFromJson(
  List? imageType, [
  List<enums.ImageType>? defaultValue,
]) {
  if (imageType == null) {
    return defaultValue ?? [];
  }

  return imageType.map((e) => imageTypeFromJson(e.toString())).toList();
}

List<enums.ImageType>? imageTypeNullableListFromJson(
  List? imageType, [
  List<enums.ImageType>? defaultValue,
]) {
  if (imageType == null) {
    return defaultValue;
  }

  return imageType.map((e) => imageTypeFromJson(e.toString())).toList();
}

String? isoTypeNullableToJson(enums.IsoType? isoType) {
  return isoType?.value;
}

String? isoTypeToJson(enums.IsoType isoType) {
  return isoType.value;
}

enums.IsoType isoTypeFromJson(
  Object? isoType, [
  enums.IsoType? defaultValue,
]) {
  return enums.IsoType.values.firstWhereOrNull((e) => e.value == isoType) ??
      defaultValue ??
      enums.IsoType.swaggerGeneratedUnknown;
}

enums.IsoType? isoTypeNullableFromJson(
  Object? isoType, [
  enums.IsoType? defaultValue,
]) {
  if (isoType == null) {
    return null;
  }
  return enums.IsoType.values.firstWhereOrNull((e) => e.value == isoType) ??
      defaultValue;
}

String isoTypeExplodedListToJson(List<enums.IsoType>? isoType) {
  return isoType?.map((e) => e.value!).join(',') ?? '';
}

List<String> isoTypeListToJson(List<enums.IsoType>? isoType) {
  if (isoType == null) {
    return [];
  }

  return isoType.map((e) => e.value!).toList();
}

List<enums.IsoType> isoTypeListFromJson(
  List? isoType, [
  List<enums.IsoType>? defaultValue,
]) {
  if (isoType == null) {
    return defaultValue ?? [];
  }

  return isoType.map((e) => isoTypeFromJson(e.toString())).toList();
}

List<enums.IsoType>? isoTypeNullableListFromJson(
  List? isoType, [
  List<enums.IsoType>? defaultValue,
]) {
  if (isoType == null) {
    return defaultValue;
  }

  return isoType.map((e) => isoTypeFromJson(e.toString())).toList();
}

String? itemFieldsNullableToJson(enums.ItemFields? itemFields) {
  return itemFields?.value;
}

String? itemFieldsToJson(enums.ItemFields itemFields) {
  return itemFields.value;
}

enums.ItemFields itemFieldsFromJson(
  Object? itemFields, [
  enums.ItemFields? defaultValue,
]) {
  return enums.ItemFields.values
          .firstWhereOrNull((e) => e.value == itemFields) ??
      defaultValue ??
      enums.ItemFields.swaggerGeneratedUnknown;
}

enums.ItemFields? itemFieldsNullableFromJson(
  Object? itemFields, [
  enums.ItemFields? defaultValue,
]) {
  if (itemFields == null) {
    return null;
  }
  return enums.ItemFields.values
          .firstWhereOrNull((e) => e.value == itemFields) ??
      defaultValue;
}

String itemFieldsExplodedListToJson(List<enums.ItemFields>? itemFields) {
  return itemFields?.map((e) => e.value!).join(',') ?? '';
}

List<String> itemFieldsListToJson(List<enums.ItemFields>? itemFields) {
  if (itemFields == null) {
    return [];
  }

  return itemFields.map((e) => e.value!).toList();
}

List<enums.ItemFields> itemFieldsListFromJson(
  List? itemFields, [
  List<enums.ItemFields>? defaultValue,
]) {
  if (itemFields == null) {
    return defaultValue ?? [];
  }

  return itemFields.map((e) => itemFieldsFromJson(e.toString())).toList();
}

List<enums.ItemFields>? itemFieldsNullableListFromJson(
  List? itemFields, [
  List<enums.ItemFields>? defaultValue,
]) {
  if (itemFields == null) {
    return defaultValue;
  }

  return itemFields.map((e) => itemFieldsFromJson(e.toString())).toList();
}

String? itemFilterNullableToJson(enums.ItemFilter? itemFilter) {
  return itemFilter?.value;
}

String? itemFilterToJson(enums.ItemFilter itemFilter) {
  return itemFilter.value;
}

enums.ItemFilter itemFilterFromJson(
  Object? itemFilter, [
  enums.ItemFilter? defaultValue,
]) {
  return enums.ItemFilter.values
          .firstWhereOrNull((e) => e.value == itemFilter) ??
      defaultValue ??
      enums.ItemFilter.swaggerGeneratedUnknown;
}

enums.ItemFilter? itemFilterNullableFromJson(
  Object? itemFilter, [
  enums.ItemFilter? defaultValue,
]) {
  if (itemFilter == null) {
    return null;
  }
  return enums.ItemFilter.values
          .firstWhereOrNull((e) => e.value == itemFilter) ??
      defaultValue;
}

String itemFilterExplodedListToJson(List<enums.ItemFilter>? itemFilter) {
  return itemFilter?.map((e) => e.value!).join(',') ?? '';
}

List<String> itemFilterListToJson(List<enums.ItemFilter>? itemFilter) {
  if (itemFilter == null) {
    return [];
  }

  return itemFilter.map((e) => e.value!).toList();
}

List<enums.ItemFilter> itemFilterListFromJson(
  List? itemFilter, [
  List<enums.ItemFilter>? defaultValue,
]) {
  if (itemFilter == null) {
    return defaultValue ?? [];
  }

  return itemFilter.map((e) => itemFilterFromJson(e.toString())).toList();
}

List<enums.ItemFilter>? itemFilterNullableListFromJson(
  List? itemFilter, [
  List<enums.ItemFilter>? defaultValue,
]) {
  if (itemFilter == null) {
    return defaultValue;
  }

  return itemFilter.map((e) => itemFilterFromJson(e.toString())).toList();
}

String? itemSortByNullableToJson(enums.ItemSortBy? itemSortBy) {
  return itemSortBy?.value;
}

String? itemSortByToJson(enums.ItemSortBy itemSortBy) {
  return itemSortBy.value;
}

enums.ItemSortBy itemSortByFromJson(
  Object? itemSortBy, [
  enums.ItemSortBy? defaultValue,
]) {
  return enums.ItemSortBy.values
          .firstWhereOrNull((e) => e.value == itemSortBy) ??
      defaultValue ??
      enums.ItemSortBy.swaggerGeneratedUnknown;
}

enums.ItemSortBy? itemSortByNullableFromJson(
  Object? itemSortBy, [
  enums.ItemSortBy? defaultValue,
]) {
  if (itemSortBy == null) {
    return null;
  }
  return enums.ItemSortBy.values
          .firstWhereOrNull((e) => e.value == itemSortBy) ??
      defaultValue;
}

String itemSortByExplodedListToJson(List<enums.ItemSortBy>? itemSortBy) {
  return itemSortBy?.map((e) => e.value!).join(',') ?? '';
}

List<String> itemSortByListToJson(List<enums.ItemSortBy>? itemSortBy) {
  if (itemSortBy == null) {
    return [];
  }

  return itemSortBy.map((e) => e.value!).toList();
}

List<enums.ItemSortBy> itemSortByListFromJson(
  List? itemSortBy, [
  List<enums.ItemSortBy>? defaultValue,
]) {
  if (itemSortBy == null) {
    return defaultValue ?? [];
  }

  return itemSortBy.map((e) => itemSortByFromJson(e.toString())).toList();
}

List<enums.ItemSortBy>? itemSortByNullableListFromJson(
  List? itemSortBy, [
  List<enums.ItemSortBy>? defaultValue,
]) {
  if (itemSortBy == null) {
    return defaultValue;
  }

  return itemSortBy.map((e) => itemSortByFromJson(e.toString())).toList();
}

String? keepUntilNullableToJson(enums.KeepUntil? keepUntil) {
  return keepUntil?.value;
}

String? keepUntilToJson(enums.KeepUntil keepUntil) {
  return keepUntil.value;
}

enums.KeepUntil keepUntilFromJson(
  Object? keepUntil, [
  enums.KeepUntil? defaultValue,
]) {
  return enums.KeepUntil.values.firstWhereOrNull((e) => e.value == keepUntil) ??
      defaultValue ??
      enums.KeepUntil.swaggerGeneratedUnknown;
}

enums.KeepUntil? keepUntilNullableFromJson(
  Object? keepUntil, [
  enums.KeepUntil? defaultValue,
]) {
  if (keepUntil == null) {
    return null;
  }
  return enums.KeepUntil.values.firstWhereOrNull((e) => e.value == keepUntil) ??
      defaultValue;
}

String keepUntilExplodedListToJson(List<enums.KeepUntil>? keepUntil) {
  return keepUntil?.map((e) => e.value!).join(',') ?? '';
}

List<String> keepUntilListToJson(List<enums.KeepUntil>? keepUntil) {
  if (keepUntil == null) {
    return [];
  }

  return keepUntil.map((e) => e.value!).toList();
}

List<enums.KeepUntil> keepUntilListFromJson(
  List? keepUntil, [
  List<enums.KeepUntil>? defaultValue,
]) {
  if (keepUntil == null) {
    return defaultValue ?? [];
  }

  return keepUntil.map((e) => keepUntilFromJson(e.toString())).toList();
}

List<enums.KeepUntil>? keepUntilNullableListFromJson(
  List? keepUntil, [
  List<enums.KeepUntil>? defaultValue,
]) {
  if (keepUntil == null) {
    return defaultValue;
  }

  return keepUntil.map((e) => keepUntilFromJson(e.toString())).toList();
}

String? liveTvServiceStatusNullableToJson(
    enums.LiveTvServiceStatus? liveTvServiceStatus) {
  return liveTvServiceStatus?.value;
}

String? liveTvServiceStatusToJson(
    enums.LiveTvServiceStatus liveTvServiceStatus) {
  return liveTvServiceStatus.value;
}

enums.LiveTvServiceStatus liveTvServiceStatusFromJson(
  Object? liveTvServiceStatus, [
  enums.LiveTvServiceStatus? defaultValue,
]) {
  return enums.LiveTvServiceStatus.values
          .firstWhereOrNull((e) => e.value == liveTvServiceStatus) ??
      defaultValue ??
      enums.LiveTvServiceStatus.swaggerGeneratedUnknown;
}

enums.LiveTvServiceStatus? liveTvServiceStatusNullableFromJson(
  Object? liveTvServiceStatus, [
  enums.LiveTvServiceStatus? defaultValue,
]) {
  if (liveTvServiceStatus == null) {
    return null;
  }
  return enums.LiveTvServiceStatus.values
          .firstWhereOrNull((e) => e.value == liveTvServiceStatus) ??
      defaultValue;
}

String liveTvServiceStatusExplodedListToJson(
    List<enums.LiveTvServiceStatus>? liveTvServiceStatus) {
  return liveTvServiceStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> liveTvServiceStatusListToJson(
    List<enums.LiveTvServiceStatus>? liveTvServiceStatus) {
  if (liveTvServiceStatus == null) {
    return [];
  }

  return liveTvServiceStatus.map((e) => e.value!).toList();
}

List<enums.LiveTvServiceStatus> liveTvServiceStatusListFromJson(
  List? liveTvServiceStatus, [
  List<enums.LiveTvServiceStatus>? defaultValue,
]) {
  if (liveTvServiceStatus == null) {
    return defaultValue ?? [];
  }

  return liveTvServiceStatus
      .map((e) => liveTvServiceStatusFromJson(e.toString()))
      .toList();
}

List<enums.LiveTvServiceStatus>? liveTvServiceStatusNullableListFromJson(
  List? liveTvServiceStatus, [
  List<enums.LiveTvServiceStatus>? defaultValue,
]) {
  if (liveTvServiceStatus == null) {
    return defaultValue;
  }

  return liveTvServiceStatus
      .map((e) => liveTvServiceStatusFromJson(e.toString()))
      .toList();
}

String? locationTypeNullableToJson(enums.LocationType? locationType) {
  return locationType?.value;
}

String? locationTypeToJson(enums.LocationType locationType) {
  return locationType.value;
}

enums.LocationType locationTypeFromJson(
  Object? locationType, [
  enums.LocationType? defaultValue,
]) {
  return enums.LocationType.values
          .firstWhereOrNull((e) => e.value == locationType) ??
      defaultValue ??
      enums.LocationType.swaggerGeneratedUnknown;
}

enums.LocationType? locationTypeNullableFromJson(
  Object? locationType, [
  enums.LocationType? defaultValue,
]) {
  if (locationType == null) {
    return null;
  }
  return enums.LocationType.values
          .firstWhereOrNull((e) => e.value == locationType) ??
      defaultValue;
}

String locationTypeExplodedListToJson(List<enums.LocationType>? locationType) {
  return locationType?.map((e) => e.value!).join(',') ?? '';
}

List<String> locationTypeListToJson(List<enums.LocationType>? locationType) {
  if (locationType == null) {
    return [];
  }

  return locationType.map((e) => e.value!).toList();
}

List<enums.LocationType> locationTypeListFromJson(
  List? locationType, [
  List<enums.LocationType>? defaultValue,
]) {
  if (locationType == null) {
    return defaultValue ?? [];
  }

  return locationType.map((e) => locationTypeFromJson(e.toString())).toList();
}

List<enums.LocationType>? locationTypeNullableListFromJson(
  List? locationType, [
  List<enums.LocationType>? defaultValue,
]) {
  if (locationType == null) {
    return defaultValue;
  }

  return locationType.map((e) => locationTypeFromJson(e.toString())).toList();
}

String? logLevelNullableToJson(enums.LogLevel? logLevel) {
  return logLevel?.value;
}

String? logLevelToJson(enums.LogLevel logLevel) {
  return logLevel.value;
}

enums.LogLevel logLevelFromJson(
  Object? logLevel, [
  enums.LogLevel? defaultValue,
]) {
  return enums.LogLevel.values.firstWhereOrNull((e) => e.value == logLevel) ??
      defaultValue ??
      enums.LogLevel.swaggerGeneratedUnknown;
}

enums.LogLevel? logLevelNullableFromJson(
  Object? logLevel, [
  enums.LogLevel? defaultValue,
]) {
  if (logLevel == null) {
    return null;
  }
  return enums.LogLevel.values.firstWhereOrNull((e) => e.value == logLevel) ??
      defaultValue;
}

String logLevelExplodedListToJson(List<enums.LogLevel>? logLevel) {
  return logLevel?.map((e) => e.value!).join(',') ?? '';
}

List<String> logLevelListToJson(List<enums.LogLevel>? logLevel) {
  if (logLevel == null) {
    return [];
  }

  return logLevel.map((e) => e.value!).toList();
}

List<enums.LogLevel> logLevelListFromJson(
  List? logLevel, [
  List<enums.LogLevel>? defaultValue,
]) {
  if (logLevel == null) {
    return defaultValue ?? [];
  }

  return logLevel.map((e) => logLevelFromJson(e.toString())).toList();
}

List<enums.LogLevel>? logLevelNullableListFromJson(
  List? logLevel, [
  List<enums.LogLevel>? defaultValue,
]) {
  if (logLevel == null) {
    return defaultValue;
  }

  return logLevel.map((e) => logLevelFromJson(e.toString())).toList();
}

String? mediaProtocolNullableToJson(enums.MediaProtocol? mediaProtocol) {
  return mediaProtocol?.value;
}

String? mediaProtocolToJson(enums.MediaProtocol mediaProtocol) {
  return mediaProtocol.value;
}

enums.MediaProtocol mediaProtocolFromJson(
  Object? mediaProtocol, [
  enums.MediaProtocol? defaultValue,
]) {
  return enums.MediaProtocol.values
          .firstWhereOrNull((e) => e.value == mediaProtocol) ??
      defaultValue ??
      enums.MediaProtocol.swaggerGeneratedUnknown;
}

enums.MediaProtocol? mediaProtocolNullableFromJson(
  Object? mediaProtocol, [
  enums.MediaProtocol? defaultValue,
]) {
  if (mediaProtocol == null) {
    return null;
  }
  return enums.MediaProtocol.values
          .firstWhereOrNull((e) => e.value == mediaProtocol) ??
      defaultValue;
}

String mediaProtocolExplodedListToJson(
    List<enums.MediaProtocol>? mediaProtocol) {
  return mediaProtocol?.map((e) => e.value!).join(',') ?? '';
}

List<String> mediaProtocolListToJson(List<enums.MediaProtocol>? mediaProtocol) {
  if (mediaProtocol == null) {
    return [];
  }

  return mediaProtocol.map((e) => e.value!).toList();
}

List<enums.MediaProtocol> mediaProtocolListFromJson(
  List? mediaProtocol, [
  List<enums.MediaProtocol>? defaultValue,
]) {
  if (mediaProtocol == null) {
    return defaultValue ?? [];
  }

  return mediaProtocol.map((e) => mediaProtocolFromJson(e.toString())).toList();
}

List<enums.MediaProtocol>? mediaProtocolNullableListFromJson(
  List? mediaProtocol, [
  List<enums.MediaProtocol>? defaultValue,
]) {
  if (mediaProtocol == null) {
    return defaultValue;
  }

  return mediaProtocol.map((e) => mediaProtocolFromJson(e.toString())).toList();
}

String? mediaSegmentTypeNullableToJson(
    enums.MediaSegmentType? mediaSegmentType) {
  return mediaSegmentType?.value;
}

String? mediaSegmentTypeToJson(enums.MediaSegmentType mediaSegmentType) {
  return mediaSegmentType.value;
}

enums.MediaSegmentType mediaSegmentTypeFromJson(
  Object? mediaSegmentType, [
  enums.MediaSegmentType? defaultValue,
]) {
  return enums.MediaSegmentType.values
          .firstWhereOrNull((e) => e.value == mediaSegmentType) ??
      defaultValue ??
      enums.MediaSegmentType.swaggerGeneratedUnknown;
}

enums.MediaSegmentType? mediaSegmentTypeNullableFromJson(
  Object? mediaSegmentType, [
  enums.MediaSegmentType? defaultValue,
]) {
  if (mediaSegmentType == null) {
    return null;
  }
  return enums.MediaSegmentType.values
          .firstWhereOrNull((e) => e.value == mediaSegmentType) ??
      defaultValue;
}

String mediaSegmentTypeExplodedListToJson(
    List<enums.MediaSegmentType>? mediaSegmentType) {
  return mediaSegmentType?.map((e) => e.value!).join(',') ?? '';
}

List<String> mediaSegmentTypeListToJson(
    List<enums.MediaSegmentType>? mediaSegmentType) {
  if (mediaSegmentType == null) {
    return [];
  }

  return mediaSegmentType.map((e) => e.value!).toList();
}

List<enums.MediaSegmentType> mediaSegmentTypeListFromJson(
  List? mediaSegmentType, [
  List<enums.MediaSegmentType>? defaultValue,
]) {
  if (mediaSegmentType == null) {
    return defaultValue ?? [];
  }

  return mediaSegmentType
      .map((e) => mediaSegmentTypeFromJson(e.toString()))
      .toList();
}

List<enums.MediaSegmentType>? mediaSegmentTypeNullableListFromJson(
  List? mediaSegmentType, [
  List<enums.MediaSegmentType>? defaultValue,
]) {
  if (mediaSegmentType == null) {
    return defaultValue;
  }

  return mediaSegmentType
      .map((e) => mediaSegmentTypeFromJson(e.toString()))
      .toList();
}

String? mediaSourceTypeNullableToJson(enums.MediaSourceType? mediaSourceType) {
  return mediaSourceType?.value;
}

String? mediaSourceTypeToJson(enums.MediaSourceType mediaSourceType) {
  return mediaSourceType.value;
}

enums.MediaSourceType mediaSourceTypeFromJson(
  Object? mediaSourceType, [
  enums.MediaSourceType? defaultValue,
]) {
  return enums.MediaSourceType.values
          .firstWhereOrNull((e) => e.value == mediaSourceType) ??
      defaultValue ??
      enums.MediaSourceType.swaggerGeneratedUnknown;
}

enums.MediaSourceType? mediaSourceTypeNullableFromJson(
  Object? mediaSourceType, [
  enums.MediaSourceType? defaultValue,
]) {
  if (mediaSourceType == null) {
    return null;
  }
  return enums.MediaSourceType.values
          .firstWhereOrNull((e) => e.value == mediaSourceType) ??
      defaultValue;
}

String mediaSourceTypeExplodedListToJson(
    List<enums.MediaSourceType>? mediaSourceType) {
  return mediaSourceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> mediaSourceTypeListToJson(
    List<enums.MediaSourceType>? mediaSourceType) {
  if (mediaSourceType == null) {
    return [];
  }

  return mediaSourceType.map((e) => e.value!).toList();
}

List<enums.MediaSourceType> mediaSourceTypeListFromJson(
  List? mediaSourceType, [
  List<enums.MediaSourceType>? defaultValue,
]) {
  if (mediaSourceType == null) {
    return defaultValue ?? [];
  }

  return mediaSourceType
      .map((e) => mediaSourceTypeFromJson(e.toString()))
      .toList();
}

List<enums.MediaSourceType>? mediaSourceTypeNullableListFromJson(
  List? mediaSourceType, [
  List<enums.MediaSourceType>? defaultValue,
]) {
  if (mediaSourceType == null) {
    return defaultValue;
  }

  return mediaSourceType
      .map((e) => mediaSourceTypeFromJson(e.toString()))
      .toList();
}

String? mediaStreamProtocolNullableToJson(
    enums.MediaStreamProtocol? mediaStreamProtocol) {
  return mediaStreamProtocol?.value;
}

String? mediaStreamProtocolToJson(
    enums.MediaStreamProtocol mediaStreamProtocol) {
  return mediaStreamProtocol.value;
}

enums.MediaStreamProtocol mediaStreamProtocolFromJson(
  Object? mediaStreamProtocol, [
  enums.MediaStreamProtocol? defaultValue,
]) {
  return enums.MediaStreamProtocol.values
          .firstWhereOrNull((e) => e.value == mediaStreamProtocol) ??
      defaultValue ??
      enums.MediaStreamProtocol.swaggerGeneratedUnknown;
}

enums.MediaStreamProtocol? mediaStreamProtocolNullableFromJson(
  Object? mediaStreamProtocol, [
  enums.MediaStreamProtocol? defaultValue,
]) {
  if (mediaStreamProtocol == null) {
    return null;
  }
  return enums.MediaStreamProtocol.values
          .firstWhereOrNull((e) => e.value == mediaStreamProtocol) ??
      defaultValue;
}

String mediaStreamProtocolExplodedListToJson(
    List<enums.MediaStreamProtocol>? mediaStreamProtocol) {
  return mediaStreamProtocol?.map((e) => e.value!).join(',') ?? '';
}

List<String> mediaStreamProtocolListToJson(
    List<enums.MediaStreamProtocol>? mediaStreamProtocol) {
  if (mediaStreamProtocol == null) {
    return [];
  }

  return mediaStreamProtocol.map((e) => e.value!).toList();
}

List<enums.MediaStreamProtocol> mediaStreamProtocolListFromJson(
  List? mediaStreamProtocol, [
  List<enums.MediaStreamProtocol>? defaultValue,
]) {
  if (mediaStreamProtocol == null) {
    return defaultValue ?? [];
  }

  return mediaStreamProtocol
      .map((e) => mediaStreamProtocolFromJson(e.toString()))
      .toList();
}

List<enums.MediaStreamProtocol>? mediaStreamProtocolNullableListFromJson(
  List? mediaStreamProtocol, [
  List<enums.MediaStreamProtocol>? defaultValue,
]) {
  if (mediaStreamProtocol == null) {
    return defaultValue;
  }

  return mediaStreamProtocol
      .map((e) => mediaStreamProtocolFromJson(e.toString()))
      .toList();
}

String? mediaStreamTypeNullableToJson(enums.MediaStreamType? mediaStreamType) {
  return mediaStreamType?.value;
}

String? mediaStreamTypeToJson(enums.MediaStreamType mediaStreamType) {
  return mediaStreamType.value;
}

enums.MediaStreamType mediaStreamTypeFromJson(
  Object? mediaStreamType, [
  enums.MediaStreamType? defaultValue,
]) {
  return enums.MediaStreamType.values
          .firstWhereOrNull((e) => e.value == mediaStreamType) ??
      defaultValue ??
      enums.MediaStreamType.swaggerGeneratedUnknown;
}

enums.MediaStreamType? mediaStreamTypeNullableFromJson(
  Object? mediaStreamType, [
  enums.MediaStreamType? defaultValue,
]) {
  if (mediaStreamType == null) {
    return null;
  }
  return enums.MediaStreamType.values
          .firstWhereOrNull((e) => e.value == mediaStreamType) ??
      defaultValue;
}

String mediaStreamTypeExplodedListToJson(
    List<enums.MediaStreamType>? mediaStreamType) {
  return mediaStreamType?.map((e) => e.value!).join(',') ?? '';
}

List<String> mediaStreamTypeListToJson(
    List<enums.MediaStreamType>? mediaStreamType) {
  if (mediaStreamType == null) {
    return [];
  }

  return mediaStreamType.map((e) => e.value!).toList();
}

List<enums.MediaStreamType> mediaStreamTypeListFromJson(
  List? mediaStreamType, [
  List<enums.MediaStreamType>? defaultValue,
]) {
  if (mediaStreamType == null) {
    return defaultValue ?? [];
  }

  return mediaStreamType
      .map((e) => mediaStreamTypeFromJson(e.toString()))
      .toList();
}

List<enums.MediaStreamType>? mediaStreamTypeNullableListFromJson(
  List? mediaStreamType, [
  List<enums.MediaStreamType>? defaultValue,
]) {
  if (mediaStreamType == null) {
    return defaultValue;
  }

  return mediaStreamType
      .map((e) => mediaStreamTypeFromJson(e.toString()))
      .toList();
}

String? mediaTypeNullableToJson(enums.MediaType? mediaType) {
  return mediaType?.value;
}

String? mediaTypeToJson(enums.MediaType mediaType) {
  return mediaType.value;
}

enums.MediaType mediaTypeFromJson(
  Object? mediaType, [
  enums.MediaType? defaultValue,
]) {
  return enums.MediaType.values.firstWhereOrNull((e) => e.value == mediaType) ??
      defaultValue ??
      enums.MediaType.swaggerGeneratedUnknown;
}

enums.MediaType? mediaTypeNullableFromJson(
  Object? mediaType, [
  enums.MediaType? defaultValue,
]) {
  if (mediaType == null) {
    return null;
  }
  return enums.MediaType.values.firstWhereOrNull((e) => e.value == mediaType) ??
      defaultValue;
}

String mediaTypeExplodedListToJson(List<enums.MediaType>? mediaType) {
  return mediaType?.map((e) => e.value!).join(',') ?? '';
}

List<String> mediaTypeListToJson(List<enums.MediaType>? mediaType) {
  if (mediaType == null) {
    return [];
  }

  return mediaType.map((e) => e.value!).toList();
}

List<enums.MediaType> mediaTypeListFromJson(
  List? mediaType, [
  List<enums.MediaType>? defaultValue,
]) {
  if (mediaType == null) {
    return defaultValue ?? [];
  }

  return mediaType.map((e) => mediaTypeFromJson(e.toString())).toList();
}

List<enums.MediaType>? mediaTypeNullableListFromJson(
  List? mediaType, [
  List<enums.MediaType>? defaultValue,
]) {
  if (mediaType == null) {
    return defaultValue;
  }

  return mediaType.map((e) => mediaTypeFromJson(e.toString())).toList();
}

String? metadataFieldNullableToJson(enums.MetadataField? metadataField) {
  return metadataField?.value;
}

String? metadataFieldToJson(enums.MetadataField metadataField) {
  return metadataField.value;
}

enums.MetadataField metadataFieldFromJson(
  Object? metadataField, [
  enums.MetadataField? defaultValue,
]) {
  return enums.MetadataField.values
          .firstWhereOrNull((e) => e.value == metadataField) ??
      defaultValue ??
      enums.MetadataField.swaggerGeneratedUnknown;
}

enums.MetadataField? metadataFieldNullableFromJson(
  Object? metadataField, [
  enums.MetadataField? defaultValue,
]) {
  if (metadataField == null) {
    return null;
  }
  return enums.MetadataField.values
          .firstWhereOrNull((e) => e.value == metadataField) ??
      defaultValue;
}

String metadataFieldExplodedListToJson(
    List<enums.MetadataField>? metadataField) {
  return metadataField?.map((e) => e.value!).join(',') ?? '';
}

List<String> metadataFieldListToJson(List<enums.MetadataField>? metadataField) {
  if (metadataField == null) {
    return [];
  }

  return metadataField.map((e) => e.value!).toList();
}

List<enums.MetadataField> metadataFieldListFromJson(
  List? metadataField, [
  List<enums.MetadataField>? defaultValue,
]) {
  if (metadataField == null) {
    return defaultValue ?? [];
  }

  return metadataField.map((e) => metadataFieldFromJson(e.toString())).toList();
}

List<enums.MetadataField>? metadataFieldNullableListFromJson(
  List? metadataField, [
  List<enums.MetadataField>? defaultValue,
]) {
  if (metadataField == null) {
    return defaultValue;
  }

  return metadataField.map((e) => metadataFieldFromJson(e.toString())).toList();
}

String? metadataRefreshModeNullableToJson(
    enums.MetadataRefreshMode? metadataRefreshMode) {
  return metadataRefreshMode?.value;
}

String? metadataRefreshModeToJson(
    enums.MetadataRefreshMode metadataRefreshMode) {
  return metadataRefreshMode.value;
}

enums.MetadataRefreshMode metadataRefreshModeFromJson(
  Object? metadataRefreshMode, [
  enums.MetadataRefreshMode? defaultValue,
]) {
  return enums.MetadataRefreshMode.values
          .firstWhereOrNull((e) => e.value == metadataRefreshMode) ??
      defaultValue ??
      enums.MetadataRefreshMode.swaggerGeneratedUnknown;
}

enums.MetadataRefreshMode? metadataRefreshModeNullableFromJson(
  Object? metadataRefreshMode, [
  enums.MetadataRefreshMode? defaultValue,
]) {
  if (metadataRefreshMode == null) {
    return null;
  }
  return enums.MetadataRefreshMode.values
          .firstWhereOrNull((e) => e.value == metadataRefreshMode) ??
      defaultValue;
}

String metadataRefreshModeExplodedListToJson(
    List<enums.MetadataRefreshMode>? metadataRefreshMode) {
  return metadataRefreshMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> metadataRefreshModeListToJson(
    List<enums.MetadataRefreshMode>? metadataRefreshMode) {
  if (metadataRefreshMode == null) {
    return [];
  }

  return metadataRefreshMode.map((e) => e.value!).toList();
}

List<enums.MetadataRefreshMode> metadataRefreshModeListFromJson(
  List? metadataRefreshMode, [
  List<enums.MetadataRefreshMode>? defaultValue,
]) {
  if (metadataRefreshMode == null) {
    return defaultValue ?? [];
  }

  return metadataRefreshMode
      .map((e) => metadataRefreshModeFromJson(e.toString()))
      .toList();
}

List<enums.MetadataRefreshMode>? metadataRefreshModeNullableListFromJson(
  List? metadataRefreshMode, [
  List<enums.MetadataRefreshMode>? defaultValue,
]) {
  if (metadataRefreshMode == null) {
    return defaultValue;
  }

  return metadataRefreshMode
      .map((e) => metadataRefreshModeFromJson(e.toString()))
      .toList();
}

String? personKindNullableToJson(enums.PersonKind? personKind) {
  return personKind?.value;
}

String? personKindToJson(enums.PersonKind personKind) {
  return personKind.value;
}

enums.PersonKind personKindFromJson(
  Object? personKind, [
  enums.PersonKind? defaultValue,
]) {
  return enums.PersonKind.values
          .firstWhereOrNull((e) => e.value == personKind) ??
      defaultValue ??
      enums.PersonKind.swaggerGeneratedUnknown;
}

enums.PersonKind? personKindNullableFromJson(
  Object? personKind, [
  enums.PersonKind? defaultValue,
]) {
  if (personKind == null) {
    return null;
  }
  return enums.PersonKind.values
          .firstWhereOrNull((e) => e.value == personKind) ??
      defaultValue;
}

String personKindExplodedListToJson(List<enums.PersonKind>? personKind) {
  return personKind?.map((e) => e.value!).join(',') ?? '';
}

List<String> personKindListToJson(List<enums.PersonKind>? personKind) {
  if (personKind == null) {
    return [];
  }

  return personKind.map((e) => e.value!).toList();
}

List<enums.PersonKind> personKindListFromJson(
  List? personKind, [
  List<enums.PersonKind>? defaultValue,
]) {
  if (personKind == null) {
    return defaultValue ?? [];
  }

  return personKind.map((e) => personKindFromJson(e.toString())).toList();
}

List<enums.PersonKind>? personKindNullableListFromJson(
  List? personKind, [
  List<enums.PersonKind>? defaultValue,
]) {
  if (personKind == null) {
    return defaultValue;
  }

  return personKind.map((e) => personKindFromJson(e.toString())).toList();
}

String? playAccessNullableToJson(enums.PlayAccess? playAccess) {
  return playAccess?.value;
}

String? playAccessToJson(enums.PlayAccess playAccess) {
  return playAccess.value;
}

enums.PlayAccess playAccessFromJson(
  Object? playAccess, [
  enums.PlayAccess? defaultValue,
]) {
  return enums.PlayAccess.values
          .firstWhereOrNull((e) => e.value == playAccess) ??
      defaultValue ??
      enums.PlayAccess.swaggerGeneratedUnknown;
}

enums.PlayAccess? playAccessNullableFromJson(
  Object? playAccess, [
  enums.PlayAccess? defaultValue,
]) {
  if (playAccess == null) {
    return null;
  }
  return enums.PlayAccess.values
          .firstWhereOrNull((e) => e.value == playAccess) ??
      defaultValue;
}

String playAccessExplodedListToJson(List<enums.PlayAccess>? playAccess) {
  return playAccess?.map((e) => e.value!).join(',') ?? '';
}

List<String> playAccessListToJson(List<enums.PlayAccess>? playAccess) {
  if (playAccess == null) {
    return [];
  }

  return playAccess.map((e) => e.value!).toList();
}

List<enums.PlayAccess> playAccessListFromJson(
  List? playAccess, [
  List<enums.PlayAccess>? defaultValue,
]) {
  if (playAccess == null) {
    return defaultValue ?? [];
  }

  return playAccess.map((e) => playAccessFromJson(e.toString())).toList();
}

List<enums.PlayAccess>? playAccessNullableListFromJson(
  List? playAccess, [
  List<enums.PlayAccess>? defaultValue,
]) {
  if (playAccess == null) {
    return defaultValue;
  }

  return playAccess.map((e) => playAccessFromJson(e.toString())).toList();
}

String? playbackErrorCodeNullableToJson(
    enums.PlaybackErrorCode? playbackErrorCode) {
  return playbackErrorCode?.value;
}

String? playbackErrorCodeToJson(enums.PlaybackErrorCode playbackErrorCode) {
  return playbackErrorCode.value;
}

enums.PlaybackErrorCode playbackErrorCodeFromJson(
  Object? playbackErrorCode, [
  enums.PlaybackErrorCode? defaultValue,
]) {
  return enums.PlaybackErrorCode.values
          .firstWhereOrNull((e) => e.value == playbackErrorCode) ??
      defaultValue ??
      enums.PlaybackErrorCode.swaggerGeneratedUnknown;
}

enums.PlaybackErrorCode? playbackErrorCodeNullableFromJson(
  Object? playbackErrorCode, [
  enums.PlaybackErrorCode? defaultValue,
]) {
  if (playbackErrorCode == null) {
    return null;
  }
  return enums.PlaybackErrorCode.values
          .firstWhereOrNull((e) => e.value == playbackErrorCode) ??
      defaultValue;
}

String playbackErrorCodeExplodedListToJson(
    List<enums.PlaybackErrorCode>? playbackErrorCode) {
  return playbackErrorCode?.map((e) => e.value!).join(',') ?? '';
}

List<String> playbackErrorCodeListToJson(
    List<enums.PlaybackErrorCode>? playbackErrorCode) {
  if (playbackErrorCode == null) {
    return [];
  }

  return playbackErrorCode.map((e) => e.value!).toList();
}

List<enums.PlaybackErrorCode> playbackErrorCodeListFromJson(
  List? playbackErrorCode, [
  List<enums.PlaybackErrorCode>? defaultValue,
]) {
  if (playbackErrorCode == null) {
    return defaultValue ?? [];
  }

  return playbackErrorCode
      .map((e) => playbackErrorCodeFromJson(e.toString()))
      .toList();
}

List<enums.PlaybackErrorCode>? playbackErrorCodeNullableListFromJson(
  List? playbackErrorCode, [
  List<enums.PlaybackErrorCode>? defaultValue,
]) {
  if (playbackErrorCode == null) {
    return defaultValue;
  }

  return playbackErrorCode
      .map((e) => playbackErrorCodeFromJson(e.toString()))
      .toList();
}

String? playbackOrderNullableToJson(enums.PlaybackOrder? playbackOrder) {
  return playbackOrder?.value;
}

String? playbackOrderToJson(enums.PlaybackOrder playbackOrder) {
  return playbackOrder.value;
}

enums.PlaybackOrder playbackOrderFromJson(
  Object? playbackOrder, [
  enums.PlaybackOrder? defaultValue,
]) {
  return enums.PlaybackOrder.values
          .firstWhereOrNull((e) => e.value == playbackOrder) ??
      defaultValue ??
      enums.PlaybackOrder.swaggerGeneratedUnknown;
}

enums.PlaybackOrder? playbackOrderNullableFromJson(
  Object? playbackOrder, [
  enums.PlaybackOrder? defaultValue,
]) {
  if (playbackOrder == null) {
    return null;
  }
  return enums.PlaybackOrder.values
          .firstWhereOrNull((e) => e.value == playbackOrder) ??
      defaultValue;
}

String playbackOrderExplodedListToJson(
    List<enums.PlaybackOrder>? playbackOrder) {
  return playbackOrder?.map((e) => e.value!).join(',') ?? '';
}

List<String> playbackOrderListToJson(List<enums.PlaybackOrder>? playbackOrder) {
  if (playbackOrder == null) {
    return [];
  }

  return playbackOrder.map((e) => e.value!).toList();
}

List<enums.PlaybackOrder> playbackOrderListFromJson(
  List? playbackOrder, [
  List<enums.PlaybackOrder>? defaultValue,
]) {
  if (playbackOrder == null) {
    return defaultValue ?? [];
  }

  return playbackOrder.map((e) => playbackOrderFromJson(e.toString())).toList();
}

List<enums.PlaybackOrder>? playbackOrderNullableListFromJson(
  List? playbackOrder, [
  List<enums.PlaybackOrder>? defaultValue,
]) {
  if (playbackOrder == null) {
    return defaultValue;
  }

  return playbackOrder.map((e) => playbackOrderFromJson(e.toString())).toList();
}

String? playbackRequestTypeNullableToJson(
    enums.PlaybackRequestType? playbackRequestType) {
  return playbackRequestType?.value;
}

String? playbackRequestTypeToJson(
    enums.PlaybackRequestType playbackRequestType) {
  return playbackRequestType.value;
}

enums.PlaybackRequestType playbackRequestTypeFromJson(
  Object? playbackRequestType, [
  enums.PlaybackRequestType? defaultValue,
]) {
  return enums.PlaybackRequestType.values
          .firstWhereOrNull((e) => e.value == playbackRequestType) ??
      defaultValue ??
      enums.PlaybackRequestType.swaggerGeneratedUnknown;
}

enums.PlaybackRequestType? playbackRequestTypeNullableFromJson(
  Object? playbackRequestType, [
  enums.PlaybackRequestType? defaultValue,
]) {
  if (playbackRequestType == null) {
    return null;
  }
  return enums.PlaybackRequestType.values
          .firstWhereOrNull((e) => e.value == playbackRequestType) ??
      defaultValue;
}

String playbackRequestTypeExplodedListToJson(
    List<enums.PlaybackRequestType>? playbackRequestType) {
  return playbackRequestType?.map((e) => e.value!).join(',') ?? '';
}

List<String> playbackRequestTypeListToJson(
    List<enums.PlaybackRequestType>? playbackRequestType) {
  if (playbackRequestType == null) {
    return [];
  }

  return playbackRequestType.map((e) => e.value!).toList();
}

List<enums.PlaybackRequestType> playbackRequestTypeListFromJson(
  List? playbackRequestType, [
  List<enums.PlaybackRequestType>? defaultValue,
]) {
  if (playbackRequestType == null) {
    return defaultValue ?? [];
  }

  return playbackRequestType
      .map((e) => playbackRequestTypeFromJson(e.toString()))
      .toList();
}

List<enums.PlaybackRequestType>? playbackRequestTypeNullableListFromJson(
  List? playbackRequestType, [
  List<enums.PlaybackRequestType>? defaultValue,
]) {
  if (playbackRequestType == null) {
    return defaultValue;
  }

  return playbackRequestType
      .map((e) => playbackRequestTypeFromJson(e.toString()))
      .toList();
}

String? playCommandNullableToJson(enums.PlayCommand? playCommand) {
  return playCommand?.value;
}

String? playCommandToJson(enums.PlayCommand playCommand) {
  return playCommand.value;
}

enums.PlayCommand playCommandFromJson(
  Object? playCommand, [
  enums.PlayCommand? defaultValue,
]) {
  return enums.PlayCommand.values
          .firstWhereOrNull((e) => e.value == playCommand) ??
      defaultValue ??
      enums.PlayCommand.swaggerGeneratedUnknown;
}

enums.PlayCommand? playCommandNullableFromJson(
  Object? playCommand, [
  enums.PlayCommand? defaultValue,
]) {
  if (playCommand == null) {
    return null;
  }
  return enums.PlayCommand.values
          .firstWhereOrNull((e) => e.value == playCommand) ??
      defaultValue;
}

String playCommandExplodedListToJson(List<enums.PlayCommand>? playCommand) {
  return playCommand?.map((e) => e.value!).join(',') ?? '';
}

List<String> playCommandListToJson(List<enums.PlayCommand>? playCommand) {
  if (playCommand == null) {
    return [];
  }

  return playCommand.map((e) => e.value!).toList();
}

List<enums.PlayCommand> playCommandListFromJson(
  List? playCommand, [
  List<enums.PlayCommand>? defaultValue,
]) {
  if (playCommand == null) {
    return defaultValue ?? [];
  }

  return playCommand.map((e) => playCommandFromJson(e.toString())).toList();
}

List<enums.PlayCommand>? playCommandNullableListFromJson(
  List? playCommand, [
  List<enums.PlayCommand>? defaultValue,
]) {
  if (playCommand == null) {
    return defaultValue;
  }

  return playCommand.map((e) => playCommandFromJson(e.toString())).toList();
}

String? playMethodNullableToJson(enums.PlayMethod? playMethod) {
  return playMethod?.value;
}

String? playMethodToJson(enums.PlayMethod playMethod) {
  return playMethod.value;
}

enums.PlayMethod playMethodFromJson(
  Object? playMethod, [
  enums.PlayMethod? defaultValue,
]) {
  return enums.PlayMethod.values
          .firstWhereOrNull((e) => e.value == playMethod) ??
      defaultValue ??
      enums.PlayMethod.swaggerGeneratedUnknown;
}

enums.PlayMethod? playMethodNullableFromJson(
  Object? playMethod, [
  enums.PlayMethod? defaultValue,
]) {
  if (playMethod == null) {
    return null;
  }
  return enums.PlayMethod.values
          .firstWhereOrNull((e) => e.value == playMethod) ??
      defaultValue;
}

String playMethodExplodedListToJson(List<enums.PlayMethod>? playMethod) {
  return playMethod?.map((e) => e.value!).join(',') ?? '';
}

List<String> playMethodListToJson(List<enums.PlayMethod>? playMethod) {
  if (playMethod == null) {
    return [];
  }

  return playMethod.map((e) => e.value!).toList();
}

List<enums.PlayMethod> playMethodListFromJson(
  List? playMethod, [
  List<enums.PlayMethod>? defaultValue,
]) {
  if (playMethod == null) {
    return defaultValue ?? [];
  }

  return playMethod.map((e) => playMethodFromJson(e.toString())).toList();
}

List<enums.PlayMethod>? playMethodNullableListFromJson(
  List? playMethod, [
  List<enums.PlayMethod>? defaultValue,
]) {
  if (playMethod == null) {
    return defaultValue;
  }

  return playMethod.map((e) => playMethodFromJson(e.toString())).toList();
}

String? playQueueUpdateReasonNullableToJson(
    enums.PlayQueueUpdateReason? playQueueUpdateReason) {
  return playQueueUpdateReason?.value;
}

String? playQueueUpdateReasonToJson(
    enums.PlayQueueUpdateReason playQueueUpdateReason) {
  return playQueueUpdateReason.value;
}

enums.PlayQueueUpdateReason playQueueUpdateReasonFromJson(
  Object? playQueueUpdateReason, [
  enums.PlayQueueUpdateReason? defaultValue,
]) {
  return enums.PlayQueueUpdateReason.values
          .firstWhereOrNull((e) => e.value == playQueueUpdateReason) ??
      defaultValue ??
      enums.PlayQueueUpdateReason.swaggerGeneratedUnknown;
}

enums.PlayQueueUpdateReason? playQueueUpdateReasonNullableFromJson(
  Object? playQueueUpdateReason, [
  enums.PlayQueueUpdateReason? defaultValue,
]) {
  if (playQueueUpdateReason == null) {
    return null;
  }
  return enums.PlayQueueUpdateReason.values
          .firstWhereOrNull((e) => e.value == playQueueUpdateReason) ??
      defaultValue;
}

String playQueueUpdateReasonExplodedListToJson(
    List<enums.PlayQueueUpdateReason>? playQueueUpdateReason) {
  return playQueueUpdateReason?.map((e) => e.value!).join(',') ?? '';
}

List<String> playQueueUpdateReasonListToJson(
    List<enums.PlayQueueUpdateReason>? playQueueUpdateReason) {
  if (playQueueUpdateReason == null) {
    return [];
  }

  return playQueueUpdateReason.map((e) => e.value!).toList();
}

List<enums.PlayQueueUpdateReason> playQueueUpdateReasonListFromJson(
  List? playQueueUpdateReason, [
  List<enums.PlayQueueUpdateReason>? defaultValue,
]) {
  if (playQueueUpdateReason == null) {
    return defaultValue ?? [];
  }

  return playQueueUpdateReason
      .map((e) => playQueueUpdateReasonFromJson(e.toString()))
      .toList();
}

List<enums.PlayQueueUpdateReason>? playQueueUpdateReasonNullableListFromJson(
  List? playQueueUpdateReason, [
  List<enums.PlayQueueUpdateReason>? defaultValue,
]) {
  if (playQueueUpdateReason == null) {
    return defaultValue;
  }

  return playQueueUpdateReason
      .map((e) => playQueueUpdateReasonFromJson(e.toString()))
      .toList();
}

String? playstateCommandNullableToJson(
    enums.PlaystateCommand? playstateCommand) {
  return playstateCommand?.value;
}

String? playstateCommandToJson(enums.PlaystateCommand playstateCommand) {
  return playstateCommand.value;
}

enums.PlaystateCommand playstateCommandFromJson(
  Object? playstateCommand, [
  enums.PlaystateCommand? defaultValue,
]) {
  return enums.PlaystateCommand.values
          .firstWhereOrNull((e) => e.value == playstateCommand) ??
      defaultValue ??
      enums.PlaystateCommand.swaggerGeneratedUnknown;
}

enums.PlaystateCommand? playstateCommandNullableFromJson(
  Object? playstateCommand, [
  enums.PlaystateCommand? defaultValue,
]) {
  if (playstateCommand == null) {
    return null;
  }
  return enums.PlaystateCommand.values
          .firstWhereOrNull((e) => e.value == playstateCommand) ??
      defaultValue;
}

String playstateCommandExplodedListToJson(
    List<enums.PlaystateCommand>? playstateCommand) {
  return playstateCommand?.map((e) => e.value!).join(',') ?? '';
}

List<String> playstateCommandListToJson(
    List<enums.PlaystateCommand>? playstateCommand) {
  if (playstateCommand == null) {
    return [];
  }

  return playstateCommand.map((e) => e.value!).toList();
}

List<enums.PlaystateCommand> playstateCommandListFromJson(
  List? playstateCommand, [
  List<enums.PlaystateCommand>? defaultValue,
]) {
  if (playstateCommand == null) {
    return defaultValue ?? [];
  }

  return playstateCommand
      .map((e) => playstateCommandFromJson(e.toString()))
      .toList();
}

List<enums.PlaystateCommand>? playstateCommandNullableListFromJson(
  List? playstateCommand, [
  List<enums.PlaystateCommand>? defaultValue,
]) {
  if (playstateCommand == null) {
    return defaultValue;
  }

  return playstateCommand
      .map((e) => playstateCommandFromJson(e.toString()))
      .toList();
}

String? pluginStatusNullableToJson(enums.PluginStatus? pluginStatus) {
  return pluginStatus?.value;
}

String? pluginStatusToJson(enums.PluginStatus pluginStatus) {
  return pluginStatus.value;
}

enums.PluginStatus pluginStatusFromJson(
  Object? pluginStatus, [
  enums.PluginStatus? defaultValue,
]) {
  return enums.PluginStatus.values
          .firstWhereOrNull((e) => e.value == pluginStatus) ??
      defaultValue ??
      enums.PluginStatus.swaggerGeneratedUnknown;
}

enums.PluginStatus? pluginStatusNullableFromJson(
  Object? pluginStatus, [
  enums.PluginStatus? defaultValue,
]) {
  if (pluginStatus == null) {
    return null;
  }
  return enums.PluginStatus.values
          .firstWhereOrNull((e) => e.value == pluginStatus) ??
      defaultValue;
}

String pluginStatusExplodedListToJson(List<enums.PluginStatus>? pluginStatus) {
  return pluginStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> pluginStatusListToJson(List<enums.PluginStatus>? pluginStatus) {
  if (pluginStatus == null) {
    return [];
  }

  return pluginStatus.map((e) => e.value!).toList();
}

List<enums.PluginStatus> pluginStatusListFromJson(
  List? pluginStatus, [
  List<enums.PluginStatus>? defaultValue,
]) {
  if (pluginStatus == null) {
    return defaultValue ?? [];
  }

  return pluginStatus.map((e) => pluginStatusFromJson(e.toString())).toList();
}

List<enums.PluginStatus>? pluginStatusNullableListFromJson(
  List? pluginStatus, [
  List<enums.PluginStatus>? defaultValue,
]) {
  if (pluginStatus == null) {
    return defaultValue;
  }

  return pluginStatus.map((e) => pluginStatusFromJson(e.toString())).toList();
}

String? processPriorityClassNullableToJson(
    enums.ProcessPriorityClass? processPriorityClass) {
  return processPriorityClass?.value;
}

String? processPriorityClassToJson(
    enums.ProcessPriorityClass processPriorityClass) {
  return processPriorityClass.value;
}

enums.ProcessPriorityClass processPriorityClassFromJson(
  Object? processPriorityClass, [
  enums.ProcessPriorityClass? defaultValue,
]) {
  return enums.ProcessPriorityClass.values
          .firstWhereOrNull((e) => e.value == processPriorityClass) ??
      defaultValue ??
      enums.ProcessPriorityClass.swaggerGeneratedUnknown;
}

enums.ProcessPriorityClass? processPriorityClassNullableFromJson(
  Object? processPriorityClass, [
  enums.ProcessPriorityClass? defaultValue,
]) {
  if (processPriorityClass == null) {
    return null;
  }
  return enums.ProcessPriorityClass.values
          .firstWhereOrNull((e) => e.value == processPriorityClass) ??
      defaultValue;
}

String processPriorityClassExplodedListToJson(
    List<enums.ProcessPriorityClass>? processPriorityClass) {
  return processPriorityClass?.map((e) => e.value!).join(',') ?? '';
}

List<String> processPriorityClassListToJson(
    List<enums.ProcessPriorityClass>? processPriorityClass) {
  if (processPriorityClass == null) {
    return [];
  }

  return processPriorityClass.map((e) => e.value!).toList();
}

List<enums.ProcessPriorityClass> processPriorityClassListFromJson(
  List? processPriorityClass, [
  List<enums.ProcessPriorityClass>? defaultValue,
]) {
  if (processPriorityClass == null) {
    return defaultValue ?? [];
  }

  return processPriorityClass
      .map((e) => processPriorityClassFromJson(e.toString()))
      .toList();
}

List<enums.ProcessPriorityClass>? processPriorityClassNullableListFromJson(
  List? processPriorityClass, [
  List<enums.ProcessPriorityClass>? defaultValue,
]) {
  if (processPriorityClass == null) {
    return defaultValue;
  }

  return processPriorityClass
      .map((e) => processPriorityClassFromJson(e.toString()))
      .toList();
}

String? profileConditionTypeNullableToJson(
    enums.ProfileConditionType? profileConditionType) {
  return profileConditionType?.value;
}

String? profileConditionTypeToJson(
    enums.ProfileConditionType profileConditionType) {
  return profileConditionType.value;
}

enums.ProfileConditionType profileConditionTypeFromJson(
  Object? profileConditionType, [
  enums.ProfileConditionType? defaultValue,
]) {
  return enums.ProfileConditionType.values
          .firstWhereOrNull((e) => e.value == profileConditionType) ??
      defaultValue ??
      enums.ProfileConditionType.swaggerGeneratedUnknown;
}

enums.ProfileConditionType? profileConditionTypeNullableFromJson(
  Object? profileConditionType, [
  enums.ProfileConditionType? defaultValue,
]) {
  if (profileConditionType == null) {
    return null;
  }
  return enums.ProfileConditionType.values
          .firstWhereOrNull((e) => e.value == profileConditionType) ??
      defaultValue;
}

String profileConditionTypeExplodedListToJson(
    List<enums.ProfileConditionType>? profileConditionType) {
  return profileConditionType?.map((e) => e.value!).join(',') ?? '';
}

List<String> profileConditionTypeListToJson(
    List<enums.ProfileConditionType>? profileConditionType) {
  if (profileConditionType == null) {
    return [];
  }

  return profileConditionType.map((e) => e.value!).toList();
}

List<enums.ProfileConditionType> profileConditionTypeListFromJson(
  List? profileConditionType, [
  List<enums.ProfileConditionType>? defaultValue,
]) {
  if (profileConditionType == null) {
    return defaultValue ?? [];
  }

  return profileConditionType
      .map((e) => profileConditionTypeFromJson(e.toString()))
      .toList();
}

List<enums.ProfileConditionType>? profileConditionTypeNullableListFromJson(
  List? profileConditionType, [
  List<enums.ProfileConditionType>? defaultValue,
]) {
  if (profileConditionType == null) {
    return defaultValue;
  }

  return profileConditionType
      .map((e) => profileConditionTypeFromJson(e.toString()))
      .toList();
}

String? profileConditionValueNullableToJson(
    enums.ProfileConditionValue? profileConditionValue) {
  return profileConditionValue?.value;
}

String? profileConditionValueToJson(
    enums.ProfileConditionValue profileConditionValue) {
  return profileConditionValue.value;
}

enums.ProfileConditionValue profileConditionValueFromJson(
  Object? profileConditionValue, [
  enums.ProfileConditionValue? defaultValue,
]) {
  return enums.ProfileConditionValue.values
          .firstWhereOrNull((e) => e.value == profileConditionValue) ??
      defaultValue ??
      enums.ProfileConditionValue.swaggerGeneratedUnknown;
}

enums.ProfileConditionValue? profileConditionValueNullableFromJson(
  Object? profileConditionValue, [
  enums.ProfileConditionValue? defaultValue,
]) {
  if (profileConditionValue == null) {
    return null;
  }
  return enums.ProfileConditionValue.values
          .firstWhereOrNull((e) => e.value == profileConditionValue) ??
      defaultValue;
}

String profileConditionValueExplodedListToJson(
    List<enums.ProfileConditionValue>? profileConditionValue) {
  return profileConditionValue?.map((e) => e.value!).join(',') ?? '';
}

List<String> profileConditionValueListToJson(
    List<enums.ProfileConditionValue>? profileConditionValue) {
  if (profileConditionValue == null) {
    return [];
  }

  return profileConditionValue.map((e) => e.value!).toList();
}

List<enums.ProfileConditionValue> profileConditionValueListFromJson(
  List? profileConditionValue, [
  List<enums.ProfileConditionValue>? defaultValue,
]) {
  if (profileConditionValue == null) {
    return defaultValue ?? [];
  }

  return profileConditionValue
      .map((e) => profileConditionValueFromJson(e.toString()))
      .toList();
}

List<enums.ProfileConditionValue>? profileConditionValueNullableListFromJson(
  List? profileConditionValue, [
  List<enums.ProfileConditionValue>? defaultValue,
]) {
  if (profileConditionValue == null) {
    return defaultValue;
  }

  return profileConditionValue
      .map((e) => profileConditionValueFromJson(e.toString()))
      .toList();
}

String? programAudioNullableToJson(enums.ProgramAudio? programAudio) {
  return programAudio?.value;
}

String? programAudioToJson(enums.ProgramAudio programAudio) {
  return programAudio.value;
}

enums.ProgramAudio programAudioFromJson(
  Object? programAudio, [
  enums.ProgramAudio? defaultValue,
]) {
  return enums.ProgramAudio.values
          .firstWhereOrNull((e) => e.value == programAudio) ??
      defaultValue ??
      enums.ProgramAudio.swaggerGeneratedUnknown;
}

enums.ProgramAudio? programAudioNullableFromJson(
  Object? programAudio, [
  enums.ProgramAudio? defaultValue,
]) {
  if (programAudio == null) {
    return null;
  }
  return enums.ProgramAudio.values
          .firstWhereOrNull((e) => e.value == programAudio) ??
      defaultValue;
}

String programAudioExplodedListToJson(List<enums.ProgramAudio>? programAudio) {
  return programAudio?.map((e) => e.value!).join(',') ?? '';
}

List<String> programAudioListToJson(List<enums.ProgramAudio>? programAudio) {
  if (programAudio == null) {
    return [];
  }

  return programAudio.map((e) => e.value!).toList();
}

List<enums.ProgramAudio> programAudioListFromJson(
  List? programAudio, [
  List<enums.ProgramAudio>? defaultValue,
]) {
  if (programAudio == null) {
    return defaultValue ?? [];
  }

  return programAudio.map((e) => programAudioFromJson(e.toString())).toList();
}

List<enums.ProgramAudio>? programAudioNullableListFromJson(
  List? programAudio, [
  List<enums.ProgramAudio>? defaultValue,
]) {
  if (programAudio == null) {
    return defaultValue;
  }

  return programAudio.map((e) => programAudioFromJson(e.toString())).toList();
}

String? ratingTypeNullableToJson(enums.RatingType? ratingType) {
  return ratingType?.value;
}

String? ratingTypeToJson(enums.RatingType ratingType) {
  return ratingType.value;
}

enums.RatingType ratingTypeFromJson(
  Object? ratingType, [
  enums.RatingType? defaultValue,
]) {
  return enums.RatingType.values
          .firstWhereOrNull((e) => e.value == ratingType) ??
      defaultValue ??
      enums.RatingType.swaggerGeneratedUnknown;
}

enums.RatingType? ratingTypeNullableFromJson(
  Object? ratingType, [
  enums.RatingType? defaultValue,
]) {
  if (ratingType == null) {
    return null;
  }
  return enums.RatingType.values
          .firstWhereOrNull((e) => e.value == ratingType) ??
      defaultValue;
}

String ratingTypeExplodedListToJson(List<enums.RatingType>? ratingType) {
  return ratingType?.map((e) => e.value!).join(',') ?? '';
}

List<String> ratingTypeListToJson(List<enums.RatingType>? ratingType) {
  if (ratingType == null) {
    return [];
  }

  return ratingType.map((e) => e.value!).toList();
}

List<enums.RatingType> ratingTypeListFromJson(
  List? ratingType, [
  List<enums.RatingType>? defaultValue,
]) {
  if (ratingType == null) {
    return defaultValue ?? [];
  }

  return ratingType.map((e) => ratingTypeFromJson(e.toString())).toList();
}

List<enums.RatingType>? ratingTypeNullableListFromJson(
  List? ratingType, [
  List<enums.RatingType>? defaultValue,
]) {
  if (ratingType == null) {
    return defaultValue;
  }

  return ratingType.map((e) => ratingTypeFromJson(e.toString())).toList();
}

String? recommendationTypeNullableToJson(
    enums.RecommendationType? recommendationType) {
  return recommendationType?.value;
}

String? recommendationTypeToJson(enums.RecommendationType recommendationType) {
  return recommendationType.value;
}

enums.RecommendationType recommendationTypeFromJson(
  Object? recommendationType, [
  enums.RecommendationType? defaultValue,
]) {
  return enums.RecommendationType.values
          .firstWhereOrNull((e) => e.value == recommendationType) ??
      defaultValue ??
      enums.RecommendationType.swaggerGeneratedUnknown;
}

enums.RecommendationType? recommendationTypeNullableFromJson(
  Object? recommendationType, [
  enums.RecommendationType? defaultValue,
]) {
  if (recommendationType == null) {
    return null;
  }
  return enums.RecommendationType.values
          .firstWhereOrNull((e) => e.value == recommendationType) ??
      defaultValue;
}

String recommendationTypeExplodedListToJson(
    List<enums.RecommendationType>? recommendationType) {
  return recommendationType?.map((e) => e.value!).join(',') ?? '';
}

List<String> recommendationTypeListToJson(
    List<enums.RecommendationType>? recommendationType) {
  if (recommendationType == null) {
    return [];
  }

  return recommendationType.map((e) => e.value!).toList();
}

List<enums.RecommendationType> recommendationTypeListFromJson(
  List? recommendationType, [
  List<enums.RecommendationType>? defaultValue,
]) {
  if (recommendationType == null) {
    return defaultValue ?? [];
  }

  return recommendationType
      .map((e) => recommendationTypeFromJson(e.toString()))
      .toList();
}

List<enums.RecommendationType>? recommendationTypeNullableListFromJson(
  List? recommendationType, [
  List<enums.RecommendationType>? defaultValue,
]) {
  if (recommendationType == null) {
    return defaultValue;
  }

  return recommendationType
      .map((e) => recommendationTypeFromJson(e.toString()))
      .toList();
}

String? recordingStatusNullableToJson(enums.RecordingStatus? recordingStatus) {
  return recordingStatus?.value;
}

String? recordingStatusToJson(enums.RecordingStatus recordingStatus) {
  return recordingStatus.value;
}

enums.RecordingStatus recordingStatusFromJson(
  Object? recordingStatus, [
  enums.RecordingStatus? defaultValue,
]) {
  return enums.RecordingStatus.values
          .firstWhereOrNull((e) => e.value == recordingStatus) ??
      defaultValue ??
      enums.RecordingStatus.swaggerGeneratedUnknown;
}

enums.RecordingStatus? recordingStatusNullableFromJson(
  Object? recordingStatus, [
  enums.RecordingStatus? defaultValue,
]) {
  if (recordingStatus == null) {
    return null;
  }
  return enums.RecordingStatus.values
          .firstWhereOrNull((e) => e.value == recordingStatus) ??
      defaultValue;
}

String recordingStatusExplodedListToJson(
    List<enums.RecordingStatus>? recordingStatus) {
  return recordingStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> recordingStatusListToJson(
    List<enums.RecordingStatus>? recordingStatus) {
  if (recordingStatus == null) {
    return [];
  }

  return recordingStatus.map((e) => e.value!).toList();
}

List<enums.RecordingStatus> recordingStatusListFromJson(
  List? recordingStatus, [
  List<enums.RecordingStatus>? defaultValue,
]) {
  if (recordingStatus == null) {
    return defaultValue ?? [];
  }

  return recordingStatus
      .map((e) => recordingStatusFromJson(e.toString()))
      .toList();
}

List<enums.RecordingStatus>? recordingStatusNullableListFromJson(
  List? recordingStatus, [
  List<enums.RecordingStatus>? defaultValue,
]) {
  if (recordingStatus == null) {
    return defaultValue;
  }

  return recordingStatus
      .map((e) => recordingStatusFromJson(e.toString()))
      .toList();
}

String? repeatModeNullableToJson(enums.RepeatMode? repeatMode) {
  return repeatMode?.value;
}

String? repeatModeToJson(enums.RepeatMode repeatMode) {
  return repeatMode.value;
}

enums.RepeatMode repeatModeFromJson(
  Object? repeatMode, [
  enums.RepeatMode? defaultValue,
]) {
  return enums.RepeatMode.values
          .firstWhereOrNull((e) => e.value == repeatMode) ??
      defaultValue ??
      enums.RepeatMode.swaggerGeneratedUnknown;
}

enums.RepeatMode? repeatModeNullableFromJson(
  Object? repeatMode, [
  enums.RepeatMode? defaultValue,
]) {
  if (repeatMode == null) {
    return null;
  }
  return enums.RepeatMode.values
          .firstWhereOrNull((e) => e.value == repeatMode) ??
      defaultValue;
}

String repeatModeExplodedListToJson(List<enums.RepeatMode>? repeatMode) {
  return repeatMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> repeatModeListToJson(List<enums.RepeatMode>? repeatMode) {
  if (repeatMode == null) {
    return [];
  }

  return repeatMode.map((e) => e.value!).toList();
}

List<enums.RepeatMode> repeatModeListFromJson(
  List? repeatMode, [
  List<enums.RepeatMode>? defaultValue,
]) {
  if (repeatMode == null) {
    return defaultValue ?? [];
  }

  return repeatMode.map((e) => repeatModeFromJson(e.toString())).toList();
}

List<enums.RepeatMode>? repeatModeNullableListFromJson(
  List? repeatMode, [
  List<enums.RepeatMode>? defaultValue,
]) {
  if (repeatMode == null) {
    return defaultValue;
  }

  return repeatMode.map((e) => repeatModeFromJson(e.toString())).toList();
}

String? scrollDirectionNullableToJson(enums.ScrollDirection? scrollDirection) {
  return scrollDirection?.value;
}

String? scrollDirectionToJson(enums.ScrollDirection scrollDirection) {
  return scrollDirection.value;
}

enums.ScrollDirection scrollDirectionFromJson(
  Object? scrollDirection, [
  enums.ScrollDirection? defaultValue,
]) {
  return enums.ScrollDirection.values
          .firstWhereOrNull((e) => e.value == scrollDirection) ??
      defaultValue ??
      enums.ScrollDirection.swaggerGeneratedUnknown;
}

enums.ScrollDirection? scrollDirectionNullableFromJson(
  Object? scrollDirection, [
  enums.ScrollDirection? defaultValue,
]) {
  if (scrollDirection == null) {
    return null;
  }
  return enums.ScrollDirection.values
          .firstWhereOrNull((e) => e.value == scrollDirection) ??
      defaultValue;
}

String scrollDirectionExplodedListToJson(
    List<enums.ScrollDirection>? scrollDirection) {
  return scrollDirection?.map((e) => e.value!).join(',') ?? '';
}

List<String> scrollDirectionListToJson(
    List<enums.ScrollDirection>? scrollDirection) {
  if (scrollDirection == null) {
    return [];
  }

  return scrollDirection.map((e) => e.value!).toList();
}

List<enums.ScrollDirection> scrollDirectionListFromJson(
  List? scrollDirection, [
  List<enums.ScrollDirection>? defaultValue,
]) {
  if (scrollDirection == null) {
    return defaultValue ?? [];
  }

  return scrollDirection
      .map((e) => scrollDirectionFromJson(e.toString()))
      .toList();
}

List<enums.ScrollDirection>? scrollDirectionNullableListFromJson(
  List? scrollDirection, [
  List<enums.ScrollDirection>? defaultValue,
]) {
  if (scrollDirection == null) {
    return defaultValue;
  }

  return scrollDirection
      .map((e) => scrollDirectionFromJson(e.toString()))
      .toList();
}

String? sendCommandTypeNullableToJson(enums.SendCommandType? sendCommandType) {
  return sendCommandType?.value;
}

String? sendCommandTypeToJson(enums.SendCommandType sendCommandType) {
  return sendCommandType.value;
}

enums.SendCommandType sendCommandTypeFromJson(
  Object? sendCommandType, [
  enums.SendCommandType? defaultValue,
]) {
  return enums.SendCommandType.values
          .firstWhereOrNull((e) => e.value == sendCommandType) ??
      defaultValue ??
      enums.SendCommandType.swaggerGeneratedUnknown;
}

enums.SendCommandType? sendCommandTypeNullableFromJson(
  Object? sendCommandType, [
  enums.SendCommandType? defaultValue,
]) {
  if (sendCommandType == null) {
    return null;
  }
  return enums.SendCommandType.values
          .firstWhereOrNull((e) => e.value == sendCommandType) ??
      defaultValue;
}

String sendCommandTypeExplodedListToJson(
    List<enums.SendCommandType>? sendCommandType) {
  return sendCommandType?.map((e) => e.value!).join(',') ?? '';
}

List<String> sendCommandTypeListToJson(
    List<enums.SendCommandType>? sendCommandType) {
  if (sendCommandType == null) {
    return [];
  }

  return sendCommandType.map((e) => e.value!).toList();
}

List<enums.SendCommandType> sendCommandTypeListFromJson(
  List? sendCommandType, [
  List<enums.SendCommandType>? defaultValue,
]) {
  if (sendCommandType == null) {
    return defaultValue ?? [];
  }

  return sendCommandType
      .map((e) => sendCommandTypeFromJson(e.toString()))
      .toList();
}

List<enums.SendCommandType>? sendCommandTypeNullableListFromJson(
  List? sendCommandType, [
  List<enums.SendCommandType>? defaultValue,
]) {
  if (sendCommandType == null) {
    return defaultValue;
  }

  return sendCommandType
      .map((e) => sendCommandTypeFromJson(e.toString()))
      .toList();
}

String? seriesStatusNullableToJson(enums.SeriesStatus? seriesStatus) {
  return seriesStatus?.value;
}

String? seriesStatusToJson(enums.SeriesStatus seriesStatus) {
  return seriesStatus.value;
}

enums.SeriesStatus seriesStatusFromJson(
  Object? seriesStatus, [
  enums.SeriesStatus? defaultValue,
]) {
  return enums.SeriesStatus.values
          .firstWhereOrNull((e) => e.value == seriesStatus) ??
      defaultValue ??
      enums.SeriesStatus.swaggerGeneratedUnknown;
}

enums.SeriesStatus? seriesStatusNullableFromJson(
  Object? seriesStatus, [
  enums.SeriesStatus? defaultValue,
]) {
  if (seriesStatus == null) {
    return null;
  }
  return enums.SeriesStatus.values
          .firstWhereOrNull((e) => e.value == seriesStatus) ??
      defaultValue;
}

String seriesStatusExplodedListToJson(List<enums.SeriesStatus>? seriesStatus) {
  return seriesStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> seriesStatusListToJson(List<enums.SeriesStatus>? seriesStatus) {
  if (seriesStatus == null) {
    return [];
  }

  return seriesStatus.map((e) => e.value!).toList();
}

List<enums.SeriesStatus> seriesStatusListFromJson(
  List? seriesStatus, [
  List<enums.SeriesStatus>? defaultValue,
]) {
  if (seriesStatus == null) {
    return defaultValue ?? [];
  }

  return seriesStatus.map((e) => seriesStatusFromJson(e.toString())).toList();
}

List<enums.SeriesStatus>? seriesStatusNullableListFromJson(
  List? seriesStatus, [
  List<enums.SeriesStatus>? defaultValue,
]) {
  if (seriesStatus == null) {
    return defaultValue;
  }

  return seriesStatus.map((e) => seriesStatusFromJson(e.toString())).toList();
}

String? sessionMessageTypeNullableToJson(
    enums.SessionMessageType? sessionMessageType) {
  return sessionMessageType?.value;
}

String? sessionMessageTypeToJson(enums.SessionMessageType sessionMessageType) {
  return sessionMessageType.value;
}

enums.SessionMessageType sessionMessageTypeFromJson(
  Object? sessionMessageType, [
  enums.SessionMessageType? defaultValue,
]) {
  return enums.SessionMessageType.values
          .firstWhereOrNull((e) => e.value == sessionMessageType) ??
      defaultValue ??
      enums.SessionMessageType.swaggerGeneratedUnknown;
}

enums.SessionMessageType? sessionMessageTypeNullableFromJson(
  Object? sessionMessageType, [
  enums.SessionMessageType? defaultValue,
]) {
  if (sessionMessageType == null) {
    return null;
  }
  return enums.SessionMessageType.values
          .firstWhereOrNull((e) => e.value == sessionMessageType) ??
      defaultValue;
}

String sessionMessageTypeExplodedListToJson(
    List<enums.SessionMessageType>? sessionMessageType) {
  return sessionMessageType?.map((e) => e.value!).join(',') ?? '';
}

List<String> sessionMessageTypeListToJson(
    List<enums.SessionMessageType>? sessionMessageType) {
  if (sessionMessageType == null) {
    return [];
  }

  return sessionMessageType.map((e) => e.value!).toList();
}

List<enums.SessionMessageType> sessionMessageTypeListFromJson(
  List? sessionMessageType, [
  List<enums.SessionMessageType>? defaultValue,
]) {
  if (sessionMessageType == null) {
    return defaultValue ?? [];
  }

  return sessionMessageType
      .map((e) => sessionMessageTypeFromJson(e.toString()))
      .toList();
}

List<enums.SessionMessageType>? sessionMessageTypeNullableListFromJson(
  List? sessionMessageType, [
  List<enums.SessionMessageType>? defaultValue,
]) {
  if (sessionMessageType == null) {
    return defaultValue;
  }

  return sessionMessageType
      .map((e) => sessionMessageTypeFromJson(e.toString()))
      .toList();
}

String? sortOrderNullableToJson(enums.SortOrder? sortOrder) {
  return sortOrder?.value;
}

String? sortOrderToJson(enums.SortOrder sortOrder) {
  return sortOrder.value;
}

enums.SortOrder sortOrderFromJson(
  Object? sortOrder, [
  enums.SortOrder? defaultValue,
]) {
  return enums.SortOrder.values.firstWhereOrNull((e) => e.value == sortOrder) ??
      defaultValue ??
      enums.SortOrder.swaggerGeneratedUnknown;
}

enums.SortOrder? sortOrderNullableFromJson(
  Object? sortOrder, [
  enums.SortOrder? defaultValue,
]) {
  if (sortOrder == null) {
    return null;
  }
  return enums.SortOrder.values.firstWhereOrNull((e) => e.value == sortOrder) ??
      defaultValue;
}

String sortOrderExplodedListToJson(List<enums.SortOrder>? sortOrder) {
  return sortOrder?.map((e) => e.value!).join(',') ?? '';
}

List<String> sortOrderListToJson(List<enums.SortOrder>? sortOrder) {
  if (sortOrder == null) {
    return [];
  }

  return sortOrder.map((e) => e.value!).toList();
}

List<enums.SortOrder> sortOrderListFromJson(
  List? sortOrder, [
  List<enums.SortOrder>? defaultValue,
]) {
  if (sortOrder == null) {
    return defaultValue ?? [];
  }

  return sortOrder.map((e) => sortOrderFromJson(e.toString())).toList();
}

List<enums.SortOrder>? sortOrderNullableListFromJson(
  List? sortOrder, [
  List<enums.SortOrder>? defaultValue,
]) {
  if (sortOrder == null) {
    return defaultValue;
  }

  return sortOrder.map((e) => sortOrderFromJson(e.toString())).toList();
}

String? subtitleDeliveryMethodNullableToJson(
    enums.SubtitleDeliveryMethod? subtitleDeliveryMethod) {
  return subtitleDeliveryMethod?.value;
}

String? subtitleDeliveryMethodToJson(
    enums.SubtitleDeliveryMethod subtitleDeliveryMethod) {
  return subtitleDeliveryMethod.value;
}

enums.SubtitleDeliveryMethod subtitleDeliveryMethodFromJson(
  Object? subtitleDeliveryMethod, [
  enums.SubtitleDeliveryMethod? defaultValue,
]) {
  return enums.SubtitleDeliveryMethod.values
          .firstWhereOrNull((e) => e.value == subtitleDeliveryMethod) ??
      defaultValue ??
      enums.SubtitleDeliveryMethod.swaggerGeneratedUnknown;
}

enums.SubtitleDeliveryMethod? subtitleDeliveryMethodNullableFromJson(
  Object? subtitleDeliveryMethod, [
  enums.SubtitleDeliveryMethod? defaultValue,
]) {
  if (subtitleDeliveryMethod == null) {
    return null;
  }
  return enums.SubtitleDeliveryMethod.values
          .firstWhereOrNull((e) => e.value == subtitleDeliveryMethod) ??
      defaultValue;
}

String subtitleDeliveryMethodExplodedListToJson(
    List<enums.SubtitleDeliveryMethod>? subtitleDeliveryMethod) {
  return subtitleDeliveryMethod?.map((e) => e.value!).join(',') ?? '';
}

List<String> subtitleDeliveryMethodListToJson(
    List<enums.SubtitleDeliveryMethod>? subtitleDeliveryMethod) {
  if (subtitleDeliveryMethod == null) {
    return [];
  }

  return subtitleDeliveryMethod.map((e) => e.value!).toList();
}

List<enums.SubtitleDeliveryMethod> subtitleDeliveryMethodListFromJson(
  List? subtitleDeliveryMethod, [
  List<enums.SubtitleDeliveryMethod>? defaultValue,
]) {
  if (subtitleDeliveryMethod == null) {
    return defaultValue ?? [];
  }

  return subtitleDeliveryMethod
      .map((e) => subtitleDeliveryMethodFromJson(e.toString()))
      .toList();
}

List<enums.SubtitleDeliveryMethod>? subtitleDeliveryMethodNullableListFromJson(
  List? subtitleDeliveryMethod, [
  List<enums.SubtitleDeliveryMethod>? defaultValue,
]) {
  if (subtitleDeliveryMethod == null) {
    return defaultValue;
  }

  return subtitleDeliveryMethod
      .map((e) => subtitleDeliveryMethodFromJson(e.toString()))
      .toList();
}

String? subtitlePlaybackModeNullableToJson(
    enums.SubtitlePlaybackMode? subtitlePlaybackMode) {
  return subtitlePlaybackMode?.value;
}

String? subtitlePlaybackModeToJson(
    enums.SubtitlePlaybackMode subtitlePlaybackMode) {
  return subtitlePlaybackMode.value;
}

enums.SubtitlePlaybackMode subtitlePlaybackModeFromJson(
  Object? subtitlePlaybackMode, [
  enums.SubtitlePlaybackMode? defaultValue,
]) {
  return enums.SubtitlePlaybackMode.values
          .firstWhereOrNull((e) => e.value == subtitlePlaybackMode) ??
      defaultValue ??
      enums.SubtitlePlaybackMode.swaggerGeneratedUnknown;
}

enums.SubtitlePlaybackMode? subtitlePlaybackModeNullableFromJson(
  Object? subtitlePlaybackMode, [
  enums.SubtitlePlaybackMode? defaultValue,
]) {
  if (subtitlePlaybackMode == null) {
    return null;
  }
  return enums.SubtitlePlaybackMode.values
          .firstWhereOrNull((e) => e.value == subtitlePlaybackMode) ??
      defaultValue;
}

String subtitlePlaybackModeExplodedListToJson(
    List<enums.SubtitlePlaybackMode>? subtitlePlaybackMode) {
  return subtitlePlaybackMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> subtitlePlaybackModeListToJson(
    List<enums.SubtitlePlaybackMode>? subtitlePlaybackMode) {
  if (subtitlePlaybackMode == null) {
    return [];
  }

  return subtitlePlaybackMode.map((e) => e.value!).toList();
}

List<enums.SubtitlePlaybackMode> subtitlePlaybackModeListFromJson(
  List? subtitlePlaybackMode, [
  List<enums.SubtitlePlaybackMode>? defaultValue,
]) {
  if (subtitlePlaybackMode == null) {
    return defaultValue ?? [];
  }

  return subtitlePlaybackMode
      .map((e) => subtitlePlaybackModeFromJson(e.toString()))
      .toList();
}

List<enums.SubtitlePlaybackMode>? subtitlePlaybackModeNullableListFromJson(
  List? subtitlePlaybackMode, [
  List<enums.SubtitlePlaybackMode>? defaultValue,
]) {
  if (subtitlePlaybackMode == null) {
    return defaultValue;
  }

  return subtitlePlaybackMode
      .map((e) => subtitlePlaybackModeFromJson(e.toString()))
      .toList();
}

String? syncPlayUserAccessTypeNullableToJson(
    enums.SyncPlayUserAccessType? syncPlayUserAccessType) {
  return syncPlayUserAccessType?.value;
}

String? syncPlayUserAccessTypeToJson(
    enums.SyncPlayUserAccessType syncPlayUserAccessType) {
  return syncPlayUserAccessType.value;
}

enums.SyncPlayUserAccessType syncPlayUserAccessTypeFromJson(
  Object? syncPlayUserAccessType, [
  enums.SyncPlayUserAccessType? defaultValue,
]) {
  return enums.SyncPlayUserAccessType.values
          .firstWhereOrNull((e) => e.value == syncPlayUserAccessType) ??
      defaultValue ??
      enums.SyncPlayUserAccessType.swaggerGeneratedUnknown;
}

enums.SyncPlayUserAccessType? syncPlayUserAccessTypeNullableFromJson(
  Object? syncPlayUserAccessType, [
  enums.SyncPlayUserAccessType? defaultValue,
]) {
  if (syncPlayUserAccessType == null) {
    return null;
  }
  return enums.SyncPlayUserAccessType.values
          .firstWhereOrNull((e) => e.value == syncPlayUserAccessType) ??
      defaultValue;
}

String syncPlayUserAccessTypeExplodedListToJson(
    List<enums.SyncPlayUserAccessType>? syncPlayUserAccessType) {
  return syncPlayUserAccessType?.map((e) => e.value!).join(',') ?? '';
}

List<String> syncPlayUserAccessTypeListToJson(
    List<enums.SyncPlayUserAccessType>? syncPlayUserAccessType) {
  if (syncPlayUserAccessType == null) {
    return [];
  }

  return syncPlayUserAccessType.map((e) => e.value!).toList();
}

List<enums.SyncPlayUserAccessType> syncPlayUserAccessTypeListFromJson(
  List? syncPlayUserAccessType, [
  List<enums.SyncPlayUserAccessType>? defaultValue,
]) {
  if (syncPlayUserAccessType == null) {
    return defaultValue ?? [];
  }

  return syncPlayUserAccessType
      .map((e) => syncPlayUserAccessTypeFromJson(e.toString()))
      .toList();
}

List<enums.SyncPlayUserAccessType>? syncPlayUserAccessTypeNullableListFromJson(
  List? syncPlayUserAccessType, [
  List<enums.SyncPlayUserAccessType>? defaultValue,
]) {
  if (syncPlayUserAccessType == null) {
    return defaultValue;
  }

  return syncPlayUserAccessType
      .map((e) => syncPlayUserAccessTypeFromJson(e.toString()))
      .toList();
}

String? taskCompletionStatusNullableToJson(
    enums.TaskCompletionStatus? taskCompletionStatus) {
  return taskCompletionStatus?.value;
}

String? taskCompletionStatusToJson(
    enums.TaskCompletionStatus taskCompletionStatus) {
  return taskCompletionStatus.value;
}

enums.TaskCompletionStatus taskCompletionStatusFromJson(
  Object? taskCompletionStatus, [
  enums.TaskCompletionStatus? defaultValue,
]) {
  return enums.TaskCompletionStatus.values
          .firstWhereOrNull((e) => e.value == taskCompletionStatus) ??
      defaultValue ??
      enums.TaskCompletionStatus.swaggerGeneratedUnknown;
}

enums.TaskCompletionStatus? taskCompletionStatusNullableFromJson(
  Object? taskCompletionStatus, [
  enums.TaskCompletionStatus? defaultValue,
]) {
  if (taskCompletionStatus == null) {
    return null;
  }
  return enums.TaskCompletionStatus.values
          .firstWhereOrNull((e) => e.value == taskCompletionStatus) ??
      defaultValue;
}

String taskCompletionStatusExplodedListToJson(
    List<enums.TaskCompletionStatus>? taskCompletionStatus) {
  return taskCompletionStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> taskCompletionStatusListToJson(
    List<enums.TaskCompletionStatus>? taskCompletionStatus) {
  if (taskCompletionStatus == null) {
    return [];
  }

  return taskCompletionStatus.map((e) => e.value!).toList();
}

List<enums.TaskCompletionStatus> taskCompletionStatusListFromJson(
  List? taskCompletionStatus, [
  List<enums.TaskCompletionStatus>? defaultValue,
]) {
  if (taskCompletionStatus == null) {
    return defaultValue ?? [];
  }

  return taskCompletionStatus
      .map((e) => taskCompletionStatusFromJson(e.toString()))
      .toList();
}

List<enums.TaskCompletionStatus>? taskCompletionStatusNullableListFromJson(
  List? taskCompletionStatus, [
  List<enums.TaskCompletionStatus>? defaultValue,
]) {
  if (taskCompletionStatus == null) {
    return defaultValue;
  }

  return taskCompletionStatus
      .map((e) => taskCompletionStatusFromJson(e.toString()))
      .toList();
}

String? taskStateNullableToJson(enums.TaskState? taskState) {
  return taskState?.value;
}

String? taskStateToJson(enums.TaskState taskState) {
  return taskState.value;
}

enums.TaskState taskStateFromJson(
  Object? taskState, [
  enums.TaskState? defaultValue,
]) {
  return enums.TaskState.values.firstWhereOrNull((e) => e.value == taskState) ??
      defaultValue ??
      enums.TaskState.swaggerGeneratedUnknown;
}

enums.TaskState? taskStateNullableFromJson(
  Object? taskState, [
  enums.TaskState? defaultValue,
]) {
  if (taskState == null) {
    return null;
  }
  return enums.TaskState.values.firstWhereOrNull((e) => e.value == taskState) ??
      defaultValue;
}

String taskStateExplodedListToJson(List<enums.TaskState>? taskState) {
  return taskState?.map((e) => e.value!).join(',') ?? '';
}

List<String> taskStateListToJson(List<enums.TaskState>? taskState) {
  if (taskState == null) {
    return [];
  }

  return taskState.map((e) => e.value!).toList();
}

List<enums.TaskState> taskStateListFromJson(
  List? taskState, [
  List<enums.TaskState>? defaultValue,
]) {
  if (taskState == null) {
    return defaultValue ?? [];
  }

  return taskState.map((e) => taskStateFromJson(e.toString())).toList();
}

List<enums.TaskState>? taskStateNullableListFromJson(
  List? taskState, [
  List<enums.TaskState>? defaultValue,
]) {
  if (taskState == null) {
    return defaultValue;
  }

  return taskState.map((e) => taskStateFromJson(e.toString())).toList();
}

String? tonemappingAlgorithmNullableToJson(
    enums.TonemappingAlgorithm? tonemappingAlgorithm) {
  return tonemappingAlgorithm?.value;
}

String? tonemappingAlgorithmToJson(
    enums.TonemappingAlgorithm tonemappingAlgorithm) {
  return tonemappingAlgorithm.value;
}

enums.TonemappingAlgorithm tonemappingAlgorithmFromJson(
  Object? tonemappingAlgorithm, [
  enums.TonemappingAlgorithm? defaultValue,
]) {
  return enums.TonemappingAlgorithm.values
          .firstWhereOrNull((e) => e.value == tonemappingAlgorithm) ??
      defaultValue ??
      enums.TonemappingAlgorithm.swaggerGeneratedUnknown;
}

enums.TonemappingAlgorithm? tonemappingAlgorithmNullableFromJson(
  Object? tonemappingAlgorithm, [
  enums.TonemappingAlgorithm? defaultValue,
]) {
  if (tonemappingAlgorithm == null) {
    return null;
  }
  return enums.TonemappingAlgorithm.values
          .firstWhereOrNull((e) => e.value == tonemappingAlgorithm) ??
      defaultValue;
}

String tonemappingAlgorithmExplodedListToJson(
    List<enums.TonemappingAlgorithm>? tonemappingAlgorithm) {
  return tonemappingAlgorithm?.map((e) => e.value!).join(',') ?? '';
}

List<String> tonemappingAlgorithmListToJson(
    List<enums.TonemappingAlgorithm>? tonemappingAlgorithm) {
  if (tonemappingAlgorithm == null) {
    return [];
  }

  return tonemappingAlgorithm.map((e) => e.value!).toList();
}

List<enums.TonemappingAlgorithm> tonemappingAlgorithmListFromJson(
  List? tonemappingAlgorithm, [
  List<enums.TonemappingAlgorithm>? defaultValue,
]) {
  if (tonemappingAlgorithm == null) {
    return defaultValue ?? [];
  }

  return tonemappingAlgorithm
      .map((e) => tonemappingAlgorithmFromJson(e.toString()))
      .toList();
}

List<enums.TonemappingAlgorithm>? tonemappingAlgorithmNullableListFromJson(
  List? tonemappingAlgorithm, [
  List<enums.TonemappingAlgorithm>? defaultValue,
]) {
  if (tonemappingAlgorithm == null) {
    return defaultValue;
  }

  return tonemappingAlgorithm
      .map((e) => tonemappingAlgorithmFromJson(e.toString()))
      .toList();
}

String? tonemappingModeNullableToJson(enums.TonemappingMode? tonemappingMode) {
  return tonemappingMode?.value;
}

String? tonemappingModeToJson(enums.TonemappingMode tonemappingMode) {
  return tonemappingMode.value;
}

enums.TonemappingMode tonemappingModeFromJson(
  Object? tonemappingMode, [
  enums.TonemappingMode? defaultValue,
]) {
  return enums.TonemappingMode.values
          .firstWhereOrNull((e) => e.value == tonemappingMode) ??
      defaultValue ??
      enums.TonemappingMode.swaggerGeneratedUnknown;
}

enums.TonemappingMode? tonemappingModeNullableFromJson(
  Object? tonemappingMode, [
  enums.TonemappingMode? defaultValue,
]) {
  if (tonemappingMode == null) {
    return null;
  }
  return enums.TonemappingMode.values
          .firstWhereOrNull((e) => e.value == tonemappingMode) ??
      defaultValue;
}

String tonemappingModeExplodedListToJson(
    List<enums.TonemappingMode>? tonemappingMode) {
  return tonemappingMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> tonemappingModeListToJson(
    List<enums.TonemappingMode>? tonemappingMode) {
  if (tonemappingMode == null) {
    return [];
  }

  return tonemappingMode.map((e) => e.value!).toList();
}

List<enums.TonemappingMode> tonemappingModeListFromJson(
  List? tonemappingMode, [
  List<enums.TonemappingMode>? defaultValue,
]) {
  if (tonemappingMode == null) {
    return defaultValue ?? [];
  }

  return tonemappingMode
      .map((e) => tonemappingModeFromJson(e.toString()))
      .toList();
}

List<enums.TonemappingMode>? tonemappingModeNullableListFromJson(
  List? tonemappingMode, [
  List<enums.TonemappingMode>? defaultValue,
]) {
  if (tonemappingMode == null) {
    return defaultValue;
  }

  return tonemappingMode
      .map((e) => tonemappingModeFromJson(e.toString()))
      .toList();
}

String? tonemappingRangeNullableToJson(
    enums.TonemappingRange? tonemappingRange) {
  return tonemappingRange?.value;
}

String? tonemappingRangeToJson(enums.TonemappingRange tonemappingRange) {
  return tonemappingRange.value;
}

enums.TonemappingRange tonemappingRangeFromJson(
  Object? tonemappingRange, [
  enums.TonemappingRange? defaultValue,
]) {
  return enums.TonemappingRange.values
          .firstWhereOrNull((e) => e.value == tonemappingRange) ??
      defaultValue ??
      enums.TonemappingRange.swaggerGeneratedUnknown;
}

enums.TonemappingRange? tonemappingRangeNullableFromJson(
  Object? tonemappingRange, [
  enums.TonemappingRange? defaultValue,
]) {
  if (tonemappingRange == null) {
    return null;
  }
  return enums.TonemappingRange.values
          .firstWhereOrNull((e) => e.value == tonemappingRange) ??
      defaultValue;
}

String tonemappingRangeExplodedListToJson(
    List<enums.TonemappingRange>? tonemappingRange) {
  return tonemappingRange?.map((e) => e.value!).join(',') ?? '';
}

List<String> tonemappingRangeListToJson(
    List<enums.TonemappingRange>? tonemappingRange) {
  if (tonemappingRange == null) {
    return [];
  }

  return tonemappingRange.map((e) => e.value!).toList();
}

List<enums.TonemappingRange> tonemappingRangeListFromJson(
  List? tonemappingRange, [
  List<enums.TonemappingRange>? defaultValue,
]) {
  if (tonemappingRange == null) {
    return defaultValue ?? [];
  }

  return tonemappingRange
      .map((e) => tonemappingRangeFromJson(e.toString()))
      .toList();
}

List<enums.TonemappingRange>? tonemappingRangeNullableListFromJson(
  List? tonemappingRange, [
  List<enums.TonemappingRange>? defaultValue,
]) {
  if (tonemappingRange == null) {
    return defaultValue;
  }

  return tonemappingRange
      .map((e) => tonemappingRangeFromJson(e.toString()))
      .toList();
}

String? transcodeReasonNullableToJson(enums.TranscodeReason? transcodeReason) {
  return transcodeReason?.value;
}

String? transcodeReasonToJson(enums.TranscodeReason transcodeReason) {
  return transcodeReason.value;
}

enums.TranscodeReason transcodeReasonFromJson(
  Object? transcodeReason, [
  enums.TranscodeReason? defaultValue,
]) {
  return enums.TranscodeReason.values
          .firstWhereOrNull((e) => e.value == transcodeReason) ??
      defaultValue ??
      enums.TranscodeReason.swaggerGeneratedUnknown;
}

enums.TranscodeReason? transcodeReasonNullableFromJson(
  Object? transcodeReason, [
  enums.TranscodeReason? defaultValue,
]) {
  if (transcodeReason == null) {
    return null;
  }
  return enums.TranscodeReason.values
          .firstWhereOrNull((e) => e.value == transcodeReason) ??
      defaultValue;
}

String transcodeReasonExplodedListToJson(
    List<enums.TranscodeReason>? transcodeReason) {
  return transcodeReason?.map((e) => e.value!).join(',') ?? '';
}

List<String> transcodeReasonListToJson(
    List<enums.TranscodeReason>? transcodeReason) {
  if (transcodeReason == null) {
    return [];
  }

  return transcodeReason.map((e) => e.value!).toList();
}

List<enums.TranscodeReason> transcodeReasonListFromJson(
  List? transcodeReason, [
  List<enums.TranscodeReason>? defaultValue,
]) {
  if (transcodeReason == null) {
    return defaultValue ?? [];
  }

  return transcodeReason
      .map((e) => transcodeReasonFromJson(e.toString()))
      .toList();
}

List<enums.TranscodeReason>? transcodeReasonNullableListFromJson(
  List? transcodeReason, [
  List<enums.TranscodeReason>? defaultValue,
]) {
  if (transcodeReason == null) {
    return defaultValue;
  }

  return transcodeReason
      .map((e) => transcodeReasonFromJson(e.toString()))
      .toList();
}

String? transcodeSeekInfoNullableToJson(
    enums.TranscodeSeekInfo? transcodeSeekInfo) {
  return transcodeSeekInfo?.value;
}

String? transcodeSeekInfoToJson(enums.TranscodeSeekInfo transcodeSeekInfo) {
  return transcodeSeekInfo.value;
}

enums.TranscodeSeekInfo transcodeSeekInfoFromJson(
  Object? transcodeSeekInfo, [
  enums.TranscodeSeekInfo? defaultValue,
]) {
  return enums.TranscodeSeekInfo.values
          .firstWhereOrNull((e) => e.value == transcodeSeekInfo) ??
      defaultValue ??
      enums.TranscodeSeekInfo.swaggerGeneratedUnknown;
}

enums.TranscodeSeekInfo? transcodeSeekInfoNullableFromJson(
  Object? transcodeSeekInfo, [
  enums.TranscodeSeekInfo? defaultValue,
]) {
  if (transcodeSeekInfo == null) {
    return null;
  }
  return enums.TranscodeSeekInfo.values
          .firstWhereOrNull((e) => e.value == transcodeSeekInfo) ??
      defaultValue;
}

String transcodeSeekInfoExplodedListToJson(
    List<enums.TranscodeSeekInfo>? transcodeSeekInfo) {
  return transcodeSeekInfo?.map((e) => e.value!).join(',') ?? '';
}

List<String> transcodeSeekInfoListToJson(
    List<enums.TranscodeSeekInfo>? transcodeSeekInfo) {
  if (transcodeSeekInfo == null) {
    return [];
  }

  return transcodeSeekInfo.map((e) => e.value!).toList();
}

List<enums.TranscodeSeekInfo> transcodeSeekInfoListFromJson(
  List? transcodeSeekInfo, [
  List<enums.TranscodeSeekInfo>? defaultValue,
]) {
  if (transcodeSeekInfo == null) {
    return defaultValue ?? [];
  }

  return transcodeSeekInfo
      .map((e) => transcodeSeekInfoFromJson(e.toString()))
      .toList();
}

List<enums.TranscodeSeekInfo>? transcodeSeekInfoNullableListFromJson(
  List? transcodeSeekInfo, [
  List<enums.TranscodeSeekInfo>? defaultValue,
]) {
  if (transcodeSeekInfo == null) {
    return defaultValue;
  }

  return transcodeSeekInfo
      .map((e) => transcodeSeekInfoFromJson(e.toString()))
      .toList();
}

String? transcodingInfoTranscodeReasonsNullableToJson(
    enums.TranscodingInfoTranscodeReasons? transcodingInfoTranscodeReasons) {
  return transcodingInfoTranscodeReasons?.value;
}

String? transcodingInfoTranscodeReasonsToJson(
    enums.TranscodingInfoTranscodeReasons transcodingInfoTranscodeReasons) {
  return transcodingInfoTranscodeReasons.value;
}

enums.TranscodingInfoTranscodeReasons transcodingInfoTranscodeReasonsFromJson(
  Object? transcodingInfoTranscodeReasons, [
  enums.TranscodingInfoTranscodeReasons? defaultValue,
]) {
  return enums.TranscodingInfoTranscodeReasons.values.firstWhereOrNull(
          (e) => e.value == transcodingInfoTranscodeReasons) ??
      defaultValue ??
      enums.TranscodingInfoTranscodeReasons.swaggerGeneratedUnknown;
}

enums.TranscodingInfoTranscodeReasons?
    transcodingInfoTranscodeReasonsNullableFromJson(
  Object? transcodingInfoTranscodeReasons, [
  enums.TranscodingInfoTranscodeReasons? defaultValue,
]) {
  if (transcodingInfoTranscodeReasons == null) {
    return null;
  }
  return enums.TranscodingInfoTranscodeReasons.values.firstWhereOrNull(
          (e) => e.value == transcodingInfoTranscodeReasons) ??
      defaultValue;
}

String transcodingInfoTranscodeReasonsExplodedListToJson(
    List<enums.TranscodingInfoTranscodeReasons>?
        transcodingInfoTranscodeReasons) {
  return transcodingInfoTranscodeReasons?.map((e) => e.value!).join(',') ?? '';
}

List<String> transcodingInfoTranscodeReasonsListToJson(
    List<enums.TranscodingInfoTranscodeReasons>?
        transcodingInfoTranscodeReasons) {
  if (transcodingInfoTranscodeReasons == null) {
    return [];
  }

  return transcodingInfoTranscodeReasons.map((e) => e.value!).toList();
}

List<enums.TranscodingInfoTranscodeReasons>
    transcodingInfoTranscodeReasonsListFromJson(
  List? transcodingInfoTranscodeReasons, [
  List<enums.TranscodingInfoTranscodeReasons>? defaultValue,
]) {
  if (transcodingInfoTranscodeReasons == null) {
    return defaultValue ?? [];
  }

  return transcodingInfoTranscodeReasons
      .map((e) => transcodingInfoTranscodeReasonsFromJson(e.toString()))
      .toList();
}

List<enums.TranscodingInfoTranscodeReasons>?
    transcodingInfoTranscodeReasonsNullableListFromJson(
  List? transcodingInfoTranscodeReasons, [
  List<enums.TranscodingInfoTranscodeReasons>? defaultValue,
]) {
  if (transcodingInfoTranscodeReasons == null) {
    return defaultValue;
  }

  return transcodingInfoTranscodeReasons
      .map((e) => transcodingInfoTranscodeReasonsFromJson(e.toString()))
      .toList();
}

String? transportStreamTimestampNullableToJson(
    enums.TransportStreamTimestamp? transportStreamTimestamp) {
  return transportStreamTimestamp?.value;
}

String? transportStreamTimestampToJson(
    enums.TransportStreamTimestamp transportStreamTimestamp) {
  return transportStreamTimestamp.value;
}

enums.TransportStreamTimestamp transportStreamTimestampFromJson(
  Object? transportStreamTimestamp, [
  enums.TransportStreamTimestamp? defaultValue,
]) {
  return enums.TransportStreamTimestamp.values
          .firstWhereOrNull((e) => e.value == transportStreamTimestamp) ??
      defaultValue ??
      enums.TransportStreamTimestamp.swaggerGeneratedUnknown;
}

enums.TransportStreamTimestamp? transportStreamTimestampNullableFromJson(
  Object? transportStreamTimestamp, [
  enums.TransportStreamTimestamp? defaultValue,
]) {
  if (transportStreamTimestamp == null) {
    return null;
  }
  return enums.TransportStreamTimestamp.values
          .firstWhereOrNull((e) => e.value == transportStreamTimestamp) ??
      defaultValue;
}

String transportStreamTimestampExplodedListToJson(
    List<enums.TransportStreamTimestamp>? transportStreamTimestamp) {
  return transportStreamTimestamp?.map((e) => e.value!).join(',') ?? '';
}

List<String> transportStreamTimestampListToJson(
    List<enums.TransportStreamTimestamp>? transportStreamTimestamp) {
  if (transportStreamTimestamp == null) {
    return [];
  }

  return transportStreamTimestamp.map((e) => e.value!).toList();
}

List<enums.TransportStreamTimestamp> transportStreamTimestampListFromJson(
  List? transportStreamTimestamp, [
  List<enums.TransportStreamTimestamp>? defaultValue,
]) {
  if (transportStreamTimestamp == null) {
    return defaultValue ?? [];
  }

  return transportStreamTimestamp
      .map((e) => transportStreamTimestampFromJson(e.toString()))
      .toList();
}

List<enums.TransportStreamTimestamp>?
    transportStreamTimestampNullableListFromJson(
  List? transportStreamTimestamp, [
  List<enums.TransportStreamTimestamp>? defaultValue,
]) {
  if (transportStreamTimestamp == null) {
    return defaultValue;
  }

  return transportStreamTimestamp
      .map((e) => transportStreamTimestampFromJson(e.toString()))
      .toList();
}

String? trickplayScanBehaviorNullableToJson(
    enums.TrickplayScanBehavior? trickplayScanBehavior) {
  return trickplayScanBehavior?.value;
}

String? trickplayScanBehaviorToJson(
    enums.TrickplayScanBehavior trickplayScanBehavior) {
  return trickplayScanBehavior.value;
}

enums.TrickplayScanBehavior trickplayScanBehaviorFromJson(
  Object? trickplayScanBehavior, [
  enums.TrickplayScanBehavior? defaultValue,
]) {
  return enums.TrickplayScanBehavior.values
          .firstWhereOrNull((e) => e.value == trickplayScanBehavior) ??
      defaultValue ??
      enums.TrickplayScanBehavior.swaggerGeneratedUnknown;
}

enums.TrickplayScanBehavior? trickplayScanBehaviorNullableFromJson(
  Object? trickplayScanBehavior, [
  enums.TrickplayScanBehavior? defaultValue,
]) {
  if (trickplayScanBehavior == null) {
    return null;
  }
  return enums.TrickplayScanBehavior.values
          .firstWhereOrNull((e) => e.value == trickplayScanBehavior) ??
      defaultValue;
}

String trickplayScanBehaviorExplodedListToJson(
    List<enums.TrickplayScanBehavior>? trickplayScanBehavior) {
  return trickplayScanBehavior?.map((e) => e.value!).join(',') ?? '';
}

List<String> trickplayScanBehaviorListToJson(
    List<enums.TrickplayScanBehavior>? trickplayScanBehavior) {
  if (trickplayScanBehavior == null) {
    return [];
  }

  return trickplayScanBehavior.map((e) => e.value!).toList();
}

List<enums.TrickplayScanBehavior> trickplayScanBehaviorListFromJson(
  List? trickplayScanBehavior, [
  List<enums.TrickplayScanBehavior>? defaultValue,
]) {
  if (trickplayScanBehavior == null) {
    return defaultValue ?? [];
  }

  return trickplayScanBehavior
      .map((e) => trickplayScanBehaviorFromJson(e.toString()))
      .toList();
}

List<enums.TrickplayScanBehavior>? trickplayScanBehaviorNullableListFromJson(
  List? trickplayScanBehavior, [
  List<enums.TrickplayScanBehavior>? defaultValue,
]) {
  if (trickplayScanBehavior == null) {
    return defaultValue;
  }

  return trickplayScanBehavior
      .map((e) => trickplayScanBehaviorFromJson(e.toString()))
      .toList();
}

String? unratedItemNullableToJson(enums.UnratedItem? unratedItem) {
  return unratedItem?.value;
}

String? unratedItemToJson(enums.UnratedItem unratedItem) {
  return unratedItem.value;
}

enums.UnratedItem unratedItemFromJson(
  Object? unratedItem, [
  enums.UnratedItem? defaultValue,
]) {
  return enums.UnratedItem.values
          .firstWhereOrNull((e) => e.value == unratedItem) ??
      defaultValue ??
      enums.UnratedItem.swaggerGeneratedUnknown;
}

enums.UnratedItem? unratedItemNullableFromJson(
  Object? unratedItem, [
  enums.UnratedItem? defaultValue,
]) {
  if (unratedItem == null) {
    return null;
  }
  return enums.UnratedItem.values
          .firstWhereOrNull((e) => e.value == unratedItem) ??
      defaultValue;
}

String unratedItemExplodedListToJson(List<enums.UnratedItem>? unratedItem) {
  return unratedItem?.map((e) => e.value!).join(',') ?? '';
}

List<String> unratedItemListToJson(List<enums.UnratedItem>? unratedItem) {
  if (unratedItem == null) {
    return [];
  }

  return unratedItem.map((e) => e.value!).toList();
}

List<enums.UnratedItem> unratedItemListFromJson(
  List? unratedItem, [
  List<enums.UnratedItem>? defaultValue,
]) {
  if (unratedItem == null) {
    return defaultValue ?? [];
  }

  return unratedItem.map((e) => unratedItemFromJson(e.toString())).toList();
}

List<enums.UnratedItem>? unratedItemNullableListFromJson(
  List? unratedItem, [
  List<enums.UnratedItem>? defaultValue,
]) {
  if (unratedItem == null) {
    return defaultValue;
  }

  return unratedItem.map((e) => unratedItemFromJson(e.toString())).toList();
}

String? video3DFormatNullableToJson(enums.Video3DFormat? video3DFormat) {
  return video3DFormat?.value;
}

String? video3DFormatToJson(enums.Video3DFormat video3DFormat) {
  return video3DFormat.value;
}

enums.Video3DFormat video3DFormatFromJson(
  Object? video3DFormat, [
  enums.Video3DFormat? defaultValue,
]) {
  return enums.Video3DFormat.values
          .firstWhereOrNull((e) => e.value == video3DFormat) ??
      defaultValue ??
      enums.Video3DFormat.swaggerGeneratedUnknown;
}

enums.Video3DFormat? video3DFormatNullableFromJson(
  Object? video3DFormat, [
  enums.Video3DFormat? defaultValue,
]) {
  if (video3DFormat == null) {
    return null;
  }
  return enums.Video3DFormat.values
          .firstWhereOrNull((e) => e.value == video3DFormat) ??
      defaultValue;
}

String video3DFormatExplodedListToJson(
    List<enums.Video3DFormat>? video3DFormat) {
  return video3DFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> video3DFormatListToJson(List<enums.Video3DFormat>? video3DFormat) {
  if (video3DFormat == null) {
    return [];
  }

  return video3DFormat.map((e) => e.value!).toList();
}

List<enums.Video3DFormat> video3DFormatListFromJson(
  List? video3DFormat, [
  List<enums.Video3DFormat>? defaultValue,
]) {
  if (video3DFormat == null) {
    return defaultValue ?? [];
  }

  return video3DFormat.map((e) => video3DFormatFromJson(e.toString())).toList();
}

List<enums.Video3DFormat>? video3DFormatNullableListFromJson(
  List? video3DFormat, [
  List<enums.Video3DFormat>? defaultValue,
]) {
  if (video3DFormat == null) {
    return defaultValue;
  }

  return video3DFormat.map((e) => video3DFormatFromJson(e.toString())).toList();
}

String? videoRangeNullableToJson(enums.VideoRange? videoRange) {
  return videoRange?.value;
}

String? videoRangeToJson(enums.VideoRange videoRange) {
  return videoRange.value;
}

enums.VideoRange videoRangeFromJson(
  Object? videoRange, [
  enums.VideoRange? defaultValue,
]) {
  return enums.VideoRange.values
          .firstWhereOrNull((e) => e.value == videoRange) ??
      defaultValue ??
      enums.VideoRange.swaggerGeneratedUnknown;
}

enums.VideoRange? videoRangeNullableFromJson(
  Object? videoRange, [
  enums.VideoRange? defaultValue,
]) {
  if (videoRange == null) {
    return null;
  }
  return enums.VideoRange.values
          .firstWhereOrNull((e) => e.value == videoRange) ??
      defaultValue;
}

String videoRangeExplodedListToJson(List<enums.VideoRange>? videoRange) {
  return videoRange?.map((e) => e.value!).join(',') ?? '';
}

List<String> videoRangeListToJson(List<enums.VideoRange>? videoRange) {
  if (videoRange == null) {
    return [];
  }

  return videoRange.map((e) => e.value!).toList();
}

List<enums.VideoRange> videoRangeListFromJson(
  List? videoRange, [
  List<enums.VideoRange>? defaultValue,
]) {
  if (videoRange == null) {
    return defaultValue ?? [];
  }

  return videoRange.map((e) => videoRangeFromJson(e.toString())).toList();
}

List<enums.VideoRange>? videoRangeNullableListFromJson(
  List? videoRange, [
  List<enums.VideoRange>? defaultValue,
]) {
  if (videoRange == null) {
    return defaultValue;
  }

  return videoRange.map((e) => videoRangeFromJson(e.toString())).toList();
}

String? videoRangeTypeNullableToJson(enums.VideoRangeType? videoRangeType) {
  return videoRangeType?.value;
}

String? videoRangeTypeToJson(enums.VideoRangeType videoRangeType) {
  return videoRangeType.value;
}

enums.VideoRangeType videoRangeTypeFromJson(
  Object? videoRangeType, [
  enums.VideoRangeType? defaultValue,
]) {
  return enums.VideoRangeType.values
          .firstWhereOrNull((e) => e.value == videoRangeType) ??
      defaultValue ??
      enums.VideoRangeType.swaggerGeneratedUnknown;
}

enums.VideoRangeType? videoRangeTypeNullableFromJson(
  Object? videoRangeType, [
  enums.VideoRangeType? defaultValue,
]) {
  if (videoRangeType == null) {
    return null;
  }
  return enums.VideoRangeType.values
          .firstWhereOrNull((e) => e.value == videoRangeType) ??
      defaultValue;
}

String videoRangeTypeExplodedListToJson(
    List<enums.VideoRangeType>? videoRangeType) {
  return videoRangeType?.map((e) => e.value!).join(',') ?? '';
}

List<String> videoRangeTypeListToJson(
    List<enums.VideoRangeType>? videoRangeType) {
  if (videoRangeType == null) {
    return [];
  }

  return videoRangeType.map((e) => e.value!).toList();
}

List<enums.VideoRangeType> videoRangeTypeListFromJson(
  List? videoRangeType, [
  List<enums.VideoRangeType>? defaultValue,
]) {
  if (videoRangeType == null) {
    return defaultValue ?? [];
  }

  return videoRangeType
      .map((e) => videoRangeTypeFromJson(e.toString()))
      .toList();
}

List<enums.VideoRangeType>? videoRangeTypeNullableListFromJson(
  List? videoRangeType, [
  List<enums.VideoRangeType>? defaultValue,
]) {
  if (videoRangeType == null) {
    return defaultValue;
  }

  return videoRangeType
      .map((e) => videoRangeTypeFromJson(e.toString()))
      .toList();
}

String? videoTypeNullableToJson(enums.VideoType? videoType) {
  return videoType?.value;
}

String? videoTypeToJson(enums.VideoType videoType) {
  return videoType.value;
}

enums.VideoType videoTypeFromJson(
  Object? videoType, [
  enums.VideoType? defaultValue,
]) {
  return enums.VideoType.values.firstWhereOrNull((e) => e.value == videoType) ??
      defaultValue ??
      enums.VideoType.swaggerGeneratedUnknown;
}

enums.VideoType? videoTypeNullableFromJson(
  Object? videoType, [
  enums.VideoType? defaultValue,
]) {
  if (videoType == null) {
    return null;
  }
  return enums.VideoType.values.firstWhereOrNull((e) => e.value == videoType) ??
      defaultValue;
}

String videoTypeExplodedListToJson(List<enums.VideoType>? videoType) {
  return videoType?.map((e) => e.value!).join(',') ?? '';
}

List<String> videoTypeListToJson(List<enums.VideoType>? videoType) {
  if (videoType == null) {
    return [];
  }

  return videoType.map((e) => e.value!).toList();
}

List<enums.VideoType> videoTypeListFromJson(
  List? videoType, [
  List<enums.VideoType>? defaultValue,
]) {
  if (videoType == null) {
    return defaultValue ?? [];
  }

  return videoType.map((e) => videoTypeFromJson(e.toString())).toList();
}

List<enums.VideoType>? videoTypeNullableListFromJson(
  List? videoType, [
  List<enums.VideoType>? defaultValue,
]) {
  if (videoType == null) {
    return defaultValue;
  }

  return videoType.map((e) => videoTypeFromJson(e.toString())).toList();
}

String? audioItemIdStreamGetSubtitleMethodNullableToJson(
    enums.AudioItemIdStreamGetSubtitleMethod?
        audioItemIdStreamGetSubtitleMethod) {
  return audioItemIdStreamGetSubtitleMethod?.value;
}

String? audioItemIdStreamGetSubtitleMethodToJson(
    enums.AudioItemIdStreamGetSubtitleMethod
        audioItemIdStreamGetSubtitleMethod) {
  return audioItemIdStreamGetSubtitleMethod.value;
}

enums.AudioItemIdStreamGetSubtitleMethod
    audioItemIdStreamGetSubtitleMethodFromJson(
  Object? audioItemIdStreamGetSubtitleMethod, [
  enums.AudioItemIdStreamGetSubtitleMethod? defaultValue,
]) {
  return enums.AudioItemIdStreamGetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdStreamGetSubtitleMethod) ??
      defaultValue ??
      enums.AudioItemIdStreamGetSubtitleMethod.swaggerGeneratedUnknown;
}

enums.AudioItemIdStreamGetSubtitleMethod?
    audioItemIdStreamGetSubtitleMethodNullableFromJson(
  Object? audioItemIdStreamGetSubtitleMethod, [
  enums.AudioItemIdStreamGetSubtitleMethod? defaultValue,
]) {
  if (audioItemIdStreamGetSubtitleMethod == null) {
    return null;
  }
  return enums.AudioItemIdStreamGetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdStreamGetSubtitleMethod) ??
      defaultValue;
}

String audioItemIdStreamGetSubtitleMethodExplodedListToJson(
    List<enums.AudioItemIdStreamGetSubtitleMethod>?
        audioItemIdStreamGetSubtitleMethod) {
  return audioItemIdStreamGetSubtitleMethod?.map((e) => e.value!).join(',') ??
      '';
}

List<String> audioItemIdStreamGetSubtitleMethodListToJson(
    List<enums.AudioItemIdStreamGetSubtitleMethod>?
        audioItemIdStreamGetSubtitleMethod) {
  if (audioItemIdStreamGetSubtitleMethod == null) {
    return [];
  }

  return audioItemIdStreamGetSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.AudioItemIdStreamGetSubtitleMethod>
    audioItemIdStreamGetSubtitleMethodListFromJson(
  List? audioItemIdStreamGetSubtitleMethod, [
  List<enums.AudioItemIdStreamGetSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdStreamGetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return audioItemIdStreamGetSubtitleMethod
      .map((e) => audioItemIdStreamGetSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdStreamGetSubtitleMethod>?
    audioItemIdStreamGetSubtitleMethodNullableListFromJson(
  List? audioItemIdStreamGetSubtitleMethod, [
  List<enums.AudioItemIdStreamGetSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdStreamGetSubtitleMethod == null) {
    return defaultValue;
  }

  return audioItemIdStreamGetSubtitleMethod
      .map((e) => audioItemIdStreamGetSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? audioItemIdStreamGetContextNullableToJson(
    enums.AudioItemIdStreamGetContext? audioItemIdStreamGetContext) {
  return audioItemIdStreamGetContext?.value;
}

String? audioItemIdStreamGetContextToJson(
    enums.AudioItemIdStreamGetContext audioItemIdStreamGetContext) {
  return audioItemIdStreamGetContext.value;
}

enums.AudioItemIdStreamGetContext audioItemIdStreamGetContextFromJson(
  Object? audioItemIdStreamGetContext, [
  enums.AudioItemIdStreamGetContext? defaultValue,
]) {
  return enums.AudioItemIdStreamGetContext.values
          .firstWhereOrNull((e) => e.value == audioItemIdStreamGetContext) ??
      defaultValue ??
      enums.AudioItemIdStreamGetContext.swaggerGeneratedUnknown;
}

enums.AudioItemIdStreamGetContext? audioItemIdStreamGetContextNullableFromJson(
  Object? audioItemIdStreamGetContext, [
  enums.AudioItemIdStreamGetContext? defaultValue,
]) {
  if (audioItemIdStreamGetContext == null) {
    return null;
  }
  return enums.AudioItemIdStreamGetContext.values
          .firstWhereOrNull((e) => e.value == audioItemIdStreamGetContext) ??
      defaultValue;
}

String audioItemIdStreamGetContextExplodedListToJson(
    List<enums.AudioItemIdStreamGetContext>? audioItemIdStreamGetContext) {
  return audioItemIdStreamGetContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> audioItemIdStreamGetContextListToJson(
    List<enums.AudioItemIdStreamGetContext>? audioItemIdStreamGetContext) {
  if (audioItemIdStreamGetContext == null) {
    return [];
  }

  return audioItemIdStreamGetContext.map((e) => e.value!).toList();
}

List<enums.AudioItemIdStreamGetContext> audioItemIdStreamGetContextListFromJson(
  List? audioItemIdStreamGetContext, [
  List<enums.AudioItemIdStreamGetContext>? defaultValue,
]) {
  if (audioItemIdStreamGetContext == null) {
    return defaultValue ?? [];
  }

  return audioItemIdStreamGetContext
      .map((e) => audioItemIdStreamGetContextFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdStreamGetContext>?
    audioItemIdStreamGetContextNullableListFromJson(
  List? audioItemIdStreamGetContext, [
  List<enums.AudioItemIdStreamGetContext>? defaultValue,
]) {
  if (audioItemIdStreamGetContext == null) {
    return defaultValue;
  }

  return audioItemIdStreamGetContext
      .map((e) => audioItemIdStreamGetContextFromJson(e.toString()))
      .toList();
}

String? audioItemIdStreamHeadSubtitleMethodNullableToJson(
    enums.AudioItemIdStreamHeadSubtitleMethod?
        audioItemIdStreamHeadSubtitleMethod) {
  return audioItemIdStreamHeadSubtitleMethod?.value;
}

String? audioItemIdStreamHeadSubtitleMethodToJson(
    enums.AudioItemIdStreamHeadSubtitleMethod
        audioItemIdStreamHeadSubtitleMethod) {
  return audioItemIdStreamHeadSubtitleMethod.value;
}

enums.AudioItemIdStreamHeadSubtitleMethod
    audioItemIdStreamHeadSubtitleMethodFromJson(
  Object? audioItemIdStreamHeadSubtitleMethod, [
  enums.AudioItemIdStreamHeadSubtitleMethod? defaultValue,
]) {
  return enums.AudioItemIdStreamHeadSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdStreamHeadSubtitleMethod) ??
      defaultValue ??
      enums.AudioItemIdStreamHeadSubtitleMethod.swaggerGeneratedUnknown;
}

enums.AudioItemIdStreamHeadSubtitleMethod?
    audioItemIdStreamHeadSubtitleMethodNullableFromJson(
  Object? audioItemIdStreamHeadSubtitleMethod, [
  enums.AudioItemIdStreamHeadSubtitleMethod? defaultValue,
]) {
  if (audioItemIdStreamHeadSubtitleMethod == null) {
    return null;
  }
  return enums.AudioItemIdStreamHeadSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdStreamHeadSubtitleMethod) ??
      defaultValue;
}

String audioItemIdStreamHeadSubtitleMethodExplodedListToJson(
    List<enums.AudioItemIdStreamHeadSubtitleMethod>?
        audioItemIdStreamHeadSubtitleMethod) {
  return audioItemIdStreamHeadSubtitleMethod?.map((e) => e.value!).join(',') ??
      '';
}

List<String> audioItemIdStreamHeadSubtitleMethodListToJson(
    List<enums.AudioItemIdStreamHeadSubtitleMethod>?
        audioItemIdStreamHeadSubtitleMethod) {
  if (audioItemIdStreamHeadSubtitleMethod == null) {
    return [];
  }

  return audioItemIdStreamHeadSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.AudioItemIdStreamHeadSubtitleMethod>
    audioItemIdStreamHeadSubtitleMethodListFromJson(
  List? audioItemIdStreamHeadSubtitleMethod, [
  List<enums.AudioItemIdStreamHeadSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdStreamHeadSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return audioItemIdStreamHeadSubtitleMethod
      .map((e) => audioItemIdStreamHeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdStreamHeadSubtitleMethod>?
    audioItemIdStreamHeadSubtitleMethodNullableListFromJson(
  List? audioItemIdStreamHeadSubtitleMethod, [
  List<enums.AudioItemIdStreamHeadSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdStreamHeadSubtitleMethod == null) {
    return defaultValue;
  }

  return audioItemIdStreamHeadSubtitleMethod
      .map((e) => audioItemIdStreamHeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? audioItemIdStreamHeadContextNullableToJson(
    enums.AudioItemIdStreamHeadContext? audioItemIdStreamHeadContext) {
  return audioItemIdStreamHeadContext?.value;
}

String? audioItemIdStreamHeadContextToJson(
    enums.AudioItemIdStreamHeadContext audioItemIdStreamHeadContext) {
  return audioItemIdStreamHeadContext.value;
}

enums.AudioItemIdStreamHeadContext audioItemIdStreamHeadContextFromJson(
  Object? audioItemIdStreamHeadContext, [
  enums.AudioItemIdStreamHeadContext? defaultValue,
]) {
  return enums.AudioItemIdStreamHeadContext.values
          .firstWhereOrNull((e) => e.value == audioItemIdStreamHeadContext) ??
      defaultValue ??
      enums.AudioItemIdStreamHeadContext.swaggerGeneratedUnknown;
}

enums.AudioItemIdStreamHeadContext?
    audioItemIdStreamHeadContextNullableFromJson(
  Object? audioItemIdStreamHeadContext, [
  enums.AudioItemIdStreamHeadContext? defaultValue,
]) {
  if (audioItemIdStreamHeadContext == null) {
    return null;
  }
  return enums.AudioItemIdStreamHeadContext.values
          .firstWhereOrNull((e) => e.value == audioItemIdStreamHeadContext) ??
      defaultValue;
}

String audioItemIdStreamHeadContextExplodedListToJson(
    List<enums.AudioItemIdStreamHeadContext>? audioItemIdStreamHeadContext) {
  return audioItemIdStreamHeadContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> audioItemIdStreamHeadContextListToJson(
    List<enums.AudioItemIdStreamHeadContext>? audioItemIdStreamHeadContext) {
  if (audioItemIdStreamHeadContext == null) {
    return [];
  }

  return audioItemIdStreamHeadContext.map((e) => e.value!).toList();
}

List<enums.AudioItemIdStreamHeadContext>
    audioItemIdStreamHeadContextListFromJson(
  List? audioItemIdStreamHeadContext, [
  List<enums.AudioItemIdStreamHeadContext>? defaultValue,
]) {
  if (audioItemIdStreamHeadContext == null) {
    return defaultValue ?? [];
  }

  return audioItemIdStreamHeadContext
      .map((e) => audioItemIdStreamHeadContextFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdStreamHeadContext>?
    audioItemIdStreamHeadContextNullableListFromJson(
  List? audioItemIdStreamHeadContext, [
  List<enums.AudioItemIdStreamHeadContext>? defaultValue,
]) {
  if (audioItemIdStreamHeadContext == null) {
    return defaultValue;
  }

  return audioItemIdStreamHeadContext
      .map((e) => audioItemIdStreamHeadContextFromJson(e.toString()))
      .toList();
}

String? audioItemIdStreamContainerGetSubtitleMethodNullableToJson(
    enums.AudioItemIdStreamContainerGetSubtitleMethod?
        audioItemIdStreamContainerGetSubtitleMethod) {
  return audioItemIdStreamContainerGetSubtitleMethod?.value;
}

String? audioItemIdStreamContainerGetSubtitleMethodToJson(
    enums.AudioItemIdStreamContainerGetSubtitleMethod
        audioItemIdStreamContainerGetSubtitleMethod) {
  return audioItemIdStreamContainerGetSubtitleMethod.value;
}

enums.AudioItemIdStreamContainerGetSubtitleMethod
    audioItemIdStreamContainerGetSubtitleMethodFromJson(
  Object? audioItemIdStreamContainerGetSubtitleMethod, [
  enums.AudioItemIdStreamContainerGetSubtitleMethod? defaultValue,
]) {
  return enums.AudioItemIdStreamContainerGetSubtitleMethod.values
          .firstWhereOrNull(
              (e) => e.value == audioItemIdStreamContainerGetSubtitleMethod) ??
      defaultValue ??
      enums.AudioItemIdStreamContainerGetSubtitleMethod.swaggerGeneratedUnknown;
}

enums.AudioItemIdStreamContainerGetSubtitleMethod?
    audioItemIdStreamContainerGetSubtitleMethodNullableFromJson(
  Object? audioItemIdStreamContainerGetSubtitleMethod, [
  enums.AudioItemIdStreamContainerGetSubtitleMethod? defaultValue,
]) {
  if (audioItemIdStreamContainerGetSubtitleMethod == null) {
    return null;
  }
  return enums.AudioItemIdStreamContainerGetSubtitleMethod.values
          .firstWhereOrNull(
              (e) => e.value == audioItemIdStreamContainerGetSubtitleMethod) ??
      defaultValue;
}

String audioItemIdStreamContainerGetSubtitleMethodExplodedListToJson(
    List<enums.AudioItemIdStreamContainerGetSubtitleMethod>?
        audioItemIdStreamContainerGetSubtitleMethod) {
  return audioItemIdStreamContainerGetSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> audioItemIdStreamContainerGetSubtitleMethodListToJson(
    List<enums.AudioItemIdStreamContainerGetSubtitleMethod>?
        audioItemIdStreamContainerGetSubtitleMethod) {
  if (audioItemIdStreamContainerGetSubtitleMethod == null) {
    return [];
  }

  return audioItemIdStreamContainerGetSubtitleMethod
      .map((e) => e.value!)
      .toList();
}

List<enums.AudioItemIdStreamContainerGetSubtitleMethod>
    audioItemIdStreamContainerGetSubtitleMethodListFromJson(
  List? audioItemIdStreamContainerGetSubtitleMethod, [
  List<enums.AudioItemIdStreamContainerGetSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdStreamContainerGetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return audioItemIdStreamContainerGetSubtitleMethod
      .map((e) =>
          audioItemIdStreamContainerGetSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdStreamContainerGetSubtitleMethod>?
    audioItemIdStreamContainerGetSubtitleMethodNullableListFromJson(
  List? audioItemIdStreamContainerGetSubtitleMethod, [
  List<enums.AudioItemIdStreamContainerGetSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdStreamContainerGetSubtitleMethod == null) {
    return defaultValue;
  }

  return audioItemIdStreamContainerGetSubtitleMethod
      .map((e) =>
          audioItemIdStreamContainerGetSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? audioItemIdStreamContainerGetContextNullableToJson(
    enums.AudioItemIdStreamContainerGetContext?
        audioItemIdStreamContainerGetContext) {
  return audioItemIdStreamContainerGetContext?.value;
}

String? audioItemIdStreamContainerGetContextToJson(
    enums.AudioItemIdStreamContainerGetContext
        audioItemIdStreamContainerGetContext) {
  return audioItemIdStreamContainerGetContext.value;
}

enums.AudioItemIdStreamContainerGetContext
    audioItemIdStreamContainerGetContextFromJson(
  Object? audioItemIdStreamContainerGetContext, [
  enums.AudioItemIdStreamContainerGetContext? defaultValue,
]) {
  return enums.AudioItemIdStreamContainerGetContext.values.firstWhereOrNull(
          (e) => e.value == audioItemIdStreamContainerGetContext) ??
      defaultValue ??
      enums.AudioItemIdStreamContainerGetContext.swaggerGeneratedUnknown;
}

enums.AudioItemIdStreamContainerGetContext?
    audioItemIdStreamContainerGetContextNullableFromJson(
  Object? audioItemIdStreamContainerGetContext, [
  enums.AudioItemIdStreamContainerGetContext? defaultValue,
]) {
  if (audioItemIdStreamContainerGetContext == null) {
    return null;
  }
  return enums.AudioItemIdStreamContainerGetContext.values.firstWhereOrNull(
          (e) => e.value == audioItemIdStreamContainerGetContext) ??
      defaultValue;
}

String audioItemIdStreamContainerGetContextExplodedListToJson(
    List<enums.AudioItemIdStreamContainerGetContext>?
        audioItemIdStreamContainerGetContext) {
  return audioItemIdStreamContainerGetContext?.map((e) => e.value!).join(',') ??
      '';
}

List<String> audioItemIdStreamContainerGetContextListToJson(
    List<enums.AudioItemIdStreamContainerGetContext>?
        audioItemIdStreamContainerGetContext) {
  if (audioItemIdStreamContainerGetContext == null) {
    return [];
  }

  return audioItemIdStreamContainerGetContext.map((e) => e.value!).toList();
}

List<enums.AudioItemIdStreamContainerGetContext>
    audioItemIdStreamContainerGetContextListFromJson(
  List? audioItemIdStreamContainerGetContext, [
  List<enums.AudioItemIdStreamContainerGetContext>? defaultValue,
]) {
  if (audioItemIdStreamContainerGetContext == null) {
    return defaultValue ?? [];
  }

  return audioItemIdStreamContainerGetContext
      .map((e) => audioItemIdStreamContainerGetContextFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdStreamContainerGetContext>?
    audioItemIdStreamContainerGetContextNullableListFromJson(
  List? audioItemIdStreamContainerGetContext, [
  List<enums.AudioItemIdStreamContainerGetContext>? defaultValue,
]) {
  if (audioItemIdStreamContainerGetContext == null) {
    return defaultValue;
  }

  return audioItemIdStreamContainerGetContext
      .map((e) => audioItemIdStreamContainerGetContextFromJson(e.toString()))
      .toList();
}

String? audioItemIdStreamContainerHeadSubtitleMethodNullableToJson(
    enums.AudioItemIdStreamContainerHeadSubtitleMethod?
        audioItemIdStreamContainerHeadSubtitleMethod) {
  return audioItemIdStreamContainerHeadSubtitleMethod?.value;
}

String? audioItemIdStreamContainerHeadSubtitleMethodToJson(
    enums.AudioItemIdStreamContainerHeadSubtitleMethod
        audioItemIdStreamContainerHeadSubtitleMethod) {
  return audioItemIdStreamContainerHeadSubtitleMethod.value;
}

enums.AudioItemIdStreamContainerHeadSubtitleMethod
    audioItemIdStreamContainerHeadSubtitleMethodFromJson(
  Object? audioItemIdStreamContainerHeadSubtitleMethod, [
  enums.AudioItemIdStreamContainerHeadSubtitleMethod? defaultValue,
]) {
  return enums.AudioItemIdStreamContainerHeadSubtitleMethod.values
          .firstWhereOrNull(
              (e) => e.value == audioItemIdStreamContainerHeadSubtitleMethod) ??
      defaultValue ??
      enums
          .AudioItemIdStreamContainerHeadSubtitleMethod.swaggerGeneratedUnknown;
}

enums.AudioItemIdStreamContainerHeadSubtitleMethod?
    audioItemIdStreamContainerHeadSubtitleMethodNullableFromJson(
  Object? audioItemIdStreamContainerHeadSubtitleMethod, [
  enums.AudioItemIdStreamContainerHeadSubtitleMethod? defaultValue,
]) {
  if (audioItemIdStreamContainerHeadSubtitleMethod == null) {
    return null;
  }
  return enums.AudioItemIdStreamContainerHeadSubtitleMethod.values
          .firstWhereOrNull(
              (e) => e.value == audioItemIdStreamContainerHeadSubtitleMethod) ??
      defaultValue;
}

String audioItemIdStreamContainerHeadSubtitleMethodExplodedListToJson(
    List<enums.AudioItemIdStreamContainerHeadSubtitleMethod>?
        audioItemIdStreamContainerHeadSubtitleMethod) {
  return audioItemIdStreamContainerHeadSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> audioItemIdStreamContainerHeadSubtitleMethodListToJson(
    List<enums.AudioItemIdStreamContainerHeadSubtitleMethod>?
        audioItemIdStreamContainerHeadSubtitleMethod) {
  if (audioItemIdStreamContainerHeadSubtitleMethod == null) {
    return [];
  }

  return audioItemIdStreamContainerHeadSubtitleMethod
      .map((e) => e.value!)
      .toList();
}

List<enums.AudioItemIdStreamContainerHeadSubtitleMethod>
    audioItemIdStreamContainerHeadSubtitleMethodListFromJson(
  List? audioItemIdStreamContainerHeadSubtitleMethod, [
  List<enums.AudioItemIdStreamContainerHeadSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdStreamContainerHeadSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return audioItemIdStreamContainerHeadSubtitleMethod
      .map((e) =>
          audioItemIdStreamContainerHeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdStreamContainerHeadSubtitleMethod>?
    audioItemIdStreamContainerHeadSubtitleMethodNullableListFromJson(
  List? audioItemIdStreamContainerHeadSubtitleMethod, [
  List<enums.AudioItemIdStreamContainerHeadSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdStreamContainerHeadSubtitleMethod == null) {
    return defaultValue;
  }

  return audioItemIdStreamContainerHeadSubtitleMethod
      .map((e) =>
          audioItemIdStreamContainerHeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? audioItemIdStreamContainerHeadContextNullableToJson(
    enums.AudioItemIdStreamContainerHeadContext?
        audioItemIdStreamContainerHeadContext) {
  return audioItemIdStreamContainerHeadContext?.value;
}

String? audioItemIdStreamContainerHeadContextToJson(
    enums.AudioItemIdStreamContainerHeadContext
        audioItemIdStreamContainerHeadContext) {
  return audioItemIdStreamContainerHeadContext.value;
}

enums.AudioItemIdStreamContainerHeadContext
    audioItemIdStreamContainerHeadContextFromJson(
  Object? audioItemIdStreamContainerHeadContext, [
  enums.AudioItemIdStreamContainerHeadContext? defaultValue,
]) {
  return enums.AudioItemIdStreamContainerHeadContext.values.firstWhereOrNull(
          (e) => e.value == audioItemIdStreamContainerHeadContext) ??
      defaultValue ??
      enums.AudioItemIdStreamContainerHeadContext.swaggerGeneratedUnknown;
}

enums.AudioItemIdStreamContainerHeadContext?
    audioItemIdStreamContainerHeadContextNullableFromJson(
  Object? audioItemIdStreamContainerHeadContext, [
  enums.AudioItemIdStreamContainerHeadContext? defaultValue,
]) {
  if (audioItemIdStreamContainerHeadContext == null) {
    return null;
  }
  return enums.AudioItemIdStreamContainerHeadContext.values.firstWhereOrNull(
          (e) => e.value == audioItemIdStreamContainerHeadContext) ??
      defaultValue;
}

String audioItemIdStreamContainerHeadContextExplodedListToJson(
    List<enums.AudioItemIdStreamContainerHeadContext>?
        audioItemIdStreamContainerHeadContext) {
  return audioItemIdStreamContainerHeadContext
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> audioItemIdStreamContainerHeadContextListToJson(
    List<enums.AudioItemIdStreamContainerHeadContext>?
        audioItemIdStreamContainerHeadContext) {
  if (audioItemIdStreamContainerHeadContext == null) {
    return [];
  }

  return audioItemIdStreamContainerHeadContext.map((e) => e.value!).toList();
}

List<enums.AudioItemIdStreamContainerHeadContext>
    audioItemIdStreamContainerHeadContextListFromJson(
  List? audioItemIdStreamContainerHeadContext, [
  List<enums.AudioItemIdStreamContainerHeadContext>? defaultValue,
]) {
  if (audioItemIdStreamContainerHeadContext == null) {
    return defaultValue ?? [];
  }

  return audioItemIdStreamContainerHeadContext
      .map((e) => audioItemIdStreamContainerHeadContextFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdStreamContainerHeadContext>?
    audioItemIdStreamContainerHeadContextNullableListFromJson(
  List? audioItemIdStreamContainerHeadContext, [
  List<enums.AudioItemIdStreamContainerHeadContext>? defaultValue,
]) {
  if (audioItemIdStreamContainerHeadContext == null) {
    return defaultValue;
  }

  return audioItemIdStreamContainerHeadContext
      .map((e) => audioItemIdStreamContainerHeadContextFromJson(e.toString()))
      .toList();
}

String?
    audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodNullableToJson(
        enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
            audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) {
  return audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?.value;
}

String? audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodToJson(
    enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
        audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) {
  return audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod.value;
}

enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
    audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodFromJson(
  Object? audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod, [
  enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
      defaultValue,
]) {
  return enums
          .AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod.values
          .firstWhereOrNull((e) =>
              e.value ==
              audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) ??
      defaultValue ??
      enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
          .swaggerGeneratedUnknown;
}

enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
    audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodNullableFromJson(
  Object? audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod, [
  enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
      defaultValue,
]) {
  if (audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod == null) {
    return null;
  }
  return enums
          .AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod.values
          .firstWhereOrNull((e) =>
              e.value ==
              audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) ??
      defaultValue;
}

String
    audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodExplodedListToJson(
        List<
                enums
                .AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
            audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) {
  return audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodListToJson(
        List<
                enums
                .AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
            audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) {
  if (audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod == null) {
    return [];
  }

  return audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
      .map((e) => e.value!)
      .toList();
}

List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>
    audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodListFromJson(
  List? audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod, [
  List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
      defaultValue,
]) {
  if (audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
      .map((e) =>
          audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodFromJson(
              e.toString()))
      .toList();
}

List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
    audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodNullableListFromJson(
  List? audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod, [
  List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
      defaultValue,
]) {
  if (audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod == null) {
    return defaultValue;
  }

  return audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
      .map((e) =>
          audioItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodFromJson(
              e.toString()))
      .toList();
}

String? audioItemIdHls1PlaylistIdSegmentIdContainerGetContextNullableToJson(
    enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext?
        audioItemIdHls1PlaylistIdSegmentIdContainerGetContext) {
  return audioItemIdHls1PlaylistIdSegmentIdContainerGetContext?.value;
}

String? audioItemIdHls1PlaylistIdSegmentIdContainerGetContextToJson(
    enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext
        audioItemIdHls1PlaylistIdSegmentIdContainerGetContext) {
  return audioItemIdHls1PlaylistIdSegmentIdContainerGetContext.value;
}

enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext
    audioItemIdHls1PlaylistIdSegmentIdContainerGetContextFromJson(
  Object? audioItemIdHls1PlaylistIdSegmentIdContainerGetContext, [
  enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext? defaultValue,
]) {
  return enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext.values
          .firstWhereOrNull((e) =>
              e.value ==
              audioItemIdHls1PlaylistIdSegmentIdContainerGetContext) ??
      defaultValue ??
      enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext
          .swaggerGeneratedUnknown;
}

enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext?
    audioItemIdHls1PlaylistIdSegmentIdContainerGetContextNullableFromJson(
  Object? audioItemIdHls1PlaylistIdSegmentIdContainerGetContext, [
  enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext? defaultValue,
]) {
  if (audioItemIdHls1PlaylistIdSegmentIdContainerGetContext == null) {
    return null;
  }
  return enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext.values
          .firstWhereOrNull((e) =>
              e.value ==
              audioItemIdHls1PlaylistIdSegmentIdContainerGetContext) ??
      defaultValue;
}

String audioItemIdHls1PlaylistIdSegmentIdContainerGetContextExplodedListToJson(
    List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
        audioItemIdHls1PlaylistIdSegmentIdContainerGetContext) {
  return audioItemIdHls1PlaylistIdSegmentIdContainerGetContext
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> audioItemIdHls1PlaylistIdSegmentIdContainerGetContextListToJson(
    List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
        audioItemIdHls1PlaylistIdSegmentIdContainerGetContext) {
  if (audioItemIdHls1PlaylistIdSegmentIdContainerGetContext == null) {
    return [];
  }

  return audioItemIdHls1PlaylistIdSegmentIdContainerGetContext
      .map((e) => e.value!)
      .toList();
}

List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext>
    audioItemIdHls1PlaylistIdSegmentIdContainerGetContextListFromJson(
  List? audioItemIdHls1PlaylistIdSegmentIdContainerGetContext, [
  List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
      defaultValue,
]) {
  if (audioItemIdHls1PlaylistIdSegmentIdContainerGetContext == null) {
    return defaultValue ?? [];
  }

  return audioItemIdHls1PlaylistIdSegmentIdContainerGetContext
      .map((e) => audioItemIdHls1PlaylistIdSegmentIdContainerGetContextFromJson(
          e.toString()))
      .toList();
}

List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
    audioItemIdHls1PlaylistIdSegmentIdContainerGetContextNullableListFromJson(
  List? audioItemIdHls1PlaylistIdSegmentIdContainerGetContext, [
  List<enums.AudioItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
      defaultValue,
]) {
  if (audioItemIdHls1PlaylistIdSegmentIdContainerGetContext == null) {
    return defaultValue;
  }

  return audioItemIdHls1PlaylistIdSegmentIdContainerGetContext
      .map((e) => audioItemIdHls1PlaylistIdSegmentIdContainerGetContextFromJson(
          e.toString()))
      .toList();
}

String? audioItemIdMainM3u8GetSubtitleMethodNullableToJson(
    enums.AudioItemIdMainM3u8GetSubtitleMethod?
        audioItemIdMainM3u8GetSubtitleMethod) {
  return audioItemIdMainM3u8GetSubtitleMethod?.value;
}

String? audioItemIdMainM3u8GetSubtitleMethodToJson(
    enums.AudioItemIdMainM3u8GetSubtitleMethod
        audioItemIdMainM3u8GetSubtitleMethod) {
  return audioItemIdMainM3u8GetSubtitleMethod.value;
}

enums.AudioItemIdMainM3u8GetSubtitleMethod
    audioItemIdMainM3u8GetSubtitleMethodFromJson(
  Object? audioItemIdMainM3u8GetSubtitleMethod, [
  enums.AudioItemIdMainM3u8GetSubtitleMethod? defaultValue,
]) {
  return enums.AudioItemIdMainM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMainM3u8GetSubtitleMethod) ??
      defaultValue ??
      enums.AudioItemIdMainM3u8GetSubtitleMethod.swaggerGeneratedUnknown;
}

enums.AudioItemIdMainM3u8GetSubtitleMethod?
    audioItemIdMainM3u8GetSubtitleMethodNullableFromJson(
  Object? audioItemIdMainM3u8GetSubtitleMethod, [
  enums.AudioItemIdMainM3u8GetSubtitleMethod? defaultValue,
]) {
  if (audioItemIdMainM3u8GetSubtitleMethod == null) {
    return null;
  }
  return enums.AudioItemIdMainM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMainM3u8GetSubtitleMethod) ??
      defaultValue;
}

String audioItemIdMainM3u8GetSubtitleMethodExplodedListToJson(
    List<enums.AudioItemIdMainM3u8GetSubtitleMethod>?
        audioItemIdMainM3u8GetSubtitleMethod) {
  return audioItemIdMainM3u8GetSubtitleMethod?.map((e) => e.value!).join(',') ??
      '';
}

List<String> audioItemIdMainM3u8GetSubtitleMethodListToJson(
    List<enums.AudioItemIdMainM3u8GetSubtitleMethod>?
        audioItemIdMainM3u8GetSubtitleMethod) {
  if (audioItemIdMainM3u8GetSubtitleMethod == null) {
    return [];
  }

  return audioItemIdMainM3u8GetSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.AudioItemIdMainM3u8GetSubtitleMethod>
    audioItemIdMainM3u8GetSubtitleMethodListFromJson(
  List? audioItemIdMainM3u8GetSubtitleMethod, [
  List<enums.AudioItemIdMainM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdMainM3u8GetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return audioItemIdMainM3u8GetSubtitleMethod
      .map((e) => audioItemIdMainM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdMainM3u8GetSubtitleMethod>?
    audioItemIdMainM3u8GetSubtitleMethodNullableListFromJson(
  List? audioItemIdMainM3u8GetSubtitleMethod, [
  List<enums.AudioItemIdMainM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdMainM3u8GetSubtitleMethod == null) {
    return defaultValue;
  }

  return audioItemIdMainM3u8GetSubtitleMethod
      .map((e) => audioItemIdMainM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? audioItemIdMainM3u8GetContextNullableToJson(
    enums.AudioItemIdMainM3u8GetContext? audioItemIdMainM3u8GetContext) {
  return audioItemIdMainM3u8GetContext?.value;
}

String? audioItemIdMainM3u8GetContextToJson(
    enums.AudioItemIdMainM3u8GetContext audioItemIdMainM3u8GetContext) {
  return audioItemIdMainM3u8GetContext.value;
}

enums.AudioItemIdMainM3u8GetContext audioItemIdMainM3u8GetContextFromJson(
  Object? audioItemIdMainM3u8GetContext, [
  enums.AudioItemIdMainM3u8GetContext? defaultValue,
]) {
  return enums.AudioItemIdMainM3u8GetContext.values
          .firstWhereOrNull((e) => e.value == audioItemIdMainM3u8GetContext) ??
      defaultValue ??
      enums.AudioItemIdMainM3u8GetContext.swaggerGeneratedUnknown;
}

enums.AudioItemIdMainM3u8GetContext?
    audioItemIdMainM3u8GetContextNullableFromJson(
  Object? audioItemIdMainM3u8GetContext, [
  enums.AudioItemIdMainM3u8GetContext? defaultValue,
]) {
  if (audioItemIdMainM3u8GetContext == null) {
    return null;
  }
  return enums.AudioItemIdMainM3u8GetContext.values
          .firstWhereOrNull((e) => e.value == audioItemIdMainM3u8GetContext) ??
      defaultValue;
}

String audioItemIdMainM3u8GetContextExplodedListToJson(
    List<enums.AudioItemIdMainM3u8GetContext>? audioItemIdMainM3u8GetContext) {
  return audioItemIdMainM3u8GetContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> audioItemIdMainM3u8GetContextListToJson(
    List<enums.AudioItemIdMainM3u8GetContext>? audioItemIdMainM3u8GetContext) {
  if (audioItemIdMainM3u8GetContext == null) {
    return [];
  }

  return audioItemIdMainM3u8GetContext.map((e) => e.value!).toList();
}

List<enums.AudioItemIdMainM3u8GetContext>
    audioItemIdMainM3u8GetContextListFromJson(
  List? audioItemIdMainM3u8GetContext, [
  List<enums.AudioItemIdMainM3u8GetContext>? defaultValue,
]) {
  if (audioItemIdMainM3u8GetContext == null) {
    return defaultValue ?? [];
  }

  return audioItemIdMainM3u8GetContext
      .map((e) => audioItemIdMainM3u8GetContextFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdMainM3u8GetContext>?
    audioItemIdMainM3u8GetContextNullableListFromJson(
  List? audioItemIdMainM3u8GetContext, [
  List<enums.AudioItemIdMainM3u8GetContext>? defaultValue,
]) {
  if (audioItemIdMainM3u8GetContext == null) {
    return defaultValue;
  }

  return audioItemIdMainM3u8GetContext
      .map((e) => audioItemIdMainM3u8GetContextFromJson(e.toString()))
      .toList();
}

String? audioItemIdMasterM3u8GetSubtitleMethodNullableToJson(
    enums.AudioItemIdMasterM3u8GetSubtitleMethod?
        audioItemIdMasterM3u8GetSubtitleMethod) {
  return audioItemIdMasterM3u8GetSubtitleMethod?.value;
}

String? audioItemIdMasterM3u8GetSubtitleMethodToJson(
    enums.AudioItemIdMasterM3u8GetSubtitleMethod
        audioItemIdMasterM3u8GetSubtitleMethod) {
  return audioItemIdMasterM3u8GetSubtitleMethod.value;
}

enums.AudioItemIdMasterM3u8GetSubtitleMethod
    audioItemIdMasterM3u8GetSubtitleMethodFromJson(
  Object? audioItemIdMasterM3u8GetSubtitleMethod, [
  enums.AudioItemIdMasterM3u8GetSubtitleMethod? defaultValue,
]) {
  return enums.AudioItemIdMasterM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMasterM3u8GetSubtitleMethod) ??
      defaultValue ??
      enums.AudioItemIdMasterM3u8GetSubtitleMethod.swaggerGeneratedUnknown;
}

enums.AudioItemIdMasterM3u8GetSubtitleMethod?
    audioItemIdMasterM3u8GetSubtitleMethodNullableFromJson(
  Object? audioItemIdMasterM3u8GetSubtitleMethod, [
  enums.AudioItemIdMasterM3u8GetSubtitleMethod? defaultValue,
]) {
  if (audioItemIdMasterM3u8GetSubtitleMethod == null) {
    return null;
  }
  return enums.AudioItemIdMasterM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMasterM3u8GetSubtitleMethod) ??
      defaultValue;
}

String audioItemIdMasterM3u8GetSubtitleMethodExplodedListToJson(
    List<enums.AudioItemIdMasterM3u8GetSubtitleMethod>?
        audioItemIdMasterM3u8GetSubtitleMethod) {
  return audioItemIdMasterM3u8GetSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> audioItemIdMasterM3u8GetSubtitleMethodListToJson(
    List<enums.AudioItemIdMasterM3u8GetSubtitleMethod>?
        audioItemIdMasterM3u8GetSubtitleMethod) {
  if (audioItemIdMasterM3u8GetSubtitleMethod == null) {
    return [];
  }

  return audioItemIdMasterM3u8GetSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.AudioItemIdMasterM3u8GetSubtitleMethod>
    audioItemIdMasterM3u8GetSubtitleMethodListFromJson(
  List? audioItemIdMasterM3u8GetSubtitleMethod, [
  List<enums.AudioItemIdMasterM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdMasterM3u8GetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return audioItemIdMasterM3u8GetSubtitleMethod
      .map((e) => audioItemIdMasterM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdMasterM3u8GetSubtitleMethod>?
    audioItemIdMasterM3u8GetSubtitleMethodNullableListFromJson(
  List? audioItemIdMasterM3u8GetSubtitleMethod, [
  List<enums.AudioItemIdMasterM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdMasterM3u8GetSubtitleMethod == null) {
    return defaultValue;
  }

  return audioItemIdMasterM3u8GetSubtitleMethod
      .map((e) => audioItemIdMasterM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? audioItemIdMasterM3u8GetContextNullableToJson(
    enums.AudioItemIdMasterM3u8GetContext? audioItemIdMasterM3u8GetContext) {
  return audioItemIdMasterM3u8GetContext?.value;
}

String? audioItemIdMasterM3u8GetContextToJson(
    enums.AudioItemIdMasterM3u8GetContext audioItemIdMasterM3u8GetContext) {
  return audioItemIdMasterM3u8GetContext.value;
}

enums.AudioItemIdMasterM3u8GetContext audioItemIdMasterM3u8GetContextFromJson(
  Object? audioItemIdMasterM3u8GetContext, [
  enums.AudioItemIdMasterM3u8GetContext? defaultValue,
]) {
  return enums.AudioItemIdMasterM3u8GetContext.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMasterM3u8GetContext) ??
      defaultValue ??
      enums.AudioItemIdMasterM3u8GetContext.swaggerGeneratedUnknown;
}

enums.AudioItemIdMasterM3u8GetContext?
    audioItemIdMasterM3u8GetContextNullableFromJson(
  Object? audioItemIdMasterM3u8GetContext, [
  enums.AudioItemIdMasterM3u8GetContext? defaultValue,
]) {
  if (audioItemIdMasterM3u8GetContext == null) {
    return null;
  }
  return enums.AudioItemIdMasterM3u8GetContext.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMasterM3u8GetContext) ??
      defaultValue;
}

String audioItemIdMasterM3u8GetContextExplodedListToJson(
    List<enums.AudioItemIdMasterM3u8GetContext>?
        audioItemIdMasterM3u8GetContext) {
  return audioItemIdMasterM3u8GetContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> audioItemIdMasterM3u8GetContextListToJson(
    List<enums.AudioItemIdMasterM3u8GetContext>?
        audioItemIdMasterM3u8GetContext) {
  if (audioItemIdMasterM3u8GetContext == null) {
    return [];
  }

  return audioItemIdMasterM3u8GetContext.map((e) => e.value!).toList();
}

List<enums.AudioItemIdMasterM3u8GetContext>
    audioItemIdMasterM3u8GetContextListFromJson(
  List? audioItemIdMasterM3u8GetContext, [
  List<enums.AudioItemIdMasterM3u8GetContext>? defaultValue,
]) {
  if (audioItemIdMasterM3u8GetContext == null) {
    return defaultValue ?? [];
  }

  return audioItemIdMasterM3u8GetContext
      .map((e) => audioItemIdMasterM3u8GetContextFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdMasterM3u8GetContext>?
    audioItemIdMasterM3u8GetContextNullableListFromJson(
  List? audioItemIdMasterM3u8GetContext, [
  List<enums.AudioItemIdMasterM3u8GetContext>? defaultValue,
]) {
  if (audioItemIdMasterM3u8GetContext == null) {
    return defaultValue;
  }

  return audioItemIdMasterM3u8GetContext
      .map((e) => audioItemIdMasterM3u8GetContextFromJson(e.toString()))
      .toList();
}

String? audioItemIdMasterM3u8HeadSubtitleMethodNullableToJson(
    enums.AudioItemIdMasterM3u8HeadSubtitleMethod?
        audioItemIdMasterM3u8HeadSubtitleMethod) {
  return audioItemIdMasterM3u8HeadSubtitleMethod?.value;
}

String? audioItemIdMasterM3u8HeadSubtitleMethodToJson(
    enums.AudioItemIdMasterM3u8HeadSubtitleMethod
        audioItemIdMasterM3u8HeadSubtitleMethod) {
  return audioItemIdMasterM3u8HeadSubtitleMethod.value;
}

enums.AudioItemIdMasterM3u8HeadSubtitleMethod
    audioItemIdMasterM3u8HeadSubtitleMethodFromJson(
  Object? audioItemIdMasterM3u8HeadSubtitleMethod, [
  enums.AudioItemIdMasterM3u8HeadSubtitleMethod? defaultValue,
]) {
  return enums.AudioItemIdMasterM3u8HeadSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMasterM3u8HeadSubtitleMethod) ??
      defaultValue ??
      enums.AudioItemIdMasterM3u8HeadSubtitleMethod.swaggerGeneratedUnknown;
}

enums.AudioItemIdMasterM3u8HeadSubtitleMethod?
    audioItemIdMasterM3u8HeadSubtitleMethodNullableFromJson(
  Object? audioItemIdMasterM3u8HeadSubtitleMethod, [
  enums.AudioItemIdMasterM3u8HeadSubtitleMethod? defaultValue,
]) {
  if (audioItemIdMasterM3u8HeadSubtitleMethod == null) {
    return null;
  }
  return enums.AudioItemIdMasterM3u8HeadSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMasterM3u8HeadSubtitleMethod) ??
      defaultValue;
}

String audioItemIdMasterM3u8HeadSubtitleMethodExplodedListToJson(
    List<enums.AudioItemIdMasterM3u8HeadSubtitleMethod>?
        audioItemIdMasterM3u8HeadSubtitleMethod) {
  return audioItemIdMasterM3u8HeadSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> audioItemIdMasterM3u8HeadSubtitleMethodListToJson(
    List<enums.AudioItemIdMasterM3u8HeadSubtitleMethod>?
        audioItemIdMasterM3u8HeadSubtitleMethod) {
  if (audioItemIdMasterM3u8HeadSubtitleMethod == null) {
    return [];
  }

  return audioItemIdMasterM3u8HeadSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.AudioItemIdMasterM3u8HeadSubtitleMethod>
    audioItemIdMasterM3u8HeadSubtitleMethodListFromJson(
  List? audioItemIdMasterM3u8HeadSubtitleMethod, [
  List<enums.AudioItemIdMasterM3u8HeadSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdMasterM3u8HeadSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return audioItemIdMasterM3u8HeadSubtitleMethod
      .map((e) => audioItemIdMasterM3u8HeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdMasterM3u8HeadSubtitleMethod>?
    audioItemIdMasterM3u8HeadSubtitleMethodNullableListFromJson(
  List? audioItemIdMasterM3u8HeadSubtitleMethod, [
  List<enums.AudioItemIdMasterM3u8HeadSubtitleMethod>? defaultValue,
]) {
  if (audioItemIdMasterM3u8HeadSubtitleMethod == null) {
    return defaultValue;
  }

  return audioItemIdMasterM3u8HeadSubtitleMethod
      .map((e) => audioItemIdMasterM3u8HeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? audioItemIdMasterM3u8HeadContextNullableToJson(
    enums.AudioItemIdMasterM3u8HeadContext? audioItemIdMasterM3u8HeadContext) {
  return audioItemIdMasterM3u8HeadContext?.value;
}

String? audioItemIdMasterM3u8HeadContextToJson(
    enums.AudioItemIdMasterM3u8HeadContext audioItemIdMasterM3u8HeadContext) {
  return audioItemIdMasterM3u8HeadContext.value;
}

enums.AudioItemIdMasterM3u8HeadContext audioItemIdMasterM3u8HeadContextFromJson(
  Object? audioItemIdMasterM3u8HeadContext, [
  enums.AudioItemIdMasterM3u8HeadContext? defaultValue,
]) {
  return enums.AudioItemIdMasterM3u8HeadContext.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMasterM3u8HeadContext) ??
      defaultValue ??
      enums.AudioItemIdMasterM3u8HeadContext.swaggerGeneratedUnknown;
}

enums.AudioItemIdMasterM3u8HeadContext?
    audioItemIdMasterM3u8HeadContextNullableFromJson(
  Object? audioItemIdMasterM3u8HeadContext, [
  enums.AudioItemIdMasterM3u8HeadContext? defaultValue,
]) {
  if (audioItemIdMasterM3u8HeadContext == null) {
    return null;
  }
  return enums.AudioItemIdMasterM3u8HeadContext.values.firstWhereOrNull(
          (e) => e.value == audioItemIdMasterM3u8HeadContext) ??
      defaultValue;
}

String audioItemIdMasterM3u8HeadContextExplodedListToJson(
    List<enums.AudioItemIdMasterM3u8HeadContext>?
        audioItemIdMasterM3u8HeadContext) {
  return audioItemIdMasterM3u8HeadContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> audioItemIdMasterM3u8HeadContextListToJson(
    List<enums.AudioItemIdMasterM3u8HeadContext>?
        audioItemIdMasterM3u8HeadContext) {
  if (audioItemIdMasterM3u8HeadContext == null) {
    return [];
  }

  return audioItemIdMasterM3u8HeadContext.map((e) => e.value!).toList();
}

List<enums.AudioItemIdMasterM3u8HeadContext>
    audioItemIdMasterM3u8HeadContextListFromJson(
  List? audioItemIdMasterM3u8HeadContext, [
  List<enums.AudioItemIdMasterM3u8HeadContext>? defaultValue,
]) {
  if (audioItemIdMasterM3u8HeadContext == null) {
    return defaultValue ?? [];
  }

  return audioItemIdMasterM3u8HeadContext
      .map((e) => audioItemIdMasterM3u8HeadContextFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdMasterM3u8HeadContext>?
    audioItemIdMasterM3u8HeadContextNullableListFromJson(
  List? audioItemIdMasterM3u8HeadContext, [
  List<enums.AudioItemIdMasterM3u8HeadContext>? defaultValue,
]) {
  if (audioItemIdMasterM3u8HeadContext == null) {
    return defaultValue;
  }

  return audioItemIdMasterM3u8HeadContext
      .map((e) => audioItemIdMasterM3u8HeadContextFromJson(e.toString()))
      .toList();
}

String?
    videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodNullableToJson(
        enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
            videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) {
  return videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?.value;
}

String? videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodToJson(
    enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
        videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) {
  return videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod.value;
}

enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
    videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodFromJson(
  Object? videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod, [
  enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
      defaultValue,
]) {
  return enums
          .VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod.values
          .firstWhereOrNull((e) =>
              e.value ==
              videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) ??
      defaultValue ??
      enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
          .swaggerGeneratedUnknown;
}

enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
    videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodNullableFromJson(
  Object? videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod, [
  enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod?
      defaultValue,
]) {
  if (videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod == null) {
    return null;
  }
  return enums
          .VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod.values
          .firstWhereOrNull((e) =>
              e.value ==
              videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) ??
      defaultValue;
}

String
    videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodExplodedListToJson(
        List<
                enums
                .VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
            videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) {
  return videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodListToJson(
        List<
                enums
                .VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
            videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod) {
  if (videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod == null) {
    return [];
  }

  return videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
      .map((e) => e.value!)
      .toList();
}

List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>
    videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodListFromJson(
  List? videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod, [
  List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
      defaultValue,
]) {
  if (videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
      .map((e) =>
          videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodFromJson(
              e.toString()))
      .toList();
}

List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
    videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodNullableListFromJson(
  List? videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod, [
  List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod>?
      defaultValue,
]) {
  if (videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod == null) {
    return defaultValue;
  }

  return videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethod
      .map((e) =>
          videosItemIdHls1PlaylistIdSegmentIdContainerGetSubtitleMethodFromJson(
              e.toString()))
      .toList();
}

String? videosItemIdHls1PlaylistIdSegmentIdContainerGetContextNullableToJson(
    enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext?
        videosItemIdHls1PlaylistIdSegmentIdContainerGetContext) {
  return videosItemIdHls1PlaylistIdSegmentIdContainerGetContext?.value;
}

String? videosItemIdHls1PlaylistIdSegmentIdContainerGetContextToJson(
    enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext
        videosItemIdHls1PlaylistIdSegmentIdContainerGetContext) {
  return videosItemIdHls1PlaylistIdSegmentIdContainerGetContext.value;
}

enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext
    videosItemIdHls1PlaylistIdSegmentIdContainerGetContextFromJson(
  Object? videosItemIdHls1PlaylistIdSegmentIdContainerGetContext, [
  enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext? defaultValue,
]) {
  return enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext.values
          .firstWhereOrNull((e) =>
              e.value ==
              videosItemIdHls1PlaylistIdSegmentIdContainerGetContext) ??
      defaultValue ??
      enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext
          .swaggerGeneratedUnknown;
}

enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext?
    videosItemIdHls1PlaylistIdSegmentIdContainerGetContextNullableFromJson(
  Object? videosItemIdHls1PlaylistIdSegmentIdContainerGetContext, [
  enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext? defaultValue,
]) {
  if (videosItemIdHls1PlaylistIdSegmentIdContainerGetContext == null) {
    return null;
  }
  return enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext.values
          .firstWhereOrNull((e) =>
              e.value ==
              videosItemIdHls1PlaylistIdSegmentIdContainerGetContext) ??
      defaultValue;
}

String videosItemIdHls1PlaylistIdSegmentIdContainerGetContextExplodedListToJson(
    List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
        videosItemIdHls1PlaylistIdSegmentIdContainerGetContext) {
  return videosItemIdHls1PlaylistIdSegmentIdContainerGetContext
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> videosItemIdHls1PlaylistIdSegmentIdContainerGetContextListToJson(
    List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
        videosItemIdHls1PlaylistIdSegmentIdContainerGetContext) {
  if (videosItemIdHls1PlaylistIdSegmentIdContainerGetContext == null) {
    return [];
  }

  return videosItemIdHls1PlaylistIdSegmentIdContainerGetContext
      .map((e) => e.value!)
      .toList();
}

List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext>
    videosItemIdHls1PlaylistIdSegmentIdContainerGetContextListFromJson(
  List? videosItemIdHls1PlaylistIdSegmentIdContainerGetContext, [
  List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
      defaultValue,
]) {
  if (videosItemIdHls1PlaylistIdSegmentIdContainerGetContext == null) {
    return defaultValue ?? [];
  }

  return videosItemIdHls1PlaylistIdSegmentIdContainerGetContext
      .map((e) =>
          videosItemIdHls1PlaylistIdSegmentIdContainerGetContextFromJson(
              e.toString()))
      .toList();
}

List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
    videosItemIdHls1PlaylistIdSegmentIdContainerGetContextNullableListFromJson(
  List? videosItemIdHls1PlaylistIdSegmentIdContainerGetContext, [
  List<enums.VideosItemIdHls1PlaylistIdSegmentIdContainerGetContext>?
      defaultValue,
]) {
  if (videosItemIdHls1PlaylistIdSegmentIdContainerGetContext == null) {
    return defaultValue;
  }

  return videosItemIdHls1PlaylistIdSegmentIdContainerGetContext
      .map((e) =>
          videosItemIdHls1PlaylistIdSegmentIdContainerGetContextFromJson(
              e.toString()))
      .toList();
}

String? videosItemIdLiveM3u8GetSubtitleMethodNullableToJson(
    enums.VideosItemIdLiveM3u8GetSubtitleMethod?
        videosItemIdLiveM3u8GetSubtitleMethod) {
  return videosItemIdLiveM3u8GetSubtitleMethod?.value;
}

String? videosItemIdLiveM3u8GetSubtitleMethodToJson(
    enums.VideosItemIdLiveM3u8GetSubtitleMethod
        videosItemIdLiveM3u8GetSubtitleMethod) {
  return videosItemIdLiveM3u8GetSubtitleMethod.value;
}

enums.VideosItemIdLiveM3u8GetSubtitleMethod
    videosItemIdLiveM3u8GetSubtitleMethodFromJson(
  Object? videosItemIdLiveM3u8GetSubtitleMethod, [
  enums.VideosItemIdLiveM3u8GetSubtitleMethod? defaultValue,
]) {
  return enums.VideosItemIdLiveM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdLiveM3u8GetSubtitleMethod) ??
      defaultValue ??
      enums.VideosItemIdLiveM3u8GetSubtitleMethod.swaggerGeneratedUnknown;
}

enums.VideosItemIdLiveM3u8GetSubtitleMethod?
    videosItemIdLiveM3u8GetSubtitleMethodNullableFromJson(
  Object? videosItemIdLiveM3u8GetSubtitleMethod, [
  enums.VideosItemIdLiveM3u8GetSubtitleMethod? defaultValue,
]) {
  if (videosItemIdLiveM3u8GetSubtitleMethod == null) {
    return null;
  }
  return enums.VideosItemIdLiveM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdLiveM3u8GetSubtitleMethod) ??
      defaultValue;
}

String videosItemIdLiveM3u8GetSubtitleMethodExplodedListToJson(
    List<enums.VideosItemIdLiveM3u8GetSubtitleMethod>?
        videosItemIdLiveM3u8GetSubtitleMethod) {
  return videosItemIdLiveM3u8GetSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> videosItemIdLiveM3u8GetSubtitleMethodListToJson(
    List<enums.VideosItemIdLiveM3u8GetSubtitleMethod>?
        videosItemIdLiveM3u8GetSubtitleMethod) {
  if (videosItemIdLiveM3u8GetSubtitleMethod == null) {
    return [];
  }

  return videosItemIdLiveM3u8GetSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.VideosItemIdLiveM3u8GetSubtitleMethod>
    videosItemIdLiveM3u8GetSubtitleMethodListFromJson(
  List? videosItemIdLiveM3u8GetSubtitleMethod, [
  List<enums.VideosItemIdLiveM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdLiveM3u8GetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return videosItemIdLiveM3u8GetSubtitleMethod
      .map((e) => videosItemIdLiveM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdLiveM3u8GetSubtitleMethod>?
    videosItemIdLiveM3u8GetSubtitleMethodNullableListFromJson(
  List? videosItemIdLiveM3u8GetSubtitleMethod, [
  List<enums.VideosItemIdLiveM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdLiveM3u8GetSubtitleMethod == null) {
    return defaultValue;
  }

  return videosItemIdLiveM3u8GetSubtitleMethod
      .map((e) => videosItemIdLiveM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? videosItemIdLiveM3u8GetContextNullableToJson(
    enums.VideosItemIdLiveM3u8GetContext? videosItemIdLiveM3u8GetContext) {
  return videosItemIdLiveM3u8GetContext?.value;
}

String? videosItemIdLiveM3u8GetContextToJson(
    enums.VideosItemIdLiveM3u8GetContext videosItemIdLiveM3u8GetContext) {
  return videosItemIdLiveM3u8GetContext.value;
}

enums.VideosItemIdLiveM3u8GetContext videosItemIdLiveM3u8GetContextFromJson(
  Object? videosItemIdLiveM3u8GetContext, [
  enums.VideosItemIdLiveM3u8GetContext? defaultValue,
]) {
  return enums.VideosItemIdLiveM3u8GetContext.values
          .firstWhereOrNull((e) => e.value == videosItemIdLiveM3u8GetContext) ??
      defaultValue ??
      enums.VideosItemIdLiveM3u8GetContext.swaggerGeneratedUnknown;
}

enums.VideosItemIdLiveM3u8GetContext?
    videosItemIdLiveM3u8GetContextNullableFromJson(
  Object? videosItemIdLiveM3u8GetContext, [
  enums.VideosItemIdLiveM3u8GetContext? defaultValue,
]) {
  if (videosItemIdLiveM3u8GetContext == null) {
    return null;
  }
  return enums.VideosItemIdLiveM3u8GetContext.values
          .firstWhereOrNull((e) => e.value == videosItemIdLiveM3u8GetContext) ??
      defaultValue;
}

String videosItemIdLiveM3u8GetContextExplodedListToJson(
    List<enums.VideosItemIdLiveM3u8GetContext>?
        videosItemIdLiveM3u8GetContext) {
  return videosItemIdLiveM3u8GetContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> videosItemIdLiveM3u8GetContextListToJson(
    List<enums.VideosItemIdLiveM3u8GetContext>?
        videosItemIdLiveM3u8GetContext) {
  if (videosItemIdLiveM3u8GetContext == null) {
    return [];
  }

  return videosItemIdLiveM3u8GetContext.map((e) => e.value!).toList();
}

List<enums.VideosItemIdLiveM3u8GetContext>
    videosItemIdLiveM3u8GetContextListFromJson(
  List? videosItemIdLiveM3u8GetContext, [
  List<enums.VideosItemIdLiveM3u8GetContext>? defaultValue,
]) {
  if (videosItemIdLiveM3u8GetContext == null) {
    return defaultValue ?? [];
  }

  return videosItemIdLiveM3u8GetContext
      .map((e) => videosItemIdLiveM3u8GetContextFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdLiveM3u8GetContext>?
    videosItemIdLiveM3u8GetContextNullableListFromJson(
  List? videosItemIdLiveM3u8GetContext, [
  List<enums.VideosItemIdLiveM3u8GetContext>? defaultValue,
]) {
  if (videosItemIdLiveM3u8GetContext == null) {
    return defaultValue;
  }

  return videosItemIdLiveM3u8GetContext
      .map((e) => videosItemIdLiveM3u8GetContextFromJson(e.toString()))
      .toList();
}

String? videosItemIdMainM3u8GetSubtitleMethodNullableToJson(
    enums.VideosItemIdMainM3u8GetSubtitleMethod?
        videosItemIdMainM3u8GetSubtitleMethod) {
  return videosItemIdMainM3u8GetSubtitleMethod?.value;
}

String? videosItemIdMainM3u8GetSubtitleMethodToJson(
    enums.VideosItemIdMainM3u8GetSubtitleMethod
        videosItemIdMainM3u8GetSubtitleMethod) {
  return videosItemIdMainM3u8GetSubtitleMethod.value;
}

enums.VideosItemIdMainM3u8GetSubtitleMethod
    videosItemIdMainM3u8GetSubtitleMethodFromJson(
  Object? videosItemIdMainM3u8GetSubtitleMethod, [
  enums.VideosItemIdMainM3u8GetSubtitleMethod? defaultValue,
]) {
  return enums.VideosItemIdMainM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMainM3u8GetSubtitleMethod) ??
      defaultValue ??
      enums.VideosItemIdMainM3u8GetSubtitleMethod.swaggerGeneratedUnknown;
}

enums.VideosItemIdMainM3u8GetSubtitleMethod?
    videosItemIdMainM3u8GetSubtitleMethodNullableFromJson(
  Object? videosItemIdMainM3u8GetSubtitleMethod, [
  enums.VideosItemIdMainM3u8GetSubtitleMethod? defaultValue,
]) {
  if (videosItemIdMainM3u8GetSubtitleMethod == null) {
    return null;
  }
  return enums.VideosItemIdMainM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMainM3u8GetSubtitleMethod) ??
      defaultValue;
}

String videosItemIdMainM3u8GetSubtitleMethodExplodedListToJson(
    List<enums.VideosItemIdMainM3u8GetSubtitleMethod>?
        videosItemIdMainM3u8GetSubtitleMethod) {
  return videosItemIdMainM3u8GetSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> videosItemIdMainM3u8GetSubtitleMethodListToJson(
    List<enums.VideosItemIdMainM3u8GetSubtitleMethod>?
        videosItemIdMainM3u8GetSubtitleMethod) {
  if (videosItemIdMainM3u8GetSubtitleMethod == null) {
    return [];
  }

  return videosItemIdMainM3u8GetSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.VideosItemIdMainM3u8GetSubtitleMethod>
    videosItemIdMainM3u8GetSubtitleMethodListFromJson(
  List? videosItemIdMainM3u8GetSubtitleMethod, [
  List<enums.VideosItemIdMainM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdMainM3u8GetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return videosItemIdMainM3u8GetSubtitleMethod
      .map((e) => videosItemIdMainM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdMainM3u8GetSubtitleMethod>?
    videosItemIdMainM3u8GetSubtitleMethodNullableListFromJson(
  List? videosItemIdMainM3u8GetSubtitleMethod, [
  List<enums.VideosItemIdMainM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdMainM3u8GetSubtitleMethod == null) {
    return defaultValue;
  }

  return videosItemIdMainM3u8GetSubtitleMethod
      .map((e) => videosItemIdMainM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? videosItemIdMainM3u8GetContextNullableToJson(
    enums.VideosItemIdMainM3u8GetContext? videosItemIdMainM3u8GetContext) {
  return videosItemIdMainM3u8GetContext?.value;
}

String? videosItemIdMainM3u8GetContextToJson(
    enums.VideosItemIdMainM3u8GetContext videosItemIdMainM3u8GetContext) {
  return videosItemIdMainM3u8GetContext.value;
}

enums.VideosItemIdMainM3u8GetContext videosItemIdMainM3u8GetContextFromJson(
  Object? videosItemIdMainM3u8GetContext, [
  enums.VideosItemIdMainM3u8GetContext? defaultValue,
]) {
  return enums.VideosItemIdMainM3u8GetContext.values
          .firstWhereOrNull((e) => e.value == videosItemIdMainM3u8GetContext) ??
      defaultValue ??
      enums.VideosItemIdMainM3u8GetContext.swaggerGeneratedUnknown;
}

enums.VideosItemIdMainM3u8GetContext?
    videosItemIdMainM3u8GetContextNullableFromJson(
  Object? videosItemIdMainM3u8GetContext, [
  enums.VideosItemIdMainM3u8GetContext? defaultValue,
]) {
  if (videosItemIdMainM3u8GetContext == null) {
    return null;
  }
  return enums.VideosItemIdMainM3u8GetContext.values
          .firstWhereOrNull((e) => e.value == videosItemIdMainM3u8GetContext) ??
      defaultValue;
}

String videosItemIdMainM3u8GetContextExplodedListToJson(
    List<enums.VideosItemIdMainM3u8GetContext>?
        videosItemIdMainM3u8GetContext) {
  return videosItemIdMainM3u8GetContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> videosItemIdMainM3u8GetContextListToJson(
    List<enums.VideosItemIdMainM3u8GetContext>?
        videosItemIdMainM3u8GetContext) {
  if (videosItemIdMainM3u8GetContext == null) {
    return [];
  }

  return videosItemIdMainM3u8GetContext.map((e) => e.value!).toList();
}

List<enums.VideosItemIdMainM3u8GetContext>
    videosItemIdMainM3u8GetContextListFromJson(
  List? videosItemIdMainM3u8GetContext, [
  List<enums.VideosItemIdMainM3u8GetContext>? defaultValue,
]) {
  if (videosItemIdMainM3u8GetContext == null) {
    return defaultValue ?? [];
  }

  return videosItemIdMainM3u8GetContext
      .map((e) => videosItemIdMainM3u8GetContextFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdMainM3u8GetContext>?
    videosItemIdMainM3u8GetContextNullableListFromJson(
  List? videosItemIdMainM3u8GetContext, [
  List<enums.VideosItemIdMainM3u8GetContext>? defaultValue,
]) {
  if (videosItemIdMainM3u8GetContext == null) {
    return defaultValue;
  }

  return videosItemIdMainM3u8GetContext
      .map((e) => videosItemIdMainM3u8GetContextFromJson(e.toString()))
      .toList();
}

String? videosItemIdMasterM3u8GetSubtitleMethodNullableToJson(
    enums.VideosItemIdMasterM3u8GetSubtitleMethod?
        videosItemIdMasterM3u8GetSubtitleMethod) {
  return videosItemIdMasterM3u8GetSubtitleMethod?.value;
}

String? videosItemIdMasterM3u8GetSubtitleMethodToJson(
    enums.VideosItemIdMasterM3u8GetSubtitleMethod
        videosItemIdMasterM3u8GetSubtitleMethod) {
  return videosItemIdMasterM3u8GetSubtitleMethod.value;
}

enums.VideosItemIdMasterM3u8GetSubtitleMethod
    videosItemIdMasterM3u8GetSubtitleMethodFromJson(
  Object? videosItemIdMasterM3u8GetSubtitleMethod, [
  enums.VideosItemIdMasterM3u8GetSubtitleMethod? defaultValue,
]) {
  return enums.VideosItemIdMasterM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMasterM3u8GetSubtitleMethod) ??
      defaultValue ??
      enums.VideosItemIdMasterM3u8GetSubtitleMethod.swaggerGeneratedUnknown;
}

enums.VideosItemIdMasterM3u8GetSubtitleMethod?
    videosItemIdMasterM3u8GetSubtitleMethodNullableFromJson(
  Object? videosItemIdMasterM3u8GetSubtitleMethod, [
  enums.VideosItemIdMasterM3u8GetSubtitleMethod? defaultValue,
]) {
  if (videosItemIdMasterM3u8GetSubtitleMethod == null) {
    return null;
  }
  return enums.VideosItemIdMasterM3u8GetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMasterM3u8GetSubtitleMethod) ??
      defaultValue;
}

String videosItemIdMasterM3u8GetSubtitleMethodExplodedListToJson(
    List<enums.VideosItemIdMasterM3u8GetSubtitleMethod>?
        videosItemIdMasterM3u8GetSubtitleMethod) {
  return videosItemIdMasterM3u8GetSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> videosItemIdMasterM3u8GetSubtitleMethodListToJson(
    List<enums.VideosItemIdMasterM3u8GetSubtitleMethod>?
        videosItemIdMasterM3u8GetSubtitleMethod) {
  if (videosItemIdMasterM3u8GetSubtitleMethod == null) {
    return [];
  }

  return videosItemIdMasterM3u8GetSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.VideosItemIdMasterM3u8GetSubtitleMethod>
    videosItemIdMasterM3u8GetSubtitleMethodListFromJson(
  List? videosItemIdMasterM3u8GetSubtitleMethod, [
  List<enums.VideosItemIdMasterM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdMasterM3u8GetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return videosItemIdMasterM3u8GetSubtitleMethod
      .map((e) => videosItemIdMasterM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdMasterM3u8GetSubtitleMethod>?
    videosItemIdMasterM3u8GetSubtitleMethodNullableListFromJson(
  List? videosItemIdMasterM3u8GetSubtitleMethod, [
  List<enums.VideosItemIdMasterM3u8GetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdMasterM3u8GetSubtitleMethod == null) {
    return defaultValue;
  }

  return videosItemIdMasterM3u8GetSubtitleMethod
      .map((e) => videosItemIdMasterM3u8GetSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? videosItemIdMasterM3u8GetContextNullableToJson(
    enums.VideosItemIdMasterM3u8GetContext? videosItemIdMasterM3u8GetContext) {
  return videosItemIdMasterM3u8GetContext?.value;
}

String? videosItemIdMasterM3u8GetContextToJson(
    enums.VideosItemIdMasterM3u8GetContext videosItemIdMasterM3u8GetContext) {
  return videosItemIdMasterM3u8GetContext.value;
}

enums.VideosItemIdMasterM3u8GetContext videosItemIdMasterM3u8GetContextFromJson(
  Object? videosItemIdMasterM3u8GetContext, [
  enums.VideosItemIdMasterM3u8GetContext? defaultValue,
]) {
  return enums.VideosItemIdMasterM3u8GetContext.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMasterM3u8GetContext) ??
      defaultValue ??
      enums.VideosItemIdMasterM3u8GetContext.swaggerGeneratedUnknown;
}

enums.VideosItemIdMasterM3u8GetContext?
    videosItemIdMasterM3u8GetContextNullableFromJson(
  Object? videosItemIdMasterM3u8GetContext, [
  enums.VideosItemIdMasterM3u8GetContext? defaultValue,
]) {
  if (videosItemIdMasterM3u8GetContext == null) {
    return null;
  }
  return enums.VideosItemIdMasterM3u8GetContext.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMasterM3u8GetContext) ??
      defaultValue;
}

String videosItemIdMasterM3u8GetContextExplodedListToJson(
    List<enums.VideosItemIdMasterM3u8GetContext>?
        videosItemIdMasterM3u8GetContext) {
  return videosItemIdMasterM3u8GetContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> videosItemIdMasterM3u8GetContextListToJson(
    List<enums.VideosItemIdMasterM3u8GetContext>?
        videosItemIdMasterM3u8GetContext) {
  if (videosItemIdMasterM3u8GetContext == null) {
    return [];
  }

  return videosItemIdMasterM3u8GetContext.map((e) => e.value!).toList();
}

List<enums.VideosItemIdMasterM3u8GetContext>
    videosItemIdMasterM3u8GetContextListFromJson(
  List? videosItemIdMasterM3u8GetContext, [
  List<enums.VideosItemIdMasterM3u8GetContext>? defaultValue,
]) {
  if (videosItemIdMasterM3u8GetContext == null) {
    return defaultValue ?? [];
  }

  return videosItemIdMasterM3u8GetContext
      .map((e) => videosItemIdMasterM3u8GetContextFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdMasterM3u8GetContext>?
    videosItemIdMasterM3u8GetContextNullableListFromJson(
  List? videosItemIdMasterM3u8GetContext, [
  List<enums.VideosItemIdMasterM3u8GetContext>? defaultValue,
]) {
  if (videosItemIdMasterM3u8GetContext == null) {
    return defaultValue;
  }

  return videosItemIdMasterM3u8GetContext
      .map((e) => videosItemIdMasterM3u8GetContextFromJson(e.toString()))
      .toList();
}

String? videosItemIdMasterM3u8HeadSubtitleMethodNullableToJson(
    enums.VideosItemIdMasterM3u8HeadSubtitleMethod?
        videosItemIdMasterM3u8HeadSubtitleMethod) {
  return videosItemIdMasterM3u8HeadSubtitleMethod?.value;
}

String? videosItemIdMasterM3u8HeadSubtitleMethodToJson(
    enums.VideosItemIdMasterM3u8HeadSubtitleMethod
        videosItemIdMasterM3u8HeadSubtitleMethod) {
  return videosItemIdMasterM3u8HeadSubtitleMethod.value;
}

enums.VideosItemIdMasterM3u8HeadSubtitleMethod
    videosItemIdMasterM3u8HeadSubtitleMethodFromJson(
  Object? videosItemIdMasterM3u8HeadSubtitleMethod, [
  enums.VideosItemIdMasterM3u8HeadSubtitleMethod? defaultValue,
]) {
  return enums.VideosItemIdMasterM3u8HeadSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMasterM3u8HeadSubtitleMethod) ??
      defaultValue ??
      enums.VideosItemIdMasterM3u8HeadSubtitleMethod.swaggerGeneratedUnknown;
}

enums.VideosItemIdMasterM3u8HeadSubtitleMethod?
    videosItemIdMasterM3u8HeadSubtitleMethodNullableFromJson(
  Object? videosItemIdMasterM3u8HeadSubtitleMethod, [
  enums.VideosItemIdMasterM3u8HeadSubtitleMethod? defaultValue,
]) {
  if (videosItemIdMasterM3u8HeadSubtitleMethod == null) {
    return null;
  }
  return enums.VideosItemIdMasterM3u8HeadSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMasterM3u8HeadSubtitleMethod) ??
      defaultValue;
}

String videosItemIdMasterM3u8HeadSubtitleMethodExplodedListToJson(
    List<enums.VideosItemIdMasterM3u8HeadSubtitleMethod>?
        videosItemIdMasterM3u8HeadSubtitleMethod) {
  return videosItemIdMasterM3u8HeadSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> videosItemIdMasterM3u8HeadSubtitleMethodListToJson(
    List<enums.VideosItemIdMasterM3u8HeadSubtitleMethod>?
        videosItemIdMasterM3u8HeadSubtitleMethod) {
  if (videosItemIdMasterM3u8HeadSubtitleMethod == null) {
    return [];
  }

  return videosItemIdMasterM3u8HeadSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.VideosItemIdMasterM3u8HeadSubtitleMethod>
    videosItemIdMasterM3u8HeadSubtitleMethodListFromJson(
  List? videosItemIdMasterM3u8HeadSubtitleMethod, [
  List<enums.VideosItemIdMasterM3u8HeadSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdMasterM3u8HeadSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return videosItemIdMasterM3u8HeadSubtitleMethod
      .map(
          (e) => videosItemIdMasterM3u8HeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdMasterM3u8HeadSubtitleMethod>?
    videosItemIdMasterM3u8HeadSubtitleMethodNullableListFromJson(
  List? videosItemIdMasterM3u8HeadSubtitleMethod, [
  List<enums.VideosItemIdMasterM3u8HeadSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdMasterM3u8HeadSubtitleMethod == null) {
    return defaultValue;
  }

  return videosItemIdMasterM3u8HeadSubtitleMethod
      .map(
          (e) => videosItemIdMasterM3u8HeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? videosItemIdMasterM3u8HeadContextNullableToJson(
    enums.VideosItemIdMasterM3u8HeadContext?
        videosItemIdMasterM3u8HeadContext) {
  return videosItemIdMasterM3u8HeadContext?.value;
}

String? videosItemIdMasterM3u8HeadContextToJson(
    enums.VideosItemIdMasterM3u8HeadContext videosItemIdMasterM3u8HeadContext) {
  return videosItemIdMasterM3u8HeadContext.value;
}

enums.VideosItemIdMasterM3u8HeadContext
    videosItemIdMasterM3u8HeadContextFromJson(
  Object? videosItemIdMasterM3u8HeadContext, [
  enums.VideosItemIdMasterM3u8HeadContext? defaultValue,
]) {
  return enums.VideosItemIdMasterM3u8HeadContext.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMasterM3u8HeadContext) ??
      defaultValue ??
      enums.VideosItemIdMasterM3u8HeadContext.swaggerGeneratedUnknown;
}

enums.VideosItemIdMasterM3u8HeadContext?
    videosItemIdMasterM3u8HeadContextNullableFromJson(
  Object? videosItemIdMasterM3u8HeadContext, [
  enums.VideosItemIdMasterM3u8HeadContext? defaultValue,
]) {
  if (videosItemIdMasterM3u8HeadContext == null) {
    return null;
  }
  return enums.VideosItemIdMasterM3u8HeadContext.values.firstWhereOrNull(
          (e) => e.value == videosItemIdMasterM3u8HeadContext) ??
      defaultValue;
}

String videosItemIdMasterM3u8HeadContextExplodedListToJson(
    List<enums.VideosItemIdMasterM3u8HeadContext>?
        videosItemIdMasterM3u8HeadContext) {
  return videosItemIdMasterM3u8HeadContext?.map((e) => e.value!).join(',') ??
      '';
}

List<String> videosItemIdMasterM3u8HeadContextListToJson(
    List<enums.VideosItemIdMasterM3u8HeadContext>?
        videosItemIdMasterM3u8HeadContext) {
  if (videosItemIdMasterM3u8HeadContext == null) {
    return [];
  }

  return videosItemIdMasterM3u8HeadContext.map((e) => e.value!).toList();
}

List<enums.VideosItemIdMasterM3u8HeadContext>
    videosItemIdMasterM3u8HeadContextListFromJson(
  List? videosItemIdMasterM3u8HeadContext, [
  List<enums.VideosItemIdMasterM3u8HeadContext>? defaultValue,
]) {
  if (videosItemIdMasterM3u8HeadContext == null) {
    return defaultValue ?? [];
  }

  return videosItemIdMasterM3u8HeadContext
      .map((e) => videosItemIdMasterM3u8HeadContextFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdMasterM3u8HeadContext>?
    videosItemIdMasterM3u8HeadContextNullableListFromJson(
  List? videosItemIdMasterM3u8HeadContext, [
  List<enums.VideosItemIdMasterM3u8HeadContext>? defaultValue,
]) {
  if (videosItemIdMasterM3u8HeadContext == null) {
    return defaultValue;
  }

  return videosItemIdMasterM3u8HeadContext
      .map((e) => videosItemIdMasterM3u8HeadContextFromJson(e.toString()))
      .toList();
}

String? artistsNameImagesImageTypeImageIndexGetImageTypeNullableToJson(
    enums.ArtistsNameImagesImageTypeImageIndexGetImageType?
        artistsNameImagesImageTypeImageIndexGetImageType) {
  return artistsNameImagesImageTypeImageIndexGetImageType?.value;
}

String? artistsNameImagesImageTypeImageIndexGetImageTypeToJson(
    enums.ArtistsNameImagesImageTypeImageIndexGetImageType
        artistsNameImagesImageTypeImageIndexGetImageType) {
  return artistsNameImagesImageTypeImageIndexGetImageType.value;
}

enums.ArtistsNameImagesImageTypeImageIndexGetImageType
    artistsNameImagesImageTypeImageIndexGetImageTypeFromJson(
  Object? artistsNameImagesImageTypeImageIndexGetImageType, [
  enums.ArtistsNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  return enums.ArtistsNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == artistsNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue ??
      enums.ArtistsNameImagesImageTypeImageIndexGetImageType
          .swaggerGeneratedUnknown;
}

enums.ArtistsNameImagesImageTypeImageIndexGetImageType?
    artistsNameImagesImageTypeImageIndexGetImageTypeNullableFromJson(
  Object? artistsNameImagesImageTypeImageIndexGetImageType, [
  enums.ArtistsNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexGetImageType == null) {
    return null;
  }
  return enums.ArtistsNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == artistsNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue;
}

String artistsNameImagesImageTypeImageIndexGetImageTypeExplodedListToJson(
    List<enums.ArtistsNameImagesImageTypeImageIndexGetImageType>?
        artistsNameImagesImageTypeImageIndexGetImageType) {
  return artistsNameImagesImageTypeImageIndexGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> artistsNameImagesImageTypeImageIndexGetImageTypeListToJson(
    List<enums.ArtistsNameImagesImageTypeImageIndexGetImageType>?
        artistsNameImagesImageTypeImageIndexGetImageType) {
  if (artistsNameImagesImageTypeImageIndexGetImageType == null) {
    return [];
  }

  return artistsNameImagesImageTypeImageIndexGetImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.ArtistsNameImagesImageTypeImageIndexGetImageType>
    artistsNameImagesImageTypeImageIndexGetImageTypeListFromJson(
  List? artistsNameImagesImageTypeImageIndexGetImageType, [
  List<enums.ArtistsNameImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue ?? [];
  }

  return artistsNameImagesImageTypeImageIndexGetImageType
      .map((e) => artistsNameImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.ArtistsNameImagesImageTypeImageIndexGetImageType>?
    artistsNameImagesImageTypeImageIndexGetImageTypeNullableListFromJson(
  List? artistsNameImagesImageTypeImageIndexGetImageType, [
  List<enums.ArtistsNameImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue;
  }

  return artistsNameImagesImageTypeImageIndexGetImageType
      .map((e) => artistsNameImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

String? artistsNameImagesImageTypeImageIndexGetFormatNullableToJson(
    enums.ArtistsNameImagesImageTypeImageIndexGetFormat?
        artistsNameImagesImageTypeImageIndexGetFormat) {
  return artistsNameImagesImageTypeImageIndexGetFormat?.value;
}

String? artistsNameImagesImageTypeImageIndexGetFormatToJson(
    enums.ArtistsNameImagesImageTypeImageIndexGetFormat
        artistsNameImagesImageTypeImageIndexGetFormat) {
  return artistsNameImagesImageTypeImageIndexGetFormat.value;
}

enums.ArtistsNameImagesImageTypeImageIndexGetFormat
    artistsNameImagesImageTypeImageIndexGetFormatFromJson(
  Object? artistsNameImagesImageTypeImageIndexGetFormat, [
  enums.ArtistsNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  return enums.ArtistsNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == artistsNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue ??
      enums.ArtistsNameImagesImageTypeImageIndexGetFormat
          .swaggerGeneratedUnknown;
}

enums.ArtistsNameImagesImageTypeImageIndexGetFormat?
    artistsNameImagesImageTypeImageIndexGetFormatNullableFromJson(
  Object? artistsNameImagesImageTypeImageIndexGetFormat, [
  enums.ArtistsNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexGetFormat == null) {
    return null;
  }
  return enums.ArtistsNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == artistsNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue;
}

String artistsNameImagesImageTypeImageIndexGetFormatExplodedListToJson(
    List<enums.ArtistsNameImagesImageTypeImageIndexGetFormat>?
        artistsNameImagesImageTypeImageIndexGetFormat) {
  return artistsNameImagesImageTypeImageIndexGetFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> artistsNameImagesImageTypeImageIndexGetFormatListToJson(
    List<enums.ArtistsNameImagesImageTypeImageIndexGetFormat>?
        artistsNameImagesImageTypeImageIndexGetFormat) {
  if (artistsNameImagesImageTypeImageIndexGetFormat == null) {
    return [];
  }

  return artistsNameImagesImageTypeImageIndexGetFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.ArtistsNameImagesImageTypeImageIndexGetFormat>
    artistsNameImagesImageTypeImageIndexGetFormatListFromJson(
  List? artistsNameImagesImageTypeImageIndexGetFormat, [
  List<enums.ArtistsNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue ?? [];
  }

  return artistsNameImagesImageTypeImageIndexGetFormat
      .map((e) =>
          artistsNameImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.ArtistsNameImagesImageTypeImageIndexGetFormat>?
    artistsNameImagesImageTypeImageIndexGetFormatNullableListFromJson(
  List? artistsNameImagesImageTypeImageIndexGetFormat, [
  List<enums.ArtistsNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue;
  }

  return artistsNameImagesImageTypeImageIndexGetFormat
      .map((e) =>
          artistsNameImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

String? artistsNameImagesImageTypeImageIndexHeadImageTypeNullableToJson(
    enums.ArtistsNameImagesImageTypeImageIndexHeadImageType?
        artistsNameImagesImageTypeImageIndexHeadImageType) {
  return artistsNameImagesImageTypeImageIndexHeadImageType?.value;
}

String? artistsNameImagesImageTypeImageIndexHeadImageTypeToJson(
    enums.ArtistsNameImagesImageTypeImageIndexHeadImageType
        artistsNameImagesImageTypeImageIndexHeadImageType) {
  return artistsNameImagesImageTypeImageIndexHeadImageType.value;
}

enums.ArtistsNameImagesImageTypeImageIndexHeadImageType
    artistsNameImagesImageTypeImageIndexHeadImageTypeFromJson(
  Object? artistsNameImagesImageTypeImageIndexHeadImageType, [
  enums.ArtistsNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  return enums.ArtistsNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == artistsNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue ??
      enums.ArtistsNameImagesImageTypeImageIndexHeadImageType
          .swaggerGeneratedUnknown;
}

enums.ArtistsNameImagesImageTypeImageIndexHeadImageType?
    artistsNameImagesImageTypeImageIndexHeadImageTypeNullableFromJson(
  Object? artistsNameImagesImageTypeImageIndexHeadImageType, [
  enums.ArtistsNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexHeadImageType == null) {
    return null;
  }
  return enums.ArtistsNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == artistsNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue;
}

String artistsNameImagesImageTypeImageIndexHeadImageTypeExplodedListToJson(
    List<enums.ArtistsNameImagesImageTypeImageIndexHeadImageType>?
        artistsNameImagesImageTypeImageIndexHeadImageType) {
  return artistsNameImagesImageTypeImageIndexHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> artistsNameImagesImageTypeImageIndexHeadImageTypeListToJson(
    List<enums.ArtistsNameImagesImageTypeImageIndexHeadImageType>?
        artistsNameImagesImageTypeImageIndexHeadImageType) {
  if (artistsNameImagesImageTypeImageIndexHeadImageType == null) {
    return [];
  }

  return artistsNameImagesImageTypeImageIndexHeadImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.ArtistsNameImagesImageTypeImageIndexHeadImageType>
    artistsNameImagesImageTypeImageIndexHeadImageTypeListFromJson(
  List? artistsNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.ArtistsNameImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue ?? [];
  }

  return artistsNameImagesImageTypeImageIndexHeadImageType
      .map((e) => artistsNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.ArtistsNameImagesImageTypeImageIndexHeadImageType>?
    artistsNameImagesImageTypeImageIndexHeadImageTypeNullableListFromJson(
  List? artistsNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.ArtistsNameImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue;
  }

  return artistsNameImagesImageTypeImageIndexHeadImageType
      .map((e) => artistsNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

String? artistsNameImagesImageTypeImageIndexHeadFormatNullableToJson(
    enums.ArtistsNameImagesImageTypeImageIndexHeadFormat?
        artistsNameImagesImageTypeImageIndexHeadFormat) {
  return artistsNameImagesImageTypeImageIndexHeadFormat?.value;
}

String? artistsNameImagesImageTypeImageIndexHeadFormatToJson(
    enums.ArtistsNameImagesImageTypeImageIndexHeadFormat
        artistsNameImagesImageTypeImageIndexHeadFormat) {
  return artistsNameImagesImageTypeImageIndexHeadFormat.value;
}

enums.ArtistsNameImagesImageTypeImageIndexHeadFormat
    artistsNameImagesImageTypeImageIndexHeadFormatFromJson(
  Object? artistsNameImagesImageTypeImageIndexHeadFormat, [
  enums.ArtistsNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  return enums.ArtistsNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == artistsNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue ??
      enums.ArtistsNameImagesImageTypeImageIndexHeadFormat
          .swaggerGeneratedUnknown;
}

enums.ArtistsNameImagesImageTypeImageIndexHeadFormat?
    artistsNameImagesImageTypeImageIndexHeadFormatNullableFromJson(
  Object? artistsNameImagesImageTypeImageIndexHeadFormat, [
  enums.ArtistsNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexHeadFormat == null) {
    return null;
  }
  return enums.ArtistsNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == artistsNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue;
}

String artistsNameImagesImageTypeImageIndexHeadFormatExplodedListToJson(
    List<enums.ArtistsNameImagesImageTypeImageIndexHeadFormat>?
        artistsNameImagesImageTypeImageIndexHeadFormat) {
  return artistsNameImagesImageTypeImageIndexHeadFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> artistsNameImagesImageTypeImageIndexHeadFormatListToJson(
    List<enums.ArtistsNameImagesImageTypeImageIndexHeadFormat>?
        artistsNameImagesImageTypeImageIndexHeadFormat) {
  if (artistsNameImagesImageTypeImageIndexHeadFormat == null) {
    return [];
  }

  return artistsNameImagesImageTypeImageIndexHeadFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.ArtistsNameImagesImageTypeImageIndexHeadFormat>
    artistsNameImagesImageTypeImageIndexHeadFormatListFromJson(
  List? artistsNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.ArtistsNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue ?? [];
  }

  return artistsNameImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          artistsNameImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.ArtistsNameImagesImageTypeImageIndexHeadFormat>?
    artistsNameImagesImageTypeImageIndexHeadFormatNullableListFromJson(
  List? artistsNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.ArtistsNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (artistsNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue;
  }

  return artistsNameImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          artistsNameImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

String? brandingSplashscreenGetFormatNullableToJson(
    enums.BrandingSplashscreenGetFormat? brandingSplashscreenGetFormat) {
  return brandingSplashscreenGetFormat?.value;
}

String? brandingSplashscreenGetFormatToJson(
    enums.BrandingSplashscreenGetFormat brandingSplashscreenGetFormat) {
  return brandingSplashscreenGetFormat.value;
}

enums.BrandingSplashscreenGetFormat brandingSplashscreenGetFormatFromJson(
  Object? brandingSplashscreenGetFormat, [
  enums.BrandingSplashscreenGetFormat? defaultValue,
]) {
  return enums.BrandingSplashscreenGetFormat.values
          .firstWhereOrNull((e) => e.value == brandingSplashscreenGetFormat) ??
      defaultValue ??
      enums.BrandingSplashscreenGetFormat.swaggerGeneratedUnknown;
}

enums.BrandingSplashscreenGetFormat?
    brandingSplashscreenGetFormatNullableFromJson(
  Object? brandingSplashscreenGetFormat, [
  enums.BrandingSplashscreenGetFormat? defaultValue,
]) {
  if (brandingSplashscreenGetFormat == null) {
    return null;
  }
  return enums.BrandingSplashscreenGetFormat.values
          .firstWhereOrNull((e) => e.value == brandingSplashscreenGetFormat) ??
      defaultValue;
}

String brandingSplashscreenGetFormatExplodedListToJson(
    List<enums.BrandingSplashscreenGetFormat>? brandingSplashscreenGetFormat) {
  return brandingSplashscreenGetFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> brandingSplashscreenGetFormatListToJson(
    List<enums.BrandingSplashscreenGetFormat>? brandingSplashscreenGetFormat) {
  if (brandingSplashscreenGetFormat == null) {
    return [];
  }

  return brandingSplashscreenGetFormat.map((e) => e.value!).toList();
}

List<enums.BrandingSplashscreenGetFormat>
    brandingSplashscreenGetFormatListFromJson(
  List? brandingSplashscreenGetFormat, [
  List<enums.BrandingSplashscreenGetFormat>? defaultValue,
]) {
  if (brandingSplashscreenGetFormat == null) {
    return defaultValue ?? [];
  }

  return brandingSplashscreenGetFormat
      .map((e) => brandingSplashscreenGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.BrandingSplashscreenGetFormat>?
    brandingSplashscreenGetFormatNullableListFromJson(
  List? brandingSplashscreenGetFormat, [
  List<enums.BrandingSplashscreenGetFormat>? defaultValue,
]) {
  if (brandingSplashscreenGetFormat == null) {
    return defaultValue;
  }

  return brandingSplashscreenGetFormat
      .map((e) => brandingSplashscreenGetFormatFromJson(e.toString()))
      .toList();
}

String? genresNameImagesImageTypeGetImageTypeNullableToJson(
    enums.GenresNameImagesImageTypeGetImageType?
        genresNameImagesImageTypeGetImageType) {
  return genresNameImagesImageTypeGetImageType?.value;
}

String? genresNameImagesImageTypeGetImageTypeToJson(
    enums.GenresNameImagesImageTypeGetImageType
        genresNameImagesImageTypeGetImageType) {
  return genresNameImagesImageTypeGetImageType.value;
}

enums.GenresNameImagesImageTypeGetImageType
    genresNameImagesImageTypeGetImageTypeFromJson(
  Object? genresNameImagesImageTypeGetImageType, [
  enums.GenresNameImagesImageTypeGetImageType? defaultValue,
]) {
  return enums.GenresNameImagesImageTypeGetImageType.values.firstWhereOrNull(
          (e) => e.value == genresNameImagesImageTypeGetImageType) ??
      defaultValue ??
      enums.GenresNameImagesImageTypeGetImageType.swaggerGeneratedUnknown;
}

enums.GenresNameImagesImageTypeGetImageType?
    genresNameImagesImageTypeGetImageTypeNullableFromJson(
  Object? genresNameImagesImageTypeGetImageType, [
  enums.GenresNameImagesImageTypeGetImageType? defaultValue,
]) {
  if (genresNameImagesImageTypeGetImageType == null) {
    return null;
  }
  return enums.GenresNameImagesImageTypeGetImageType.values.firstWhereOrNull(
          (e) => e.value == genresNameImagesImageTypeGetImageType) ??
      defaultValue;
}

String genresNameImagesImageTypeGetImageTypeExplodedListToJson(
    List<enums.GenresNameImagesImageTypeGetImageType>?
        genresNameImagesImageTypeGetImageType) {
  return genresNameImagesImageTypeGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> genresNameImagesImageTypeGetImageTypeListToJson(
    List<enums.GenresNameImagesImageTypeGetImageType>?
        genresNameImagesImageTypeGetImageType) {
  if (genresNameImagesImageTypeGetImageType == null) {
    return [];
  }

  return genresNameImagesImageTypeGetImageType.map((e) => e.value!).toList();
}

List<enums.GenresNameImagesImageTypeGetImageType>
    genresNameImagesImageTypeGetImageTypeListFromJson(
  List? genresNameImagesImageTypeGetImageType, [
  List<enums.GenresNameImagesImageTypeGetImageType>? defaultValue,
]) {
  if (genresNameImagesImageTypeGetImageType == null) {
    return defaultValue ?? [];
  }

  return genresNameImagesImageTypeGetImageType
      .map((e) => genresNameImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.GenresNameImagesImageTypeGetImageType>?
    genresNameImagesImageTypeGetImageTypeNullableListFromJson(
  List? genresNameImagesImageTypeGetImageType, [
  List<enums.GenresNameImagesImageTypeGetImageType>? defaultValue,
]) {
  if (genresNameImagesImageTypeGetImageType == null) {
    return defaultValue;
  }

  return genresNameImagesImageTypeGetImageType
      .map((e) => genresNameImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

String? genresNameImagesImageTypeGetFormatNullableToJson(
    enums.GenresNameImagesImageTypeGetFormat?
        genresNameImagesImageTypeGetFormat) {
  return genresNameImagesImageTypeGetFormat?.value;
}

String? genresNameImagesImageTypeGetFormatToJson(
    enums.GenresNameImagesImageTypeGetFormat
        genresNameImagesImageTypeGetFormat) {
  return genresNameImagesImageTypeGetFormat.value;
}

enums.GenresNameImagesImageTypeGetFormat
    genresNameImagesImageTypeGetFormatFromJson(
  Object? genresNameImagesImageTypeGetFormat, [
  enums.GenresNameImagesImageTypeGetFormat? defaultValue,
]) {
  return enums.GenresNameImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == genresNameImagesImageTypeGetFormat) ??
      defaultValue ??
      enums.GenresNameImagesImageTypeGetFormat.swaggerGeneratedUnknown;
}

enums.GenresNameImagesImageTypeGetFormat?
    genresNameImagesImageTypeGetFormatNullableFromJson(
  Object? genresNameImagesImageTypeGetFormat, [
  enums.GenresNameImagesImageTypeGetFormat? defaultValue,
]) {
  if (genresNameImagesImageTypeGetFormat == null) {
    return null;
  }
  return enums.GenresNameImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == genresNameImagesImageTypeGetFormat) ??
      defaultValue;
}

String genresNameImagesImageTypeGetFormatExplodedListToJson(
    List<enums.GenresNameImagesImageTypeGetFormat>?
        genresNameImagesImageTypeGetFormat) {
  return genresNameImagesImageTypeGetFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<String> genresNameImagesImageTypeGetFormatListToJson(
    List<enums.GenresNameImagesImageTypeGetFormat>?
        genresNameImagesImageTypeGetFormat) {
  if (genresNameImagesImageTypeGetFormat == null) {
    return [];
  }

  return genresNameImagesImageTypeGetFormat.map((e) => e.value!).toList();
}

List<enums.GenresNameImagesImageTypeGetFormat>
    genresNameImagesImageTypeGetFormatListFromJson(
  List? genresNameImagesImageTypeGetFormat, [
  List<enums.GenresNameImagesImageTypeGetFormat>? defaultValue,
]) {
  if (genresNameImagesImageTypeGetFormat == null) {
    return defaultValue ?? [];
  }

  return genresNameImagesImageTypeGetFormat
      .map((e) => genresNameImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.GenresNameImagesImageTypeGetFormat>?
    genresNameImagesImageTypeGetFormatNullableListFromJson(
  List? genresNameImagesImageTypeGetFormat, [
  List<enums.GenresNameImagesImageTypeGetFormat>? defaultValue,
]) {
  if (genresNameImagesImageTypeGetFormat == null) {
    return defaultValue;
  }

  return genresNameImagesImageTypeGetFormat
      .map((e) => genresNameImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

String? genresNameImagesImageTypeHeadImageTypeNullableToJson(
    enums.GenresNameImagesImageTypeHeadImageType?
        genresNameImagesImageTypeHeadImageType) {
  return genresNameImagesImageTypeHeadImageType?.value;
}

String? genresNameImagesImageTypeHeadImageTypeToJson(
    enums.GenresNameImagesImageTypeHeadImageType
        genresNameImagesImageTypeHeadImageType) {
  return genresNameImagesImageTypeHeadImageType.value;
}

enums.GenresNameImagesImageTypeHeadImageType
    genresNameImagesImageTypeHeadImageTypeFromJson(
  Object? genresNameImagesImageTypeHeadImageType, [
  enums.GenresNameImagesImageTypeHeadImageType? defaultValue,
]) {
  return enums.GenresNameImagesImageTypeHeadImageType.values.firstWhereOrNull(
          (e) => e.value == genresNameImagesImageTypeHeadImageType) ??
      defaultValue ??
      enums.GenresNameImagesImageTypeHeadImageType.swaggerGeneratedUnknown;
}

enums.GenresNameImagesImageTypeHeadImageType?
    genresNameImagesImageTypeHeadImageTypeNullableFromJson(
  Object? genresNameImagesImageTypeHeadImageType, [
  enums.GenresNameImagesImageTypeHeadImageType? defaultValue,
]) {
  if (genresNameImagesImageTypeHeadImageType == null) {
    return null;
  }
  return enums.GenresNameImagesImageTypeHeadImageType.values.firstWhereOrNull(
          (e) => e.value == genresNameImagesImageTypeHeadImageType) ??
      defaultValue;
}

String genresNameImagesImageTypeHeadImageTypeExplodedListToJson(
    List<enums.GenresNameImagesImageTypeHeadImageType>?
        genresNameImagesImageTypeHeadImageType) {
  return genresNameImagesImageTypeHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> genresNameImagesImageTypeHeadImageTypeListToJson(
    List<enums.GenresNameImagesImageTypeHeadImageType>?
        genresNameImagesImageTypeHeadImageType) {
  if (genresNameImagesImageTypeHeadImageType == null) {
    return [];
  }

  return genresNameImagesImageTypeHeadImageType.map((e) => e.value!).toList();
}

List<enums.GenresNameImagesImageTypeHeadImageType>
    genresNameImagesImageTypeHeadImageTypeListFromJson(
  List? genresNameImagesImageTypeHeadImageType, [
  List<enums.GenresNameImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (genresNameImagesImageTypeHeadImageType == null) {
    return defaultValue ?? [];
  }

  return genresNameImagesImageTypeHeadImageType
      .map((e) => genresNameImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.GenresNameImagesImageTypeHeadImageType>?
    genresNameImagesImageTypeHeadImageTypeNullableListFromJson(
  List? genresNameImagesImageTypeHeadImageType, [
  List<enums.GenresNameImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (genresNameImagesImageTypeHeadImageType == null) {
    return defaultValue;
  }

  return genresNameImagesImageTypeHeadImageType
      .map((e) => genresNameImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

String? genresNameImagesImageTypeHeadFormatNullableToJson(
    enums.GenresNameImagesImageTypeHeadFormat?
        genresNameImagesImageTypeHeadFormat) {
  return genresNameImagesImageTypeHeadFormat?.value;
}

String? genresNameImagesImageTypeHeadFormatToJson(
    enums.GenresNameImagesImageTypeHeadFormat
        genresNameImagesImageTypeHeadFormat) {
  return genresNameImagesImageTypeHeadFormat.value;
}

enums.GenresNameImagesImageTypeHeadFormat
    genresNameImagesImageTypeHeadFormatFromJson(
  Object? genresNameImagesImageTypeHeadFormat, [
  enums.GenresNameImagesImageTypeHeadFormat? defaultValue,
]) {
  return enums.GenresNameImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == genresNameImagesImageTypeHeadFormat) ??
      defaultValue ??
      enums.GenresNameImagesImageTypeHeadFormat.swaggerGeneratedUnknown;
}

enums.GenresNameImagesImageTypeHeadFormat?
    genresNameImagesImageTypeHeadFormatNullableFromJson(
  Object? genresNameImagesImageTypeHeadFormat, [
  enums.GenresNameImagesImageTypeHeadFormat? defaultValue,
]) {
  if (genresNameImagesImageTypeHeadFormat == null) {
    return null;
  }
  return enums.GenresNameImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == genresNameImagesImageTypeHeadFormat) ??
      defaultValue;
}

String genresNameImagesImageTypeHeadFormatExplodedListToJson(
    List<enums.GenresNameImagesImageTypeHeadFormat>?
        genresNameImagesImageTypeHeadFormat) {
  return genresNameImagesImageTypeHeadFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<String> genresNameImagesImageTypeHeadFormatListToJson(
    List<enums.GenresNameImagesImageTypeHeadFormat>?
        genresNameImagesImageTypeHeadFormat) {
  if (genresNameImagesImageTypeHeadFormat == null) {
    return [];
  }

  return genresNameImagesImageTypeHeadFormat.map((e) => e.value!).toList();
}

List<enums.GenresNameImagesImageTypeHeadFormat>
    genresNameImagesImageTypeHeadFormatListFromJson(
  List? genresNameImagesImageTypeHeadFormat, [
  List<enums.GenresNameImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (genresNameImagesImageTypeHeadFormat == null) {
    return defaultValue ?? [];
  }

  return genresNameImagesImageTypeHeadFormat
      .map((e) => genresNameImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.GenresNameImagesImageTypeHeadFormat>?
    genresNameImagesImageTypeHeadFormatNullableListFromJson(
  List? genresNameImagesImageTypeHeadFormat, [
  List<enums.GenresNameImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (genresNameImagesImageTypeHeadFormat == null) {
    return defaultValue;
  }

  return genresNameImagesImageTypeHeadFormat
      .map((e) => genresNameImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

String? genresNameImagesImageTypeImageIndexGetImageTypeNullableToJson(
    enums.GenresNameImagesImageTypeImageIndexGetImageType?
        genresNameImagesImageTypeImageIndexGetImageType) {
  return genresNameImagesImageTypeImageIndexGetImageType?.value;
}

String? genresNameImagesImageTypeImageIndexGetImageTypeToJson(
    enums.GenresNameImagesImageTypeImageIndexGetImageType
        genresNameImagesImageTypeImageIndexGetImageType) {
  return genresNameImagesImageTypeImageIndexGetImageType.value;
}

enums.GenresNameImagesImageTypeImageIndexGetImageType
    genresNameImagesImageTypeImageIndexGetImageTypeFromJson(
  Object? genresNameImagesImageTypeImageIndexGetImageType, [
  enums.GenresNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  return enums.GenresNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == genresNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue ??
      enums.GenresNameImagesImageTypeImageIndexGetImageType
          .swaggerGeneratedUnknown;
}

enums.GenresNameImagesImageTypeImageIndexGetImageType?
    genresNameImagesImageTypeImageIndexGetImageTypeNullableFromJson(
  Object? genresNameImagesImageTypeImageIndexGetImageType, [
  enums.GenresNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexGetImageType == null) {
    return null;
  }
  return enums.GenresNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == genresNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue;
}

String genresNameImagesImageTypeImageIndexGetImageTypeExplodedListToJson(
    List<enums.GenresNameImagesImageTypeImageIndexGetImageType>?
        genresNameImagesImageTypeImageIndexGetImageType) {
  return genresNameImagesImageTypeImageIndexGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> genresNameImagesImageTypeImageIndexGetImageTypeListToJson(
    List<enums.GenresNameImagesImageTypeImageIndexGetImageType>?
        genresNameImagesImageTypeImageIndexGetImageType) {
  if (genresNameImagesImageTypeImageIndexGetImageType == null) {
    return [];
  }

  return genresNameImagesImageTypeImageIndexGetImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.GenresNameImagesImageTypeImageIndexGetImageType>
    genresNameImagesImageTypeImageIndexGetImageTypeListFromJson(
  List? genresNameImagesImageTypeImageIndexGetImageType, [
  List<enums.GenresNameImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue ?? [];
  }

  return genresNameImagesImageTypeImageIndexGetImageType
      .map((e) =>
          genresNameImagesImageTypeImageIndexGetImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.GenresNameImagesImageTypeImageIndexGetImageType>?
    genresNameImagesImageTypeImageIndexGetImageTypeNullableListFromJson(
  List? genresNameImagesImageTypeImageIndexGetImageType, [
  List<enums.GenresNameImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue;
  }

  return genresNameImagesImageTypeImageIndexGetImageType
      .map((e) =>
          genresNameImagesImageTypeImageIndexGetImageTypeFromJson(e.toString()))
      .toList();
}

String? genresNameImagesImageTypeImageIndexGetFormatNullableToJson(
    enums.GenresNameImagesImageTypeImageIndexGetFormat?
        genresNameImagesImageTypeImageIndexGetFormat) {
  return genresNameImagesImageTypeImageIndexGetFormat?.value;
}

String? genresNameImagesImageTypeImageIndexGetFormatToJson(
    enums.GenresNameImagesImageTypeImageIndexGetFormat
        genresNameImagesImageTypeImageIndexGetFormat) {
  return genresNameImagesImageTypeImageIndexGetFormat.value;
}

enums.GenresNameImagesImageTypeImageIndexGetFormat
    genresNameImagesImageTypeImageIndexGetFormatFromJson(
  Object? genresNameImagesImageTypeImageIndexGetFormat, [
  enums.GenresNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  return enums.GenresNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull(
              (e) => e.value == genresNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue ??
      enums
          .GenresNameImagesImageTypeImageIndexGetFormat.swaggerGeneratedUnknown;
}

enums.GenresNameImagesImageTypeImageIndexGetFormat?
    genresNameImagesImageTypeImageIndexGetFormatNullableFromJson(
  Object? genresNameImagesImageTypeImageIndexGetFormat, [
  enums.GenresNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexGetFormat == null) {
    return null;
  }
  return enums.GenresNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull(
              (e) => e.value == genresNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue;
}

String genresNameImagesImageTypeImageIndexGetFormatExplodedListToJson(
    List<enums.GenresNameImagesImageTypeImageIndexGetFormat>?
        genresNameImagesImageTypeImageIndexGetFormat) {
  return genresNameImagesImageTypeImageIndexGetFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> genresNameImagesImageTypeImageIndexGetFormatListToJson(
    List<enums.GenresNameImagesImageTypeImageIndexGetFormat>?
        genresNameImagesImageTypeImageIndexGetFormat) {
  if (genresNameImagesImageTypeImageIndexGetFormat == null) {
    return [];
  }

  return genresNameImagesImageTypeImageIndexGetFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.GenresNameImagesImageTypeImageIndexGetFormat>
    genresNameImagesImageTypeImageIndexGetFormatListFromJson(
  List? genresNameImagesImageTypeImageIndexGetFormat, [
  List<enums.GenresNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue ?? [];
  }

  return genresNameImagesImageTypeImageIndexGetFormat
      .map((e) =>
          genresNameImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.GenresNameImagesImageTypeImageIndexGetFormat>?
    genresNameImagesImageTypeImageIndexGetFormatNullableListFromJson(
  List? genresNameImagesImageTypeImageIndexGetFormat, [
  List<enums.GenresNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue;
  }

  return genresNameImagesImageTypeImageIndexGetFormat
      .map((e) =>
          genresNameImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

String? genresNameImagesImageTypeImageIndexHeadImageTypeNullableToJson(
    enums.GenresNameImagesImageTypeImageIndexHeadImageType?
        genresNameImagesImageTypeImageIndexHeadImageType) {
  return genresNameImagesImageTypeImageIndexHeadImageType?.value;
}

String? genresNameImagesImageTypeImageIndexHeadImageTypeToJson(
    enums.GenresNameImagesImageTypeImageIndexHeadImageType
        genresNameImagesImageTypeImageIndexHeadImageType) {
  return genresNameImagesImageTypeImageIndexHeadImageType.value;
}

enums.GenresNameImagesImageTypeImageIndexHeadImageType
    genresNameImagesImageTypeImageIndexHeadImageTypeFromJson(
  Object? genresNameImagesImageTypeImageIndexHeadImageType, [
  enums.GenresNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  return enums.GenresNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == genresNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue ??
      enums.GenresNameImagesImageTypeImageIndexHeadImageType
          .swaggerGeneratedUnknown;
}

enums.GenresNameImagesImageTypeImageIndexHeadImageType?
    genresNameImagesImageTypeImageIndexHeadImageTypeNullableFromJson(
  Object? genresNameImagesImageTypeImageIndexHeadImageType, [
  enums.GenresNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexHeadImageType == null) {
    return null;
  }
  return enums.GenresNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == genresNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue;
}

String genresNameImagesImageTypeImageIndexHeadImageTypeExplodedListToJson(
    List<enums.GenresNameImagesImageTypeImageIndexHeadImageType>?
        genresNameImagesImageTypeImageIndexHeadImageType) {
  return genresNameImagesImageTypeImageIndexHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> genresNameImagesImageTypeImageIndexHeadImageTypeListToJson(
    List<enums.GenresNameImagesImageTypeImageIndexHeadImageType>?
        genresNameImagesImageTypeImageIndexHeadImageType) {
  if (genresNameImagesImageTypeImageIndexHeadImageType == null) {
    return [];
  }

  return genresNameImagesImageTypeImageIndexHeadImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.GenresNameImagesImageTypeImageIndexHeadImageType>
    genresNameImagesImageTypeImageIndexHeadImageTypeListFromJson(
  List? genresNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.GenresNameImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue ?? [];
  }

  return genresNameImagesImageTypeImageIndexHeadImageType
      .map((e) => genresNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.GenresNameImagesImageTypeImageIndexHeadImageType>?
    genresNameImagesImageTypeImageIndexHeadImageTypeNullableListFromJson(
  List? genresNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.GenresNameImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue;
  }

  return genresNameImagesImageTypeImageIndexHeadImageType
      .map((e) => genresNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

String? genresNameImagesImageTypeImageIndexHeadFormatNullableToJson(
    enums.GenresNameImagesImageTypeImageIndexHeadFormat?
        genresNameImagesImageTypeImageIndexHeadFormat) {
  return genresNameImagesImageTypeImageIndexHeadFormat?.value;
}

String? genresNameImagesImageTypeImageIndexHeadFormatToJson(
    enums.GenresNameImagesImageTypeImageIndexHeadFormat
        genresNameImagesImageTypeImageIndexHeadFormat) {
  return genresNameImagesImageTypeImageIndexHeadFormat.value;
}

enums.GenresNameImagesImageTypeImageIndexHeadFormat
    genresNameImagesImageTypeImageIndexHeadFormatFromJson(
  Object? genresNameImagesImageTypeImageIndexHeadFormat, [
  enums.GenresNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  return enums.GenresNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == genresNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue ??
      enums.GenresNameImagesImageTypeImageIndexHeadFormat
          .swaggerGeneratedUnknown;
}

enums.GenresNameImagesImageTypeImageIndexHeadFormat?
    genresNameImagesImageTypeImageIndexHeadFormatNullableFromJson(
  Object? genresNameImagesImageTypeImageIndexHeadFormat, [
  enums.GenresNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexHeadFormat == null) {
    return null;
  }
  return enums.GenresNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == genresNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue;
}

String genresNameImagesImageTypeImageIndexHeadFormatExplodedListToJson(
    List<enums.GenresNameImagesImageTypeImageIndexHeadFormat>?
        genresNameImagesImageTypeImageIndexHeadFormat) {
  return genresNameImagesImageTypeImageIndexHeadFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> genresNameImagesImageTypeImageIndexHeadFormatListToJson(
    List<enums.GenresNameImagesImageTypeImageIndexHeadFormat>?
        genresNameImagesImageTypeImageIndexHeadFormat) {
  if (genresNameImagesImageTypeImageIndexHeadFormat == null) {
    return [];
  }

  return genresNameImagesImageTypeImageIndexHeadFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.GenresNameImagesImageTypeImageIndexHeadFormat>
    genresNameImagesImageTypeImageIndexHeadFormatListFromJson(
  List? genresNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.GenresNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue ?? [];
  }

  return genresNameImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          genresNameImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.GenresNameImagesImageTypeImageIndexHeadFormat>?
    genresNameImagesImageTypeImageIndexHeadFormatNullableListFromJson(
  List? genresNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.GenresNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (genresNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue;
  }

  return genresNameImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          genresNameImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeDeleteImageTypeNullableToJson(
    enums.ItemsItemIdImagesImageTypeDeleteImageType?
        itemsItemIdImagesImageTypeDeleteImageType) {
  return itemsItemIdImagesImageTypeDeleteImageType?.value;
}

String? itemsItemIdImagesImageTypeDeleteImageTypeToJson(
    enums.ItemsItemIdImagesImageTypeDeleteImageType
        itemsItemIdImagesImageTypeDeleteImageType) {
  return itemsItemIdImagesImageTypeDeleteImageType.value;
}

enums.ItemsItemIdImagesImageTypeDeleteImageType
    itemsItemIdImagesImageTypeDeleteImageTypeFromJson(
  Object? itemsItemIdImagesImageTypeDeleteImageType, [
  enums.ItemsItemIdImagesImageTypeDeleteImageType? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeDeleteImageType.values
          .firstWhereOrNull(
              (e) => e.value == itemsItemIdImagesImageTypeDeleteImageType) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeDeleteImageType.swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeDeleteImageType?
    itemsItemIdImagesImageTypeDeleteImageTypeNullableFromJson(
  Object? itemsItemIdImagesImageTypeDeleteImageType, [
  enums.ItemsItemIdImagesImageTypeDeleteImageType? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeDeleteImageType == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeDeleteImageType.values
          .firstWhereOrNull(
              (e) => e.value == itemsItemIdImagesImageTypeDeleteImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeDeleteImageTypeExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeDeleteImageType>?
        itemsItemIdImagesImageTypeDeleteImageType) {
  return itemsItemIdImagesImageTypeDeleteImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeDeleteImageTypeListToJson(
    List<enums.ItemsItemIdImagesImageTypeDeleteImageType>?
        itemsItemIdImagesImageTypeDeleteImageType) {
  if (itemsItemIdImagesImageTypeDeleteImageType == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeDeleteImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeDeleteImageType>
    itemsItemIdImagesImageTypeDeleteImageTypeListFromJson(
  List? itemsItemIdImagesImageTypeDeleteImageType, [
  List<enums.ItemsItemIdImagesImageTypeDeleteImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeDeleteImageType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeDeleteImageType
      .map((e) =>
          itemsItemIdImagesImageTypeDeleteImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeDeleteImageType>?
    itemsItemIdImagesImageTypeDeleteImageTypeNullableListFromJson(
  List? itemsItemIdImagesImageTypeDeleteImageType, [
  List<enums.ItemsItemIdImagesImageTypeDeleteImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeDeleteImageType == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeDeleteImageType
      .map((e) =>
          itemsItemIdImagesImageTypeDeleteImageTypeFromJson(e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypePostImageTypeNullableToJson(
    enums.ItemsItemIdImagesImageTypePostImageType?
        itemsItemIdImagesImageTypePostImageType) {
  return itemsItemIdImagesImageTypePostImageType?.value;
}

String? itemsItemIdImagesImageTypePostImageTypeToJson(
    enums.ItemsItemIdImagesImageTypePostImageType
        itemsItemIdImagesImageTypePostImageType) {
  return itemsItemIdImagesImageTypePostImageType.value;
}

enums.ItemsItemIdImagesImageTypePostImageType
    itemsItemIdImagesImageTypePostImageTypeFromJson(
  Object? itemsItemIdImagesImageTypePostImageType, [
  enums.ItemsItemIdImagesImageTypePostImageType? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypePostImageType.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypePostImageType) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypePostImageType.swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypePostImageType?
    itemsItemIdImagesImageTypePostImageTypeNullableFromJson(
  Object? itemsItemIdImagesImageTypePostImageType, [
  enums.ItemsItemIdImagesImageTypePostImageType? defaultValue,
]) {
  if (itemsItemIdImagesImageTypePostImageType == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypePostImageType.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypePostImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypePostImageTypeExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypePostImageType>?
        itemsItemIdImagesImageTypePostImageType) {
  return itemsItemIdImagesImageTypePostImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypePostImageTypeListToJson(
    List<enums.ItemsItemIdImagesImageTypePostImageType>?
        itemsItemIdImagesImageTypePostImageType) {
  if (itemsItemIdImagesImageTypePostImageType == null) {
    return [];
  }

  return itemsItemIdImagesImageTypePostImageType.map((e) => e.value!).toList();
}

List<enums.ItemsItemIdImagesImageTypePostImageType>
    itemsItemIdImagesImageTypePostImageTypeListFromJson(
  List? itemsItemIdImagesImageTypePostImageType, [
  List<enums.ItemsItemIdImagesImageTypePostImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypePostImageType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypePostImageType
      .map((e) => itemsItemIdImagesImageTypePostImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypePostImageType>?
    itemsItemIdImagesImageTypePostImageTypeNullableListFromJson(
  List? itemsItemIdImagesImageTypePostImageType, [
  List<enums.ItemsItemIdImagesImageTypePostImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypePostImageType == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypePostImageType
      .map((e) => itemsItemIdImagesImageTypePostImageTypeFromJson(e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeGetImageTypeNullableToJson(
    enums.ItemsItemIdImagesImageTypeGetImageType?
        itemsItemIdImagesImageTypeGetImageType) {
  return itemsItemIdImagesImageTypeGetImageType?.value;
}

String? itemsItemIdImagesImageTypeGetImageTypeToJson(
    enums.ItemsItemIdImagesImageTypeGetImageType
        itemsItemIdImagesImageTypeGetImageType) {
  return itemsItemIdImagesImageTypeGetImageType.value;
}

enums.ItemsItemIdImagesImageTypeGetImageType
    itemsItemIdImagesImageTypeGetImageTypeFromJson(
  Object? itemsItemIdImagesImageTypeGetImageType, [
  enums.ItemsItemIdImagesImageTypeGetImageType? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeGetImageType.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypeGetImageType) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeGetImageType.swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeGetImageType?
    itemsItemIdImagesImageTypeGetImageTypeNullableFromJson(
  Object? itemsItemIdImagesImageTypeGetImageType, [
  enums.ItemsItemIdImagesImageTypeGetImageType? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeGetImageType == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeGetImageType.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypeGetImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeGetImageTypeExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeGetImageType>?
        itemsItemIdImagesImageTypeGetImageType) {
  return itemsItemIdImagesImageTypeGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeGetImageTypeListToJson(
    List<enums.ItemsItemIdImagesImageTypeGetImageType>?
        itemsItemIdImagesImageTypeGetImageType) {
  if (itemsItemIdImagesImageTypeGetImageType == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeGetImageType.map((e) => e.value!).toList();
}

List<enums.ItemsItemIdImagesImageTypeGetImageType>
    itemsItemIdImagesImageTypeGetImageTypeListFromJson(
  List? itemsItemIdImagesImageTypeGetImageType, [
  List<enums.ItemsItemIdImagesImageTypeGetImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeGetImageType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeGetImageType
      .map((e) => itemsItemIdImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeGetImageType>?
    itemsItemIdImagesImageTypeGetImageTypeNullableListFromJson(
  List? itemsItemIdImagesImageTypeGetImageType, [
  List<enums.ItemsItemIdImagesImageTypeGetImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeGetImageType == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeGetImageType
      .map((e) => itemsItemIdImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeGetFormatNullableToJson(
    enums.ItemsItemIdImagesImageTypeGetFormat?
        itemsItemIdImagesImageTypeGetFormat) {
  return itemsItemIdImagesImageTypeGetFormat?.value;
}

String? itemsItemIdImagesImageTypeGetFormatToJson(
    enums.ItemsItemIdImagesImageTypeGetFormat
        itemsItemIdImagesImageTypeGetFormat) {
  return itemsItemIdImagesImageTypeGetFormat.value;
}

enums.ItemsItemIdImagesImageTypeGetFormat
    itemsItemIdImagesImageTypeGetFormatFromJson(
  Object? itemsItemIdImagesImageTypeGetFormat, [
  enums.ItemsItemIdImagesImageTypeGetFormat? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypeGetFormat) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeGetFormat.swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeGetFormat?
    itemsItemIdImagesImageTypeGetFormatNullableFromJson(
  Object? itemsItemIdImagesImageTypeGetFormat, [
  enums.ItemsItemIdImagesImageTypeGetFormat? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeGetFormat == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypeGetFormat) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeGetFormatExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeGetFormat>?
        itemsItemIdImagesImageTypeGetFormat) {
  return itemsItemIdImagesImageTypeGetFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeGetFormatListToJson(
    List<enums.ItemsItemIdImagesImageTypeGetFormat>?
        itemsItemIdImagesImageTypeGetFormat) {
  if (itemsItemIdImagesImageTypeGetFormat == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeGetFormat.map((e) => e.value!).toList();
}

List<enums.ItemsItemIdImagesImageTypeGetFormat>
    itemsItemIdImagesImageTypeGetFormatListFromJson(
  List? itemsItemIdImagesImageTypeGetFormat, [
  List<enums.ItemsItemIdImagesImageTypeGetFormat>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeGetFormat == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeGetFormat
      .map((e) => itemsItemIdImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeGetFormat>?
    itemsItemIdImagesImageTypeGetFormatNullableListFromJson(
  List? itemsItemIdImagesImageTypeGetFormat, [
  List<enums.ItemsItemIdImagesImageTypeGetFormat>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeGetFormat == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeGetFormat
      .map((e) => itemsItemIdImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeHeadImageTypeNullableToJson(
    enums.ItemsItemIdImagesImageTypeHeadImageType?
        itemsItemIdImagesImageTypeHeadImageType) {
  return itemsItemIdImagesImageTypeHeadImageType?.value;
}

String? itemsItemIdImagesImageTypeHeadImageTypeToJson(
    enums.ItemsItemIdImagesImageTypeHeadImageType
        itemsItemIdImagesImageTypeHeadImageType) {
  return itemsItemIdImagesImageTypeHeadImageType.value;
}

enums.ItemsItemIdImagesImageTypeHeadImageType
    itemsItemIdImagesImageTypeHeadImageTypeFromJson(
  Object? itemsItemIdImagesImageTypeHeadImageType, [
  enums.ItemsItemIdImagesImageTypeHeadImageType? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeHeadImageType.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypeHeadImageType) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeHeadImageType.swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeHeadImageType?
    itemsItemIdImagesImageTypeHeadImageTypeNullableFromJson(
  Object? itemsItemIdImagesImageTypeHeadImageType, [
  enums.ItemsItemIdImagesImageTypeHeadImageType? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeHeadImageType == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeHeadImageType.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypeHeadImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeHeadImageTypeExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeHeadImageType>?
        itemsItemIdImagesImageTypeHeadImageType) {
  return itemsItemIdImagesImageTypeHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeHeadImageTypeListToJson(
    List<enums.ItemsItemIdImagesImageTypeHeadImageType>?
        itemsItemIdImagesImageTypeHeadImageType) {
  if (itemsItemIdImagesImageTypeHeadImageType == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeHeadImageType.map((e) => e.value!).toList();
}

List<enums.ItemsItemIdImagesImageTypeHeadImageType>
    itemsItemIdImagesImageTypeHeadImageTypeListFromJson(
  List? itemsItemIdImagesImageTypeHeadImageType, [
  List<enums.ItemsItemIdImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeHeadImageType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeHeadImageType
      .map((e) => itemsItemIdImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeHeadImageType>?
    itemsItemIdImagesImageTypeHeadImageTypeNullableListFromJson(
  List? itemsItemIdImagesImageTypeHeadImageType, [
  List<enums.ItemsItemIdImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeHeadImageType == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeHeadImageType
      .map((e) => itemsItemIdImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeHeadFormatNullableToJson(
    enums.ItemsItemIdImagesImageTypeHeadFormat?
        itemsItemIdImagesImageTypeHeadFormat) {
  return itemsItemIdImagesImageTypeHeadFormat?.value;
}

String? itemsItemIdImagesImageTypeHeadFormatToJson(
    enums.ItemsItemIdImagesImageTypeHeadFormat
        itemsItemIdImagesImageTypeHeadFormat) {
  return itemsItemIdImagesImageTypeHeadFormat.value;
}

enums.ItemsItemIdImagesImageTypeHeadFormat
    itemsItemIdImagesImageTypeHeadFormatFromJson(
  Object? itemsItemIdImagesImageTypeHeadFormat, [
  enums.ItemsItemIdImagesImageTypeHeadFormat? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypeHeadFormat) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeHeadFormat.swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeHeadFormat?
    itemsItemIdImagesImageTypeHeadFormatNullableFromJson(
  Object? itemsItemIdImagesImageTypeHeadFormat, [
  enums.ItemsItemIdImagesImageTypeHeadFormat? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeHeadFormat == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdImagesImageTypeHeadFormat) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeHeadFormatExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeHeadFormat>?
        itemsItemIdImagesImageTypeHeadFormat) {
  return itemsItemIdImagesImageTypeHeadFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeHeadFormatListToJson(
    List<enums.ItemsItemIdImagesImageTypeHeadFormat>?
        itemsItemIdImagesImageTypeHeadFormat) {
  if (itemsItemIdImagesImageTypeHeadFormat == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeHeadFormat.map((e) => e.value!).toList();
}

List<enums.ItemsItemIdImagesImageTypeHeadFormat>
    itemsItemIdImagesImageTypeHeadFormatListFromJson(
  List? itemsItemIdImagesImageTypeHeadFormat, [
  List<enums.ItemsItemIdImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeHeadFormat == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeHeadFormat
      .map((e) => itemsItemIdImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeHeadFormat>?
    itemsItemIdImagesImageTypeHeadFormatNullableListFromJson(
  List? itemsItemIdImagesImageTypeHeadFormat, [
  List<enums.ItemsItemIdImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeHeadFormat == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeHeadFormat
      .map((e) => itemsItemIdImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexDeleteImageTypeNullableToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType?
        itemsItemIdImagesImageTypeImageIndexDeleteImageType) {
  return itemsItemIdImagesImageTypeImageIndexDeleteImageType?.value;
}

String? itemsItemIdImagesImageTypeImageIndexDeleteImageTypeToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType
        itemsItemIdImagesImageTypeImageIndexDeleteImageType) {
  return itemsItemIdImagesImageTypeImageIndexDeleteImageType.value;
}

enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType
    itemsItemIdImagesImageTypeImageIndexDeleteImageTypeFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexDeleteImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexDeleteImageType) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType
          .swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType?
    itemsItemIdImagesImageTypeImageIndexDeleteImageTypeNullableFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexDeleteImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexDeleteImageType == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexDeleteImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexDeleteImageTypeExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType>?
        itemsItemIdImagesImageTypeImageIndexDeleteImageType) {
  return itemsItemIdImagesImageTypeImageIndexDeleteImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeImageIndexDeleteImageTypeListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType>?
        itemsItemIdImagesImageTypeImageIndexDeleteImageType) {
  if (itemsItemIdImagesImageTypeImageIndexDeleteImageType == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexDeleteImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType>
    itemsItemIdImagesImageTypeImageIndexDeleteImageTypeListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexDeleteImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexDeleteImageType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexDeleteImageType
      .map((e) => itemsItemIdImagesImageTypeImageIndexDeleteImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType>?
    itemsItemIdImagesImageTypeImageIndexDeleteImageTypeNullableListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexDeleteImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexDeleteImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexDeleteImageType == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexDeleteImageType
      .map((e) => itemsItemIdImagesImageTypeImageIndexDeleteImageTypeFromJson(
          e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexPostImageTypeNullableToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexPostImageType?
        itemsItemIdImagesImageTypeImageIndexPostImageType) {
  return itemsItemIdImagesImageTypeImageIndexPostImageType?.value;
}

String? itemsItemIdImagesImageTypeImageIndexPostImageTypeToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexPostImageType
        itemsItemIdImagesImageTypeImageIndexPostImageType) {
  return itemsItemIdImagesImageTypeImageIndexPostImageType.value;
}

enums.ItemsItemIdImagesImageTypeImageIndexPostImageType
    itemsItemIdImagesImageTypeImageIndexPostImageTypeFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexPostImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexPostImageType? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeImageIndexPostImageType.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexPostImageType) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeImageIndexPostImageType
          .swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeImageIndexPostImageType?
    itemsItemIdImagesImageTypeImageIndexPostImageTypeNullableFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexPostImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexPostImageType? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexPostImageType == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeImageIndexPostImageType.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexPostImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexPostImageTypeExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexPostImageType>?
        itemsItemIdImagesImageTypeImageIndexPostImageType) {
  return itemsItemIdImagesImageTypeImageIndexPostImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeImageIndexPostImageTypeListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexPostImageType>?
        itemsItemIdImagesImageTypeImageIndexPostImageType) {
  if (itemsItemIdImagesImageTypeImageIndexPostImageType == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexPostImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexPostImageType>
    itemsItemIdImagesImageTypeImageIndexPostImageTypeListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexPostImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexPostImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexPostImageType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexPostImageType
      .map((e) => itemsItemIdImagesImageTypeImageIndexPostImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexPostImageType>?
    itemsItemIdImagesImageTypeImageIndexPostImageTypeNullableListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexPostImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexPostImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexPostImageType == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexPostImageType
      .map((e) => itemsItemIdImagesImageTypeImageIndexPostImageTypeFromJson(
          e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexGetImageTypeNullableToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexGetImageType?
        itemsItemIdImagesImageTypeImageIndexGetImageType) {
  return itemsItemIdImagesImageTypeImageIndexGetImageType?.value;
}

String? itemsItemIdImagesImageTypeImageIndexGetImageTypeToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexGetImageType
        itemsItemIdImagesImageTypeImageIndexGetImageType) {
  return itemsItemIdImagesImageTypeImageIndexGetImageType.value;
}

enums.ItemsItemIdImagesImageTypeImageIndexGetImageType
    itemsItemIdImagesImageTypeImageIndexGetImageTypeFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexGetImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexGetImageType) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeImageIndexGetImageType
          .swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeImageIndexGetImageType?
    itemsItemIdImagesImageTypeImageIndexGetImageTypeNullableFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexGetImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexGetImageType == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexGetImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexGetImageTypeExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexGetImageType>?
        itemsItemIdImagesImageTypeImageIndexGetImageType) {
  return itemsItemIdImagesImageTypeImageIndexGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeImageIndexGetImageTypeListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexGetImageType>?
        itemsItemIdImagesImageTypeImageIndexGetImageType) {
  if (itemsItemIdImagesImageTypeImageIndexGetImageType == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexGetImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexGetImageType>
    itemsItemIdImagesImageTypeImageIndexGetImageTypeListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexGetImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexGetImageType
      .map((e) => itemsItemIdImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexGetImageType>?
    itemsItemIdImagesImageTypeImageIndexGetImageTypeNullableListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexGetImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexGetImageType
      .map((e) => itemsItemIdImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexGetFormatNullableToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexGetFormat?
        itemsItemIdImagesImageTypeImageIndexGetFormat) {
  return itemsItemIdImagesImageTypeImageIndexGetFormat?.value;
}

String? itemsItemIdImagesImageTypeImageIndexGetFormatToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexGetFormat
        itemsItemIdImagesImageTypeImageIndexGetFormat) {
  return itemsItemIdImagesImageTypeImageIndexGetFormat.value;
}

enums.ItemsItemIdImagesImageTypeImageIndexGetFormat
    itemsItemIdImagesImageTypeImageIndexGetFormatFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexGetFormat, [
  enums.ItemsItemIdImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexGetFormat) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeImageIndexGetFormat
          .swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeImageIndexGetFormat?
    itemsItemIdImagesImageTypeImageIndexGetFormatNullableFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexGetFormat, [
  enums.ItemsItemIdImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexGetFormat == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexGetFormat) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexGetFormatExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexGetFormat>?
        itemsItemIdImagesImageTypeImageIndexGetFormat) {
  return itemsItemIdImagesImageTypeImageIndexGetFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeImageIndexGetFormatListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexGetFormat>?
        itemsItemIdImagesImageTypeImageIndexGetFormat) {
  if (itemsItemIdImagesImageTypeImageIndexGetFormat == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexGetFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexGetFormat>
    itemsItemIdImagesImageTypeImageIndexGetFormatListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexGetFormat, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexGetFormat
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexGetFormat>?
    itemsItemIdImagesImageTypeImageIndexGetFormatNullableListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexGetFormat, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexGetFormat
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexHeadImageTypeNullableToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType?
        itemsItemIdImagesImageTypeImageIndexHeadImageType) {
  return itemsItemIdImagesImageTypeImageIndexHeadImageType?.value;
}

String? itemsItemIdImagesImageTypeImageIndexHeadImageTypeToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType
        itemsItemIdImagesImageTypeImageIndexHeadImageType) {
  return itemsItemIdImagesImageTypeImageIndexHeadImageType.value;
}

enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType
    itemsItemIdImagesImageTypeImageIndexHeadImageTypeFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexHeadImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexHeadImageType) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType
          .swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType?
    itemsItemIdImagesImageTypeImageIndexHeadImageTypeNullableFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexHeadImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexHeadImageType == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexHeadImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexHeadImageTypeExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType>?
        itemsItemIdImagesImageTypeImageIndexHeadImageType) {
  return itemsItemIdImagesImageTypeImageIndexHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeImageIndexHeadImageTypeListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType>?
        itemsItemIdImagesImageTypeImageIndexHeadImageType) {
  if (itemsItemIdImagesImageTypeImageIndexHeadImageType == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexHeadImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType>
    itemsItemIdImagesImageTypeImageIndexHeadImageTypeListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexHeadImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexHeadImageType
      .map((e) => itemsItemIdImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType>?
    itemsItemIdImagesImageTypeImageIndexHeadImageTypeNullableListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexHeadImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexHeadImageType
      .map((e) => itemsItemIdImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexHeadFormatNullableToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat?
        itemsItemIdImagesImageTypeImageIndexHeadFormat) {
  return itemsItemIdImagesImageTypeImageIndexHeadFormat?.value;
}

String? itemsItemIdImagesImageTypeImageIndexHeadFormatToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat
        itemsItemIdImagesImageTypeImageIndexHeadFormat) {
  return itemsItemIdImagesImageTypeImageIndexHeadFormat.value;
}

enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat
    itemsItemIdImagesImageTypeImageIndexHeadFormatFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexHeadFormat, [
  enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexHeadFormat) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat
          .swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat?
    itemsItemIdImagesImageTypeImageIndexHeadFormatNullableFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexHeadFormat, [
  enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexHeadFormat == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == itemsItemIdImagesImageTypeImageIndexHeadFormat) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexHeadFormatExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat>?
        itemsItemIdImagesImageTypeImageIndexHeadFormat) {
  return itemsItemIdImagesImageTypeImageIndexHeadFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeImageIndexHeadFormatListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat>?
        itemsItemIdImagesImageTypeImageIndexHeadFormat) {
  if (itemsItemIdImagesImageTypeImageIndexHeadFormat == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexHeadFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat>
    itemsItemIdImagesImageTypeImageIndexHeadFormatListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexHeadFormat, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat>?
    itemsItemIdImagesImageTypeImageIndexHeadFormatNullableListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexHeadFormat, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeNullableToJson(
    enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType?
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
      ?.value;
}

String? itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeToJson(
    enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
      .value;
}

enums
    .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeFromJson(
  Object?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType, [
  enums
      .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType?
      defaultValue,
]) {
  return enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType) ??
      defaultValue ??
      enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
          .swaggerGeneratedUnknown;
}

enums
    .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType?
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeNullableFromJson(
  Object?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType, [
  enums
      .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType ==
      null) {
    return null;
  }
  return enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeExplodedListToJson(
    List<
            enums
            .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType>?
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeListToJson(
        List<
                enums
                .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType>?
            itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType ==
      null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
      .map((e) => e.value!)
      .toList();
}

List<
        enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType>
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeListFromJson(
  List?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType, [
  List<
          enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType ==
      null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeFromJson(
              e.toString()))
      .toList();
}

List<
        enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType>?
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeNullableListFromJson(
  List?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType, [
  List<
          enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType ==
      null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageType
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetImageTypeFromJson(
              e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatNullableToJson(
    enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat?
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
      ?.value;
}

String? itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatToJson(
    enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
      .value;
}

enums
    .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatFromJson(
  Object?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat, [
  enums
      .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat?
      defaultValue,
]) {
  return enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat) ??
      defaultValue ??
      enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
          .swaggerGeneratedUnknown;
}

enums
    .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat?
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatNullableFromJson(
  Object?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat, [
  enums
      .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat ==
      null) {
    return null;
  }
  return enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatExplodedListToJson(
    List<
            enums
            .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat>?
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatListToJson(
        List<
                enums
                .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat>?
            itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat ==
      null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
      .map((e) => e.value!)
      .toList();
}

List<
        enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat>
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatListFromJson(
  List?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat, [
  List<
          enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat ==
      null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatFromJson(
              e.toString()))
      .toList();
}

List<
        enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat>?
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatNullableListFromJson(
  List?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat, [
  List<
          enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat ==
      null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormat
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountGetFormatFromJson(
              e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeNullableToJson(
    enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType?
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
      ?.value;
}

String? itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeToJson(
    enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
      .value;
}

enums
    .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeFromJson(
  Object?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType, [
  enums
      .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType?
      defaultValue,
]) {
  return enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType) ??
      defaultValue ??
      enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
          .swaggerGeneratedUnknown;
}

enums
    .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType?
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeNullableFromJson(
  Object?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType, [
  enums
      .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType ==
      null) {
    return null;
  }
  return enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeExplodedListToJson(
    List<
            enums
            .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType>?
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeListToJson(
        List<
                enums
                .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType>?
            itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType ==
      null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
      .map((e) => e.value!)
      .toList();
}

List<
        enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType>
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeListFromJson(
  List?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType, [
  List<
          enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType ==
      null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeFromJson(
              e.toString()))
      .toList();
}

List<
        enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType>?
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeNullableListFromJson(
  List?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType, [
  List<
          enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType ==
      null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageType
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadImageTypeFromJson(
              e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatNullableToJson(
    enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat?
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
      ?.value;
}

String? itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatToJson(
    enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
      .value;
}

enums
    .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatFromJson(
  Object?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat, [
  enums
      .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat?
      defaultValue,
]) {
  return enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat) ??
      defaultValue ??
      enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
          .swaggerGeneratedUnknown;
}

enums
    .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat?
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatNullableFromJson(
  Object?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat, [
  enums
      .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat ==
      null) {
    return null;
  }
  return enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatExplodedListToJson(
    List<
            enums
            .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat>?
        itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat) {
  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatListToJson(
        List<
                enums
                .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat>?
            itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat ==
      null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
      .map((e) => e.value!)
      .toList();
}

List<
        enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat>
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatListFromJson(
  List?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat, [
  List<
          enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat ==
      null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatFromJson(
              e.toString()))
      .toList();
}

List<
        enums
        .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat>?
    itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatNullableListFromJson(
  List?
      itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat, [
  List<
          enums
          .ItemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat ==
      null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormat
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexTagFormatMaxWidthMaxHeightPercentPlayedUnplayedCountHeadFormatFromJson(
              e.toString()))
      .toList();
}

String? itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeNullableToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType?
        itemsItemIdImagesImageTypeImageIndexIndexPostImageType) {
  return itemsItemIdImagesImageTypeImageIndexIndexPostImageType?.value;
}

String? itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeToJson(
    enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType
        itemsItemIdImagesImageTypeImageIndexIndexPostImageType) {
  return itemsItemIdImagesImageTypeImageIndexIndexPostImageType.value;
}

enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType
    itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexIndexPostImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType? defaultValue,
]) {
  return enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType.values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexIndexPostImageType) ??
      defaultValue ??
      enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType
          .swaggerGeneratedUnknown;
}

enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType?
    itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeNullableFromJson(
  Object? itemsItemIdImagesImageTypeImageIndexIndexPostImageType, [
  enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType? defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexIndexPostImageType == null) {
    return null;
  }
  return enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType.values
          .firstWhereOrNull((e) =>
              e.value ==
              itemsItemIdImagesImageTypeImageIndexIndexPostImageType) ??
      defaultValue;
}

String itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeExplodedListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType>?
        itemsItemIdImagesImageTypeImageIndexIndexPostImageType) {
  return itemsItemIdImagesImageTypeImageIndexIndexPostImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeListToJson(
    List<enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType>?
        itemsItemIdImagesImageTypeImageIndexIndexPostImageType) {
  if (itemsItemIdImagesImageTypeImageIndexIndexPostImageType == null) {
    return [];
  }

  return itemsItemIdImagesImageTypeImageIndexIndexPostImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType>
    itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexIndexPostImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexIndexPostImageType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdImagesImageTypeImageIndexIndexPostImageType
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeFromJson(
              e.toString()))
      .toList();
}

List<enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType>?
    itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeNullableListFromJson(
  List? itemsItemIdImagesImageTypeImageIndexIndexPostImageType, [
  List<enums.ItemsItemIdImagesImageTypeImageIndexIndexPostImageType>?
      defaultValue,
]) {
  if (itemsItemIdImagesImageTypeImageIndexIndexPostImageType == null) {
    return defaultValue;
  }

  return itemsItemIdImagesImageTypeImageIndexIndexPostImageType
      .map((e) =>
          itemsItemIdImagesImageTypeImageIndexIndexPostImageTypeFromJson(
              e.toString()))
      .toList();
}

String? musicGenresNameImagesImageTypeGetImageTypeNullableToJson(
    enums.MusicGenresNameImagesImageTypeGetImageType?
        musicGenresNameImagesImageTypeGetImageType) {
  return musicGenresNameImagesImageTypeGetImageType?.value;
}

String? musicGenresNameImagesImageTypeGetImageTypeToJson(
    enums.MusicGenresNameImagesImageTypeGetImageType
        musicGenresNameImagesImageTypeGetImageType) {
  return musicGenresNameImagesImageTypeGetImageType.value;
}

enums.MusicGenresNameImagesImageTypeGetImageType
    musicGenresNameImagesImageTypeGetImageTypeFromJson(
  Object? musicGenresNameImagesImageTypeGetImageType, [
  enums.MusicGenresNameImagesImageTypeGetImageType? defaultValue,
]) {
  return enums.MusicGenresNameImagesImageTypeGetImageType.values
          .firstWhereOrNull(
              (e) => e.value == musicGenresNameImagesImageTypeGetImageType) ??
      defaultValue ??
      enums.MusicGenresNameImagesImageTypeGetImageType.swaggerGeneratedUnknown;
}

enums.MusicGenresNameImagesImageTypeGetImageType?
    musicGenresNameImagesImageTypeGetImageTypeNullableFromJson(
  Object? musicGenresNameImagesImageTypeGetImageType, [
  enums.MusicGenresNameImagesImageTypeGetImageType? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeGetImageType == null) {
    return null;
  }
  return enums.MusicGenresNameImagesImageTypeGetImageType.values
          .firstWhereOrNull(
              (e) => e.value == musicGenresNameImagesImageTypeGetImageType) ??
      defaultValue;
}

String musicGenresNameImagesImageTypeGetImageTypeExplodedListToJson(
    List<enums.MusicGenresNameImagesImageTypeGetImageType>?
        musicGenresNameImagesImageTypeGetImageType) {
  return musicGenresNameImagesImageTypeGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> musicGenresNameImagesImageTypeGetImageTypeListToJson(
    List<enums.MusicGenresNameImagesImageTypeGetImageType>?
        musicGenresNameImagesImageTypeGetImageType) {
  if (musicGenresNameImagesImageTypeGetImageType == null) {
    return [];
  }

  return musicGenresNameImagesImageTypeGetImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeGetImageType>
    musicGenresNameImagesImageTypeGetImageTypeListFromJson(
  List? musicGenresNameImagesImageTypeGetImageType, [
  List<enums.MusicGenresNameImagesImageTypeGetImageType>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeGetImageType == null) {
    return defaultValue ?? [];
  }

  return musicGenresNameImagesImageTypeGetImageType
      .map((e) =>
          musicGenresNameImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeGetImageType>?
    musicGenresNameImagesImageTypeGetImageTypeNullableListFromJson(
  List? musicGenresNameImagesImageTypeGetImageType, [
  List<enums.MusicGenresNameImagesImageTypeGetImageType>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeGetImageType == null) {
    return defaultValue;
  }

  return musicGenresNameImagesImageTypeGetImageType
      .map((e) =>
          musicGenresNameImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

String? musicGenresNameImagesImageTypeGetFormatNullableToJson(
    enums.MusicGenresNameImagesImageTypeGetFormat?
        musicGenresNameImagesImageTypeGetFormat) {
  return musicGenresNameImagesImageTypeGetFormat?.value;
}

String? musicGenresNameImagesImageTypeGetFormatToJson(
    enums.MusicGenresNameImagesImageTypeGetFormat
        musicGenresNameImagesImageTypeGetFormat) {
  return musicGenresNameImagesImageTypeGetFormat.value;
}

enums.MusicGenresNameImagesImageTypeGetFormat
    musicGenresNameImagesImageTypeGetFormatFromJson(
  Object? musicGenresNameImagesImageTypeGetFormat, [
  enums.MusicGenresNameImagesImageTypeGetFormat? defaultValue,
]) {
  return enums.MusicGenresNameImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == musicGenresNameImagesImageTypeGetFormat) ??
      defaultValue ??
      enums.MusicGenresNameImagesImageTypeGetFormat.swaggerGeneratedUnknown;
}

enums.MusicGenresNameImagesImageTypeGetFormat?
    musicGenresNameImagesImageTypeGetFormatNullableFromJson(
  Object? musicGenresNameImagesImageTypeGetFormat, [
  enums.MusicGenresNameImagesImageTypeGetFormat? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeGetFormat == null) {
    return null;
  }
  return enums.MusicGenresNameImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == musicGenresNameImagesImageTypeGetFormat) ??
      defaultValue;
}

String musicGenresNameImagesImageTypeGetFormatExplodedListToJson(
    List<enums.MusicGenresNameImagesImageTypeGetFormat>?
        musicGenresNameImagesImageTypeGetFormat) {
  return musicGenresNameImagesImageTypeGetFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> musicGenresNameImagesImageTypeGetFormatListToJson(
    List<enums.MusicGenresNameImagesImageTypeGetFormat>?
        musicGenresNameImagesImageTypeGetFormat) {
  if (musicGenresNameImagesImageTypeGetFormat == null) {
    return [];
  }

  return musicGenresNameImagesImageTypeGetFormat.map((e) => e.value!).toList();
}

List<enums.MusicGenresNameImagesImageTypeGetFormat>
    musicGenresNameImagesImageTypeGetFormatListFromJson(
  List? musicGenresNameImagesImageTypeGetFormat, [
  List<enums.MusicGenresNameImagesImageTypeGetFormat>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeGetFormat == null) {
    return defaultValue ?? [];
  }

  return musicGenresNameImagesImageTypeGetFormat
      .map((e) => musicGenresNameImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeGetFormat>?
    musicGenresNameImagesImageTypeGetFormatNullableListFromJson(
  List? musicGenresNameImagesImageTypeGetFormat, [
  List<enums.MusicGenresNameImagesImageTypeGetFormat>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeGetFormat == null) {
    return defaultValue;
  }

  return musicGenresNameImagesImageTypeGetFormat
      .map((e) => musicGenresNameImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

String? musicGenresNameImagesImageTypeHeadImageTypeNullableToJson(
    enums.MusicGenresNameImagesImageTypeHeadImageType?
        musicGenresNameImagesImageTypeHeadImageType) {
  return musicGenresNameImagesImageTypeHeadImageType?.value;
}

String? musicGenresNameImagesImageTypeHeadImageTypeToJson(
    enums.MusicGenresNameImagesImageTypeHeadImageType
        musicGenresNameImagesImageTypeHeadImageType) {
  return musicGenresNameImagesImageTypeHeadImageType.value;
}

enums.MusicGenresNameImagesImageTypeHeadImageType
    musicGenresNameImagesImageTypeHeadImageTypeFromJson(
  Object? musicGenresNameImagesImageTypeHeadImageType, [
  enums.MusicGenresNameImagesImageTypeHeadImageType? defaultValue,
]) {
  return enums.MusicGenresNameImagesImageTypeHeadImageType.values
          .firstWhereOrNull(
              (e) => e.value == musicGenresNameImagesImageTypeHeadImageType) ??
      defaultValue ??
      enums.MusicGenresNameImagesImageTypeHeadImageType.swaggerGeneratedUnknown;
}

enums.MusicGenresNameImagesImageTypeHeadImageType?
    musicGenresNameImagesImageTypeHeadImageTypeNullableFromJson(
  Object? musicGenresNameImagesImageTypeHeadImageType, [
  enums.MusicGenresNameImagesImageTypeHeadImageType? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeHeadImageType == null) {
    return null;
  }
  return enums.MusicGenresNameImagesImageTypeHeadImageType.values
          .firstWhereOrNull(
              (e) => e.value == musicGenresNameImagesImageTypeHeadImageType) ??
      defaultValue;
}

String musicGenresNameImagesImageTypeHeadImageTypeExplodedListToJson(
    List<enums.MusicGenresNameImagesImageTypeHeadImageType>?
        musicGenresNameImagesImageTypeHeadImageType) {
  return musicGenresNameImagesImageTypeHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> musicGenresNameImagesImageTypeHeadImageTypeListToJson(
    List<enums.MusicGenresNameImagesImageTypeHeadImageType>?
        musicGenresNameImagesImageTypeHeadImageType) {
  if (musicGenresNameImagesImageTypeHeadImageType == null) {
    return [];
  }

  return musicGenresNameImagesImageTypeHeadImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeHeadImageType>
    musicGenresNameImagesImageTypeHeadImageTypeListFromJson(
  List? musicGenresNameImagesImageTypeHeadImageType, [
  List<enums.MusicGenresNameImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeHeadImageType == null) {
    return defaultValue ?? [];
  }

  return musicGenresNameImagesImageTypeHeadImageType
      .map((e) =>
          musicGenresNameImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeHeadImageType>?
    musicGenresNameImagesImageTypeHeadImageTypeNullableListFromJson(
  List? musicGenresNameImagesImageTypeHeadImageType, [
  List<enums.MusicGenresNameImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeHeadImageType == null) {
    return defaultValue;
  }

  return musicGenresNameImagesImageTypeHeadImageType
      .map((e) =>
          musicGenresNameImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

String? musicGenresNameImagesImageTypeHeadFormatNullableToJson(
    enums.MusicGenresNameImagesImageTypeHeadFormat?
        musicGenresNameImagesImageTypeHeadFormat) {
  return musicGenresNameImagesImageTypeHeadFormat?.value;
}

String? musicGenresNameImagesImageTypeHeadFormatToJson(
    enums.MusicGenresNameImagesImageTypeHeadFormat
        musicGenresNameImagesImageTypeHeadFormat) {
  return musicGenresNameImagesImageTypeHeadFormat.value;
}

enums.MusicGenresNameImagesImageTypeHeadFormat
    musicGenresNameImagesImageTypeHeadFormatFromJson(
  Object? musicGenresNameImagesImageTypeHeadFormat, [
  enums.MusicGenresNameImagesImageTypeHeadFormat? defaultValue,
]) {
  return enums.MusicGenresNameImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == musicGenresNameImagesImageTypeHeadFormat) ??
      defaultValue ??
      enums.MusicGenresNameImagesImageTypeHeadFormat.swaggerGeneratedUnknown;
}

enums.MusicGenresNameImagesImageTypeHeadFormat?
    musicGenresNameImagesImageTypeHeadFormatNullableFromJson(
  Object? musicGenresNameImagesImageTypeHeadFormat, [
  enums.MusicGenresNameImagesImageTypeHeadFormat? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeHeadFormat == null) {
    return null;
  }
  return enums.MusicGenresNameImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == musicGenresNameImagesImageTypeHeadFormat) ??
      defaultValue;
}

String musicGenresNameImagesImageTypeHeadFormatExplodedListToJson(
    List<enums.MusicGenresNameImagesImageTypeHeadFormat>?
        musicGenresNameImagesImageTypeHeadFormat) {
  return musicGenresNameImagesImageTypeHeadFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> musicGenresNameImagesImageTypeHeadFormatListToJson(
    List<enums.MusicGenresNameImagesImageTypeHeadFormat>?
        musicGenresNameImagesImageTypeHeadFormat) {
  if (musicGenresNameImagesImageTypeHeadFormat == null) {
    return [];
  }

  return musicGenresNameImagesImageTypeHeadFormat.map((e) => e.value!).toList();
}

List<enums.MusicGenresNameImagesImageTypeHeadFormat>
    musicGenresNameImagesImageTypeHeadFormatListFromJson(
  List? musicGenresNameImagesImageTypeHeadFormat, [
  List<enums.MusicGenresNameImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeHeadFormat == null) {
    return defaultValue ?? [];
  }

  return musicGenresNameImagesImageTypeHeadFormat
      .map(
          (e) => musicGenresNameImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeHeadFormat>?
    musicGenresNameImagesImageTypeHeadFormatNullableListFromJson(
  List? musicGenresNameImagesImageTypeHeadFormat, [
  List<enums.MusicGenresNameImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeHeadFormat == null) {
    return defaultValue;
  }

  return musicGenresNameImagesImageTypeHeadFormat
      .map(
          (e) => musicGenresNameImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

String? musicGenresNameImagesImageTypeImageIndexGetImageTypeNullableToJson(
    enums.MusicGenresNameImagesImageTypeImageIndexGetImageType?
        musicGenresNameImagesImageTypeImageIndexGetImageType) {
  return musicGenresNameImagesImageTypeImageIndexGetImageType?.value;
}

String? musicGenresNameImagesImageTypeImageIndexGetImageTypeToJson(
    enums.MusicGenresNameImagesImageTypeImageIndexGetImageType
        musicGenresNameImagesImageTypeImageIndexGetImageType) {
  return musicGenresNameImagesImageTypeImageIndexGetImageType.value;
}

enums.MusicGenresNameImagesImageTypeImageIndexGetImageType
    musicGenresNameImagesImageTypeImageIndexGetImageTypeFromJson(
  Object? musicGenresNameImagesImageTypeImageIndexGetImageType, [
  enums.MusicGenresNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  return enums.MusicGenresNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value ==
              musicGenresNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue ??
      enums.MusicGenresNameImagesImageTypeImageIndexGetImageType
          .swaggerGeneratedUnknown;
}

enums.MusicGenresNameImagesImageTypeImageIndexGetImageType?
    musicGenresNameImagesImageTypeImageIndexGetImageTypeNullableFromJson(
  Object? musicGenresNameImagesImageTypeImageIndexGetImageType, [
  enums.MusicGenresNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexGetImageType == null) {
    return null;
  }
  return enums.MusicGenresNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value ==
              musicGenresNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue;
}

String musicGenresNameImagesImageTypeImageIndexGetImageTypeExplodedListToJson(
    List<enums.MusicGenresNameImagesImageTypeImageIndexGetImageType>?
        musicGenresNameImagesImageTypeImageIndexGetImageType) {
  return musicGenresNameImagesImageTypeImageIndexGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> musicGenresNameImagesImageTypeImageIndexGetImageTypeListToJson(
    List<enums.MusicGenresNameImagesImageTypeImageIndexGetImageType>?
        musicGenresNameImagesImageTypeImageIndexGetImageType) {
  if (musicGenresNameImagesImageTypeImageIndexGetImageType == null) {
    return [];
  }

  return musicGenresNameImagesImageTypeImageIndexGetImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeImageIndexGetImageType>
    musicGenresNameImagesImageTypeImageIndexGetImageTypeListFromJson(
  List? musicGenresNameImagesImageTypeImageIndexGetImageType, [
  List<enums.MusicGenresNameImagesImageTypeImageIndexGetImageType>?
      defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue ?? [];
  }

  return musicGenresNameImagesImageTypeImageIndexGetImageType
      .map((e) => musicGenresNameImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeImageIndexGetImageType>?
    musicGenresNameImagesImageTypeImageIndexGetImageTypeNullableListFromJson(
  List? musicGenresNameImagesImageTypeImageIndexGetImageType, [
  List<enums.MusicGenresNameImagesImageTypeImageIndexGetImageType>?
      defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue;
  }

  return musicGenresNameImagesImageTypeImageIndexGetImageType
      .map((e) => musicGenresNameImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

String? musicGenresNameImagesImageTypeImageIndexGetFormatNullableToJson(
    enums.MusicGenresNameImagesImageTypeImageIndexGetFormat?
        musicGenresNameImagesImageTypeImageIndexGetFormat) {
  return musicGenresNameImagesImageTypeImageIndexGetFormat?.value;
}

String? musicGenresNameImagesImageTypeImageIndexGetFormatToJson(
    enums.MusicGenresNameImagesImageTypeImageIndexGetFormat
        musicGenresNameImagesImageTypeImageIndexGetFormat) {
  return musicGenresNameImagesImageTypeImageIndexGetFormat.value;
}

enums.MusicGenresNameImagesImageTypeImageIndexGetFormat
    musicGenresNameImagesImageTypeImageIndexGetFormatFromJson(
  Object? musicGenresNameImagesImageTypeImageIndexGetFormat, [
  enums.MusicGenresNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  return enums.MusicGenresNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == musicGenresNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue ??
      enums.MusicGenresNameImagesImageTypeImageIndexGetFormat
          .swaggerGeneratedUnknown;
}

enums.MusicGenresNameImagesImageTypeImageIndexGetFormat?
    musicGenresNameImagesImageTypeImageIndexGetFormatNullableFromJson(
  Object? musicGenresNameImagesImageTypeImageIndexGetFormat, [
  enums.MusicGenresNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexGetFormat == null) {
    return null;
  }
  return enums.MusicGenresNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == musicGenresNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue;
}

String musicGenresNameImagesImageTypeImageIndexGetFormatExplodedListToJson(
    List<enums.MusicGenresNameImagesImageTypeImageIndexGetFormat>?
        musicGenresNameImagesImageTypeImageIndexGetFormat) {
  return musicGenresNameImagesImageTypeImageIndexGetFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> musicGenresNameImagesImageTypeImageIndexGetFormatListToJson(
    List<enums.MusicGenresNameImagesImageTypeImageIndexGetFormat>?
        musicGenresNameImagesImageTypeImageIndexGetFormat) {
  if (musicGenresNameImagesImageTypeImageIndexGetFormat == null) {
    return [];
  }

  return musicGenresNameImagesImageTypeImageIndexGetFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeImageIndexGetFormat>
    musicGenresNameImagesImageTypeImageIndexGetFormatListFromJson(
  List? musicGenresNameImagesImageTypeImageIndexGetFormat, [
  List<enums.MusicGenresNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue ?? [];
  }

  return musicGenresNameImagesImageTypeImageIndexGetFormat
      .map((e) => musicGenresNameImagesImageTypeImageIndexGetFormatFromJson(
          e.toString()))
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeImageIndexGetFormat>?
    musicGenresNameImagesImageTypeImageIndexGetFormatNullableListFromJson(
  List? musicGenresNameImagesImageTypeImageIndexGetFormat, [
  List<enums.MusicGenresNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue;
  }

  return musicGenresNameImagesImageTypeImageIndexGetFormat
      .map((e) => musicGenresNameImagesImageTypeImageIndexGetFormatFromJson(
          e.toString()))
      .toList();
}

String? musicGenresNameImagesImageTypeImageIndexHeadImageTypeNullableToJson(
    enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType?
        musicGenresNameImagesImageTypeImageIndexHeadImageType) {
  return musicGenresNameImagesImageTypeImageIndexHeadImageType?.value;
}

String? musicGenresNameImagesImageTypeImageIndexHeadImageTypeToJson(
    enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType
        musicGenresNameImagesImageTypeImageIndexHeadImageType) {
  return musicGenresNameImagesImageTypeImageIndexHeadImageType.value;
}

enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType
    musicGenresNameImagesImageTypeImageIndexHeadImageTypeFromJson(
  Object? musicGenresNameImagesImageTypeImageIndexHeadImageType, [
  enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  return enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value ==
              musicGenresNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue ??
      enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType
          .swaggerGeneratedUnknown;
}

enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType?
    musicGenresNameImagesImageTypeImageIndexHeadImageTypeNullableFromJson(
  Object? musicGenresNameImagesImageTypeImageIndexHeadImageType, [
  enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexHeadImageType == null) {
    return null;
  }
  return enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value ==
              musicGenresNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue;
}

String musicGenresNameImagesImageTypeImageIndexHeadImageTypeExplodedListToJson(
    List<enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType>?
        musicGenresNameImagesImageTypeImageIndexHeadImageType) {
  return musicGenresNameImagesImageTypeImageIndexHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> musicGenresNameImagesImageTypeImageIndexHeadImageTypeListToJson(
    List<enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType>?
        musicGenresNameImagesImageTypeImageIndexHeadImageType) {
  if (musicGenresNameImagesImageTypeImageIndexHeadImageType == null) {
    return [];
  }

  return musicGenresNameImagesImageTypeImageIndexHeadImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType>
    musicGenresNameImagesImageTypeImageIndexHeadImageTypeListFromJson(
  List? musicGenresNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType>?
      defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue ?? [];
  }

  return musicGenresNameImagesImageTypeImageIndexHeadImageType
      .map((e) => musicGenresNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType>?
    musicGenresNameImagesImageTypeImageIndexHeadImageTypeNullableListFromJson(
  List? musicGenresNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.MusicGenresNameImagesImageTypeImageIndexHeadImageType>?
      defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue;
  }

  return musicGenresNameImagesImageTypeImageIndexHeadImageType
      .map((e) => musicGenresNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

String? musicGenresNameImagesImageTypeImageIndexHeadFormatNullableToJson(
    enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat?
        musicGenresNameImagesImageTypeImageIndexHeadFormat) {
  return musicGenresNameImagesImageTypeImageIndexHeadFormat?.value;
}

String? musicGenresNameImagesImageTypeImageIndexHeadFormatToJson(
    enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat
        musicGenresNameImagesImageTypeImageIndexHeadFormat) {
  return musicGenresNameImagesImageTypeImageIndexHeadFormat.value;
}

enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat
    musicGenresNameImagesImageTypeImageIndexHeadFormatFromJson(
  Object? musicGenresNameImagesImageTypeImageIndexHeadFormat, [
  enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  return enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == musicGenresNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue ??
      enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat
          .swaggerGeneratedUnknown;
}

enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat?
    musicGenresNameImagesImageTypeImageIndexHeadFormatNullableFromJson(
  Object? musicGenresNameImagesImageTypeImageIndexHeadFormat, [
  enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexHeadFormat == null) {
    return null;
  }
  return enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == musicGenresNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue;
}

String musicGenresNameImagesImageTypeImageIndexHeadFormatExplodedListToJson(
    List<enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat>?
        musicGenresNameImagesImageTypeImageIndexHeadFormat) {
  return musicGenresNameImagesImageTypeImageIndexHeadFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> musicGenresNameImagesImageTypeImageIndexHeadFormatListToJson(
    List<enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat>?
        musicGenresNameImagesImageTypeImageIndexHeadFormat) {
  if (musicGenresNameImagesImageTypeImageIndexHeadFormat == null) {
    return [];
  }

  return musicGenresNameImagesImageTypeImageIndexHeadFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat>
    musicGenresNameImagesImageTypeImageIndexHeadFormatListFromJson(
  List? musicGenresNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue ?? [];
  }

  return musicGenresNameImagesImageTypeImageIndexHeadFormat
      .map((e) => musicGenresNameImagesImageTypeImageIndexHeadFormatFromJson(
          e.toString()))
      .toList();
}

List<enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat>?
    musicGenresNameImagesImageTypeImageIndexHeadFormatNullableListFromJson(
  List? musicGenresNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.MusicGenresNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (musicGenresNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue;
  }

  return musicGenresNameImagesImageTypeImageIndexHeadFormat
      .map((e) => musicGenresNameImagesImageTypeImageIndexHeadFormatFromJson(
          e.toString()))
      .toList();
}

String? personsNameImagesImageTypeGetImageTypeNullableToJson(
    enums.PersonsNameImagesImageTypeGetImageType?
        personsNameImagesImageTypeGetImageType) {
  return personsNameImagesImageTypeGetImageType?.value;
}

String? personsNameImagesImageTypeGetImageTypeToJson(
    enums.PersonsNameImagesImageTypeGetImageType
        personsNameImagesImageTypeGetImageType) {
  return personsNameImagesImageTypeGetImageType.value;
}

enums.PersonsNameImagesImageTypeGetImageType
    personsNameImagesImageTypeGetImageTypeFromJson(
  Object? personsNameImagesImageTypeGetImageType, [
  enums.PersonsNameImagesImageTypeGetImageType? defaultValue,
]) {
  return enums.PersonsNameImagesImageTypeGetImageType.values.firstWhereOrNull(
          (e) => e.value == personsNameImagesImageTypeGetImageType) ??
      defaultValue ??
      enums.PersonsNameImagesImageTypeGetImageType.swaggerGeneratedUnknown;
}

enums.PersonsNameImagesImageTypeGetImageType?
    personsNameImagesImageTypeGetImageTypeNullableFromJson(
  Object? personsNameImagesImageTypeGetImageType, [
  enums.PersonsNameImagesImageTypeGetImageType? defaultValue,
]) {
  if (personsNameImagesImageTypeGetImageType == null) {
    return null;
  }
  return enums.PersonsNameImagesImageTypeGetImageType.values.firstWhereOrNull(
          (e) => e.value == personsNameImagesImageTypeGetImageType) ??
      defaultValue;
}

String personsNameImagesImageTypeGetImageTypeExplodedListToJson(
    List<enums.PersonsNameImagesImageTypeGetImageType>?
        personsNameImagesImageTypeGetImageType) {
  return personsNameImagesImageTypeGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> personsNameImagesImageTypeGetImageTypeListToJson(
    List<enums.PersonsNameImagesImageTypeGetImageType>?
        personsNameImagesImageTypeGetImageType) {
  if (personsNameImagesImageTypeGetImageType == null) {
    return [];
  }

  return personsNameImagesImageTypeGetImageType.map((e) => e.value!).toList();
}

List<enums.PersonsNameImagesImageTypeGetImageType>
    personsNameImagesImageTypeGetImageTypeListFromJson(
  List? personsNameImagesImageTypeGetImageType, [
  List<enums.PersonsNameImagesImageTypeGetImageType>? defaultValue,
]) {
  if (personsNameImagesImageTypeGetImageType == null) {
    return defaultValue ?? [];
  }

  return personsNameImagesImageTypeGetImageType
      .map((e) => personsNameImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.PersonsNameImagesImageTypeGetImageType>?
    personsNameImagesImageTypeGetImageTypeNullableListFromJson(
  List? personsNameImagesImageTypeGetImageType, [
  List<enums.PersonsNameImagesImageTypeGetImageType>? defaultValue,
]) {
  if (personsNameImagesImageTypeGetImageType == null) {
    return defaultValue;
  }

  return personsNameImagesImageTypeGetImageType
      .map((e) => personsNameImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

String? personsNameImagesImageTypeGetFormatNullableToJson(
    enums.PersonsNameImagesImageTypeGetFormat?
        personsNameImagesImageTypeGetFormat) {
  return personsNameImagesImageTypeGetFormat?.value;
}

String? personsNameImagesImageTypeGetFormatToJson(
    enums.PersonsNameImagesImageTypeGetFormat
        personsNameImagesImageTypeGetFormat) {
  return personsNameImagesImageTypeGetFormat.value;
}

enums.PersonsNameImagesImageTypeGetFormat
    personsNameImagesImageTypeGetFormatFromJson(
  Object? personsNameImagesImageTypeGetFormat, [
  enums.PersonsNameImagesImageTypeGetFormat? defaultValue,
]) {
  return enums.PersonsNameImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == personsNameImagesImageTypeGetFormat) ??
      defaultValue ??
      enums.PersonsNameImagesImageTypeGetFormat.swaggerGeneratedUnknown;
}

enums.PersonsNameImagesImageTypeGetFormat?
    personsNameImagesImageTypeGetFormatNullableFromJson(
  Object? personsNameImagesImageTypeGetFormat, [
  enums.PersonsNameImagesImageTypeGetFormat? defaultValue,
]) {
  if (personsNameImagesImageTypeGetFormat == null) {
    return null;
  }
  return enums.PersonsNameImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == personsNameImagesImageTypeGetFormat) ??
      defaultValue;
}

String personsNameImagesImageTypeGetFormatExplodedListToJson(
    List<enums.PersonsNameImagesImageTypeGetFormat>?
        personsNameImagesImageTypeGetFormat) {
  return personsNameImagesImageTypeGetFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<String> personsNameImagesImageTypeGetFormatListToJson(
    List<enums.PersonsNameImagesImageTypeGetFormat>?
        personsNameImagesImageTypeGetFormat) {
  if (personsNameImagesImageTypeGetFormat == null) {
    return [];
  }

  return personsNameImagesImageTypeGetFormat.map((e) => e.value!).toList();
}

List<enums.PersonsNameImagesImageTypeGetFormat>
    personsNameImagesImageTypeGetFormatListFromJson(
  List? personsNameImagesImageTypeGetFormat, [
  List<enums.PersonsNameImagesImageTypeGetFormat>? defaultValue,
]) {
  if (personsNameImagesImageTypeGetFormat == null) {
    return defaultValue ?? [];
  }

  return personsNameImagesImageTypeGetFormat
      .map((e) => personsNameImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.PersonsNameImagesImageTypeGetFormat>?
    personsNameImagesImageTypeGetFormatNullableListFromJson(
  List? personsNameImagesImageTypeGetFormat, [
  List<enums.PersonsNameImagesImageTypeGetFormat>? defaultValue,
]) {
  if (personsNameImagesImageTypeGetFormat == null) {
    return defaultValue;
  }

  return personsNameImagesImageTypeGetFormat
      .map((e) => personsNameImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

String? personsNameImagesImageTypeHeadImageTypeNullableToJson(
    enums.PersonsNameImagesImageTypeHeadImageType?
        personsNameImagesImageTypeHeadImageType) {
  return personsNameImagesImageTypeHeadImageType?.value;
}

String? personsNameImagesImageTypeHeadImageTypeToJson(
    enums.PersonsNameImagesImageTypeHeadImageType
        personsNameImagesImageTypeHeadImageType) {
  return personsNameImagesImageTypeHeadImageType.value;
}

enums.PersonsNameImagesImageTypeHeadImageType
    personsNameImagesImageTypeHeadImageTypeFromJson(
  Object? personsNameImagesImageTypeHeadImageType, [
  enums.PersonsNameImagesImageTypeHeadImageType? defaultValue,
]) {
  return enums.PersonsNameImagesImageTypeHeadImageType.values.firstWhereOrNull(
          (e) => e.value == personsNameImagesImageTypeHeadImageType) ??
      defaultValue ??
      enums.PersonsNameImagesImageTypeHeadImageType.swaggerGeneratedUnknown;
}

enums.PersonsNameImagesImageTypeHeadImageType?
    personsNameImagesImageTypeHeadImageTypeNullableFromJson(
  Object? personsNameImagesImageTypeHeadImageType, [
  enums.PersonsNameImagesImageTypeHeadImageType? defaultValue,
]) {
  if (personsNameImagesImageTypeHeadImageType == null) {
    return null;
  }
  return enums.PersonsNameImagesImageTypeHeadImageType.values.firstWhereOrNull(
          (e) => e.value == personsNameImagesImageTypeHeadImageType) ??
      defaultValue;
}

String personsNameImagesImageTypeHeadImageTypeExplodedListToJson(
    List<enums.PersonsNameImagesImageTypeHeadImageType>?
        personsNameImagesImageTypeHeadImageType) {
  return personsNameImagesImageTypeHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> personsNameImagesImageTypeHeadImageTypeListToJson(
    List<enums.PersonsNameImagesImageTypeHeadImageType>?
        personsNameImagesImageTypeHeadImageType) {
  if (personsNameImagesImageTypeHeadImageType == null) {
    return [];
  }

  return personsNameImagesImageTypeHeadImageType.map((e) => e.value!).toList();
}

List<enums.PersonsNameImagesImageTypeHeadImageType>
    personsNameImagesImageTypeHeadImageTypeListFromJson(
  List? personsNameImagesImageTypeHeadImageType, [
  List<enums.PersonsNameImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (personsNameImagesImageTypeHeadImageType == null) {
    return defaultValue ?? [];
  }

  return personsNameImagesImageTypeHeadImageType
      .map((e) => personsNameImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.PersonsNameImagesImageTypeHeadImageType>?
    personsNameImagesImageTypeHeadImageTypeNullableListFromJson(
  List? personsNameImagesImageTypeHeadImageType, [
  List<enums.PersonsNameImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (personsNameImagesImageTypeHeadImageType == null) {
    return defaultValue;
  }

  return personsNameImagesImageTypeHeadImageType
      .map((e) => personsNameImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

String? personsNameImagesImageTypeHeadFormatNullableToJson(
    enums.PersonsNameImagesImageTypeHeadFormat?
        personsNameImagesImageTypeHeadFormat) {
  return personsNameImagesImageTypeHeadFormat?.value;
}

String? personsNameImagesImageTypeHeadFormatToJson(
    enums.PersonsNameImagesImageTypeHeadFormat
        personsNameImagesImageTypeHeadFormat) {
  return personsNameImagesImageTypeHeadFormat.value;
}

enums.PersonsNameImagesImageTypeHeadFormat
    personsNameImagesImageTypeHeadFormatFromJson(
  Object? personsNameImagesImageTypeHeadFormat, [
  enums.PersonsNameImagesImageTypeHeadFormat? defaultValue,
]) {
  return enums.PersonsNameImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == personsNameImagesImageTypeHeadFormat) ??
      defaultValue ??
      enums.PersonsNameImagesImageTypeHeadFormat.swaggerGeneratedUnknown;
}

enums.PersonsNameImagesImageTypeHeadFormat?
    personsNameImagesImageTypeHeadFormatNullableFromJson(
  Object? personsNameImagesImageTypeHeadFormat, [
  enums.PersonsNameImagesImageTypeHeadFormat? defaultValue,
]) {
  if (personsNameImagesImageTypeHeadFormat == null) {
    return null;
  }
  return enums.PersonsNameImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == personsNameImagesImageTypeHeadFormat) ??
      defaultValue;
}

String personsNameImagesImageTypeHeadFormatExplodedListToJson(
    List<enums.PersonsNameImagesImageTypeHeadFormat>?
        personsNameImagesImageTypeHeadFormat) {
  return personsNameImagesImageTypeHeadFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<String> personsNameImagesImageTypeHeadFormatListToJson(
    List<enums.PersonsNameImagesImageTypeHeadFormat>?
        personsNameImagesImageTypeHeadFormat) {
  if (personsNameImagesImageTypeHeadFormat == null) {
    return [];
  }

  return personsNameImagesImageTypeHeadFormat.map((e) => e.value!).toList();
}

List<enums.PersonsNameImagesImageTypeHeadFormat>
    personsNameImagesImageTypeHeadFormatListFromJson(
  List? personsNameImagesImageTypeHeadFormat, [
  List<enums.PersonsNameImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (personsNameImagesImageTypeHeadFormat == null) {
    return defaultValue ?? [];
  }

  return personsNameImagesImageTypeHeadFormat
      .map((e) => personsNameImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.PersonsNameImagesImageTypeHeadFormat>?
    personsNameImagesImageTypeHeadFormatNullableListFromJson(
  List? personsNameImagesImageTypeHeadFormat, [
  List<enums.PersonsNameImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (personsNameImagesImageTypeHeadFormat == null) {
    return defaultValue;
  }

  return personsNameImagesImageTypeHeadFormat
      .map((e) => personsNameImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

String? personsNameImagesImageTypeImageIndexGetImageTypeNullableToJson(
    enums.PersonsNameImagesImageTypeImageIndexGetImageType?
        personsNameImagesImageTypeImageIndexGetImageType) {
  return personsNameImagesImageTypeImageIndexGetImageType?.value;
}

String? personsNameImagesImageTypeImageIndexGetImageTypeToJson(
    enums.PersonsNameImagesImageTypeImageIndexGetImageType
        personsNameImagesImageTypeImageIndexGetImageType) {
  return personsNameImagesImageTypeImageIndexGetImageType.value;
}

enums.PersonsNameImagesImageTypeImageIndexGetImageType
    personsNameImagesImageTypeImageIndexGetImageTypeFromJson(
  Object? personsNameImagesImageTypeImageIndexGetImageType, [
  enums.PersonsNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  return enums.PersonsNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == personsNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue ??
      enums.PersonsNameImagesImageTypeImageIndexGetImageType
          .swaggerGeneratedUnknown;
}

enums.PersonsNameImagesImageTypeImageIndexGetImageType?
    personsNameImagesImageTypeImageIndexGetImageTypeNullableFromJson(
  Object? personsNameImagesImageTypeImageIndexGetImageType, [
  enums.PersonsNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexGetImageType == null) {
    return null;
  }
  return enums.PersonsNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == personsNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue;
}

String personsNameImagesImageTypeImageIndexGetImageTypeExplodedListToJson(
    List<enums.PersonsNameImagesImageTypeImageIndexGetImageType>?
        personsNameImagesImageTypeImageIndexGetImageType) {
  return personsNameImagesImageTypeImageIndexGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> personsNameImagesImageTypeImageIndexGetImageTypeListToJson(
    List<enums.PersonsNameImagesImageTypeImageIndexGetImageType>?
        personsNameImagesImageTypeImageIndexGetImageType) {
  if (personsNameImagesImageTypeImageIndexGetImageType == null) {
    return [];
  }

  return personsNameImagesImageTypeImageIndexGetImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.PersonsNameImagesImageTypeImageIndexGetImageType>
    personsNameImagesImageTypeImageIndexGetImageTypeListFromJson(
  List? personsNameImagesImageTypeImageIndexGetImageType, [
  List<enums.PersonsNameImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue ?? [];
  }

  return personsNameImagesImageTypeImageIndexGetImageType
      .map((e) => personsNameImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.PersonsNameImagesImageTypeImageIndexGetImageType>?
    personsNameImagesImageTypeImageIndexGetImageTypeNullableListFromJson(
  List? personsNameImagesImageTypeImageIndexGetImageType, [
  List<enums.PersonsNameImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue;
  }

  return personsNameImagesImageTypeImageIndexGetImageType
      .map((e) => personsNameImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

String? personsNameImagesImageTypeImageIndexGetFormatNullableToJson(
    enums.PersonsNameImagesImageTypeImageIndexGetFormat?
        personsNameImagesImageTypeImageIndexGetFormat) {
  return personsNameImagesImageTypeImageIndexGetFormat?.value;
}

String? personsNameImagesImageTypeImageIndexGetFormatToJson(
    enums.PersonsNameImagesImageTypeImageIndexGetFormat
        personsNameImagesImageTypeImageIndexGetFormat) {
  return personsNameImagesImageTypeImageIndexGetFormat.value;
}

enums.PersonsNameImagesImageTypeImageIndexGetFormat
    personsNameImagesImageTypeImageIndexGetFormatFromJson(
  Object? personsNameImagesImageTypeImageIndexGetFormat, [
  enums.PersonsNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  return enums.PersonsNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == personsNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue ??
      enums.PersonsNameImagesImageTypeImageIndexGetFormat
          .swaggerGeneratedUnknown;
}

enums.PersonsNameImagesImageTypeImageIndexGetFormat?
    personsNameImagesImageTypeImageIndexGetFormatNullableFromJson(
  Object? personsNameImagesImageTypeImageIndexGetFormat, [
  enums.PersonsNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexGetFormat == null) {
    return null;
  }
  return enums.PersonsNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == personsNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue;
}

String personsNameImagesImageTypeImageIndexGetFormatExplodedListToJson(
    List<enums.PersonsNameImagesImageTypeImageIndexGetFormat>?
        personsNameImagesImageTypeImageIndexGetFormat) {
  return personsNameImagesImageTypeImageIndexGetFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> personsNameImagesImageTypeImageIndexGetFormatListToJson(
    List<enums.PersonsNameImagesImageTypeImageIndexGetFormat>?
        personsNameImagesImageTypeImageIndexGetFormat) {
  if (personsNameImagesImageTypeImageIndexGetFormat == null) {
    return [];
  }

  return personsNameImagesImageTypeImageIndexGetFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.PersonsNameImagesImageTypeImageIndexGetFormat>
    personsNameImagesImageTypeImageIndexGetFormatListFromJson(
  List? personsNameImagesImageTypeImageIndexGetFormat, [
  List<enums.PersonsNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue ?? [];
  }

  return personsNameImagesImageTypeImageIndexGetFormat
      .map((e) =>
          personsNameImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.PersonsNameImagesImageTypeImageIndexGetFormat>?
    personsNameImagesImageTypeImageIndexGetFormatNullableListFromJson(
  List? personsNameImagesImageTypeImageIndexGetFormat, [
  List<enums.PersonsNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue;
  }

  return personsNameImagesImageTypeImageIndexGetFormat
      .map((e) =>
          personsNameImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

String? personsNameImagesImageTypeImageIndexHeadImageTypeNullableToJson(
    enums.PersonsNameImagesImageTypeImageIndexHeadImageType?
        personsNameImagesImageTypeImageIndexHeadImageType) {
  return personsNameImagesImageTypeImageIndexHeadImageType?.value;
}

String? personsNameImagesImageTypeImageIndexHeadImageTypeToJson(
    enums.PersonsNameImagesImageTypeImageIndexHeadImageType
        personsNameImagesImageTypeImageIndexHeadImageType) {
  return personsNameImagesImageTypeImageIndexHeadImageType.value;
}

enums.PersonsNameImagesImageTypeImageIndexHeadImageType
    personsNameImagesImageTypeImageIndexHeadImageTypeFromJson(
  Object? personsNameImagesImageTypeImageIndexHeadImageType, [
  enums.PersonsNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  return enums.PersonsNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == personsNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue ??
      enums.PersonsNameImagesImageTypeImageIndexHeadImageType
          .swaggerGeneratedUnknown;
}

enums.PersonsNameImagesImageTypeImageIndexHeadImageType?
    personsNameImagesImageTypeImageIndexHeadImageTypeNullableFromJson(
  Object? personsNameImagesImageTypeImageIndexHeadImageType, [
  enums.PersonsNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexHeadImageType == null) {
    return null;
  }
  return enums.PersonsNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == personsNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue;
}

String personsNameImagesImageTypeImageIndexHeadImageTypeExplodedListToJson(
    List<enums.PersonsNameImagesImageTypeImageIndexHeadImageType>?
        personsNameImagesImageTypeImageIndexHeadImageType) {
  return personsNameImagesImageTypeImageIndexHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> personsNameImagesImageTypeImageIndexHeadImageTypeListToJson(
    List<enums.PersonsNameImagesImageTypeImageIndexHeadImageType>?
        personsNameImagesImageTypeImageIndexHeadImageType) {
  if (personsNameImagesImageTypeImageIndexHeadImageType == null) {
    return [];
  }

  return personsNameImagesImageTypeImageIndexHeadImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.PersonsNameImagesImageTypeImageIndexHeadImageType>
    personsNameImagesImageTypeImageIndexHeadImageTypeListFromJson(
  List? personsNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.PersonsNameImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue ?? [];
  }

  return personsNameImagesImageTypeImageIndexHeadImageType
      .map((e) => personsNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.PersonsNameImagesImageTypeImageIndexHeadImageType>?
    personsNameImagesImageTypeImageIndexHeadImageTypeNullableListFromJson(
  List? personsNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.PersonsNameImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue;
  }

  return personsNameImagesImageTypeImageIndexHeadImageType
      .map((e) => personsNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

String? personsNameImagesImageTypeImageIndexHeadFormatNullableToJson(
    enums.PersonsNameImagesImageTypeImageIndexHeadFormat?
        personsNameImagesImageTypeImageIndexHeadFormat) {
  return personsNameImagesImageTypeImageIndexHeadFormat?.value;
}

String? personsNameImagesImageTypeImageIndexHeadFormatToJson(
    enums.PersonsNameImagesImageTypeImageIndexHeadFormat
        personsNameImagesImageTypeImageIndexHeadFormat) {
  return personsNameImagesImageTypeImageIndexHeadFormat.value;
}

enums.PersonsNameImagesImageTypeImageIndexHeadFormat
    personsNameImagesImageTypeImageIndexHeadFormatFromJson(
  Object? personsNameImagesImageTypeImageIndexHeadFormat, [
  enums.PersonsNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  return enums.PersonsNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == personsNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue ??
      enums.PersonsNameImagesImageTypeImageIndexHeadFormat
          .swaggerGeneratedUnknown;
}

enums.PersonsNameImagesImageTypeImageIndexHeadFormat?
    personsNameImagesImageTypeImageIndexHeadFormatNullableFromJson(
  Object? personsNameImagesImageTypeImageIndexHeadFormat, [
  enums.PersonsNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexHeadFormat == null) {
    return null;
  }
  return enums.PersonsNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == personsNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue;
}

String personsNameImagesImageTypeImageIndexHeadFormatExplodedListToJson(
    List<enums.PersonsNameImagesImageTypeImageIndexHeadFormat>?
        personsNameImagesImageTypeImageIndexHeadFormat) {
  return personsNameImagesImageTypeImageIndexHeadFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> personsNameImagesImageTypeImageIndexHeadFormatListToJson(
    List<enums.PersonsNameImagesImageTypeImageIndexHeadFormat>?
        personsNameImagesImageTypeImageIndexHeadFormat) {
  if (personsNameImagesImageTypeImageIndexHeadFormat == null) {
    return [];
  }

  return personsNameImagesImageTypeImageIndexHeadFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.PersonsNameImagesImageTypeImageIndexHeadFormat>
    personsNameImagesImageTypeImageIndexHeadFormatListFromJson(
  List? personsNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.PersonsNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue ?? [];
  }

  return personsNameImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          personsNameImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.PersonsNameImagesImageTypeImageIndexHeadFormat>?
    personsNameImagesImageTypeImageIndexHeadFormatNullableListFromJson(
  List? personsNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.PersonsNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (personsNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue;
  }

  return personsNameImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          personsNameImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

String? studiosNameImagesImageTypeGetImageTypeNullableToJson(
    enums.StudiosNameImagesImageTypeGetImageType?
        studiosNameImagesImageTypeGetImageType) {
  return studiosNameImagesImageTypeGetImageType?.value;
}

String? studiosNameImagesImageTypeGetImageTypeToJson(
    enums.StudiosNameImagesImageTypeGetImageType
        studiosNameImagesImageTypeGetImageType) {
  return studiosNameImagesImageTypeGetImageType.value;
}

enums.StudiosNameImagesImageTypeGetImageType
    studiosNameImagesImageTypeGetImageTypeFromJson(
  Object? studiosNameImagesImageTypeGetImageType, [
  enums.StudiosNameImagesImageTypeGetImageType? defaultValue,
]) {
  return enums.StudiosNameImagesImageTypeGetImageType.values.firstWhereOrNull(
          (e) => e.value == studiosNameImagesImageTypeGetImageType) ??
      defaultValue ??
      enums.StudiosNameImagesImageTypeGetImageType.swaggerGeneratedUnknown;
}

enums.StudiosNameImagesImageTypeGetImageType?
    studiosNameImagesImageTypeGetImageTypeNullableFromJson(
  Object? studiosNameImagesImageTypeGetImageType, [
  enums.StudiosNameImagesImageTypeGetImageType? defaultValue,
]) {
  if (studiosNameImagesImageTypeGetImageType == null) {
    return null;
  }
  return enums.StudiosNameImagesImageTypeGetImageType.values.firstWhereOrNull(
          (e) => e.value == studiosNameImagesImageTypeGetImageType) ??
      defaultValue;
}

String studiosNameImagesImageTypeGetImageTypeExplodedListToJson(
    List<enums.StudiosNameImagesImageTypeGetImageType>?
        studiosNameImagesImageTypeGetImageType) {
  return studiosNameImagesImageTypeGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> studiosNameImagesImageTypeGetImageTypeListToJson(
    List<enums.StudiosNameImagesImageTypeGetImageType>?
        studiosNameImagesImageTypeGetImageType) {
  if (studiosNameImagesImageTypeGetImageType == null) {
    return [];
  }

  return studiosNameImagesImageTypeGetImageType.map((e) => e.value!).toList();
}

List<enums.StudiosNameImagesImageTypeGetImageType>
    studiosNameImagesImageTypeGetImageTypeListFromJson(
  List? studiosNameImagesImageTypeGetImageType, [
  List<enums.StudiosNameImagesImageTypeGetImageType>? defaultValue,
]) {
  if (studiosNameImagesImageTypeGetImageType == null) {
    return defaultValue ?? [];
  }

  return studiosNameImagesImageTypeGetImageType
      .map((e) => studiosNameImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.StudiosNameImagesImageTypeGetImageType>?
    studiosNameImagesImageTypeGetImageTypeNullableListFromJson(
  List? studiosNameImagesImageTypeGetImageType, [
  List<enums.StudiosNameImagesImageTypeGetImageType>? defaultValue,
]) {
  if (studiosNameImagesImageTypeGetImageType == null) {
    return defaultValue;
  }

  return studiosNameImagesImageTypeGetImageType
      .map((e) => studiosNameImagesImageTypeGetImageTypeFromJson(e.toString()))
      .toList();
}

String? studiosNameImagesImageTypeGetFormatNullableToJson(
    enums.StudiosNameImagesImageTypeGetFormat?
        studiosNameImagesImageTypeGetFormat) {
  return studiosNameImagesImageTypeGetFormat?.value;
}

String? studiosNameImagesImageTypeGetFormatToJson(
    enums.StudiosNameImagesImageTypeGetFormat
        studiosNameImagesImageTypeGetFormat) {
  return studiosNameImagesImageTypeGetFormat.value;
}

enums.StudiosNameImagesImageTypeGetFormat
    studiosNameImagesImageTypeGetFormatFromJson(
  Object? studiosNameImagesImageTypeGetFormat, [
  enums.StudiosNameImagesImageTypeGetFormat? defaultValue,
]) {
  return enums.StudiosNameImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == studiosNameImagesImageTypeGetFormat) ??
      defaultValue ??
      enums.StudiosNameImagesImageTypeGetFormat.swaggerGeneratedUnknown;
}

enums.StudiosNameImagesImageTypeGetFormat?
    studiosNameImagesImageTypeGetFormatNullableFromJson(
  Object? studiosNameImagesImageTypeGetFormat, [
  enums.StudiosNameImagesImageTypeGetFormat? defaultValue,
]) {
  if (studiosNameImagesImageTypeGetFormat == null) {
    return null;
  }
  return enums.StudiosNameImagesImageTypeGetFormat.values.firstWhereOrNull(
          (e) => e.value == studiosNameImagesImageTypeGetFormat) ??
      defaultValue;
}

String studiosNameImagesImageTypeGetFormatExplodedListToJson(
    List<enums.StudiosNameImagesImageTypeGetFormat>?
        studiosNameImagesImageTypeGetFormat) {
  return studiosNameImagesImageTypeGetFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<String> studiosNameImagesImageTypeGetFormatListToJson(
    List<enums.StudiosNameImagesImageTypeGetFormat>?
        studiosNameImagesImageTypeGetFormat) {
  if (studiosNameImagesImageTypeGetFormat == null) {
    return [];
  }

  return studiosNameImagesImageTypeGetFormat.map((e) => e.value!).toList();
}

List<enums.StudiosNameImagesImageTypeGetFormat>
    studiosNameImagesImageTypeGetFormatListFromJson(
  List? studiosNameImagesImageTypeGetFormat, [
  List<enums.StudiosNameImagesImageTypeGetFormat>? defaultValue,
]) {
  if (studiosNameImagesImageTypeGetFormat == null) {
    return defaultValue ?? [];
  }

  return studiosNameImagesImageTypeGetFormat
      .map((e) => studiosNameImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.StudiosNameImagesImageTypeGetFormat>?
    studiosNameImagesImageTypeGetFormatNullableListFromJson(
  List? studiosNameImagesImageTypeGetFormat, [
  List<enums.StudiosNameImagesImageTypeGetFormat>? defaultValue,
]) {
  if (studiosNameImagesImageTypeGetFormat == null) {
    return defaultValue;
  }

  return studiosNameImagesImageTypeGetFormat
      .map((e) => studiosNameImagesImageTypeGetFormatFromJson(e.toString()))
      .toList();
}

String? studiosNameImagesImageTypeHeadImageTypeNullableToJson(
    enums.StudiosNameImagesImageTypeHeadImageType?
        studiosNameImagesImageTypeHeadImageType) {
  return studiosNameImagesImageTypeHeadImageType?.value;
}

String? studiosNameImagesImageTypeHeadImageTypeToJson(
    enums.StudiosNameImagesImageTypeHeadImageType
        studiosNameImagesImageTypeHeadImageType) {
  return studiosNameImagesImageTypeHeadImageType.value;
}

enums.StudiosNameImagesImageTypeHeadImageType
    studiosNameImagesImageTypeHeadImageTypeFromJson(
  Object? studiosNameImagesImageTypeHeadImageType, [
  enums.StudiosNameImagesImageTypeHeadImageType? defaultValue,
]) {
  return enums.StudiosNameImagesImageTypeHeadImageType.values.firstWhereOrNull(
          (e) => e.value == studiosNameImagesImageTypeHeadImageType) ??
      defaultValue ??
      enums.StudiosNameImagesImageTypeHeadImageType.swaggerGeneratedUnknown;
}

enums.StudiosNameImagesImageTypeHeadImageType?
    studiosNameImagesImageTypeHeadImageTypeNullableFromJson(
  Object? studiosNameImagesImageTypeHeadImageType, [
  enums.StudiosNameImagesImageTypeHeadImageType? defaultValue,
]) {
  if (studiosNameImagesImageTypeHeadImageType == null) {
    return null;
  }
  return enums.StudiosNameImagesImageTypeHeadImageType.values.firstWhereOrNull(
          (e) => e.value == studiosNameImagesImageTypeHeadImageType) ??
      defaultValue;
}

String studiosNameImagesImageTypeHeadImageTypeExplodedListToJson(
    List<enums.StudiosNameImagesImageTypeHeadImageType>?
        studiosNameImagesImageTypeHeadImageType) {
  return studiosNameImagesImageTypeHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> studiosNameImagesImageTypeHeadImageTypeListToJson(
    List<enums.StudiosNameImagesImageTypeHeadImageType>?
        studiosNameImagesImageTypeHeadImageType) {
  if (studiosNameImagesImageTypeHeadImageType == null) {
    return [];
  }

  return studiosNameImagesImageTypeHeadImageType.map((e) => e.value!).toList();
}

List<enums.StudiosNameImagesImageTypeHeadImageType>
    studiosNameImagesImageTypeHeadImageTypeListFromJson(
  List? studiosNameImagesImageTypeHeadImageType, [
  List<enums.StudiosNameImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (studiosNameImagesImageTypeHeadImageType == null) {
    return defaultValue ?? [];
  }

  return studiosNameImagesImageTypeHeadImageType
      .map((e) => studiosNameImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

List<enums.StudiosNameImagesImageTypeHeadImageType>?
    studiosNameImagesImageTypeHeadImageTypeNullableListFromJson(
  List? studiosNameImagesImageTypeHeadImageType, [
  List<enums.StudiosNameImagesImageTypeHeadImageType>? defaultValue,
]) {
  if (studiosNameImagesImageTypeHeadImageType == null) {
    return defaultValue;
  }

  return studiosNameImagesImageTypeHeadImageType
      .map((e) => studiosNameImagesImageTypeHeadImageTypeFromJson(e.toString()))
      .toList();
}

String? studiosNameImagesImageTypeHeadFormatNullableToJson(
    enums.StudiosNameImagesImageTypeHeadFormat?
        studiosNameImagesImageTypeHeadFormat) {
  return studiosNameImagesImageTypeHeadFormat?.value;
}

String? studiosNameImagesImageTypeHeadFormatToJson(
    enums.StudiosNameImagesImageTypeHeadFormat
        studiosNameImagesImageTypeHeadFormat) {
  return studiosNameImagesImageTypeHeadFormat.value;
}

enums.StudiosNameImagesImageTypeHeadFormat
    studiosNameImagesImageTypeHeadFormatFromJson(
  Object? studiosNameImagesImageTypeHeadFormat, [
  enums.StudiosNameImagesImageTypeHeadFormat? defaultValue,
]) {
  return enums.StudiosNameImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == studiosNameImagesImageTypeHeadFormat) ??
      defaultValue ??
      enums.StudiosNameImagesImageTypeHeadFormat.swaggerGeneratedUnknown;
}

enums.StudiosNameImagesImageTypeHeadFormat?
    studiosNameImagesImageTypeHeadFormatNullableFromJson(
  Object? studiosNameImagesImageTypeHeadFormat, [
  enums.StudiosNameImagesImageTypeHeadFormat? defaultValue,
]) {
  if (studiosNameImagesImageTypeHeadFormat == null) {
    return null;
  }
  return enums.StudiosNameImagesImageTypeHeadFormat.values.firstWhereOrNull(
          (e) => e.value == studiosNameImagesImageTypeHeadFormat) ??
      defaultValue;
}

String studiosNameImagesImageTypeHeadFormatExplodedListToJson(
    List<enums.StudiosNameImagesImageTypeHeadFormat>?
        studiosNameImagesImageTypeHeadFormat) {
  return studiosNameImagesImageTypeHeadFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<String> studiosNameImagesImageTypeHeadFormatListToJson(
    List<enums.StudiosNameImagesImageTypeHeadFormat>?
        studiosNameImagesImageTypeHeadFormat) {
  if (studiosNameImagesImageTypeHeadFormat == null) {
    return [];
  }

  return studiosNameImagesImageTypeHeadFormat.map((e) => e.value!).toList();
}

List<enums.StudiosNameImagesImageTypeHeadFormat>
    studiosNameImagesImageTypeHeadFormatListFromJson(
  List? studiosNameImagesImageTypeHeadFormat, [
  List<enums.StudiosNameImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (studiosNameImagesImageTypeHeadFormat == null) {
    return defaultValue ?? [];
  }

  return studiosNameImagesImageTypeHeadFormat
      .map((e) => studiosNameImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.StudiosNameImagesImageTypeHeadFormat>?
    studiosNameImagesImageTypeHeadFormatNullableListFromJson(
  List? studiosNameImagesImageTypeHeadFormat, [
  List<enums.StudiosNameImagesImageTypeHeadFormat>? defaultValue,
]) {
  if (studiosNameImagesImageTypeHeadFormat == null) {
    return defaultValue;
  }

  return studiosNameImagesImageTypeHeadFormat
      .map((e) => studiosNameImagesImageTypeHeadFormatFromJson(e.toString()))
      .toList();
}

String? studiosNameImagesImageTypeImageIndexGetImageTypeNullableToJson(
    enums.StudiosNameImagesImageTypeImageIndexGetImageType?
        studiosNameImagesImageTypeImageIndexGetImageType) {
  return studiosNameImagesImageTypeImageIndexGetImageType?.value;
}

String? studiosNameImagesImageTypeImageIndexGetImageTypeToJson(
    enums.StudiosNameImagesImageTypeImageIndexGetImageType
        studiosNameImagesImageTypeImageIndexGetImageType) {
  return studiosNameImagesImageTypeImageIndexGetImageType.value;
}

enums.StudiosNameImagesImageTypeImageIndexGetImageType
    studiosNameImagesImageTypeImageIndexGetImageTypeFromJson(
  Object? studiosNameImagesImageTypeImageIndexGetImageType, [
  enums.StudiosNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  return enums.StudiosNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == studiosNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue ??
      enums.StudiosNameImagesImageTypeImageIndexGetImageType
          .swaggerGeneratedUnknown;
}

enums.StudiosNameImagesImageTypeImageIndexGetImageType?
    studiosNameImagesImageTypeImageIndexGetImageTypeNullableFromJson(
  Object? studiosNameImagesImageTypeImageIndexGetImageType, [
  enums.StudiosNameImagesImageTypeImageIndexGetImageType? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexGetImageType == null) {
    return null;
  }
  return enums.StudiosNameImagesImageTypeImageIndexGetImageType.values
          .firstWhereOrNull((e) =>
              e.value == studiosNameImagesImageTypeImageIndexGetImageType) ??
      defaultValue;
}

String studiosNameImagesImageTypeImageIndexGetImageTypeExplodedListToJson(
    List<enums.StudiosNameImagesImageTypeImageIndexGetImageType>?
        studiosNameImagesImageTypeImageIndexGetImageType) {
  return studiosNameImagesImageTypeImageIndexGetImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> studiosNameImagesImageTypeImageIndexGetImageTypeListToJson(
    List<enums.StudiosNameImagesImageTypeImageIndexGetImageType>?
        studiosNameImagesImageTypeImageIndexGetImageType) {
  if (studiosNameImagesImageTypeImageIndexGetImageType == null) {
    return [];
  }

  return studiosNameImagesImageTypeImageIndexGetImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.StudiosNameImagesImageTypeImageIndexGetImageType>
    studiosNameImagesImageTypeImageIndexGetImageTypeListFromJson(
  List? studiosNameImagesImageTypeImageIndexGetImageType, [
  List<enums.StudiosNameImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue ?? [];
  }

  return studiosNameImagesImageTypeImageIndexGetImageType
      .map((e) => studiosNameImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.StudiosNameImagesImageTypeImageIndexGetImageType>?
    studiosNameImagesImageTypeImageIndexGetImageTypeNullableListFromJson(
  List? studiosNameImagesImageTypeImageIndexGetImageType, [
  List<enums.StudiosNameImagesImageTypeImageIndexGetImageType>? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexGetImageType == null) {
    return defaultValue;
  }

  return studiosNameImagesImageTypeImageIndexGetImageType
      .map((e) => studiosNameImagesImageTypeImageIndexGetImageTypeFromJson(
          e.toString()))
      .toList();
}

String? studiosNameImagesImageTypeImageIndexGetFormatNullableToJson(
    enums.StudiosNameImagesImageTypeImageIndexGetFormat?
        studiosNameImagesImageTypeImageIndexGetFormat) {
  return studiosNameImagesImageTypeImageIndexGetFormat?.value;
}

String? studiosNameImagesImageTypeImageIndexGetFormatToJson(
    enums.StudiosNameImagesImageTypeImageIndexGetFormat
        studiosNameImagesImageTypeImageIndexGetFormat) {
  return studiosNameImagesImageTypeImageIndexGetFormat.value;
}

enums.StudiosNameImagesImageTypeImageIndexGetFormat
    studiosNameImagesImageTypeImageIndexGetFormatFromJson(
  Object? studiosNameImagesImageTypeImageIndexGetFormat, [
  enums.StudiosNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  return enums.StudiosNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == studiosNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue ??
      enums.StudiosNameImagesImageTypeImageIndexGetFormat
          .swaggerGeneratedUnknown;
}

enums.StudiosNameImagesImageTypeImageIndexGetFormat?
    studiosNameImagesImageTypeImageIndexGetFormatNullableFromJson(
  Object? studiosNameImagesImageTypeImageIndexGetFormat, [
  enums.StudiosNameImagesImageTypeImageIndexGetFormat? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexGetFormat == null) {
    return null;
  }
  return enums.StudiosNameImagesImageTypeImageIndexGetFormat.values
          .firstWhereOrNull((e) =>
              e.value == studiosNameImagesImageTypeImageIndexGetFormat) ??
      defaultValue;
}

String studiosNameImagesImageTypeImageIndexGetFormatExplodedListToJson(
    List<enums.StudiosNameImagesImageTypeImageIndexGetFormat>?
        studiosNameImagesImageTypeImageIndexGetFormat) {
  return studiosNameImagesImageTypeImageIndexGetFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> studiosNameImagesImageTypeImageIndexGetFormatListToJson(
    List<enums.StudiosNameImagesImageTypeImageIndexGetFormat>?
        studiosNameImagesImageTypeImageIndexGetFormat) {
  if (studiosNameImagesImageTypeImageIndexGetFormat == null) {
    return [];
  }

  return studiosNameImagesImageTypeImageIndexGetFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.StudiosNameImagesImageTypeImageIndexGetFormat>
    studiosNameImagesImageTypeImageIndexGetFormatListFromJson(
  List? studiosNameImagesImageTypeImageIndexGetFormat, [
  List<enums.StudiosNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue ?? [];
  }

  return studiosNameImagesImageTypeImageIndexGetFormat
      .map((e) =>
          studiosNameImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.StudiosNameImagesImageTypeImageIndexGetFormat>?
    studiosNameImagesImageTypeImageIndexGetFormatNullableListFromJson(
  List? studiosNameImagesImageTypeImageIndexGetFormat, [
  List<enums.StudiosNameImagesImageTypeImageIndexGetFormat>? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexGetFormat == null) {
    return defaultValue;
  }

  return studiosNameImagesImageTypeImageIndexGetFormat
      .map((e) =>
          studiosNameImagesImageTypeImageIndexGetFormatFromJson(e.toString()))
      .toList();
}

String? studiosNameImagesImageTypeImageIndexHeadImageTypeNullableToJson(
    enums.StudiosNameImagesImageTypeImageIndexHeadImageType?
        studiosNameImagesImageTypeImageIndexHeadImageType) {
  return studiosNameImagesImageTypeImageIndexHeadImageType?.value;
}

String? studiosNameImagesImageTypeImageIndexHeadImageTypeToJson(
    enums.StudiosNameImagesImageTypeImageIndexHeadImageType
        studiosNameImagesImageTypeImageIndexHeadImageType) {
  return studiosNameImagesImageTypeImageIndexHeadImageType.value;
}

enums.StudiosNameImagesImageTypeImageIndexHeadImageType
    studiosNameImagesImageTypeImageIndexHeadImageTypeFromJson(
  Object? studiosNameImagesImageTypeImageIndexHeadImageType, [
  enums.StudiosNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  return enums.StudiosNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == studiosNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue ??
      enums.StudiosNameImagesImageTypeImageIndexHeadImageType
          .swaggerGeneratedUnknown;
}

enums.StudiosNameImagesImageTypeImageIndexHeadImageType?
    studiosNameImagesImageTypeImageIndexHeadImageTypeNullableFromJson(
  Object? studiosNameImagesImageTypeImageIndexHeadImageType, [
  enums.StudiosNameImagesImageTypeImageIndexHeadImageType? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexHeadImageType == null) {
    return null;
  }
  return enums.StudiosNameImagesImageTypeImageIndexHeadImageType.values
          .firstWhereOrNull((e) =>
              e.value == studiosNameImagesImageTypeImageIndexHeadImageType) ??
      defaultValue;
}

String studiosNameImagesImageTypeImageIndexHeadImageTypeExplodedListToJson(
    List<enums.StudiosNameImagesImageTypeImageIndexHeadImageType>?
        studiosNameImagesImageTypeImageIndexHeadImageType) {
  return studiosNameImagesImageTypeImageIndexHeadImageType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> studiosNameImagesImageTypeImageIndexHeadImageTypeListToJson(
    List<enums.StudiosNameImagesImageTypeImageIndexHeadImageType>?
        studiosNameImagesImageTypeImageIndexHeadImageType) {
  if (studiosNameImagesImageTypeImageIndexHeadImageType == null) {
    return [];
  }

  return studiosNameImagesImageTypeImageIndexHeadImageType
      .map((e) => e.value!)
      .toList();
}

List<enums.StudiosNameImagesImageTypeImageIndexHeadImageType>
    studiosNameImagesImageTypeImageIndexHeadImageTypeListFromJson(
  List? studiosNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.StudiosNameImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue ?? [];
  }

  return studiosNameImagesImageTypeImageIndexHeadImageType
      .map((e) => studiosNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.StudiosNameImagesImageTypeImageIndexHeadImageType>?
    studiosNameImagesImageTypeImageIndexHeadImageTypeNullableListFromJson(
  List? studiosNameImagesImageTypeImageIndexHeadImageType, [
  List<enums.StudiosNameImagesImageTypeImageIndexHeadImageType>? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexHeadImageType == null) {
    return defaultValue;
  }

  return studiosNameImagesImageTypeImageIndexHeadImageType
      .map((e) => studiosNameImagesImageTypeImageIndexHeadImageTypeFromJson(
          e.toString()))
      .toList();
}

String? studiosNameImagesImageTypeImageIndexHeadFormatNullableToJson(
    enums.StudiosNameImagesImageTypeImageIndexHeadFormat?
        studiosNameImagesImageTypeImageIndexHeadFormat) {
  return studiosNameImagesImageTypeImageIndexHeadFormat?.value;
}

String? studiosNameImagesImageTypeImageIndexHeadFormatToJson(
    enums.StudiosNameImagesImageTypeImageIndexHeadFormat
        studiosNameImagesImageTypeImageIndexHeadFormat) {
  return studiosNameImagesImageTypeImageIndexHeadFormat.value;
}

enums.StudiosNameImagesImageTypeImageIndexHeadFormat
    studiosNameImagesImageTypeImageIndexHeadFormatFromJson(
  Object? studiosNameImagesImageTypeImageIndexHeadFormat, [
  enums.StudiosNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  return enums.StudiosNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == studiosNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue ??
      enums.StudiosNameImagesImageTypeImageIndexHeadFormat
          .swaggerGeneratedUnknown;
}

enums.StudiosNameImagesImageTypeImageIndexHeadFormat?
    studiosNameImagesImageTypeImageIndexHeadFormatNullableFromJson(
  Object? studiosNameImagesImageTypeImageIndexHeadFormat, [
  enums.StudiosNameImagesImageTypeImageIndexHeadFormat? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexHeadFormat == null) {
    return null;
  }
  return enums.StudiosNameImagesImageTypeImageIndexHeadFormat.values
          .firstWhereOrNull((e) =>
              e.value == studiosNameImagesImageTypeImageIndexHeadFormat) ??
      defaultValue;
}

String studiosNameImagesImageTypeImageIndexHeadFormatExplodedListToJson(
    List<enums.StudiosNameImagesImageTypeImageIndexHeadFormat>?
        studiosNameImagesImageTypeImageIndexHeadFormat) {
  return studiosNameImagesImageTypeImageIndexHeadFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> studiosNameImagesImageTypeImageIndexHeadFormatListToJson(
    List<enums.StudiosNameImagesImageTypeImageIndexHeadFormat>?
        studiosNameImagesImageTypeImageIndexHeadFormat) {
  if (studiosNameImagesImageTypeImageIndexHeadFormat == null) {
    return [];
  }

  return studiosNameImagesImageTypeImageIndexHeadFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.StudiosNameImagesImageTypeImageIndexHeadFormat>
    studiosNameImagesImageTypeImageIndexHeadFormatListFromJson(
  List? studiosNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.StudiosNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue ?? [];
  }

  return studiosNameImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          studiosNameImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.StudiosNameImagesImageTypeImageIndexHeadFormat>?
    studiosNameImagesImageTypeImageIndexHeadFormatNullableListFromJson(
  List? studiosNameImagesImageTypeImageIndexHeadFormat, [
  List<enums.StudiosNameImagesImageTypeImageIndexHeadFormat>? defaultValue,
]) {
  if (studiosNameImagesImageTypeImageIndexHeadFormat == null) {
    return defaultValue;
  }

  return studiosNameImagesImageTypeImageIndexHeadFormat
      .map((e) =>
          studiosNameImagesImageTypeImageIndexHeadFormatFromJson(e.toString()))
      .toList();
}

String? userImageGetFormatNullableToJson(
    enums.UserImageGetFormat? userImageGetFormat) {
  return userImageGetFormat?.value;
}

String? userImageGetFormatToJson(enums.UserImageGetFormat userImageGetFormat) {
  return userImageGetFormat.value;
}

enums.UserImageGetFormat userImageGetFormatFromJson(
  Object? userImageGetFormat, [
  enums.UserImageGetFormat? defaultValue,
]) {
  return enums.UserImageGetFormat.values
          .firstWhereOrNull((e) => e.value == userImageGetFormat) ??
      defaultValue ??
      enums.UserImageGetFormat.swaggerGeneratedUnknown;
}

enums.UserImageGetFormat? userImageGetFormatNullableFromJson(
  Object? userImageGetFormat, [
  enums.UserImageGetFormat? defaultValue,
]) {
  if (userImageGetFormat == null) {
    return null;
  }
  return enums.UserImageGetFormat.values
          .firstWhereOrNull((e) => e.value == userImageGetFormat) ??
      defaultValue;
}

String userImageGetFormatExplodedListToJson(
    List<enums.UserImageGetFormat>? userImageGetFormat) {
  return userImageGetFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> userImageGetFormatListToJson(
    List<enums.UserImageGetFormat>? userImageGetFormat) {
  if (userImageGetFormat == null) {
    return [];
  }

  return userImageGetFormat.map((e) => e.value!).toList();
}

List<enums.UserImageGetFormat> userImageGetFormatListFromJson(
  List? userImageGetFormat, [
  List<enums.UserImageGetFormat>? defaultValue,
]) {
  if (userImageGetFormat == null) {
    return defaultValue ?? [];
  }

  return userImageGetFormat
      .map((e) => userImageGetFormatFromJson(e.toString()))
      .toList();
}

List<enums.UserImageGetFormat>? userImageGetFormatNullableListFromJson(
  List? userImageGetFormat, [
  List<enums.UserImageGetFormat>? defaultValue,
]) {
  if (userImageGetFormat == null) {
    return defaultValue;
  }

  return userImageGetFormat
      .map((e) => userImageGetFormatFromJson(e.toString()))
      .toList();
}

String? userImageHeadFormatNullableToJson(
    enums.UserImageHeadFormat? userImageHeadFormat) {
  return userImageHeadFormat?.value;
}

String? userImageHeadFormatToJson(
    enums.UserImageHeadFormat userImageHeadFormat) {
  return userImageHeadFormat.value;
}

enums.UserImageHeadFormat userImageHeadFormatFromJson(
  Object? userImageHeadFormat, [
  enums.UserImageHeadFormat? defaultValue,
]) {
  return enums.UserImageHeadFormat.values
          .firstWhereOrNull((e) => e.value == userImageHeadFormat) ??
      defaultValue ??
      enums.UserImageHeadFormat.swaggerGeneratedUnknown;
}

enums.UserImageHeadFormat? userImageHeadFormatNullableFromJson(
  Object? userImageHeadFormat, [
  enums.UserImageHeadFormat? defaultValue,
]) {
  if (userImageHeadFormat == null) {
    return null;
  }
  return enums.UserImageHeadFormat.values
          .firstWhereOrNull((e) => e.value == userImageHeadFormat) ??
      defaultValue;
}

String userImageHeadFormatExplodedListToJson(
    List<enums.UserImageHeadFormat>? userImageHeadFormat) {
  return userImageHeadFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> userImageHeadFormatListToJson(
    List<enums.UserImageHeadFormat>? userImageHeadFormat) {
  if (userImageHeadFormat == null) {
    return [];
  }

  return userImageHeadFormat.map((e) => e.value!).toList();
}

List<enums.UserImageHeadFormat> userImageHeadFormatListFromJson(
  List? userImageHeadFormat, [
  List<enums.UserImageHeadFormat>? defaultValue,
]) {
  if (userImageHeadFormat == null) {
    return defaultValue ?? [];
  }

  return userImageHeadFormat
      .map((e) => userImageHeadFormatFromJson(e.toString()))
      .toList();
}

List<enums.UserImageHeadFormat>? userImageHeadFormatNullableListFromJson(
  List? userImageHeadFormat, [
  List<enums.UserImageHeadFormat>? defaultValue,
]) {
  if (userImageHeadFormat == null) {
    return defaultValue;
  }

  return userImageHeadFormat
      .map((e) => userImageHeadFormatFromJson(e.toString()))
      .toList();
}

String? itemsItemIdRefreshPostMetadataRefreshModeNullableToJson(
    enums.ItemsItemIdRefreshPostMetadataRefreshMode?
        itemsItemIdRefreshPostMetadataRefreshMode) {
  return itemsItemIdRefreshPostMetadataRefreshMode?.value;
}

String? itemsItemIdRefreshPostMetadataRefreshModeToJson(
    enums.ItemsItemIdRefreshPostMetadataRefreshMode
        itemsItemIdRefreshPostMetadataRefreshMode) {
  return itemsItemIdRefreshPostMetadataRefreshMode.value;
}

enums.ItemsItemIdRefreshPostMetadataRefreshMode
    itemsItemIdRefreshPostMetadataRefreshModeFromJson(
  Object? itemsItemIdRefreshPostMetadataRefreshMode, [
  enums.ItemsItemIdRefreshPostMetadataRefreshMode? defaultValue,
]) {
  return enums.ItemsItemIdRefreshPostMetadataRefreshMode.values
          .firstWhereOrNull(
              (e) => e.value == itemsItemIdRefreshPostMetadataRefreshMode) ??
      defaultValue ??
      enums.ItemsItemIdRefreshPostMetadataRefreshMode.swaggerGeneratedUnknown;
}

enums.ItemsItemIdRefreshPostMetadataRefreshMode?
    itemsItemIdRefreshPostMetadataRefreshModeNullableFromJson(
  Object? itemsItemIdRefreshPostMetadataRefreshMode, [
  enums.ItemsItemIdRefreshPostMetadataRefreshMode? defaultValue,
]) {
  if (itemsItemIdRefreshPostMetadataRefreshMode == null) {
    return null;
  }
  return enums.ItemsItemIdRefreshPostMetadataRefreshMode.values
          .firstWhereOrNull(
              (e) => e.value == itemsItemIdRefreshPostMetadataRefreshMode) ??
      defaultValue;
}

String itemsItemIdRefreshPostMetadataRefreshModeExplodedListToJson(
    List<enums.ItemsItemIdRefreshPostMetadataRefreshMode>?
        itemsItemIdRefreshPostMetadataRefreshMode) {
  return itemsItemIdRefreshPostMetadataRefreshMode
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdRefreshPostMetadataRefreshModeListToJson(
    List<enums.ItemsItemIdRefreshPostMetadataRefreshMode>?
        itemsItemIdRefreshPostMetadataRefreshMode) {
  if (itemsItemIdRefreshPostMetadataRefreshMode == null) {
    return [];
  }

  return itemsItemIdRefreshPostMetadataRefreshMode
      .map((e) => e.value!)
      .toList();
}

List<enums.ItemsItemIdRefreshPostMetadataRefreshMode>
    itemsItemIdRefreshPostMetadataRefreshModeListFromJson(
  List? itemsItemIdRefreshPostMetadataRefreshMode, [
  List<enums.ItemsItemIdRefreshPostMetadataRefreshMode>? defaultValue,
]) {
  if (itemsItemIdRefreshPostMetadataRefreshMode == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdRefreshPostMetadataRefreshMode
      .map((e) =>
          itemsItemIdRefreshPostMetadataRefreshModeFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdRefreshPostMetadataRefreshMode>?
    itemsItemIdRefreshPostMetadataRefreshModeNullableListFromJson(
  List? itemsItemIdRefreshPostMetadataRefreshMode, [
  List<enums.ItemsItemIdRefreshPostMetadataRefreshMode>? defaultValue,
]) {
  if (itemsItemIdRefreshPostMetadataRefreshMode == null) {
    return defaultValue;
  }

  return itemsItemIdRefreshPostMetadataRefreshMode
      .map((e) =>
          itemsItemIdRefreshPostMetadataRefreshModeFromJson(e.toString()))
      .toList();
}

String? itemsItemIdRefreshPostImageRefreshModeNullableToJson(
    enums.ItemsItemIdRefreshPostImageRefreshMode?
        itemsItemIdRefreshPostImageRefreshMode) {
  return itemsItemIdRefreshPostImageRefreshMode?.value;
}

String? itemsItemIdRefreshPostImageRefreshModeToJson(
    enums.ItemsItemIdRefreshPostImageRefreshMode
        itemsItemIdRefreshPostImageRefreshMode) {
  return itemsItemIdRefreshPostImageRefreshMode.value;
}

enums.ItemsItemIdRefreshPostImageRefreshMode
    itemsItemIdRefreshPostImageRefreshModeFromJson(
  Object? itemsItemIdRefreshPostImageRefreshMode, [
  enums.ItemsItemIdRefreshPostImageRefreshMode? defaultValue,
]) {
  return enums.ItemsItemIdRefreshPostImageRefreshMode.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdRefreshPostImageRefreshMode) ??
      defaultValue ??
      enums.ItemsItemIdRefreshPostImageRefreshMode.swaggerGeneratedUnknown;
}

enums.ItemsItemIdRefreshPostImageRefreshMode?
    itemsItemIdRefreshPostImageRefreshModeNullableFromJson(
  Object? itemsItemIdRefreshPostImageRefreshMode, [
  enums.ItemsItemIdRefreshPostImageRefreshMode? defaultValue,
]) {
  if (itemsItemIdRefreshPostImageRefreshMode == null) {
    return null;
  }
  return enums.ItemsItemIdRefreshPostImageRefreshMode.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdRefreshPostImageRefreshMode) ??
      defaultValue;
}

String itemsItemIdRefreshPostImageRefreshModeExplodedListToJson(
    List<enums.ItemsItemIdRefreshPostImageRefreshMode>?
        itemsItemIdRefreshPostImageRefreshMode) {
  return itemsItemIdRefreshPostImageRefreshMode
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdRefreshPostImageRefreshModeListToJson(
    List<enums.ItemsItemIdRefreshPostImageRefreshMode>?
        itemsItemIdRefreshPostImageRefreshMode) {
  if (itemsItemIdRefreshPostImageRefreshMode == null) {
    return [];
  }

  return itemsItemIdRefreshPostImageRefreshMode.map((e) => e.value!).toList();
}

List<enums.ItemsItemIdRefreshPostImageRefreshMode>
    itemsItemIdRefreshPostImageRefreshModeListFromJson(
  List? itemsItemIdRefreshPostImageRefreshMode, [
  List<enums.ItemsItemIdRefreshPostImageRefreshMode>? defaultValue,
]) {
  if (itemsItemIdRefreshPostImageRefreshMode == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdRefreshPostImageRefreshMode
      .map((e) => itemsItemIdRefreshPostImageRefreshModeFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdRefreshPostImageRefreshMode>?
    itemsItemIdRefreshPostImageRefreshModeNullableListFromJson(
  List? itemsItemIdRefreshPostImageRefreshMode, [
  List<enums.ItemsItemIdRefreshPostImageRefreshMode>? defaultValue,
]) {
  if (itemsItemIdRefreshPostImageRefreshMode == null) {
    return defaultValue;
  }

  return itemsItemIdRefreshPostImageRefreshMode
      .map((e) => itemsItemIdRefreshPostImageRefreshModeFromJson(e.toString()))
      .toList();
}

String? librariesAvailableOptionsGetLibraryContentTypeNullableToJson(
    enums.LibrariesAvailableOptionsGetLibraryContentType?
        librariesAvailableOptionsGetLibraryContentType) {
  return librariesAvailableOptionsGetLibraryContentType?.value;
}

String? librariesAvailableOptionsGetLibraryContentTypeToJson(
    enums.LibrariesAvailableOptionsGetLibraryContentType
        librariesAvailableOptionsGetLibraryContentType) {
  return librariesAvailableOptionsGetLibraryContentType.value;
}

enums.LibrariesAvailableOptionsGetLibraryContentType
    librariesAvailableOptionsGetLibraryContentTypeFromJson(
  Object? librariesAvailableOptionsGetLibraryContentType, [
  enums.LibrariesAvailableOptionsGetLibraryContentType? defaultValue,
]) {
  return enums.LibrariesAvailableOptionsGetLibraryContentType.values
          .firstWhereOrNull((e) =>
              e.value == librariesAvailableOptionsGetLibraryContentType) ??
      defaultValue ??
      enums.LibrariesAvailableOptionsGetLibraryContentType
          .swaggerGeneratedUnknown;
}

enums.LibrariesAvailableOptionsGetLibraryContentType?
    librariesAvailableOptionsGetLibraryContentTypeNullableFromJson(
  Object? librariesAvailableOptionsGetLibraryContentType, [
  enums.LibrariesAvailableOptionsGetLibraryContentType? defaultValue,
]) {
  if (librariesAvailableOptionsGetLibraryContentType == null) {
    return null;
  }
  return enums.LibrariesAvailableOptionsGetLibraryContentType.values
          .firstWhereOrNull((e) =>
              e.value == librariesAvailableOptionsGetLibraryContentType) ??
      defaultValue;
}

String librariesAvailableOptionsGetLibraryContentTypeExplodedListToJson(
    List<enums.LibrariesAvailableOptionsGetLibraryContentType>?
        librariesAvailableOptionsGetLibraryContentType) {
  return librariesAvailableOptionsGetLibraryContentType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> librariesAvailableOptionsGetLibraryContentTypeListToJson(
    List<enums.LibrariesAvailableOptionsGetLibraryContentType>?
        librariesAvailableOptionsGetLibraryContentType) {
  if (librariesAvailableOptionsGetLibraryContentType == null) {
    return [];
  }

  return librariesAvailableOptionsGetLibraryContentType
      .map((e) => e.value!)
      .toList();
}

List<enums.LibrariesAvailableOptionsGetLibraryContentType>
    librariesAvailableOptionsGetLibraryContentTypeListFromJson(
  List? librariesAvailableOptionsGetLibraryContentType, [
  List<enums.LibrariesAvailableOptionsGetLibraryContentType>? defaultValue,
]) {
  if (librariesAvailableOptionsGetLibraryContentType == null) {
    return defaultValue ?? [];
  }

  return librariesAvailableOptionsGetLibraryContentType
      .map((e) =>
          librariesAvailableOptionsGetLibraryContentTypeFromJson(e.toString()))
      .toList();
}

List<enums.LibrariesAvailableOptionsGetLibraryContentType>?
    librariesAvailableOptionsGetLibraryContentTypeNullableListFromJson(
  List? librariesAvailableOptionsGetLibraryContentType, [
  List<enums.LibrariesAvailableOptionsGetLibraryContentType>? defaultValue,
]) {
  if (librariesAvailableOptionsGetLibraryContentType == null) {
    return defaultValue;
  }

  return librariesAvailableOptionsGetLibraryContentType
      .map((e) =>
          librariesAvailableOptionsGetLibraryContentTypeFromJson(e.toString()))
      .toList();
}

String? libraryVirtualFoldersPostCollectionTypeNullableToJson(
    enums.LibraryVirtualFoldersPostCollectionType?
        libraryVirtualFoldersPostCollectionType) {
  return libraryVirtualFoldersPostCollectionType?.value;
}

String? libraryVirtualFoldersPostCollectionTypeToJson(
    enums.LibraryVirtualFoldersPostCollectionType
        libraryVirtualFoldersPostCollectionType) {
  return libraryVirtualFoldersPostCollectionType.value;
}

enums.LibraryVirtualFoldersPostCollectionType
    libraryVirtualFoldersPostCollectionTypeFromJson(
  Object? libraryVirtualFoldersPostCollectionType, [
  enums.LibraryVirtualFoldersPostCollectionType? defaultValue,
]) {
  return enums.LibraryVirtualFoldersPostCollectionType.values.firstWhereOrNull(
          (e) => e.value == libraryVirtualFoldersPostCollectionType) ??
      defaultValue ??
      enums.LibraryVirtualFoldersPostCollectionType.swaggerGeneratedUnknown;
}

enums.LibraryVirtualFoldersPostCollectionType?
    libraryVirtualFoldersPostCollectionTypeNullableFromJson(
  Object? libraryVirtualFoldersPostCollectionType, [
  enums.LibraryVirtualFoldersPostCollectionType? defaultValue,
]) {
  if (libraryVirtualFoldersPostCollectionType == null) {
    return null;
  }
  return enums.LibraryVirtualFoldersPostCollectionType.values.firstWhereOrNull(
          (e) => e.value == libraryVirtualFoldersPostCollectionType) ??
      defaultValue;
}

String libraryVirtualFoldersPostCollectionTypeExplodedListToJson(
    List<enums.LibraryVirtualFoldersPostCollectionType>?
        libraryVirtualFoldersPostCollectionType) {
  return libraryVirtualFoldersPostCollectionType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> libraryVirtualFoldersPostCollectionTypeListToJson(
    List<enums.LibraryVirtualFoldersPostCollectionType>?
        libraryVirtualFoldersPostCollectionType) {
  if (libraryVirtualFoldersPostCollectionType == null) {
    return [];
  }

  return libraryVirtualFoldersPostCollectionType.map((e) => e.value!).toList();
}

List<enums.LibraryVirtualFoldersPostCollectionType>
    libraryVirtualFoldersPostCollectionTypeListFromJson(
  List? libraryVirtualFoldersPostCollectionType, [
  List<enums.LibraryVirtualFoldersPostCollectionType>? defaultValue,
]) {
  if (libraryVirtualFoldersPostCollectionType == null) {
    return defaultValue ?? [];
  }

  return libraryVirtualFoldersPostCollectionType
      .map((e) => libraryVirtualFoldersPostCollectionTypeFromJson(e.toString()))
      .toList();
}

List<enums.LibraryVirtualFoldersPostCollectionType>?
    libraryVirtualFoldersPostCollectionTypeNullableListFromJson(
  List? libraryVirtualFoldersPostCollectionType, [
  List<enums.LibraryVirtualFoldersPostCollectionType>? defaultValue,
]) {
  if (libraryVirtualFoldersPostCollectionType == null) {
    return defaultValue;
  }

  return libraryVirtualFoldersPostCollectionType
      .map((e) => libraryVirtualFoldersPostCollectionTypeFromJson(e.toString()))
      .toList();
}

String? liveTvChannelsGetTypeNullableToJson(
    enums.LiveTvChannelsGetType? liveTvChannelsGetType) {
  return liveTvChannelsGetType?.value;
}

String? liveTvChannelsGetTypeToJson(
    enums.LiveTvChannelsGetType liveTvChannelsGetType) {
  return liveTvChannelsGetType.value;
}

enums.LiveTvChannelsGetType liveTvChannelsGetTypeFromJson(
  Object? liveTvChannelsGetType, [
  enums.LiveTvChannelsGetType? defaultValue,
]) {
  return enums.LiveTvChannelsGetType.values
          .firstWhereOrNull((e) => e.value == liveTvChannelsGetType) ??
      defaultValue ??
      enums.LiveTvChannelsGetType.swaggerGeneratedUnknown;
}

enums.LiveTvChannelsGetType? liveTvChannelsGetTypeNullableFromJson(
  Object? liveTvChannelsGetType, [
  enums.LiveTvChannelsGetType? defaultValue,
]) {
  if (liveTvChannelsGetType == null) {
    return null;
  }
  return enums.LiveTvChannelsGetType.values
          .firstWhereOrNull((e) => e.value == liveTvChannelsGetType) ??
      defaultValue;
}

String liveTvChannelsGetTypeExplodedListToJson(
    List<enums.LiveTvChannelsGetType>? liveTvChannelsGetType) {
  return liveTvChannelsGetType?.map((e) => e.value!).join(',') ?? '';
}

List<String> liveTvChannelsGetTypeListToJson(
    List<enums.LiveTvChannelsGetType>? liveTvChannelsGetType) {
  if (liveTvChannelsGetType == null) {
    return [];
  }

  return liveTvChannelsGetType.map((e) => e.value!).toList();
}

List<enums.LiveTvChannelsGetType> liveTvChannelsGetTypeListFromJson(
  List? liveTvChannelsGetType, [
  List<enums.LiveTvChannelsGetType>? defaultValue,
]) {
  if (liveTvChannelsGetType == null) {
    return defaultValue ?? [];
  }

  return liveTvChannelsGetType
      .map((e) => liveTvChannelsGetTypeFromJson(e.toString()))
      .toList();
}

List<enums.LiveTvChannelsGetType>? liveTvChannelsGetTypeNullableListFromJson(
  List? liveTvChannelsGetType, [
  List<enums.LiveTvChannelsGetType>? defaultValue,
]) {
  if (liveTvChannelsGetType == null) {
    return defaultValue;
  }

  return liveTvChannelsGetType
      .map((e) => liveTvChannelsGetTypeFromJson(e.toString()))
      .toList();
}

String? liveTvChannelsGetSortOrderNullableToJson(
    enums.LiveTvChannelsGetSortOrder? liveTvChannelsGetSortOrder) {
  return liveTvChannelsGetSortOrder?.value;
}

String? liveTvChannelsGetSortOrderToJson(
    enums.LiveTvChannelsGetSortOrder liveTvChannelsGetSortOrder) {
  return liveTvChannelsGetSortOrder.value;
}

enums.LiveTvChannelsGetSortOrder liveTvChannelsGetSortOrderFromJson(
  Object? liveTvChannelsGetSortOrder, [
  enums.LiveTvChannelsGetSortOrder? defaultValue,
]) {
  return enums.LiveTvChannelsGetSortOrder.values
          .firstWhereOrNull((e) => e.value == liveTvChannelsGetSortOrder) ??
      defaultValue ??
      enums.LiveTvChannelsGetSortOrder.swaggerGeneratedUnknown;
}

enums.LiveTvChannelsGetSortOrder? liveTvChannelsGetSortOrderNullableFromJson(
  Object? liveTvChannelsGetSortOrder, [
  enums.LiveTvChannelsGetSortOrder? defaultValue,
]) {
  if (liveTvChannelsGetSortOrder == null) {
    return null;
  }
  return enums.LiveTvChannelsGetSortOrder.values
          .firstWhereOrNull((e) => e.value == liveTvChannelsGetSortOrder) ??
      defaultValue;
}

String liveTvChannelsGetSortOrderExplodedListToJson(
    List<enums.LiveTvChannelsGetSortOrder>? liveTvChannelsGetSortOrder) {
  return liveTvChannelsGetSortOrder?.map((e) => e.value!).join(',') ?? '';
}

List<String> liveTvChannelsGetSortOrderListToJson(
    List<enums.LiveTvChannelsGetSortOrder>? liveTvChannelsGetSortOrder) {
  if (liveTvChannelsGetSortOrder == null) {
    return [];
  }

  return liveTvChannelsGetSortOrder.map((e) => e.value!).toList();
}

List<enums.LiveTvChannelsGetSortOrder> liveTvChannelsGetSortOrderListFromJson(
  List? liveTvChannelsGetSortOrder, [
  List<enums.LiveTvChannelsGetSortOrder>? defaultValue,
]) {
  if (liveTvChannelsGetSortOrder == null) {
    return defaultValue ?? [];
  }

  return liveTvChannelsGetSortOrder
      .map((e) => liveTvChannelsGetSortOrderFromJson(e.toString()))
      .toList();
}

List<enums.LiveTvChannelsGetSortOrder>?
    liveTvChannelsGetSortOrderNullableListFromJson(
  List? liveTvChannelsGetSortOrder, [
  List<enums.LiveTvChannelsGetSortOrder>? defaultValue,
]) {
  if (liveTvChannelsGetSortOrder == null) {
    return defaultValue;
  }

  return liveTvChannelsGetSortOrder
      .map((e) => liveTvChannelsGetSortOrderFromJson(e.toString()))
      .toList();
}

String? liveTvRecordingsGetStatusNullableToJson(
    enums.LiveTvRecordingsGetStatus? liveTvRecordingsGetStatus) {
  return liveTvRecordingsGetStatus?.value;
}

String? liveTvRecordingsGetStatusToJson(
    enums.LiveTvRecordingsGetStatus liveTvRecordingsGetStatus) {
  return liveTvRecordingsGetStatus.value;
}

enums.LiveTvRecordingsGetStatus liveTvRecordingsGetStatusFromJson(
  Object? liveTvRecordingsGetStatus, [
  enums.LiveTvRecordingsGetStatus? defaultValue,
]) {
  return enums.LiveTvRecordingsGetStatus.values
          .firstWhereOrNull((e) => e.value == liveTvRecordingsGetStatus) ??
      defaultValue ??
      enums.LiveTvRecordingsGetStatus.swaggerGeneratedUnknown;
}

enums.LiveTvRecordingsGetStatus? liveTvRecordingsGetStatusNullableFromJson(
  Object? liveTvRecordingsGetStatus, [
  enums.LiveTvRecordingsGetStatus? defaultValue,
]) {
  if (liveTvRecordingsGetStatus == null) {
    return null;
  }
  return enums.LiveTvRecordingsGetStatus.values
          .firstWhereOrNull((e) => e.value == liveTvRecordingsGetStatus) ??
      defaultValue;
}

String liveTvRecordingsGetStatusExplodedListToJson(
    List<enums.LiveTvRecordingsGetStatus>? liveTvRecordingsGetStatus) {
  return liveTvRecordingsGetStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> liveTvRecordingsGetStatusListToJson(
    List<enums.LiveTvRecordingsGetStatus>? liveTvRecordingsGetStatus) {
  if (liveTvRecordingsGetStatus == null) {
    return [];
  }

  return liveTvRecordingsGetStatus.map((e) => e.value!).toList();
}

List<enums.LiveTvRecordingsGetStatus> liveTvRecordingsGetStatusListFromJson(
  List? liveTvRecordingsGetStatus, [
  List<enums.LiveTvRecordingsGetStatus>? defaultValue,
]) {
  if (liveTvRecordingsGetStatus == null) {
    return defaultValue ?? [];
  }

  return liveTvRecordingsGetStatus
      .map((e) => liveTvRecordingsGetStatusFromJson(e.toString()))
      .toList();
}

List<enums.LiveTvRecordingsGetStatus>?
    liveTvRecordingsGetStatusNullableListFromJson(
  List? liveTvRecordingsGetStatus, [
  List<enums.LiveTvRecordingsGetStatus>? defaultValue,
]) {
  if (liveTvRecordingsGetStatus == null) {
    return defaultValue;
  }

  return liveTvRecordingsGetStatus
      .map((e) => liveTvRecordingsGetStatusFromJson(e.toString()))
      .toList();
}

String? liveTvRecordingsSeriesGetStatusNullableToJson(
    enums.LiveTvRecordingsSeriesGetStatus? liveTvRecordingsSeriesGetStatus) {
  return liveTvRecordingsSeriesGetStatus?.value;
}

String? liveTvRecordingsSeriesGetStatusToJson(
    enums.LiveTvRecordingsSeriesGetStatus liveTvRecordingsSeriesGetStatus) {
  return liveTvRecordingsSeriesGetStatus.value;
}

enums.LiveTvRecordingsSeriesGetStatus liveTvRecordingsSeriesGetStatusFromJson(
  Object? liveTvRecordingsSeriesGetStatus, [
  enums.LiveTvRecordingsSeriesGetStatus? defaultValue,
]) {
  return enums.LiveTvRecordingsSeriesGetStatus.values.firstWhereOrNull(
          (e) => e.value == liveTvRecordingsSeriesGetStatus) ??
      defaultValue ??
      enums.LiveTvRecordingsSeriesGetStatus.swaggerGeneratedUnknown;
}

enums.LiveTvRecordingsSeriesGetStatus?
    liveTvRecordingsSeriesGetStatusNullableFromJson(
  Object? liveTvRecordingsSeriesGetStatus, [
  enums.LiveTvRecordingsSeriesGetStatus? defaultValue,
]) {
  if (liveTvRecordingsSeriesGetStatus == null) {
    return null;
  }
  return enums.LiveTvRecordingsSeriesGetStatus.values.firstWhereOrNull(
          (e) => e.value == liveTvRecordingsSeriesGetStatus) ??
      defaultValue;
}

String liveTvRecordingsSeriesGetStatusExplodedListToJson(
    List<enums.LiveTvRecordingsSeriesGetStatus>?
        liveTvRecordingsSeriesGetStatus) {
  return liveTvRecordingsSeriesGetStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> liveTvRecordingsSeriesGetStatusListToJson(
    List<enums.LiveTvRecordingsSeriesGetStatus>?
        liveTvRecordingsSeriesGetStatus) {
  if (liveTvRecordingsSeriesGetStatus == null) {
    return [];
  }

  return liveTvRecordingsSeriesGetStatus.map((e) => e.value!).toList();
}

List<enums.LiveTvRecordingsSeriesGetStatus>
    liveTvRecordingsSeriesGetStatusListFromJson(
  List? liveTvRecordingsSeriesGetStatus, [
  List<enums.LiveTvRecordingsSeriesGetStatus>? defaultValue,
]) {
  if (liveTvRecordingsSeriesGetStatus == null) {
    return defaultValue ?? [];
  }

  return liveTvRecordingsSeriesGetStatus
      .map((e) => liveTvRecordingsSeriesGetStatusFromJson(e.toString()))
      .toList();
}

List<enums.LiveTvRecordingsSeriesGetStatus>?
    liveTvRecordingsSeriesGetStatusNullableListFromJson(
  List? liveTvRecordingsSeriesGetStatus, [
  List<enums.LiveTvRecordingsSeriesGetStatus>? defaultValue,
]) {
  if (liveTvRecordingsSeriesGetStatus == null) {
    return defaultValue;
  }

  return liveTvRecordingsSeriesGetStatus
      .map((e) => liveTvRecordingsSeriesGetStatusFromJson(e.toString()))
      .toList();
}

String? liveTvSeriesTimersGetSortOrderNullableToJson(
    enums.LiveTvSeriesTimersGetSortOrder? liveTvSeriesTimersGetSortOrder) {
  return liveTvSeriesTimersGetSortOrder?.value;
}

String? liveTvSeriesTimersGetSortOrderToJson(
    enums.LiveTvSeriesTimersGetSortOrder liveTvSeriesTimersGetSortOrder) {
  return liveTvSeriesTimersGetSortOrder.value;
}

enums.LiveTvSeriesTimersGetSortOrder liveTvSeriesTimersGetSortOrderFromJson(
  Object? liveTvSeriesTimersGetSortOrder, [
  enums.LiveTvSeriesTimersGetSortOrder? defaultValue,
]) {
  return enums.LiveTvSeriesTimersGetSortOrder.values
          .firstWhereOrNull((e) => e.value == liveTvSeriesTimersGetSortOrder) ??
      defaultValue ??
      enums.LiveTvSeriesTimersGetSortOrder.swaggerGeneratedUnknown;
}

enums.LiveTvSeriesTimersGetSortOrder?
    liveTvSeriesTimersGetSortOrderNullableFromJson(
  Object? liveTvSeriesTimersGetSortOrder, [
  enums.LiveTvSeriesTimersGetSortOrder? defaultValue,
]) {
  if (liveTvSeriesTimersGetSortOrder == null) {
    return null;
  }
  return enums.LiveTvSeriesTimersGetSortOrder.values
          .firstWhereOrNull((e) => e.value == liveTvSeriesTimersGetSortOrder) ??
      defaultValue;
}

String liveTvSeriesTimersGetSortOrderExplodedListToJson(
    List<enums.LiveTvSeriesTimersGetSortOrder>?
        liveTvSeriesTimersGetSortOrder) {
  return liveTvSeriesTimersGetSortOrder?.map((e) => e.value!).join(',') ?? '';
}

List<String> liveTvSeriesTimersGetSortOrderListToJson(
    List<enums.LiveTvSeriesTimersGetSortOrder>?
        liveTvSeriesTimersGetSortOrder) {
  if (liveTvSeriesTimersGetSortOrder == null) {
    return [];
  }

  return liveTvSeriesTimersGetSortOrder.map((e) => e.value!).toList();
}

List<enums.LiveTvSeriesTimersGetSortOrder>
    liveTvSeriesTimersGetSortOrderListFromJson(
  List? liveTvSeriesTimersGetSortOrder, [
  List<enums.LiveTvSeriesTimersGetSortOrder>? defaultValue,
]) {
  if (liveTvSeriesTimersGetSortOrder == null) {
    return defaultValue ?? [];
  }

  return liveTvSeriesTimersGetSortOrder
      .map((e) => liveTvSeriesTimersGetSortOrderFromJson(e.toString()))
      .toList();
}

List<enums.LiveTvSeriesTimersGetSortOrder>?
    liveTvSeriesTimersGetSortOrderNullableListFromJson(
  List? liveTvSeriesTimersGetSortOrder, [
  List<enums.LiveTvSeriesTimersGetSortOrder>? defaultValue,
]) {
  if (liveTvSeriesTimersGetSortOrder == null) {
    return defaultValue;
  }

  return liveTvSeriesTimersGetSortOrder
      .map((e) => liveTvSeriesTimersGetSortOrderFromJson(e.toString()))
      .toList();
}

String? playlistsPostMediaTypeNullableToJson(
    enums.PlaylistsPostMediaType? playlistsPostMediaType) {
  return playlistsPostMediaType?.value;
}

String? playlistsPostMediaTypeToJson(
    enums.PlaylistsPostMediaType playlistsPostMediaType) {
  return playlistsPostMediaType.value;
}

enums.PlaylistsPostMediaType playlistsPostMediaTypeFromJson(
  Object? playlistsPostMediaType, [
  enums.PlaylistsPostMediaType? defaultValue,
]) {
  return enums.PlaylistsPostMediaType.values
          .firstWhereOrNull((e) => e.value == playlistsPostMediaType) ??
      defaultValue ??
      enums.PlaylistsPostMediaType.swaggerGeneratedUnknown;
}

enums.PlaylistsPostMediaType? playlistsPostMediaTypeNullableFromJson(
  Object? playlistsPostMediaType, [
  enums.PlaylistsPostMediaType? defaultValue,
]) {
  if (playlistsPostMediaType == null) {
    return null;
  }
  return enums.PlaylistsPostMediaType.values
          .firstWhereOrNull((e) => e.value == playlistsPostMediaType) ??
      defaultValue;
}

String playlistsPostMediaTypeExplodedListToJson(
    List<enums.PlaylistsPostMediaType>? playlistsPostMediaType) {
  return playlistsPostMediaType?.map((e) => e.value!).join(',') ?? '';
}

List<String> playlistsPostMediaTypeListToJson(
    List<enums.PlaylistsPostMediaType>? playlistsPostMediaType) {
  if (playlistsPostMediaType == null) {
    return [];
  }

  return playlistsPostMediaType.map((e) => e.value!).toList();
}

List<enums.PlaylistsPostMediaType> playlistsPostMediaTypeListFromJson(
  List? playlistsPostMediaType, [
  List<enums.PlaylistsPostMediaType>? defaultValue,
]) {
  if (playlistsPostMediaType == null) {
    return defaultValue ?? [];
  }

  return playlistsPostMediaType
      .map((e) => playlistsPostMediaTypeFromJson(e.toString()))
      .toList();
}

List<enums.PlaylistsPostMediaType>? playlistsPostMediaTypeNullableListFromJson(
  List? playlistsPostMediaType, [
  List<enums.PlaylistsPostMediaType>? defaultValue,
]) {
  if (playlistsPostMediaType == null) {
    return defaultValue;
  }

  return playlistsPostMediaType
      .map((e) => playlistsPostMediaTypeFromJson(e.toString()))
      .toList();
}

String? playingItemsItemIdPostPlayMethodNullableToJson(
    enums.PlayingItemsItemIdPostPlayMethod? playingItemsItemIdPostPlayMethod) {
  return playingItemsItemIdPostPlayMethod?.value;
}

String? playingItemsItemIdPostPlayMethodToJson(
    enums.PlayingItemsItemIdPostPlayMethod playingItemsItemIdPostPlayMethod) {
  return playingItemsItemIdPostPlayMethod.value;
}

enums.PlayingItemsItemIdPostPlayMethod playingItemsItemIdPostPlayMethodFromJson(
  Object? playingItemsItemIdPostPlayMethod, [
  enums.PlayingItemsItemIdPostPlayMethod? defaultValue,
]) {
  return enums.PlayingItemsItemIdPostPlayMethod.values.firstWhereOrNull(
          (e) => e.value == playingItemsItemIdPostPlayMethod) ??
      defaultValue ??
      enums.PlayingItemsItemIdPostPlayMethod.swaggerGeneratedUnknown;
}

enums.PlayingItemsItemIdPostPlayMethod?
    playingItemsItemIdPostPlayMethodNullableFromJson(
  Object? playingItemsItemIdPostPlayMethod, [
  enums.PlayingItemsItemIdPostPlayMethod? defaultValue,
]) {
  if (playingItemsItemIdPostPlayMethod == null) {
    return null;
  }
  return enums.PlayingItemsItemIdPostPlayMethod.values.firstWhereOrNull(
          (e) => e.value == playingItemsItemIdPostPlayMethod) ??
      defaultValue;
}

String playingItemsItemIdPostPlayMethodExplodedListToJson(
    List<enums.PlayingItemsItemIdPostPlayMethod>?
        playingItemsItemIdPostPlayMethod) {
  return playingItemsItemIdPostPlayMethod?.map((e) => e.value!).join(',') ?? '';
}

List<String> playingItemsItemIdPostPlayMethodListToJson(
    List<enums.PlayingItemsItemIdPostPlayMethod>?
        playingItemsItemIdPostPlayMethod) {
  if (playingItemsItemIdPostPlayMethod == null) {
    return [];
  }

  return playingItemsItemIdPostPlayMethod.map((e) => e.value!).toList();
}

List<enums.PlayingItemsItemIdPostPlayMethod>
    playingItemsItemIdPostPlayMethodListFromJson(
  List? playingItemsItemIdPostPlayMethod, [
  List<enums.PlayingItemsItemIdPostPlayMethod>? defaultValue,
]) {
  if (playingItemsItemIdPostPlayMethod == null) {
    return defaultValue ?? [];
  }

  return playingItemsItemIdPostPlayMethod
      .map((e) => playingItemsItemIdPostPlayMethodFromJson(e.toString()))
      .toList();
}

List<enums.PlayingItemsItemIdPostPlayMethod>?
    playingItemsItemIdPostPlayMethodNullableListFromJson(
  List? playingItemsItemIdPostPlayMethod, [
  List<enums.PlayingItemsItemIdPostPlayMethod>? defaultValue,
]) {
  if (playingItemsItemIdPostPlayMethod == null) {
    return defaultValue;
  }

  return playingItemsItemIdPostPlayMethod
      .map((e) => playingItemsItemIdPostPlayMethodFromJson(e.toString()))
      .toList();
}

String? playingItemsItemIdProgressPostPlayMethodNullableToJson(
    enums.PlayingItemsItemIdProgressPostPlayMethod?
        playingItemsItemIdProgressPostPlayMethod) {
  return playingItemsItemIdProgressPostPlayMethod?.value;
}

String? playingItemsItemIdProgressPostPlayMethodToJson(
    enums.PlayingItemsItemIdProgressPostPlayMethod
        playingItemsItemIdProgressPostPlayMethod) {
  return playingItemsItemIdProgressPostPlayMethod.value;
}

enums.PlayingItemsItemIdProgressPostPlayMethod
    playingItemsItemIdProgressPostPlayMethodFromJson(
  Object? playingItemsItemIdProgressPostPlayMethod, [
  enums.PlayingItemsItemIdProgressPostPlayMethod? defaultValue,
]) {
  return enums.PlayingItemsItemIdProgressPostPlayMethod.values.firstWhereOrNull(
          (e) => e.value == playingItemsItemIdProgressPostPlayMethod) ??
      defaultValue ??
      enums.PlayingItemsItemIdProgressPostPlayMethod.swaggerGeneratedUnknown;
}

enums.PlayingItemsItemIdProgressPostPlayMethod?
    playingItemsItemIdProgressPostPlayMethodNullableFromJson(
  Object? playingItemsItemIdProgressPostPlayMethod, [
  enums.PlayingItemsItemIdProgressPostPlayMethod? defaultValue,
]) {
  if (playingItemsItemIdProgressPostPlayMethod == null) {
    return null;
  }
  return enums.PlayingItemsItemIdProgressPostPlayMethod.values.firstWhereOrNull(
          (e) => e.value == playingItemsItemIdProgressPostPlayMethod) ??
      defaultValue;
}

String playingItemsItemIdProgressPostPlayMethodExplodedListToJson(
    List<enums.PlayingItemsItemIdProgressPostPlayMethod>?
        playingItemsItemIdProgressPostPlayMethod) {
  return playingItemsItemIdProgressPostPlayMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> playingItemsItemIdProgressPostPlayMethodListToJson(
    List<enums.PlayingItemsItemIdProgressPostPlayMethod>?
        playingItemsItemIdProgressPostPlayMethod) {
  if (playingItemsItemIdProgressPostPlayMethod == null) {
    return [];
  }

  return playingItemsItemIdProgressPostPlayMethod.map((e) => e.value!).toList();
}

List<enums.PlayingItemsItemIdProgressPostPlayMethod>
    playingItemsItemIdProgressPostPlayMethodListFromJson(
  List? playingItemsItemIdProgressPostPlayMethod, [
  List<enums.PlayingItemsItemIdProgressPostPlayMethod>? defaultValue,
]) {
  if (playingItemsItemIdProgressPostPlayMethod == null) {
    return defaultValue ?? [];
  }

  return playingItemsItemIdProgressPostPlayMethod
      .map(
          (e) => playingItemsItemIdProgressPostPlayMethodFromJson(e.toString()))
      .toList();
}

List<enums.PlayingItemsItemIdProgressPostPlayMethod>?
    playingItemsItemIdProgressPostPlayMethodNullableListFromJson(
  List? playingItemsItemIdProgressPostPlayMethod, [
  List<enums.PlayingItemsItemIdProgressPostPlayMethod>? defaultValue,
]) {
  if (playingItemsItemIdProgressPostPlayMethod == null) {
    return defaultValue;
  }

  return playingItemsItemIdProgressPostPlayMethod
      .map(
          (e) => playingItemsItemIdProgressPostPlayMethodFromJson(e.toString()))
      .toList();
}

String? playingItemsItemIdProgressPostRepeatModeNullableToJson(
    enums.PlayingItemsItemIdProgressPostRepeatMode?
        playingItemsItemIdProgressPostRepeatMode) {
  return playingItemsItemIdProgressPostRepeatMode?.value;
}

String? playingItemsItemIdProgressPostRepeatModeToJson(
    enums.PlayingItemsItemIdProgressPostRepeatMode
        playingItemsItemIdProgressPostRepeatMode) {
  return playingItemsItemIdProgressPostRepeatMode.value;
}

enums.PlayingItemsItemIdProgressPostRepeatMode
    playingItemsItemIdProgressPostRepeatModeFromJson(
  Object? playingItemsItemIdProgressPostRepeatMode, [
  enums.PlayingItemsItemIdProgressPostRepeatMode? defaultValue,
]) {
  return enums.PlayingItemsItemIdProgressPostRepeatMode.values.firstWhereOrNull(
          (e) => e.value == playingItemsItemIdProgressPostRepeatMode) ??
      defaultValue ??
      enums.PlayingItemsItemIdProgressPostRepeatMode.swaggerGeneratedUnknown;
}

enums.PlayingItemsItemIdProgressPostRepeatMode?
    playingItemsItemIdProgressPostRepeatModeNullableFromJson(
  Object? playingItemsItemIdProgressPostRepeatMode, [
  enums.PlayingItemsItemIdProgressPostRepeatMode? defaultValue,
]) {
  if (playingItemsItemIdProgressPostRepeatMode == null) {
    return null;
  }
  return enums.PlayingItemsItemIdProgressPostRepeatMode.values.firstWhereOrNull(
          (e) => e.value == playingItemsItemIdProgressPostRepeatMode) ??
      defaultValue;
}

String playingItemsItemIdProgressPostRepeatModeExplodedListToJson(
    List<enums.PlayingItemsItemIdProgressPostRepeatMode>?
        playingItemsItemIdProgressPostRepeatMode) {
  return playingItemsItemIdProgressPostRepeatMode
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> playingItemsItemIdProgressPostRepeatModeListToJson(
    List<enums.PlayingItemsItemIdProgressPostRepeatMode>?
        playingItemsItemIdProgressPostRepeatMode) {
  if (playingItemsItemIdProgressPostRepeatMode == null) {
    return [];
  }

  return playingItemsItemIdProgressPostRepeatMode.map((e) => e.value!).toList();
}

List<enums.PlayingItemsItemIdProgressPostRepeatMode>
    playingItemsItemIdProgressPostRepeatModeListFromJson(
  List? playingItemsItemIdProgressPostRepeatMode, [
  List<enums.PlayingItemsItemIdProgressPostRepeatMode>? defaultValue,
]) {
  if (playingItemsItemIdProgressPostRepeatMode == null) {
    return defaultValue ?? [];
  }

  return playingItemsItemIdProgressPostRepeatMode
      .map(
          (e) => playingItemsItemIdProgressPostRepeatModeFromJson(e.toString()))
      .toList();
}

List<enums.PlayingItemsItemIdProgressPostRepeatMode>?
    playingItemsItemIdProgressPostRepeatModeNullableListFromJson(
  List? playingItemsItemIdProgressPostRepeatMode, [
  List<enums.PlayingItemsItemIdProgressPostRepeatMode>? defaultValue,
]) {
  if (playingItemsItemIdProgressPostRepeatMode == null) {
    return defaultValue;
  }

  return playingItemsItemIdProgressPostRepeatMode
      .map(
          (e) => playingItemsItemIdProgressPostRepeatModeFromJson(e.toString()))
      .toList();
}

String? itemsItemIdRemoteImagesGetTypeNullableToJson(
    enums.ItemsItemIdRemoteImagesGetType? itemsItemIdRemoteImagesGetType) {
  return itemsItemIdRemoteImagesGetType?.value;
}

String? itemsItemIdRemoteImagesGetTypeToJson(
    enums.ItemsItemIdRemoteImagesGetType itemsItemIdRemoteImagesGetType) {
  return itemsItemIdRemoteImagesGetType.value;
}

enums.ItemsItemIdRemoteImagesGetType itemsItemIdRemoteImagesGetTypeFromJson(
  Object? itemsItemIdRemoteImagesGetType, [
  enums.ItemsItemIdRemoteImagesGetType? defaultValue,
]) {
  return enums.ItemsItemIdRemoteImagesGetType.values
          .firstWhereOrNull((e) => e.value == itemsItemIdRemoteImagesGetType) ??
      defaultValue ??
      enums.ItemsItemIdRemoteImagesGetType.swaggerGeneratedUnknown;
}

enums.ItemsItemIdRemoteImagesGetType?
    itemsItemIdRemoteImagesGetTypeNullableFromJson(
  Object? itemsItemIdRemoteImagesGetType, [
  enums.ItemsItemIdRemoteImagesGetType? defaultValue,
]) {
  if (itemsItemIdRemoteImagesGetType == null) {
    return null;
  }
  return enums.ItemsItemIdRemoteImagesGetType.values
          .firstWhereOrNull((e) => e.value == itemsItemIdRemoteImagesGetType) ??
      defaultValue;
}

String itemsItemIdRemoteImagesGetTypeExplodedListToJson(
    List<enums.ItemsItemIdRemoteImagesGetType>?
        itemsItemIdRemoteImagesGetType) {
  return itemsItemIdRemoteImagesGetType?.map((e) => e.value!).join(',') ?? '';
}

List<String> itemsItemIdRemoteImagesGetTypeListToJson(
    List<enums.ItemsItemIdRemoteImagesGetType>?
        itemsItemIdRemoteImagesGetType) {
  if (itemsItemIdRemoteImagesGetType == null) {
    return [];
  }

  return itemsItemIdRemoteImagesGetType.map((e) => e.value!).toList();
}

List<enums.ItemsItemIdRemoteImagesGetType>
    itemsItemIdRemoteImagesGetTypeListFromJson(
  List? itemsItemIdRemoteImagesGetType, [
  List<enums.ItemsItemIdRemoteImagesGetType>? defaultValue,
]) {
  if (itemsItemIdRemoteImagesGetType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdRemoteImagesGetType
      .map((e) => itemsItemIdRemoteImagesGetTypeFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdRemoteImagesGetType>?
    itemsItemIdRemoteImagesGetTypeNullableListFromJson(
  List? itemsItemIdRemoteImagesGetType, [
  List<enums.ItemsItemIdRemoteImagesGetType>? defaultValue,
]) {
  if (itemsItemIdRemoteImagesGetType == null) {
    return defaultValue;
  }

  return itemsItemIdRemoteImagesGetType
      .map((e) => itemsItemIdRemoteImagesGetTypeFromJson(e.toString()))
      .toList();
}

String? itemsItemIdRemoteImagesDownloadPostTypeNullableToJson(
    enums.ItemsItemIdRemoteImagesDownloadPostType?
        itemsItemIdRemoteImagesDownloadPostType) {
  return itemsItemIdRemoteImagesDownloadPostType?.value;
}

String? itemsItemIdRemoteImagesDownloadPostTypeToJson(
    enums.ItemsItemIdRemoteImagesDownloadPostType
        itemsItemIdRemoteImagesDownloadPostType) {
  return itemsItemIdRemoteImagesDownloadPostType.value;
}

enums.ItemsItemIdRemoteImagesDownloadPostType
    itemsItemIdRemoteImagesDownloadPostTypeFromJson(
  Object? itemsItemIdRemoteImagesDownloadPostType, [
  enums.ItemsItemIdRemoteImagesDownloadPostType? defaultValue,
]) {
  return enums.ItemsItemIdRemoteImagesDownloadPostType.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdRemoteImagesDownloadPostType) ??
      defaultValue ??
      enums.ItemsItemIdRemoteImagesDownloadPostType.swaggerGeneratedUnknown;
}

enums.ItemsItemIdRemoteImagesDownloadPostType?
    itemsItemIdRemoteImagesDownloadPostTypeNullableFromJson(
  Object? itemsItemIdRemoteImagesDownloadPostType, [
  enums.ItemsItemIdRemoteImagesDownloadPostType? defaultValue,
]) {
  if (itemsItemIdRemoteImagesDownloadPostType == null) {
    return null;
  }
  return enums.ItemsItemIdRemoteImagesDownloadPostType.values.firstWhereOrNull(
          (e) => e.value == itemsItemIdRemoteImagesDownloadPostType) ??
      defaultValue;
}

String itemsItemIdRemoteImagesDownloadPostTypeExplodedListToJson(
    List<enums.ItemsItemIdRemoteImagesDownloadPostType>?
        itemsItemIdRemoteImagesDownloadPostType) {
  return itemsItemIdRemoteImagesDownloadPostType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> itemsItemIdRemoteImagesDownloadPostTypeListToJson(
    List<enums.ItemsItemIdRemoteImagesDownloadPostType>?
        itemsItemIdRemoteImagesDownloadPostType) {
  if (itemsItemIdRemoteImagesDownloadPostType == null) {
    return [];
  }

  return itemsItemIdRemoteImagesDownloadPostType.map((e) => e.value!).toList();
}

List<enums.ItemsItemIdRemoteImagesDownloadPostType>
    itemsItemIdRemoteImagesDownloadPostTypeListFromJson(
  List? itemsItemIdRemoteImagesDownloadPostType, [
  List<enums.ItemsItemIdRemoteImagesDownloadPostType>? defaultValue,
]) {
  if (itemsItemIdRemoteImagesDownloadPostType == null) {
    return defaultValue ?? [];
  }

  return itemsItemIdRemoteImagesDownloadPostType
      .map((e) => itemsItemIdRemoteImagesDownloadPostTypeFromJson(e.toString()))
      .toList();
}

List<enums.ItemsItemIdRemoteImagesDownloadPostType>?
    itemsItemIdRemoteImagesDownloadPostTypeNullableListFromJson(
  List? itemsItemIdRemoteImagesDownloadPostType, [
  List<enums.ItemsItemIdRemoteImagesDownloadPostType>? defaultValue,
]) {
  if (itemsItemIdRemoteImagesDownloadPostType == null) {
    return defaultValue;
  }

  return itemsItemIdRemoteImagesDownloadPostType
      .map((e) => itemsItemIdRemoteImagesDownloadPostTypeFromJson(e.toString()))
      .toList();
}

String? sessionsSessionIdCommandCommandPostCommandNullableToJson(
    enums.SessionsSessionIdCommandCommandPostCommand?
        sessionsSessionIdCommandCommandPostCommand) {
  return sessionsSessionIdCommandCommandPostCommand?.value;
}

String? sessionsSessionIdCommandCommandPostCommandToJson(
    enums.SessionsSessionIdCommandCommandPostCommand
        sessionsSessionIdCommandCommandPostCommand) {
  return sessionsSessionIdCommandCommandPostCommand.value;
}

enums.SessionsSessionIdCommandCommandPostCommand
    sessionsSessionIdCommandCommandPostCommandFromJson(
  Object? sessionsSessionIdCommandCommandPostCommand, [
  enums.SessionsSessionIdCommandCommandPostCommand? defaultValue,
]) {
  return enums.SessionsSessionIdCommandCommandPostCommand.values
          .firstWhereOrNull(
              (e) => e.value == sessionsSessionIdCommandCommandPostCommand) ??
      defaultValue ??
      enums.SessionsSessionIdCommandCommandPostCommand.swaggerGeneratedUnknown;
}

enums.SessionsSessionIdCommandCommandPostCommand?
    sessionsSessionIdCommandCommandPostCommandNullableFromJson(
  Object? sessionsSessionIdCommandCommandPostCommand, [
  enums.SessionsSessionIdCommandCommandPostCommand? defaultValue,
]) {
  if (sessionsSessionIdCommandCommandPostCommand == null) {
    return null;
  }
  return enums.SessionsSessionIdCommandCommandPostCommand.values
          .firstWhereOrNull(
              (e) => e.value == sessionsSessionIdCommandCommandPostCommand) ??
      defaultValue;
}

String sessionsSessionIdCommandCommandPostCommandExplodedListToJson(
    List<enums.SessionsSessionIdCommandCommandPostCommand>?
        sessionsSessionIdCommandCommandPostCommand) {
  return sessionsSessionIdCommandCommandPostCommand
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> sessionsSessionIdCommandCommandPostCommandListToJson(
    List<enums.SessionsSessionIdCommandCommandPostCommand>?
        sessionsSessionIdCommandCommandPostCommand) {
  if (sessionsSessionIdCommandCommandPostCommand == null) {
    return [];
  }

  return sessionsSessionIdCommandCommandPostCommand
      .map((e) => e.value!)
      .toList();
}

List<enums.SessionsSessionIdCommandCommandPostCommand>
    sessionsSessionIdCommandCommandPostCommandListFromJson(
  List? sessionsSessionIdCommandCommandPostCommand, [
  List<enums.SessionsSessionIdCommandCommandPostCommand>? defaultValue,
]) {
  if (sessionsSessionIdCommandCommandPostCommand == null) {
    return defaultValue ?? [];
  }

  return sessionsSessionIdCommandCommandPostCommand
      .map((e) =>
          sessionsSessionIdCommandCommandPostCommandFromJson(e.toString()))
      .toList();
}

List<enums.SessionsSessionIdCommandCommandPostCommand>?
    sessionsSessionIdCommandCommandPostCommandNullableListFromJson(
  List? sessionsSessionIdCommandCommandPostCommand, [
  List<enums.SessionsSessionIdCommandCommandPostCommand>? defaultValue,
]) {
  if (sessionsSessionIdCommandCommandPostCommand == null) {
    return defaultValue;
  }

  return sessionsSessionIdCommandCommandPostCommand
      .map((e) =>
          sessionsSessionIdCommandCommandPostCommandFromJson(e.toString()))
      .toList();
}

String? sessionsSessionIdPlayingPostPlayCommandNullableToJson(
    enums.SessionsSessionIdPlayingPostPlayCommand?
        sessionsSessionIdPlayingPostPlayCommand) {
  return sessionsSessionIdPlayingPostPlayCommand?.value;
}

String? sessionsSessionIdPlayingPostPlayCommandToJson(
    enums.SessionsSessionIdPlayingPostPlayCommand
        sessionsSessionIdPlayingPostPlayCommand) {
  return sessionsSessionIdPlayingPostPlayCommand.value;
}

enums.SessionsSessionIdPlayingPostPlayCommand
    sessionsSessionIdPlayingPostPlayCommandFromJson(
  Object? sessionsSessionIdPlayingPostPlayCommand, [
  enums.SessionsSessionIdPlayingPostPlayCommand? defaultValue,
]) {
  return enums.SessionsSessionIdPlayingPostPlayCommand.values.firstWhereOrNull(
          (e) => e.value == sessionsSessionIdPlayingPostPlayCommand) ??
      defaultValue ??
      enums.SessionsSessionIdPlayingPostPlayCommand.swaggerGeneratedUnknown;
}

enums.SessionsSessionIdPlayingPostPlayCommand?
    sessionsSessionIdPlayingPostPlayCommandNullableFromJson(
  Object? sessionsSessionIdPlayingPostPlayCommand, [
  enums.SessionsSessionIdPlayingPostPlayCommand? defaultValue,
]) {
  if (sessionsSessionIdPlayingPostPlayCommand == null) {
    return null;
  }
  return enums.SessionsSessionIdPlayingPostPlayCommand.values.firstWhereOrNull(
          (e) => e.value == sessionsSessionIdPlayingPostPlayCommand) ??
      defaultValue;
}

String sessionsSessionIdPlayingPostPlayCommandExplodedListToJson(
    List<enums.SessionsSessionIdPlayingPostPlayCommand>?
        sessionsSessionIdPlayingPostPlayCommand) {
  return sessionsSessionIdPlayingPostPlayCommand
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> sessionsSessionIdPlayingPostPlayCommandListToJson(
    List<enums.SessionsSessionIdPlayingPostPlayCommand>?
        sessionsSessionIdPlayingPostPlayCommand) {
  if (sessionsSessionIdPlayingPostPlayCommand == null) {
    return [];
  }

  return sessionsSessionIdPlayingPostPlayCommand.map((e) => e.value!).toList();
}

List<enums.SessionsSessionIdPlayingPostPlayCommand>
    sessionsSessionIdPlayingPostPlayCommandListFromJson(
  List? sessionsSessionIdPlayingPostPlayCommand, [
  List<enums.SessionsSessionIdPlayingPostPlayCommand>? defaultValue,
]) {
  if (sessionsSessionIdPlayingPostPlayCommand == null) {
    return defaultValue ?? [];
  }

  return sessionsSessionIdPlayingPostPlayCommand
      .map((e) => sessionsSessionIdPlayingPostPlayCommandFromJson(e.toString()))
      .toList();
}

List<enums.SessionsSessionIdPlayingPostPlayCommand>?
    sessionsSessionIdPlayingPostPlayCommandNullableListFromJson(
  List? sessionsSessionIdPlayingPostPlayCommand, [
  List<enums.SessionsSessionIdPlayingPostPlayCommand>? defaultValue,
]) {
  if (sessionsSessionIdPlayingPostPlayCommand == null) {
    return defaultValue;
  }

  return sessionsSessionIdPlayingPostPlayCommand
      .map((e) => sessionsSessionIdPlayingPostPlayCommandFromJson(e.toString()))
      .toList();
}

String? sessionsSessionIdPlayingCommandPostCommandNullableToJson(
    enums.SessionsSessionIdPlayingCommandPostCommand?
        sessionsSessionIdPlayingCommandPostCommand) {
  return sessionsSessionIdPlayingCommandPostCommand?.value;
}

String? sessionsSessionIdPlayingCommandPostCommandToJson(
    enums.SessionsSessionIdPlayingCommandPostCommand
        sessionsSessionIdPlayingCommandPostCommand) {
  return sessionsSessionIdPlayingCommandPostCommand.value;
}

enums.SessionsSessionIdPlayingCommandPostCommand
    sessionsSessionIdPlayingCommandPostCommandFromJson(
  Object? sessionsSessionIdPlayingCommandPostCommand, [
  enums.SessionsSessionIdPlayingCommandPostCommand? defaultValue,
]) {
  return enums.SessionsSessionIdPlayingCommandPostCommand.values
          .firstWhereOrNull(
              (e) => e.value == sessionsSessionIdPlayingCommandPostCommand) ??
      defaultValue ??
      enums.SessionsSessionIdPlayingCommandPostCommand.swaggerGeneratedUnknown;
}

enums.SessionsSessionIdPlayingCommandPostCommand?
    sessionsSessionIdPlayingCommandPostCommandNullableFromJson(
  Object? sessionsSessionIdPlayingCommandPostCommand, [
  enums.SessionsSessionIdPlayingCommandPostCommand? defaultValue,
]) {
  if (sessionsSessionIdPlayingCommandPostCommand == null) {
    return null;
  }
  return enums.SessionsSessionIdPlayingCommandPostCommand.values
          .firstWhereOrNull(
              (e) => e.value == sessionsSessionIdPlayingCommandPostCommand) ??
      defaultValue;
}

String sessionsSessionIdPlayingCommandPostCommandExplodedListToJson(
    List<enums.SessionsSessionIdPlayingCommandPostCommand>?
        sessionsSessionIdPlayingCommandPostCommand) {
  return sessionsSessionIdPlayingCommandPostCommand
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> sessionsSessionIdPlayingCommandPostCommandListToJson(
    List<enums.SessionsSessionIdPlayingCommandPostCommand>?
        sessionsSessionIdPlayingCommandPostCommand) {
  if (sessionsSessionIdPlayingCommandPostCommand == null) {
    return [];
  }

  return sessionsSessionIdPlayingCommandPostCommand
      .map((e) => e.value!)
      .toList();
}

List<enums.SessionsSessionIdPlayingCommandPostCommand>
    sessionsSessionIdPlayingCommandPostCommandListFromJson(
  List? sessionsSessionIdPlayingCommandPostCommand, [
  List<enums.SessionsSessionIdPlayingCommandPostCommand>? defaultValue,
]) {
  if (sessionsSessionIdPlayingCommandPostCommand == null) {
    return defaultValue ?? [];
  }

  return sessionsSessionIdPlayingCommandPostCommand
      .map((e) =>
          sessionsSessionIdPlayingCommandPostCommandFromJson(e.toString()))
      .toList();
}

List<enums.SessionsSessionIdPlayingCommandPostCommand>?
    sessionsSessionIdPlayingCommandPostCommandNullableListFromJson(
  List? sessionsSessionIdPlayingCommandPostCommand, [
  List<enums.SessionsSessionIdPlayingCommandPostCommand>? defaultValue,
]) {
  if (sessionsSessionIdPlayingCommandPostCommand == null) {
    return defaultValue;
  }

  return sessionsSessionIdPlayingCommandPostCommand
      .map((e) =>
          sessionsSessionIdPlayingCommandPostCommandFromJson(e.toString()))
      .toList();
}

String? sessionsSessionIdSystemCommandPostCommandNullableToJson(
    enums.SessionsSessionIdSystemCommandPostCommand?
        sessionsSessionIdSystemCommandPostCommand) {
  return sessionsSessionIdSystemCommandPostCommand?.value;
}

String? sessionsSessionIdSystemCommandPostCommandToJson(
    enums.SessionsSessionIdSystemCommandPostCommand
        sessionsSessionIdSystemCommandPostCommand) {
  return sessionsSessionIdSystemCommandPostCommand.value;
}

enums.SessionsSessionIdSystemCommandPostCommand
    sessionsSessionIdSystemCommandPostCommandFromJson(
  Object? sessionsSessionIdSystemCommandPostCommand, [
  enums.SessionsSessionIdSystemCommandPostCommand? defaultValue,
]) {
  return enums.SessionsSessionIdSystemCommandPostCommand.values
          .firstWhereOrNull(
              (e) => e.value == sessionsSessionIdSystemCommandPostCommand) ??
      defaultValue ??
      enums.SessionsSessionIdSystemCommandPostCommand.swaggerGeneratedUnknown;
}

enums.SessionsSessionIdSystemCommandPostCommand?
    sessionsSessionIdSystemCommandPostCommandNullableFromJson(
  Object? sessionsSessionIdSystemCommandPostCommand, [
  enums.SessionsSessionIdSystemCommandPostCommand? defaultValue,
]) {
  if (sessionsSessionIdSystemCommandPostCommand == null) {
    return null;
  }
  return enums.SessionsSessionIdSystemCommandPostCommand.values
          .firstWhereOrNull(
              (e) => e.value == sessionsSessionIdSystemCommandPostCommand) ??
      defaultValue;
}

String sessionsSessionIdSystemCommandPostCommandExplodedListToJson(
    List<enums.SessionsSessionIdSystemCommandPostCommand>?
        sessionsSessionIdSystemCommandPostCommand) {
  return sessionsSessionIdSystemCommandPostCommand
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> sessionsSessionIdSystemCommandPostCommandListToJson(
    List<enums.SessionsSessionIdSystemCommandPostCommand>?
        sessionsSessionIdSystemCommandPostCommand) {
  if (sessionsSessionIdSystemCommandPostCommand == null) {
    return [];
  }

  return sessionsSessionIdSystemCommandPostCommand
      .map((e) => e.value!)
      .toList();
}

List<enums.SessionsSessionIdSystemCommandPostCommand>
    sessionsSessionIdSystemCommandPostCommandListFromJson(
  List? sessionsSessionIdSystemCommandPostCommand, [
  List<enums.SessionsSessionIdSystemCommandPostCommand>? defaultValue,
]) {
  if (sessionsSessionIdSystemCommandPostCommand == null) {
    return defaultValue ?? [];
  }

  return sessionsSessionIdSystemCommandPostCommand
      .map((e) =>
          sessionsSessionIdSystemCommandPostCommandFromJson(e.toString()))
      .toList();
}

List<enums.SessionsSessionIdSystemCommandPostCommand>?
    sessionsSessionIdSystemCommandPostCommandNullableListFromJson(
  List? sessionsSessionIdSystemCommandPostCommand, [
  List<enums.SessionsSessionIdSystemCommandPostCommand>? defaultValue,
]) {
  if (sessionsSessionIdSystemCommandPostCommand == null) {
    return defaultValue;
  }

  return sessionsSessionIdSystemCommandPostCommand
      .map((e) =>
          sessionsSessionIdSystemCommandPostCommandFromJson(e.toString()))
      .toList();
}

String? sessionsSessionIdViewingPostItemTypeNullableToJson(
    enums.SessionsSessionIdViewingPostItemType?
        sessionsSessionIdViewingPostItemType) {
  return sessionsSessionIdViewingPostItemType?.value;
}

String? sessionsSessionIdViewingPostItemTypeToJson(
    enums.SessionsSessionIdViewingPostItemType
        sessionsSessionIdViewingPostItemType) {
  return sessionsSessionIdViewingPostItemType.value;
}

enums.SessionsSessionIdViewingPostItemType
    sessionsSessionIdViewingPostItemTypeFromJson(
  Object? sessionsSessionIdViewingPostItemType, [
  enums.SessionsSessionIdViewingPostItemType? defaultValue,
]) {
  return enums.SessionsSessionIdViewingPostItemType.values.firstWhereOrNull(
          (e) => e.value == sessionsSessionIdViewingPostItemType) ??
      defaultValue ??
      enums.SessionsSessionIdViewingPostItemType.swaggerGeneratedUnknown;
}

enums.SessionsSessionIdViewingPostItemType?
    sessionsSessionIdViewingPostItemTypeNullableFromJson(
  Object? sessionsSessionIdViewingPostItemType, [
  enums.SessionsSessionIdViewingPostItemType? defaultValue,
]) {
  if (sessionsSessionIdViewingPostItemType == null) {
    return null;
  }
  return enums.SessionsSessionIdViewingPostItemType.values.firstWhereOrNull(
          (e) => e.value == sessionsSessionIdViewingPostItemType) ??
      defaultValue;
}

String sessionsSessionIdViewingPostItemTypeExplodedListToJson(
    List<enums.SessionsSessionIdViewingPostItemType>?
        sessionsSessionIdViewingPostItemType) {
  return sessionsSessionIdViewingPostItemType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> sessionsSessionIdViewingPostItemTypeListToJson(
    List<enums.SessionsSessionIdViewingPostItemType>?
        sessionsSessionIdViewingPostItemType) {
  if (sessionsSessionIdViewingPostItemType == null) {
    return [];
  }

  return sessionsSessionIdViewingPostItemType.map((e) => e.value!).toList();
}

List<enums.SessionsSessionIdViewingPostItemType>
    sessionsSessionIdViewingPostItemTypeListFromJson(
  List? sessionsSessionIdViewingPostItemType, [
  List<enums.SessionsSessionIdViewingPostItemType>? defaultValue,
]) {
  if (sessionsSessionIdViewingPostItemType == null) {
    return defaultValue ?? [];
  }

  return sessionsSessionIdViewingPostItemType
      .map((e) => sessionsSessionIdViewingPostItemTypeFromJson(e.toString()))
      .toList();
}

List<enums.SessionsSessionIdViewingPostItemType>?
    sessionsSessionIdViewingPostItemTypeNullableListFromJson(
  List? sessionsSessionIdViewingPostItemType, [
  List<enums.SessionsSessionIdViewingPostItemType>? defaultValue,
]) {
  if (sessionsSessionIdViewingPostItemType == null) {
    return defaultValue;
  }

  return sessionsSessionIdViewingPostItemType
      .map((e) => sessionsSessionIdViewingPostItemTypeFromJson(e.toString()))
      .toList();
}

String? showsSeriesIdEpisodesGetSortByNullableToJson(
    enums.ShowsSeriesIdEpisodesGetSortBy? showsSeriesIdEpisodesGetSortBy) {
  return showsSeriesIdEpisodesGetSortBy?.value;
}

String? showsSeriesIdEpisodesGetSortByToJson(
    enums.ShowsSeriesIdEpisodesGetSortBy showsSeriesIdEpisodesGetSortBy) {
  return showsSeriesIdEpisodesGetSortBy.value;
}

enums.ShowsSeriesIdEpisodesGetSortBy showsSeriesIdEpisodesGetSortByFromJson(
  Object? showsSeriesIdEpisodesGetSortBy, [
  enums.ShowsSeriesIdEpisodesGetSortBy? defaultValue,
]) {
  return enums.ShowsSeriesIdEpisodesGetSortBy.values
          .firstWhereOrNull((e) => e.value == showsSeriesIdEpisodesGetSortBy) ??
      defaultValue ??
      enums.ShowsSeriesIdEpisodesGetSortBy.swaggerGeneratedUnknown;
}

enums.ShowsSeriesIdEpisodesGetSortBy?
    showsSeriesIdEpisodesGetSortByNullableFromJson(
  Object? showsSeriesIdEpisodesGetSortBy, [
  enums.ShowsSeriesIdEpisodesGetSortBy? defaultValue,
]) {
  if (showsSeriesIdEpisodesGetSortBy == null) {
    return null;
  }
  return enums.ShowsSeriesIdEpisodesGetSortBy.values
          .firstWhereOrNull((e) => e.value == showsSeriesIdEpisodesGetSortBy) ??
      defaultValue;
}

String showsSeriesIdEpisodesGetSortByExplodedListToJson(
    List<enums.ShowsSeriesIdEpisodesGetSortBy>?
        showsSeriesIdEpisodesGetSortBy) {
  return showsSeriesIdEpisodesGetSortBy?.map((e) => e.value!).join(',') ?? '';
}

List<String> showsSeriesIdEpisodesGetSortByListToJson(
    List<enums.ShowsSeriesIdEpisodesGetSortBy>?
        showsSeriesIdEpisodesGetSortBy) {
  if (showsSeriesIdEpisodesGetSortBy == null) {
    return [];
  }

  return showsSeriesIdEpisodesGetSortBy.map((e) => e.value!).toList();
}

List<enums.ShowsSeriesIdEpisodesGetSortBy>
    showsSeriesIdEpisodesGetSortByListFromJson(
  List? showsSeriesIdEpisodesGetSortBy, [
  List<enums.ShowsSeriesIdEpisodesGetSortBy>? defaultValue,
]) {
  if (showsSeriesIdEpisodesGetSortBy == null) {
    return defaultValue ?? [];
  }

  return showsSeriesIdEpisodesGetSortBy
      .map((e) => showsSeriesIdEpisodesGetSortByFromJson(e.toString()))
      .toList();
}

List<enums.ShowsSeriesIdEpisodesGetSortBy>?
    showsSeriesIdEpisodesGetSortByNullableListFromJson(
  List? showsSeriesIdEpisodesGetSortBy, [
  List<enums.ShowsSeriesIdEpisodesGetSortBy>? defaultValue,
]) {
  if (showsSeriesIdEpisodesGetSortBy == null) {
    return defaultValue;
  }

  return showsSeriesIdEpisodesGetSortBy
      .map((e) => showsSeriesIdEpisodesGetSortByFromJson(e.toString()))
      .toList();
}

String? audioItemIdUniversalGetTranscodingProtocolNullableToJson(
    enums.AudioItemIdUniversalGetTranscodingProtocol?
        audioItemIdUniversalGetTranscodingProtocol) {
  return audioItemIdUniversalGetTranscodingProtocol?.value;
}

String? audioItemIdUniversalGetTranscodingProtocolToJson(
    enums.AudioItemIdUniversalGetTranscodingProtocol
        audioItemIdUniversalGetTranscodingProtocol) {
  return audioItemIdUniversalGetTranscodingProtocol.value;
}

enums.AudioItemIdUniversalGetTranscodingProtocol
    audioItemIdUniversalGetTranscodingProtocolFromJson(
  Object? audioItemIdUniversalGetTranscodingProtocol, [
  enums.AudioItemIdUniversalGetTranscodingProtocol? defaultValue,
]) {
  return enums.AudioItemIdUniversalGetTranscodingProtocol.values
          .firstWhereOrNull(
              (e) => e.value == audioItemIdUniversalGetTranscodingProtocol) ??
      defaultValue ??
      enums.AudioItemIdUniversalGetTranscodingProtocol.swaggerGeneratedUnknown;
}

enums.AudioItemIdUniversalGetTranscodingProtocol?
    audioItemIdUniversalGetTranscodingProtocolNullableFromJson(
  Object? audioItemIdUniversalGetTranscodingProtocol, [
  enums.AudioItemIdUniversalGetTranscodingProtocol? defaultValue,
]) {
  if (audioItemIdUniversalGetTranscodingProtocol == null) {
    return null;
  }
  return enums.AudioItemIdUniversalGetTranscodingProtocol.values
          .firstWhereOrNull(
              (e) => e.value == audioItemIdUniversalGetTranscodingProtocol) ??
      defaultValue;
}

String audioItemIdUniversalGetTranscodingProtocolExplodedListToJson(
    List<enums.AudioItemIdUniversalGetTranscodingProtocol>?
        audioItemIdUniversalGetTranscodingProtocol) {
  return audioItemIdUniversalGetTranscodingProtocol
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> audioItemIdUniversalGetTranscodingProtocolListToJson(
    List<enums.AudioItemIdUniversalGetTranscodingProtocol>?
        audioItemIdUniversalGetTranscodingProtocol) {
  if (audioItemIdUniversalGetTranscodingProtocol == null) {
    return [];
  }

  return audioItemIdUniversalGetTranscodingProtocol
      .map((e) => e.value!)
      .toList();
}

List<enums.AudioItemIdUniversalGetTranscodingProtocol>
    audioItemIdUniversalGetTranscodingProtocolListFromJson(
  List? audioItemIdUniversalGetTranscodingProtocol, [
  List<enums.AudioItemIdUniversalGetTranscodingProtocol>? defaultValue,
]) {
  if (audioItemIdUniversalGetTranscodingProtocol == null) {
    return defaultValue ?? [];
  }

  return audioItemIdUniversalGetTranscodingProtocol
      .map((e) =>
          audioItemIdUniversalGetTranscodingProtocolFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdUniversalGetTranscodingProtocol>?
    audioItemIdUniversalGetTranscodingProtocolNullableListFromJson(
  List? audioItemIdUniversalGetTranscodingProtocol, [
  List<enums.AudioItemIdUniversalGetTranscodingProtocol>? defaultValue,
]) {
  if (audioItemIdUniversalGetTranscodingProtocol == null) {
    return defaultValue;
  }

  return audioItemIdUniversalGetTranscodingProtocol
      .map((e) =>
          audioItemIdUniversalGetTranscodingProtocolFromJson(e.toString()))
      .toList();
}

String? audioItemIdUniversalHeadTranscodingProtocolNullableToJson(
    enums.AudioItemIdUniversalHeadTranscodingProtocol?
        audioItemIdUniversalHeadTranscodingProtocol) {
  return audioItemIdUniversalHeadTranscodingProtocol?.value;
}

String? audioItemIdUniversalHeadTranscodingProtocolToJson(
    enums.AudioItemIdUniversalHeadTranscodingProtocol
        audioItemIdUniversalHeadTranscodingProtocol) {
  return audioItemIdUniversalHeadTranscodingProtocol.value;
}

enums.AudioItemIdUniversalHeadTranscodingProtocol
    audioItemIdUniversalHeadTranscodingProtocolFromJson(
  Object? audioItemIdUniversalHeadTranscodingProtocol, [
  enums.AudioItemIdUniversalHeadTranscodingProtocol? defaultValue,
]) {
  return enums.AudioItemIdUniversalHeadTranscodingProtocol.values
          .firstWhereOrNull(
              (e) => e.value == audioItemIdUniversalHeadTranscodingProtocol) ??
      defaultValue ??
      enums.AudioItemIdUniversalHeadTranscodingProtocol.swaggerGeneratedUnknown;
}

enums.AudioItemIdUniversalHeadTranscodingProtocol?
    audioItemIdUniversalHeadTranscodingProtocolNullableFromJson(
  Object? audioItemIdUniversalHeadTranscodingProtocol, [
  enums.AudioItemIdUniversalHeadTranscodingProtocol? defaultValue,
]) {
  if (audioItemIdUniversalHeadTranscodingProtocol == null) {
    return null;
  }
  return enums.AudioItemIdUniversalHeadTranscodingProtocol.values
          .firstWhereOrNull(
              (e) => e.value == audioItemIdUniversalHeadTranscodingProtocol) ??
      defaultValue;
}

String audioItemIdUniversalHeadTranscodingProtocolExplodedListToJson(
    List<enums.AudioItemIdUniversalHeadTranscodingProtocol>?
        audioItemIdUniversalHeadTranscodingProtocol) {
  return audioItemIdUniversalHeadTranscodingProtocol
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> audioItemIdUniversalHeadTranscodingProtocolListToJson(
    List<enums.AudioItemIdUniversalHeadTranscodingProtocol>?
        audioItemIdUniversalHeadTranscodingProtocol) {
  if (audioItemIdUniversalHeadTranscodingProtocol == null) {
    return [];
  }

  return audioItemIdUniversalHeadTranscodingProtocol
      .map((e) => e.value!)
      .toList();
}

List<enums.AudioItemIdUniversalHeadTranscodingProtocol>
    audioItemIdUniversalHeadTranscodingProtocolListFromJson(
  List? audioItemIdUniversalHeadTranscodingProtocol, [
  List<enums.AudioItemIdUniversalHeadTranscodingProtocol>? defaultValue,
]) {
  if (audioItemIdUniversalHeadTranscodingProtocol == null) {
    return defaultValue ?? [];
  }

  return audioItemIdUniversalHeadTranscodingProtocol
      .map((e) =>
          audioItemIdUniversalHeadTranscodingProtocolFromJson(e.toString()))
      .toList();
}

List<enums.AudioItemIdUniversalHeadTranscodingProtocol>?
    audioItemIdUniversalHeadTranscodingProtocolNullableListFromJson(
  List? audioItemIdUniversalHeadTranscodingProtocol, [
  List<enums.AudioItemIdUniversalHeadTranscodingProtocol>? defaultValue,
]) {
  if (audioItemIdUniversalHeadTranscodingProtocol == null) {
    return defaultValue;
  }

  return audioItemIdUniversalHeadTranscodingProtocol
      .map((e) =>
          audioItemIdUniversalHeadTranscodingProtocolFromJson(e.toString()))
      .toList();
}

String? videosItemIdStreamGetSubtitleMethodNullableToJson(
    enums.VideosItemIdStreamGetSubtitleMethod?
        videosItemIdStreamGetSubtitleMethod) {
  return videosItemIdStreamGetSubtitleMethod?.value;
}

String? videosItemIdStreamGetSubtitleMethodToJson(
    enums.VideosItemIdStreamGetSubtitleMethod
        videosItemIdStreamGetSubtitleMethod) {
  return videosItemIdStreamGetSubtitleMethod.value;
}

enums.VideosItemIdStreamGetSubtitleMethod
    videosItemIdStreamGetSubtitleMethodFromJson(
  Object? videosItemIdStreamGetSubtitleMethod, [
  enums.VideosItemIdStreamGetSubtitleMethod? defaultValue,
]) {
  return enums.VideosItemIdStreamGetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdStreamGetSubtitleMethod) ??
      defaultValue ??
      enums.VideosItemIdStreamGetSubtitleMethod.swaggerGeneratedUnknown;
}

enums.VideosItemIdStreamGetSubtitleMethod?
    videosItemIdStreamGetSubtitleMethodNullableFromJson(
  Object? videosItemIdStreamGetSubtitleMethod, [
  enums.VideosItemIdStreamGetSubtitleMethod? defaultValue,
]) {
  if (videosItemIdStreamGetSubtitleMethod == null) {
    return null;
  }
  return enums.VideosItemIdStreamGetSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdStreamGetSubtitleMethod) ??
      defaultValue;
}

String videosItemIdStreamGetSubtitleMethodExplodedListToJson(
    List<enums.VideosItemIdStreamGetSubtitleMethod>?
        videosItemIdStreamGetSubtitleMethod) {
  return videosItemIdStreamGetSubtitleMethod?.map((e) => e.value!).join(',') ??
      '';
}

List<String> videosItemIdStreamGetSubtitleMethodListToJson(
    List<enums.VideosItemIdStreamGetSubtitleMethod>?
        videosItemIdStreamGetSubtitleMethod) {
  if (videosItemIdStreamGetSubtitleMethod == null) {
    return [];
  }

  return videosItemIdStreamGetSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.VideosItemIdStreamGetSubtitleMethod>
    videosItemIdStreamGetSubtitleMethodListFromJson(
  List? videosItemIdStreamGetSubtitleMethod, [
  List<enums.VideosItemIdStreamGetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdStreamGetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return videosItemIdStreamGetSubtitleMethod
      .map((e) => videosItemIdStreamGetSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdStreamGetSubtitleMethod>?
    videosItemIdStreamGetSubtitleMethodNullableListFromJson(
  List? videosItemIdStreamGetSubtitleMethod, [
  List<enums.VideosItemIdStreamGetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdStreamGetSubtitleMethod == null) {
    return defaultValue;
  }

  return videosItemIdStreamGetSubtitleMethod
      .map((e) => videosItemIdStreamGetSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? videosItemIdStreamGetContextNullableToJson(
    enums.VideosItemIdStreamGetContext? videosItemIdStreamGetContext) {
  return videosItemIdStreamGetContext?.value;
}

String? videosItemIdStreamGetContextToJson(
    enums.VideosItemIdStreamGetContext videosItemIdStreamGetContext) {
  return videosItemIdStreamGetContext.value;
}

enums.VideosItemIdStreamGetContext videosItemIdStreamGetContextFromJson(
  Object? videosItemIdStreamGetContext, [
  enums.VideosItemIdStreamGetContext? defaultValue,
]) {
  return enums.VideosItemIdStreamGetContext.values
          .firstWhereOrNull((e) => e.value == videosItemIdStreamGetContext) ??
      defaultValue ??
      enums.VideosItemIdStreamGetContext.swaggerGeneratedUnknown;
}

enums.VideosItemIdStreamGetContext?
    videosItemIdStreamGetContextNullableFromJson(
  Object? videosItemIdStreamGetContext, [
  enums.VideosItemIdStreamGetContext? defaultValue,
]) {
  if (videosItemIdStreamGetContext == null) {
    return null;
  }
  return enums.VideosItemIdStreamGetContext.values
          .firstWhereOrNull((e) => e.value == videosItemIdStreamGetContext) ??
      defaultValue;
}

String videosItemIdStreamGetContextExplodedListToJson(
    List<enums.VideosItemIdStreamGetContext>? videosItemIdStreamGetContext) {
  return videosItemIdStreamGetContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> videosItemIdStreamGetContextListToJson(
    List<enums.VideosItemIdStreamGetContext>? videosItemIdStreamGetContext) {
  if (videosItemIdStreamGetContext == null) {
    return [];
  }

  return videosItemIdStreamGetContext.map((e) => e.value!).toList();
}

List<enums.VideosItemIdStreamGetContext>
    videosItemIdStreamGetContextListFromJson(
  List? videosItemIdStreamGetContext, [
  List<enums.VideosItemIdStreamGetContext>? defaultValue,
]) {
  if (videosItemIdStreamGetContext == null) {
    return defaultValue ?? [];
  }

  return videosItemIdStreamGetContext
      .map((e) => videosItemIdStreamGetContextFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdStreamGetContext>?
    videosItemIdStreamGetContextNullableListFromJson(
  List? videosItemIdStreamGetContext, [
  List<enums.VideosItemIdStreamGetContext>? defaultValue,
]) {
  if (videosItemIdStreamGetContext == null) {
    return defaultValue;
  }

  return videosItemIdStreamGetContext
      .map((e) => videosItemIdStreamGetContextFromJson(e.toString()))
      .toList();
}

String? videosItemIdStreamHeadSubtitleMethodNullableToJson(
    enums.VideosItemIdStreamHeadSubtitleMethod?
        videosItemIdStreamHeadSubtitleMethod) {
  return videosItemIdStreamHeadSubtitleMethod?.value;
}

String? videosItemIdStreamHeadSubtitleMethodToJson(
    enums.VideosItemIdStreamHeadSubtitleMethod
        videosItemIdStreamHeadSubtitleMethod) {
  return videosItemIdStreamHeadSubtitleMethod.value;
}

enums.VideosItemIdStreamHeadSubtitleMethod
    videosItemIdStreamHeadSubtitleMethodFromJson(
  Object? videosItemIdStreamHeadSubtitleMethod, [
  enums.VideosItemIdStreamHeadSubtitleMethod? defaultValue,
]) {
  return enums.VideosItemIdStreamHeadSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdStreamHeadSubtitleMethod) ??
      defaultValue ??
      enums.VideosItemIdStreamHeadSubtitleMethod.swaggerGeneratedUnknown;
}

enums.VideosItemIdStreamHeadSubtitleMethod?
    videosItemIdStreamHeadSubtitleMethodNullableFromJson(
  Object? videosItemIdStreamHeadSubtitleMethod, [
  enums.VideosItemIdStreamHeadSubtitleMethod? defaultValue,
]) {
  if (videosItemIdStreamHeadSubtitleMethod == null) {
    return null;
  }
  return enums.VideosItemIdStreamHeadSubtitleMethod.values.firstWhereOrNull(
          (e) => e.value == videosItemIdStreamHeadSubtitleMethod) ??
      defaultValue;
}

String videosItemIdStreamHeadSubtitleMethodExplodedListToJson(
    List<enums.VideosItemIdStreamHeadSubtitleMethod>?
        videosItemIdStreamHeadSubtitleMethod) {
  return videosItemIdStreamHeadSubtitleMethod?.map((e) => e.value!).join(',') ??
      '';
}

List<String> videosItemIdStreamHeadSubtitleMethodListToJson(
    List<enums.VideosItemIdStreamHeadSubtitleMethod>?
        videosItemIdStreamHeadSubtitleMethod) {
  if (videosItemIdStreamHeadSubtitleMethod == null) {
    return [];
  }

  return videosItemIdStreamHeadSubtitleMethod.map((e) => e.value!).toList();
}

List<enums.VideosItemIdStreamHeadSubtitleMethod>
    videosItemIdStreamHeadSubtitleMethodListFromJson(
  List? videosItemIdStreamHeadSubtitleMethod, [
  List<enums.VideosItemIdStreamHeadSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdStreamHeadSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return videosItemIdStreamHeadSubtitleMethod
      .map((e) => videosItemIdStreamHeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdStreamHeadSubtitleMethod>?
    videosItemIdStreamHeadSubtitleMethodNullableListFromJson(
  List? videosItemIdStreamHeadSubtitleMethod, [
  List<enums.VideosItemIdStreamHeadSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdStreamHeadSubtitleMethod == null) {
    return defaultValue;
  }

  return videosItemIdStreamHeadSubtitleMethod
      .map((e) => videosItemIdStreamHeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? videosItemIdStreamHeadContextNullableToJson(
    enums.VideosItemIdStreamHeadContext? videosItemIdStreamHeadContext) {
  return videosItemIdStreamHeadContext?.value;
}

String? videosItemIdStreamHeadContextToJson(
    enums.VideosItemIdStreamHeadContext videosItemIdStreamHeadContext) {
  return videosItemIdStreamHeadContext.value;
}

enums.VideosItemIdStreamHeadContext videosItemIdStreamHeadContextFromJson(
  Object? videosItemIdStreamHeadContext, [
  enums.VideosItemIdStreamHeadContext? defaultValue,
]) {
  return enums.VideosItemIdStreamHeadContext.values
          .firstWhereOrNull((e) => e.value == videosItemIdStreamHeadContext) ??
      defaultValue ??
      enums.VideosItemIdStreamHeadContext.swaggerGeneratedUnknown;
}

enums.VideosItemIdStreamHeadContext?
    videosItemIdStreamHeadContextNullableFromJson(
  Object? videosItemIdStreamHeadContext, [
  enums.VideosItemIdStreamHeadContext? defaultValue,
]) {
  if (videosItemIdStreamHeadContext == null) {
    return null;
  }
  return enums.VideosItemIdStreamHeadContext.values
          .firstWhereOrNull((e) => e.value == videosItemIdStreamHeadContext) ??
      defaultValue;
}

String videosItemIdStreamHeadContextExplodedListToJson(
    List<enums.VideosItemIdStreamHeadContext>? videosItemIdStreamHeadContext) {
  return videosItemIdStreamHeadContext?.map((e) => e.value!).join(',') ?? '';
}

List<String> videosItemIdStreamHeadContextListToJson(
    List<enums.VideosItemIdStreamHeadContext>? videosItemIdStreamHeadContext) {
  if (videosItemIdStreamHeadContext == null) {
    return [];
  }

  return videosItemIdStreamHeadContext.map((e) => e.value!).toList();
}

List<enums.VideosItemIdStreamHeadContext>
    videosItemIdStreamHeadContextListFromJson(
  List? videosItemIdStreamHeadContext, [
  List<enums.VideosItemIdStreamHeadContext>? defaultValue,
]) {
  if (videosItemIdStreamHeadContext == null) {
    return defaultValue ?? [];
  }

  return videosItemIdStreamHeadContext
      .map((e) => videosItemIdStreamHeadContextFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdStreamHeadContext>?
    videosItemIdStreamHeadContextNullableListFromJson(
  List? videosItemIdStreamHeadContext, [
  List<enums.VideosItemIdStreamHeadContext>? defaultValue,
]) {
  if (videosItemIdStreamHeadContext == null) {
    return defaultValue;
  }

  return videosItemIdStreamHeadContext
      .map((e) => videosItemIdStreamHeadContextFromJson(e.toString()))
      .toList();
}

String? videosItemIdStreamContainerGetSubtitleMethodNullableToJson(
    enums.VideosItemIdStreamContainerGetSubtitleMethod?
        videosItemIdStreamContainerGetSubtitleMethod) {
  return videosItemIdStreamContainerGetSubtitleMethod?.value;
}

String? videosItemIdStreamContainerGetSubtitleMethodToJson(
    enums.VideosItemIdStreamContainerGetSubtitleMethod
        videosItemIdStreamContainerGetSubtitleMethod) {
  return videosItemIdStreamContainerGetSubtitleMethod.value;
}

enums.VideosItemIdStreamContainerGetSubtitleMethod
    videosItemIdStreamContainerGetSubtitleMethodFromJson(
  Object? videosItemIdStreamContainerGetSubtitleMethod, [
  enums.VideosItemIdStreamContainerGetSubtitleMethod? defaultValue,
]) {
  return enums.VideosItemIdStreamContainerGetSubtitleMethod.values
          .firstWhereOrNull(
              (e) => e.value == videosItemIdStreamContainerGetSubtitleMethod) ??
      defaultValue ??
      enums
          .VideosItemIdStreamContainerGetSubtitleMethod.swaggerGeneratedUnknown;
}

enums.VideosItemIdStreamContainerGetSubtitleMethod?
    videosItemIdStreamContainerGetSubtitleMethodNullableFromJson(
  Object? videosItemIdStreamContainerGetSubtitleMethod, [
  enums.VideosItemIdStreamContainerGetSubtitleMethod? defaultValue,
]) {
  if (videosItemIdStreamContainerGetSubtitleMethod == null) {
    return null;
  }
  return enums.VideosItemIdStreamContainerGetSubtitleMethod.values
          .firstWhereOrNull(
              (e) => e.value == videosItemIdStreamContainerGetSubtitleMethod) ??
      defaultValue;
}

String videosItemIdStreamContainerGetSubtitleMethodExplodedListToJson(
    List<enums.VideosItemIdStreamContainerGetSubtitleMethod>?
        videosItemIdStreamContainerGetSubtitleMethod) {
  return videosItemIdStreamContainerGetSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> videosItemIdStreamContainerGetSubtitleMethodListToJson(
    List<enums.VideosItemIdStreamContainerGetSubtitleMethod>?
        videosItemIdStreamContainerGetSubtitleMethod) {
  if (videosItemIdStreamContainerGetSubtitleMethod == null) {
    return [];
  }

  return videosItemIdStreamContainerGetSubtitleMethod
      .map((e) => e.value!)
      .toList();
}

List<enums.VideosItemIdStreamContainerGetSubtitleMethod>
    videosItemIdStreamContainerGetSubtitleMethodListFromJson(
  List? videosItemIdStreamContainerGetSubtitleMethod, [
  List<enums.VideosItemIdStreamContainerGetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdStreamContainerGetSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return videosItemIdStreamContainerGetSubtitleMethod
      .map((e) =>
          videosItemIdStreamContainerGetSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdStreamContainerGetSubtitleMethod>?
    videosItemIdStreamContainerGetSubtitleMethodNullableListFromJson(
  List? videosItemIdStreamContainerGetSubtitleMethod, [
  List<enums.VideosItemIdStreamContainerGetSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdStreamContainerGetSubtitleMethod == null) {
    return defaultValue;
  }

  return videosItemIdStreamContainerGetSubtitleMethod
      .map((e) =>
          videosItemIdStreamContainerGetSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? videosItemIdStreamContainerGetContextNullableToJson(
    enums.VideosItemIdStreamContainerGetContext?
        videosItemIdStreamContainerGetContext) {
  return videosItemIdStreamContainerGetContext?.value;
}

String? videosItemIdStreamContainerGetContextToJson(
    enums.VideosItemIdStreamContainerGetContext
        videosItemIdStreamContainerGetContext) {
  return videosItemIdStreamContainerGetContext.value;
}

enums.VideosItemIdStreamContainerGetContext
    videosItemIdStreamContainerGetContextFromJson(
  Object? videosItemIdStreamContainerGetContext, [
  enums.VideosItemIdStreamContainerGetContext? defaultValue,
]) {
  return enums.VideosItemIdStreamContainerGetContext.values.firstWhereOrNull(
          (e) => e.value == videosItemIdStreamContainerGetContext) ??
      defaultValue ??
      enums.VideosItemIdStreamContainerGetContext.swaggerGeneratedUnknown;
}

enums.VideosItemIdStreamContainerGetContext?
    videosItemIdStreamContainerGetContextNullableFromJson(
  Object? videosItemIdStreamContainerGetContext, [
  enums.VideosItemIdStreamContainerGetContext? defaultValue,
]) {
  if (videosItemIdStreamContainerGetContext == null) {
    return null;
  }
  return enums.VideosItemIdStreamContainerGetContext.values.firstWhereOrNull(
          (e) => e.value == videosItemIdStreamContainerGetContext) ??
      defaultValue;
}

String videosItemIdStreamContainerGetContextExplodedListToJson(
    List<enums.VideosItemIdStreamContainerGetContext>?
        videosItemIdStreamContainerGetContext) {
  return videosItemIdStreamContainerGetContext
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> videosItemIdStreamContainerGetContextListToJson(
    List<enums.VideosItemIdStreamContainerGetContext>?
        videosItemIdStreamContainerGetContext) {
  if (videosItemIdStreamContainerGetContext == null) {
    return [];
  }

  return videosItemIdStreamContainerGetContext.map((e) => e.value!).toList();
}

List<enums.VideosItemIdStreamContainerGetContext>
    videosItemIdStreamContainerGetContextListFromJson(
  List? videosItemIdStreamContainerGetContext, [
  List<enums.VideosItemIdStreamContainerGetContext>? defaultValue,
]) {
  if (videosItemIdStreamContainerGetContext == null) {
    return defaultValue ?? [];
  }

  return videosItemIdStreamContainerGetContext
      .map((e) => videosItemIdStreamContainerGetContextFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdStreamContainerGetContext>?
    videosItemIdStreamContainerGetContextNullableListFromJson(
  List? videosItemIdStreamContainerGetContext, [
  List<enums.VideosItemIdStreamContainerGetContext>? defaultValue,
]) {
  if (videosItemIdStreamContainerGetContext == null) {
    return defaultValue;
  }

  return videosItemIdStreamContainerGetContext
      .map((e) => videosItemIdStreamContainerGetContextFromJson(e.toString()))
      .toList();
}

String? videosItemIdStreamContainerHeadSubtitleMethodNullableToJson(
    enums.VideosItemIdStreamContainerHeadSubtitleMethod?
        videosItemIdStreamContainerHeadSubtitleMethod) {
  return videosItemIdStreamContainerHeadSubtitleMethod?.value;
}

String? videosItemIdStreamContainerHeadSubtitleMethodToJson(
    enums.VideosItemIdStreamContainerHeadSubtitleMethod
        videosItemIdStreamContainerHeadSubtitleMethod) {
  return videosItemIdStreamContainerHeadSubtitleMethod.value;
}

enums.VideosItemIdStreamContainerHeadSubtitleMethod
    videosItemIdStreamContainerHeadSubtitleMethodFromJson(
  Object? videosItemIdStreamContainerHeadSubtitleMethod, [
  enums.VideosItemIdStreamContainerHeadSubtitleMethod? defaultValue,
]) {
  return enums.VideosItemIdStreamContainerHeadSubtitleMethod.values
          .firstWhereOrNull((e) =>
              e.value == videosItemIdStreamContainerHeadSubtitleMethod) ??
      defaultValue ??
      enums.VideosItemIdStreamContainerHeadSubtitleMethod
          .swaggerGeneratedUnknown;
}

enums.VideosItemIdStreamContainerHeadSubtitleMethod?
    videosItemIdStreamContainerHeadSubtitleMethodNullableFromJson(
  Object? videosItemIdStreamContainerHeadSubtitleMethod, [
  enums.VideosItemIdStreamContainerHeadSubtitleMethod? defaultValue,
]) {
  if (videosItemIdStreamContainerHeadSubtitleMethod == null) {
    return null;
  }
  return enums.VideosItemIdStreamContainerHeadSubtitleMethod.values
          .firstWhereOrNull((e) =>
              e.value == videosItemIdStreamContainerHeadSubtitleMethod) ??
      defaultValue;
}

String videosItemIdStreamContainerHeadSubtitleMethodExplodedListToJson(
    List<enums.VideosItemIdStreamContainerHeadSubtitleMethod>?
        videosItemIdStreamContainerHeadSubtitleMethod) {
  return videosItemIdStreamContainerHeadSubtitleMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> videosItemIdStreamContainerHeadSubtitleMethodListToJson(
    List<enums.VideosItemIdStreamContainerHeadSubtitleMethod>?
        videosItemIdStreamContainerHeadSubtitleMethod) {
  if (videosItemIdStreamContainerHeadSubtitleMethod == null) {
    return [];
  }

  return videosItemIdStreamContainerHeadSubtitleMethod
      .map((e) => e.value!)
      .toList();
}

List<enums.VideosItemIdStreamContainerHeadSubtitleMethod>
    videosItemIdStreamContainerHeadSubtitleMethodListFromJson(
  List? videosItemIdStreamContainerHeadSubtitleMethod, [
  List<enums.VideosItemIdStreamContainerHeadSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdStreamContainerHeadSubtitleMethod == null) {
    return defaultValue ?? [];
  }

  return videosItemIdStreamContainerHeadSubtitleMethod
      .map((e) =>
          videosItemIdStreamContainerHeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdStreamContainerHeadSubtitleMethod>?
    videosItemIdStreamContainerHeadSubtitleMethodNullableListFromJson(
  List? videosItemIdStreamContainerHeadSubtitleMethod, [
  List<enums.VideosItemIdStreamContainerHeadSubtitleMethod>? defaultValue,
]) {
  if (videosItemIdStreamContainerHeadSubtitleMethod == null) {
    return defaultValue;
  }

  return videosItemIdStreamContainerHeadSubtitleMethod
      .map((e) =>
          videosItemIdStreamContainerHeadSubtitleMethodFromJson(e.toString()))
      .toList();
}

String? videosItemIdStreamContainerHeadContextNullableToJson(
    enums.VideosItemIdStreamContainerHeadContext?
        videosItemIdStreamContainerHeadContext) {
  return videosItemIdStreamContainerHeadContext?.value;
}

String? videosItemIdStreamContainerHeadContextToJson(
    enums.VideosItemIdStreamContainerHeadContext
        videosItemIdStreamContainerHeadContext) {
  return videosItemIdStreamContainerHeadContext.value;
}

enums.VideosItemIdStreamContainerHeadContext
    videosItemIdStreamContainerHeadContextFromJson(
  Object? videosItemIdStreamContainerHeadContext, [
  enums.VideosItemIdStreamContainerHeadContext? defaultValue,
]) {
  return enums.VideosItemIdStreamContainerHeadContext.values.firstWhereOrNull(
          (e) => e.value == videosItemIdStreamContainerHeadContext) ??
      defaultValue ??
      enums.VideosItemIdStreamContainerHeadContext.swaggerGeneratedUnknown;
}

enums.VideosItemIdStreamContainerHeadContext?
    videosItemIdStreamContainerHeadContextNullableFromJson(
  Object? videosItemIdStreamContainerHeadContext, [
  enums.VideosItemIdStreamContainerHeadContext? defaultValue,
]) {
  if (videosItemIdStreamContainerHeadContext == null) {
    return null;
  }
  return enums.VideosItemIdStreamContainerHeadContext.values.firstWhereOrNull(
          (e) => e.value == videosItemIdStreamContainerHeadContext) ??
      defaultValue;
}

String videosItemIdStreamContainerHeadContextExplodedListToJson(
    List<enums.VideosItemIdStreamContainerHeadContext>?
        videosItemIdStreamContainerHeadContext) {
  return videosItemIdStreamContainerHeadContext
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> videosItemIdStreamContainerHeadContextListToJson(
    List<enums.VideosItemIdStreamContainerHeadContext>?
        videosItemIdStreamContainerHeadContext) {
  if (videosItemIdStreamContainerHeadContext == null) {
    return [];
  }

  return videosItemIdStreamContainerHeadContext.map((e) => e.value!).toList();
}

List<enums.VideosItemIdStreamContainerHeadContext>
    videosItemIdStreamContainerHeadContextListFromJson(
  List? videosItemIdStreamContainerHeadContext, [
  List<enums.VideosItemIdStreamContainerHeadContext>? defaultValue,
]) {
  if (videosItemIdStreamContainerHeadContext == null) {
    return defaultValue ?? [];
  }

  return videosItemIdStreamContainerHeadContext
      .map((e) => videosItemIdStreamContainerHeadContextFromJson(e.toString()))
      .toList();
}

List<enums.VideosItemIdStreamContainerHeadContext>?
    videosItemIdStreamContainerHeadContextNullableListFromJson(
  List? videosItemIdStreamContainerHeadContext, [
  List<enums.VideosItemIdStreamContainerHeadContext>? defaultValue,
]) {
  if (videosItemIdStreamContainerHeadContext == null) {
    return defaultValue;
  }

  return videosItemIdStreamContainerHeadContext
      .map((e) => videosItemIdStreamContainerHeadContextFromJson(e.toString()))
      .toList();
}

typedef $JsonFactory<T> = T Function(Map<String, dynamic> json);

class $CustomJsonDecoder {
  $CustomJsonDecoder(this.factories);

  final Map<Type, $JsonFactory> factories;

  dynamic decode<T>(dynamic entity) {
    if (entity is Iterable) {
      return _decodeList<T>(entity);
    }

    if (entity is T) {
      return entity;
    }

    if (isTypeOf<T, Map>()) {
      return entity;
    }

    if (isTypeOf<T, Iterable>()) {
      return entity;
    }

    if (entity is Map<String, dynamic>) {
      return _decodeMap<T>(entity);
    }

    return entity;
  }

  T _decodeMap<T>(Map<String, dynamic> values) {
    final jsonFactory = factories[T];
    if (jsonFactory == null || jsonFactory is! $JsonFactory<T>) {
      return throw "Could not find factory for type $T. Is '$T: $T.fromJsonFactory' included in the CustomJsonDecoder instance creation in bootstrapper.dart?";
    }

    return jsonFactory(values);
  }

  List<T> _decodeList<T>(Iterable values) =>
      values.where((v) => v != null).map<T>((v) => decode<T>(v) as T).toList();
}

class $JsonSerializableConverter extends chopper.JsonConverter {
  @override
  FutureOr<chopper.Response<ResultType>> convertResponse<ResultType, Item>(
      chopper.Response response) async {
    if (response.bodyString.isEmpty) {
      // In rare cases, when let's say 204 (no content) is returned -
      // we cannot decode the missing json with the result type specified
      return chopper.Response(response.base, null, error: response.error);
    }

    if (ResultType == String) {
      return response.copyWith();
    }

    if (ResultType == DateTime) {
      return response.copyWith(
          body: DateTime.parse((response.body as String).replaceAll('"', ''))
              as ResultType);
    }

    final jsonRes = await super.convertResponse(response);
    return jsonRes.copyWith<ResultType>(
        body: $jsonDecoder.decode<Item>(jsonRes.body) as ResultType);
  }
}

final $jsonDecoder = $CustomJsonDecoder(generatedMapping);

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
